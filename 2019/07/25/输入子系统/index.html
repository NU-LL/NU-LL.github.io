<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>输入子系统 | 无名小卒</title>
  <meta name="keywords" content=" 按键驱动 , 输入子系统 ">
  <meta name="description" content="输入子系统 | 无名小卒">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://NU-LL.github.io/about/index.html">
<meta property="og:site_name" content="无名小卒">
<meta property="og:description" content="关于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-21T14:30:10.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="关于">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>NU-LL</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/NU-LL" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="csdn" href="https://blog.csdn.net/CSDN_JZ_" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="email" href="mailto:1125934312@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1125934312&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=323374922" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(36)</small></div></li>
    
        
            
            <li><div data-rel="Linux">Linux<small>(22)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程语言">编程语言<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="感悟与总结">感悟与总结<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="STM32">STM32<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="人工智能">人工智能<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a style="border-right: 1px solid #fff; width: 49%"  class="about site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="36">
<input type="hidden" id="yelog_site_word_count" value="211.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://github.com/NU-LL">NU-LL</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">DM9000C</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">网卡移植</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Kconfig语法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux内核</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Latex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Ctex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">LiCheePi Zero</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">IIC驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Markdown</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">字符驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Mininet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">文件描述符</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Kubernetes</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">NanoPi Neo Core</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">数据分析</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">network namespace</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Xmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">远程链接</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">爬虫</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">等待队列</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_head_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">python实战</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">markdownlint</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">u-boot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">快速排序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">存储器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">二维数组</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">指针</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">IAP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">BootLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">dual bank</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">TensorFlow2</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">按键驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">poll机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">异步通知机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">根文件系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">设备树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">网卡驱动框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">虚拟网卡</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">输入子系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Go语言入门经典</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">廖雪峰python教程</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Linux "
           href="/2019/08/04/DM9000C网卡移植/"
           data-tag="DM9000C,网卡移植"
           data-author="" >
            <span class="post-title" title="DM9000C网卡移植">DM9000C网卡移植</span>
            <span class="post-date" title="2019-08-04 23:07:22">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/15/Kconfig文件语法分析/"
           data-tag="Kconfig语法"
           data-author="" >
            <span class="post-title" title="Kconfig文件语法分析">Kconfig文件语法分析</span>
            <span class="post-date" title="2019-08-15 19:38:40">2019/08/15</span>
        </a>
        
        <a  class="Linux "
           href="/2020/01/16/Docker/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="Docker">Docker</span>
            <span class="post-date" title="2020-01-16 20:14:51">2020/01/16</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/13/Linux内核启动流程/"
           data-tag="Linux内核"
           data-author="" >
            <span class="post-title" title="Linux内核启动流程">Linux内核启动流程</span>
            <span class="post-date" title="2019-08-13 16:13:46">2019/08/13</span>
        </a>
        
        <a  class="工具 "
           href="/2019/08/19/Latex排版全解/"
           data-tag="Latex,Ctex"
           data-author="" >
            <span class="post-title" title="Latex排版全解">Latex排版全解</span>
            <span class="post-date" title="2019-08-19 16:02:27">2019/08/19</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/LiCheePi_Zero底层开发/"
           data-tag="LiCheePi Zero"
           data-author="" >
            <span class="post-title" title="LiCheePi_Zero底层开发">LiCheePi_Zero底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/05/IIC驱动/"
           data-tag="IIC驱动"
           data-author="" >
            <span class="post-title" title="IIC驱动">IIC驱动</span>
            <span class="post-date" title="2019-08-05 14:39:10">2019/08/05</span>
        </a>
        
        <a  class="工具 "
           href="/2019/07/12/Markdown 语法整理/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 语法整理">Markdown 语法整理</span>
            <span class="post-date" title="2019-07-12 13:57:24">2019/07/12</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/RTC驱动分析/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="RTC驱动分析">RTC驱动分析</span>
            <span class="post-date" title="2019-08-07 13:37:33">2019/08/07</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/13/Mininet/"
           data-tag="Mininet"
           data-author="" >
            <span class="post-title" title="Mininet">Mininet</span>
            <span class="post-date" title="2020-02-13 18:37:12">2020/02/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/Linux编程--文件描述符fd/"
           data-tag="文件描述符"
           data-author="" >
            <span class="post-title" title="Linux编程--文件描述符fd">Linux编程--文件描述符fd</span>
            <span class="post-date" title="2019-07-21 10:13:47">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/15/kubernetes/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes">Kubernetes</span>
            <span class="post-date" title="2020-03-15 13:48:53">2020/03/15</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/NanoPi_Neo_Core底层开发/"
           data-tag="NanoPi Neo Core"
           data-author="" >
            <span class="post-title" title="NanoPi_Neo_Core底层开发">NanoPi_Neo_Core底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/git/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <span class="post-date" title="2019-09-17 09:59:56">2019/09/17</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/03/10/Python数据分析与展示/"
           data-tag="数据分析"
           data-author="" >
            <span class="post-title" title="Python数据分析与展示">Python数据分析与展示</span>
            <span class="post-date" title="2020-03-10 15:10:50">2020/03/10</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/10/linux 网络虚拟化： network namespace 简介/"
           data-tag="network namespace"
           data-author="" >
            <span class="post-title" title="linux 网络虚拟化： network namespace 简介">linux 网络虚拟化： network namespace 简介</span>
            <span class="post-date" title="2020-02-10 14:24:09">2020/02/10</span>
        </a>
        
        <a  class="Linux "
           href="/2019/11/08/Xmanager远程Ubuntu系统图像化界面/"
           data-tag="Xmanager,远程链接"
           data-author="" >
            <span class="post-title" title="Xmanager远程Ubuntu系统图像化界面">Xmanager远程Ubuntu系统图像化界面</span>
            <span class="post-date" title="2019-11-08 22:58:53">2019/11/08</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/02/18/python爬虫/"
           data-tag="python,爬虫"
           data-author="" >
            <span class="post-title" title="python爬虫">python爬虫</span>
            <span class="post-date" title="2020-02-18 23:40:18">2020/02/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/linux等待队列wait_queue_head_t和wait_queue_t/"
           data-tag="等待队列,wait_queue_head_t,wait_queue_t"
           data-author="" >
            <span class="post-title" title="linux等待队列wait_queue_head_t和wait_queue_t">linux等待队列wait_queue_head_t和wait_queue_t</span>
            <span class="post-date" title="2019-07-21 18:18:54">2019/07/21</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/29/python实战/"
           data-tag="python实战"
           data-author="" >
            <span class="post-title" title="python实战">python实战</span>
            <span class="post-date" title="2020-01-29 21:36:32">2020/01/29</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/markdownlint规则详细介绍/"
           data-tag="markdownlint"
           data-author="" >
            <span class="post-title" title="VSC插件之markdownlint规则详细介绍">VSC插件之markdownlint规则详细介绍</span>
            <span class="post-date" title="2019-09-17 15:00:13">2019/09/17</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="算法 "
           href="/2019/07/29/快速排序/"
           data-tag="快速排序"
           data-author="" >
            <span class="post-title" title="快速排序">快速排序</span>
            <span class="post-date" title="2019-07-29 22:27:34">2019/07/29</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/11/各种存储器的区别/"
           data-tag="存储器"
           data-author="" >
            <span class="post-title" title="各种存储器的区别">各种存储器的区别</span>
            <span class="post-date" title="2019-08-11 10:57:19">2019/08/11</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/06/二维数组与指针的一些问题/"
           data-tag="二维数组,指针"
           data-author="" >
            <span class="post-title" title="二维数组与指针的一些问题">二维数组与指针的一些问题</span>
            <span class="post-date" title="2019-08-06 13:11:26">2019/08/06</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/字符驱动设备的另一种写法/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="字符驱动设备的另一种写法">字符驱动设备的另一种写法</span>
            <span class="post-date" title="2019-08-07 12:20:30">2019/08/07</span>
        </a>
        
        <a  class="STM32 "
           href="/2019/11/12/基于STM32L476的IAP升级/"
           data-tag="IAP,BootLoader,dual bank"
           data-author="" >
            <span class="post-title" title="基于STM32L476的IAP升级">基于STM32L476的IAP升级</span>
            <span class="post-date" title="2019-11-12 22:47:40">2019/11/12</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/01/03/深度学习与TensorFlow2/"
           data-tag="深度学习,TensorFlow2"
           data-author="" >
            <span class="post-title" title="深度学习与TensorFlow2">深度学习与TensorFlow2</span>
            <span class="post-date" title="2020-01-03 21:04:26">2020/01/03</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/按键驱动——poll机制/"
           data-tag="按键驱动,poll机制"
           data-author="" >
            <span class="post-title" title="按键驱动——poll机制">按键驱动——poll机制</span>
            <span class="post-date" title="2019-07-21 20:30:38">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/22/按键驱动：异步通知机制/"
           data-tag="按键驱动,异步通知机制"
           data-author="" >
            <span class="post-title" title="按键驱动：异步通知机制">按键驱动：异步通知机制</span>
            <span class="post-date" title="2019-07-22 19:04:24">2019/07/22</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/14/构造根文件系统/"
           data-tag="根文件系统"
           data-author="" >
            <span class="post-title" title="构造根文件系统">构造根文件系统</span>
            <span class="post-date" title="2019-08-14 20:18:45">2019/08/14</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/13/设备树/"
           data-tag="设备树"
           data-author="" >
            <span class="post-title" title="设备树">设备树</span>
            <span class="post-date" title="2019-10-13 15:53:24">2019/10/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/04/网卡驱动程序/"
           data-tag="网卡驱动框架,虚拟网卡"
           data-author="" >
            <span class="post-title" title="网卡驱动程序">网卡驱动程序</span>
            <span class="post-date" title="2019-08-04 21:24:07">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/25/输入子系统/"
           data-tag="按键驱动,输入子系统"
           data-author="" >
            <span class="post-title" title="输入子系统">输入子系统</span>
            <span class="post-date" title="2019-07-25 00:05:15">2019/07/25</span>
        </a>
        
        <a  class="编程语言 "
           href="/2019/10/23/Go语言/"
           data-tag="Go语言入门经典"
           data-author="" >
            <span class="post-title" title="Go语言">Go语言</span>
            <span class="post-date" title="2019-10-23 21:07:25">2019/10/23</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/10/python/"
           data-tag="廖雪峰python教程"
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2020-01-10 20:18:52">2020/01/10</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-输入子系统" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">输入子系统</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="Linux">Linux</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color5">按键驱动</a>
            
            <a href="javascript:" class="color1">输入子系统</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-09-18 13:51:06'>2019-07-25 00:05</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:5.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#输入子系统"><span class="toc-text">输入子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、系统分析"><span class="toc-text">一、系统分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-输入子系统简介"><span class="toc-text">1.输入子系统简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-输入子系统初始化分析"><span class="toc-text">2.输入子系统初始化分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-input-open-file函数分析"><span class="toc-text">3.input_open_file函数分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-input-table-数组的赋值"><span class="toc-text">4.input_table[]数组的赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-input-register-handler的调用"><span class="toc-text">5.input_register_handler的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-input-handler结构体分析"><span class="toc-text">6.input_handler结构体分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-input-dev和input-handler及其相关关系"><span class="toc-text">7.input_dev和input_handler及其相关关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1input-register-device-函数分析"><span class="toc-text">7.1input_register_device()函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-input-register-handler-函数分析"><span class="toc-text">7.2.input_register_handler()函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-input-attach-handler-函数分析"><span class="toc-text">7.3.input_attach_handler()函数分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-连接的建立"><span class="toc-text">8.连接的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-evdev-connect-函数分析"><span class="toc-text">8.1.evdev_connect()函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-input-register-handle-函数分析"><span class="toc-text">8.2.input_register_handle()函数分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-按键读取分析"><span class="toc-text">9.按键读取分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-read函数的唤醒"><span class="toc-text">10.read函数的唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-evdev-event-的调用"><span class="toc-text">11.evdev_event()的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-总结分析"><span class="toc-text">12.总结分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、程序分析"><span class="toc-text">二、程序分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-几个常用结构体和函数"><span class="toc-text">1.几个常用结构体和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-代码分析"><span class="toc-text">2.代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-测试运行"><span class="toc-text">3.测试运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1测试运行有两种-一种是直接打开-dev-tyy1-第二种是使用exec命令"><span class="toc-text">3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-调试"><span class="toc-text">3.2 调试</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h1><h2 id="一、系统分析"><a href="#一、系统分析" class="headerlink" title="一、系统分析"></a>一、系统分析</h2><h3 id="1-输入子系统简介"><a href="#1-输入子系统简介" class="headerlink" title="1.输入子系统简介"></a>1.输入子系统简介</h3><p>同样的输入子系统也需要输入驱动的框架,好来辨认应用程序要打开的是哪个输入驱动</p>
<p>比如: 鼠标、键盘、游戏手柄等等这些都属于输入设备；这些输入设备的驱动都是通过输入子系统来实现的（当然，这些设备也依赖于usb子系统）</p>
<p>这些输入设备都各有不同，那么输入子系统也就只能实现他们的共性，差异性则由设备驱动来实现。差异性又体现在哪里？</p>
<p>最直观的就表现在这些设备功能上的不同了。对于我们写驱动的人来说在设备驱动中就只要使用输入子系统提供的工具（也就是函数）来完成这些“差异”就行了，其他的则是输入子系统的工作。这个思想不仅存在于输入子系统，其他子系统也是一样(比如:usb子系统、video子系统等)</p>
<p>所以我们先来分析下输入子系统<strong>input.c</strong>的代码,然后怎么来使用输入子系统(在内核中以input来形容输入子系统)</p>
<h3 id="2-输入子系统初始化分析"><a href="#2-输入子系统初始化分析" class="headerlink" title="2.输入子系统初始化分析"></a>2.输入子系统初始化分析</h3><p>打开input.c,位于内核deivers/input，有以下这么两段:</p>
<pre><code class="c">subsys_initcall(input_init);   //修饰入口函数
module_exit(input_exit);     //修饰出口函数</code></pre>
<p>显然输入子系统是作为一个模块存在,我们先来分析下input_int()入口函数</p>
<pre><code class="c">static int __init input_init(void)
{
       int err;
       err = class_register(&amp;input_class);   //(1)在/sys/class 里创建一个 input类
       if (err) {
              printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);
              return err;
       }

       err = input_proc_init();    //在/proc下面建立相关的文件
       if (err)
              goto fail1;

       err = register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops); //(2)注册驱动
       if (err) {
              printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);
              goto fail2;
       }

       return 0;

 fail2:
    input_proc_exit();

 fail1:
    class_unregister(&amp;input_class);

       return err;
}</code></pre>
<ul>
<li><p>(1)这里的input_class变量如下所示：</p>
<pre><code class="c">  struct class input_class={
      .name        = &quot;input&quot;,
      .release    = input_dev_release,
      .uevent        = input_dev_uevent,
  }</code></pre>
<p>  当启动一个input子系统的驱动后，可以通过如下命令看到创建了个”input”类 :</p>
<pre><code class="bash">  # ls /sys/class/
  graphics     misc
  hwmon         mmc_host
  i2c-adapter mtd
  input         net
  mem         ppdev
  #</code></pre>
<p>  为什么这里代码只创建类，没有使用class_device_create()函数在类下面创建驱动设备？</p>
<p>  在下面第8小结会详细讲到,这里简单描述:当注册input子系统的驱动后，才会有驱动设备，此时这里的代码是没有驱动的</p>
</li>
<li><p>(2)这里通过register_chrdev创建驱动设备,其中宏INPUT_MAJOR =13,所以创建了一个主设备为13的”input”设备。</p>
<p>   然后我们来看看它的操作结构体input_fops,如下:</p>
<pre><code class="c">  static const struct file_operations input_fops={
      .owner    =THIS_MODULE,
      .open    =input_open_file,
  };</code></pre>
<p>  只有一个.open函数,比如当我们挂载一个新的input驱动,则内核便会调用该.open函数，其他一些工作肯定是在这个函数中处理的,接下来分析该.open函数</p>
</li>
</ul>
<h3 id="3-input-open-file函数分析"><a href="#3-input-open-file函数分析" class="headerlink" title="3.input_open_file函数分析"></a>3.input_open_file函数分析</h3><p>然后进入input_open_file函数(drivers/input/input.c)：</p>
<pre><code class="c">static int input_open_file(struct inode *inode, struct file *file)
 {
    struct input_handler *handler = input_table[iminor(inode) &gt;&gt; 5]; // (1)
    const struct file_operations *old_fops, *new_fops = NULL;
    int err;

    if (!handler || !(new_fops = fops_get(handler-&gt;fops)))  //(2)
        return -ENODEV;

    if (!new_fops-&gt;open) {
        fops_put(new_fops);
        return -ENODEV;
    }

    old_fops = file-&gt;f_op;
    file-&gt;f_op = new_fops;     //(3)

    err = new_fops-&gt;open(inode, file);   //(4)
    if (err) {
        fops_put(file-&gt;f_op);
        file-&gt;f_op = fops_get(old_fops);
    }

    fops_put(old_fops);

    return err;
}</code></pre>
<ul>
<li>（1）这里iminor (inode)函数调用了MINOR(inode-&gt;i_rdev);读取打开文件（input设备）的子设备号,然后将子设备除以32,找到<strong>新挂载的input驱动</strong>的数组号,然后放在input_handler *类型的handler中</li>
<li>（2）若handler有值,说明挂载有这个驱动,利用fops_get()将handler结构体里的成员file_operations *fops取出赋到新的file_operations *new_fops里面，即此时new_fops指向了<strong>新挂载的input驱动</strong>的操作函数</li>
<li>（3）再将新的file_operations <em>new_fops赋到file-&gt;file_operations  <em>f_op里, 此时input子系统的file_operations就等于</em></em>新挂载的input驱动<strong>的file_operations结构体,实现一个</strong>偷天换日的效果.**</li>
<li>（4）然后调用<strong>新挂载的input驱动</strong>的*new_fops里面的成员.open函数</li>
</ul>
<h3 id="4-input-table-数组的赋值"><a href="#4-input-table-数组的赋值" class="headerlink" title="4.input_table[]数组的赋值"></a>4.input_table[]数组的赋值</h3><p>上面代码的input_table[]数组在初始时是没有值的,所以需要找到他在那里被赋值</p>
<p>在input.c函数(drivers/input/input.c)中搜索input_table,找到它在input_register_handler()函数中被赋值,代码如下:</p>
<pre><code class="c">int input_register_handler(struct input_handler *handler)
{
    ... ...
        input_table[handler-&gt;minor &gt;&gt; 5] = handler;   //input_table[]被赋值
    ... ...
        list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //将这个input_handler放到input_handler_list链表中  
    ... ...
}</code></pre>
<p>这里就是将input_handler *类型的变量handler注册到input_table[]中，然后将handler插入input_handler_list链表中,后面第7.1会讲这个链表</p>
<h3 id="5-input-register-handler的调用"><a href="#5-input-register-handler的调用" class="headerlink" title="5.input_register_handler的调用"></a>5.input_register_handler的调用</h3><p>继续来搜索input_register_handler,看看这个函数被谁来调用</p>
<p>通过搜索可以查到,有evdev.c(事件设备)，tsdev.c(触摸屏设备)，joydev.c(joystick操作杆设备)，keyboard.c(键盘设备)，mousedev.c(鼠标设备) 等各种设备调用了该函数</p>
<p>大致可以推断，以上各种设备通过input_register_handler函数向input.c注册</p>
<p>这里以evdev.c(事件设备)举例，通过如下函数向input.c注册</p>
<pre><code class="c">static int __init evdev_init(void)
{
    return input_register_handler(&amp;evdev_handler)
}</code></pre>
<h3 id="6-input-handler结构体分析"><a href="#6-input-handler结构体分析" class="headerlink" title="6.input_handler结构体分析"></a>6.input_handler结构体分析</h3><p>我们来看看这个evdev_handler变量是什么结构体</p>
<pre><code class="c">static struct input_handler evdev_handler = {
       .event         = evdev_event,
       .connect     = evdev_connect,  //(4)
       .disconnect     = evdev_disconnect,
       .fops         = &amp;evdev_fops,    //(1)
       .minor         = EVDEV_MINOR_BASE, //(2)
       .name         = &quot;evdev&quot;,
       .id_table     = evdev_ids, //(3)
};</code></pre>
<ul>
<li><p>（1）<strong>.fops:</strong>文件操作结构体,其中evdev_fops为file_operations结构体，就是自己的写的操作函数,然后赋到.fops中</p>
</li>
<li><p>（2）<strong>.minor:</strong>用来存放次设备号，其中EVDEV_MINOR_BASE=64, 这里调用input_register_handler(&amp;evdev_handler)后,由于EVDEV_MINOR_BASE/32=2,所以最终会将evdev_handler存到input_table[2]中</p>
<p>  假设当open打开这个input设备时，就会进入 input_open_file()函数,执行evdev_handler-&gt; evdev_fops -&gt; .open函数,如下所示为evdev_fops结构体的内容</p>
<pre><code class="c">  static const struct flle_operations evdev_fops={
      .owner            =THIS MODULE,
      .read            =evdev_read,
      .write            =evdev_write,
      .poll            =evdeV_poll,
      .open            =evdev_open,
      .release        =evdev_release,
      .unlocked_ioctl    =evdev_ioctl,
  #ifdef CONFIG_COMPAT
      .compat_ioctl    =evdev_ioctl_compat,
  #endif
      .fasync            =evdev_fasync,
      .flush            =evdev_flush
  };</code></pre>
<p>  故最终会调用到evdev_open函数</p>
</li>
<li><p>（3）<strong>.id_table :</strong> 表示能支持哪些输入设备，比如某个驱动设备的input_dev-&gt;的id和某个input_handler的id_table相匹配，就会调用.connect连接函数,如下图</p>
</li>
<li><p>（4）<strong>.connect:</strong> 连接函数，将设备input_dev和某个input_handler建立连接,如下图</p>
<p>  <img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125805775-128197571.png" alt="img"></p>
</li>
</ul>
<h3 id="7-input-dev和input-handler及其相关关系"><a href="#7-input-dev和input-handler及其相关关系" class="headerlink" title="7.input_dev和input_handler及其相关关系"></a>7.input_dev和input_handler及其相关关系</h3><p>我们先来看看上图的input_register_device()函数,谁负责调用他</p>
<p>搜索input_register_device,发现内核自己就已经注册了很多驱动设备</p>
<h4 id="7-1input-register-device-函数分析"><a href="#7-1input-register-device-函数分析" class="headerlink" title="7.1input_register_device()函数分析"></a>7.1input_register_device()函数分析</h4><p>进入input_register_device()函数,代码如下:</p>
<pre><code class="c">int input_register_device(struct input_dev *dev)   //*dev:要注册的驱动设备
{
    ... ...
        list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   //(1)将驱动设备放入input_dev_list链表中
    ... ...
        list_for_each_entry(handler, &amp;input_handler_list, node)  //(2)
            input_attach_handler(dev, handler); //(3)
    ... ...
}</code></pre>
<ul>
<li>（1）将要注册的input_dev类型的驱动设备放在input_dev_list链表中</li>
<li>（2）其中input_handler_list在前面第4点讲过（下面会再讲）,就是存放每个input_handle结构体的链表,然后list_for_each_entry()函数会将每个input_handle从链表中取出，放到handler中，并调用一次input_attach_handler</li>
<li>（3）根据要注册的驱动设备和每个input_handle类型的handler的id_table进行判断，能否支持这个input_dev类型的驱动设备，若两者支持便进行连接。</li>
</ul>
<h4 id="7-2-input-register-handler-函数分析"><a href="#7-2-input-register-handler-函数分析" class="headerlink" title="7.2.input_register_handler()函数分析"></a>7.2.input_register_handler()函数分析</h4><p>然后我们在回过头来看注册input_handler的input_register_handler()函数，有：</p>
<pre><code class="c">int input_register_handler(struct input_handler *handler)
{
    ... ...
        input_table[handler-&gt;minor &gt;&gt; 5] = handler;   //(1)input_table[]被赋值
    ... ...
        list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //(2)将这个input_handler放到input_handler_list链表中
        list_for_each_entry(dev,&amp;input_dev_list,node)//(3)
            input_attach_handler(dev,handler);//(4)
    ... ...
}</code></pre>
<ul>
<li>（1）将input_handler *类型的变量handler放入数组input_table[]中</li>
<li>（2）将input_handler *类型的变量handler插入input_handler_list链表中</li>
<li>（3）list_for_each_entry()函数会将每个input_dev从链表input_dev_list中取出，放到dev中，并调用一次input_attach_handler</li>
<li>（4）根据要注册的input_handler类型的handler的id_table和每个input_dev类型的dev进行判断，能否支持这个input_dev类型的驱动设备，若两者支持便进行连接。</li>
</ul>
<p>所以,不管新添加input_dev还是input_handler,都会进入<strong>input_attach_handler()</strong>判断两者id是否匹配, 若两者匹配便进行连接。</p>
<h4 id="7-3-input-attach-handler-函数分析"><a href="#7-3-input-attach-handler-函数分析" class="headerlink" title="7.3.input_attach_handler()函数分析"></a>7.3.input_attach_handler()函数分析</h4><p>我们来看看input_attach_handler()如何实现匹配两者id的</p>
<pre><code class="c">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)
{
    ... ...
        id = input_match_device(handler-&gt;id_table, dev);  //根据handler的id_table和dev进行匹配

    if (!id)                                     //若不匹配,return退出
        return -ENODEV;

    error = handler-&gt;connect(handler, dev, id);  //若匹配,调用handler的connect函数建立连接
    ... ...
}</code></pre>
<p>若两者匹配成功，就会自动进入input_handler类型变量handler的connect函数建立连接</p>
<h3 id="8-连接的建立"><a href="#8-连接的建立" class="headerlink" title="8.连接的建立"></a>8.连接的建立</h3><p>我们还是以evdev.c(事件驱动) 的evdev_handler-&gt;connect函数来分析是怎样建立连接的。</p>
<p>首先根据evdev.c中的input_handler类型变量evdev_handler分析，有：</p>
<pre><code class="c">static struct input_handler evdev_handler={
    .event=evdev_event,
    .connect=evdev_connect,
    .disConnect=evdev_disconnect,
    .fops=&amp; evdev_fops,
    .minor=EVDEV_MINOR_BASE,
    .name=&quot;evdev&quot;,
    .id_table=evdev_ids,
};</code></pre>
<h4 id="8-1-evdev-connect-函数分析"><a href="#8-1-evdev-connect-函数分析" class="headerlink" title="8.1.evdev_connect()函数分析"></a>8.1.evdev_connect()函数分析</h4><p>evdev_handler的.connect函数是evdev_connect(),代码如下:</p>
<pre><code class="c">static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)
{
    ... ...
    for (minor = 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++); //查找驱动设备的子设备号
    if (minor == EVDEV_MINORS) {  // EVDEV_MINORS=32,所以该事件下的驱动设备最多存32个,
        printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);
        return -ENFILE;                //没找到驱动设备
    }
    ... ...
    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);   //struct evdev结构体中包含input_handle，这里主要是分配一个input_handle全局结构体(没有r)
    ... ...
    evdev-&gt;exist = 1;
    evdev-&gt;minor = minor;
    evdev-&gt;handle.dev = dev;              //指向input_dev驱动设备
    evdev-&gt;handle.name = evdev-&gt;name;
    evdev-&gt;handle.handler = handler;    //指向input_handler驱动处理结构体
    evdev-&gt;handle.private = evdev;
    sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);    //(1)保存驱动设备名字, event%d
    ... ...
    devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  //(2) 将主设备号和次设备号转换成dev_t类型
    cdev = class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name); // (3)在input类下创建驱动设备

    ... ...
    error = input_register_handle(&amp;evdev-&gt;handle); //(4)注册这个input_handle结构体
    ... ...
}</code></pre>
<ul>
<li><p>（1）保存驱动设备名字,名为event%d, 比如下面(键盘驱动)event1: 因为没有设置子设备号，默认从小到大排列,其中event0是表示这个input子系统,所以这个键盘驱动名字就是event1</p>
</li>
<li><p>（2）是在保存驱动设备的主次设备号,其中主设备号INPUT_MAJOR=13,因为EVDEV_MINOR_BASE=64,所以此设备号=64+驱动程序本事子设备号, 比如下图(键盘驱动)event1:  主次设备号就是13,65</p>
</li>
<li><p>（3）在之前在第2点中就分析了input_class类结构，所以该处会在/sys/class/input类下创建驱动设备event%d，比如下图(键盘驱动)event1:</p>
<pre><code class="shell">  # ls -l /dev/event*
  crw-rw----    1 0      0       13, 64 Jan  1 00:00 /dev/event0(input子系统自带的驱动设备)
  crw-rw----    1 0      0       13, 65 Jan  1 01:02 /dev/event1(后来安装的键盘驱动设备)
  # ls /sys/class/input/
  event0 event1 input0 input1 mice mouse0 ts0
           |
           V
  键盘与input_handler在连接函数里创建的驱动设备</code></pre>
</li>
<li><p>（4）最终会进入input_register_handle()函数来注册,代码在下面</p>
</li>
</ul>
<h4 id="8-2-input-register-handle-函数分析"><a href="#8-2-input-register-handle-函数分析" class="headerlink" title="8.2.input_register_handle()函数分析"></a>8.2.input_register_handle()函数分析</h4><pre><code class="c">//error = input_register_handle(&amp;evdev-&gt;handle);
int input_register_handle(struct input_handle *handle)
{
    struct input_handler *handler = handle-&gt;handler; //此处的handler==evdev-&gt;handle.handler，即evdev_connect函数传下来的input_handler驱动处理结构体

    list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); //(1)
    list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    // (2)

    if (handler-&gt;start)
        handler-&gt;start(handle);
    return 0;
}</code></pre>
<ul>
<li><p>（1）此处因为右边参数中handle-&gt;dev指向input_dev驱动设备，所以就是将左边参数handle-&gt;d_node放入到input_dev驱动设备的h_list链表中，即input_dev驱动设备的h_list就指向input_handle（没有r）结构体handle中的d_node成员</p>
</li>
<li><p>（2）同样, input_handler驱动处理结构体的h_list也指向了handle-&gt;h_node</p>
<p>  最终如下图所示:</p>
</li>
</ul>
<p><img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125909525-684596795.png" alt="img"></p>
<p>两者的.h_list都指向了同一个handle结构体，然后通过.h_list 来找到handle的成员.dev和handler,便能找到对方,便建立了连接</p>
<h3 id="9-按键读取分析"><a href="#9-按键读取分析" class="headerlink" title="9.按键读取分析"></a>9.按键读取分析</h3><p>假设当read打开这个input设备时，就会执行evdev_handler结构体中evdev_fops成员中的.read函数,如下所示为evdev_fops结构体的内容</p>
<pre><code class="c">static const struct flle_operations evdev_fops={
    .owner            =THIS MODULE,
    .read            =evdev_read,
    .write            =evdev_write,
    .poll            =evdeV poll,
    .open            =evdev_open,
    .release        =evdev_release,
    .unlocked_ioctl    =evdev_ioctl,
#ifdef CONFIG_COMPAT
    .compat_ioctl    =evdev_ioctl_compat,
#endif
    .fasync            =evdev_fasync,
    .flush            =evdev_flush
};</code></pre>
<p>故最终会调用到evdev_read函数，我们来分析下:</p>
<pre><code class="c">static ssize_t evdev_read(struct file *file, char __user *      buffer, size_t count, loff_t *ppos)
{
    ... ...
    /*判断应用层要读取的数据是否正确*/
    if (count &lt; evdev_event_size())
        return -EINVAL;

    /*无数据并且是非阻塞方式打开，则立刻返回*/
    if (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))
        return -EAGAIN;

    /*否则进入休眠  */
    retval = wait_event_interruptible(evdev-&gt;wait,client-&gt;head != client-&gt;tail || !evdev-&gt;exist);
    ... ...           //上传数据
}</code></pre>
<h3 id="10-read函数的唤醒"><a href="#10-read函数的唤醒" class="headerlink" title="10.read函数的唤醒"></a>10.read函数的唤醒</h3><p>若read函数进入了休眠状态，又是谁来唤醒？</p>
<p>我们搜索这个evdev-&gt;wait这个等待队列变量,找到在evdev_event函数中唤醒:</p>
<pre><code class="c">static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)
{
    ... ...
    wake_up_interruptible(&amp;evdev-&gt;wait);   //有事件触发，便唤醒等待中断
}</code></pre>
<p>其中evdev_event()是evdev.c(事件驱动) 的input_handler结构体中的成员event,如下所示:</p>
<pre><code class="c">static struct input_handler evdev_handler={
.event        =evdev_event,
.connect    =evdev_connect,
.disconnect    =evdev_disconnect,
.fops        =&amp; evdev_fops,
.minor        =EVDEV_MINOR_BASE,
.name        =&quot;evdev&quot;,
.id_table    =evdev_ids,
};</code></pre>
<p>当有事件发生了,比如对于按键驱动,当有按键按下时,就会进入.event函数中处理事件</p>
<h3 id="11-evdev-event-的调用"><a href="#11-evdev-event-的调用" class="headerlink" title="11.evdev_event()的调用"></a>11.evdev_event()的调用</h3><p>分析下,是谁调用evdev_event()这个.event事件驱动函数</p>
<p>应该就是之前分析的input_dev那层调用的</p>
<p>我们来看看内核 gpio_keys_isr()函数代码例子就知道了 (driver/input/keyboard/gpio_key.c)</p>
<pre><code class="c">static irqreturn_t gpio_keys_isr(int irq, void *dev_id)
{
    /*获取按键值,赋到state里*/
    ... ...
    /*上报事件*/
    input_event(input, type, button-&gt;code, !!state);  
    input_sync(input);//同步信号通知,表示事件发送完毕
}</code></pre>
<p>显然就是通过input_event()来调用.event事件函数,我们来看看:</p>
<pre><code class="c">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
{
    struct input_handle *handle;
    ... ...

    /* 通过input_dev-&gt;h_list链表找到input_handle驱动处理结构体*/
    list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)//这里就是从dev-&gt;h_list取出每一项（这里的每一项就是input_handle（没有r）类型的）并执行其对应的open函数
        if (handle-&gt;open)  //如果input_handle之前open过,那么这个就是我们的驱动处理结构体
            handle-&gt;handler-&gt;event(handle, type, code, value); //调用evdev_event()的.event事件函数
}</code></pre>
<p>若之前驱动input_dev和处理input_handler已经通过input_handler 的.connect函数建立起了连接,那么就调用evdev_event()的.event事件函数，如下图所示:</p>
<p><img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125942290-1009610213.png" alt="img"></p>
<h3 id="12-总结分析"><a href="#12-总结分析" class="headerlink" title="12.总结分析"></a>12.总结分析</h3><p>1.注册输入子系统,进入put_init():</p>
<p>1)创建主设备号为13的”input”字符设备</p>
<pre><code class="c">err = register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</code></pre>
<p>2.open打开驱动,进入input_open_file():</p>
<p>1)更新设备的file_oprations</p>
<pre><code class="c">file-&gt;f_op=fops_get(handler-&gt;fops);</code></pre>
<p> 2)执行file_oprations-&gt;open函数</p>
<pre><code class="c">err = new_fops-&gt;open(inode, file);</code></pre>
<p>3.注册input_handler,进入input_register_handler():</p>
<p>1)添加到input_table[]处理数组中</p>
<pre><code class="c">input_table[handler-&gt;minor &gt;&gt; 5] = handler;</code></pre>
<p>2）添加到input_handler_list链表中</p>
<pre><code class="c">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</code></pre>
<p>3)判断input_dev的id,是否有支持这个驱动的设备</p>
<pre><code class="c"> list_for_each_entry(dev, &amp;input_dev_list, node)   //遍历查找input_dev_list链表里所有input_dev

 input_attach_handler(dev, handler);             //判断两者id,若两者支持便进行连接。</code></pre>
<p>4.注册input_dev，进入input_register_device():</p>
<p>1)放在input_dev_list链表中</p>
<pre><code class="c">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</code></pre>
<p>2)判断input_handler的id，是否有支持这个设备的驱动</p>
<pre><code class="c">list_for_each_entry(handler, &amp;input_handler_list, node)  //遍历查找input_handler_list链表里所有input_handler
input_attach_handler(dev, handler);                      //判断两者id,若两者支持便进行连接。</code></pre>
<p>5.判断input_handler和input_dev的id,进入input_attach_handler():</p>
<p>1）匹配两者id,</p>
<pre><code class="c">input_match_device(handler-&gt;id_table, dev);        //匹配input_handler和dev的id,不成功退出函数</code></pre>
<p>2)匹配成功调用input_handler -&gt;connect</p>
<pre><code class="c">handler-&gt;connect(handler, dev, id);              //建立连接</code></pre>
<p>6.建立input_handler和input_dev的连接，进入input_handler-&gt;connect():</p>
<p>1)创建全局结构体,通过input_handle结构体连接双方</p>
<pre><code class="c">evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);    //创建两者连接的input_handle全局结构体
list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); //连接input_dev-&gt;h_list
list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    // 连接input_handle-&gt;h_list</code></pre>
<p>7.有事件发生时,比如按键中断,在中断函数中需要进入input_event()上报事件:</p>
<p>1)找到驱动处理结构体，然后执行input_handler-&gt;event()</p>
<pre><code class="c">    list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)     // 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体
    if (handle-&gt;open)  //如果input_handle之前open 过,那么这个就是我们的驱动处理结构体(有可能一个驱动设备在不同情况下有不同的驱动处理方式)
        handle-&gt;handler-&gt;event(handle, type, code, value); //调用evdev_event()的.event事件函数</code></pre>
<h2 id="二、程序分析"><a href="#二、程序分析" class="headerlink" title="二、程序分析"></a>二、程序分析</h2><p><strong>目标:</strong>实现键盘驱动,让开发板的4个按键代表键盘中的L、S、空格键、回车键</p>
<h3 id="1-几个常用结构体和函数"><a href="#1-几个常用结构体和函数" class="headerlink" title="1.几个常用结构体和函数"></a>1.几个常用结构体和函数</h3><ul>
<li><p><strong>1)input_dev驱动设备结构体中常用成员如下:</strong></p>
<pre><code class="c">  struct input_dev {

      void *private;
      const char *name;  //设备名字
      const char *phys;  //文件路径,比如 input/buttons
      const char *uniq;
      struct input_id id;

</code></pre>
</li>
</ul>
<pre><code>    unsigned long evbit[NBITS(EV_MAX)];  //表示支持哪类事件,常用有以下几种事件(可以多选)
    //EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件
    //EV_KEY       键盘事件
    //EV_REL       (relative)相对坐标事件，比如鼠标
    //EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应
    //EV_MSC      其他事件,功能
    //EV_LED       LED灯事件
    //EV_SND      (sound)声音事件

    //EV_REP       重复键盘按键事件
    //(内部会定义一个定时器,若有键盘按键事件一直按下/松开,就重复定时,时间一到就上报事件)

    //EV_FF         受力事件
    //EV_PWR      电源事件
    //EV_FF_STATUS  受力状态事件

    unsigned long keybit[NBITS(KEY_MAX)];   //存放支持的键盘按键值
    //键盘变量定义在:include/linux/input.h, 比如: KEY_L(按键L)
    unsigned long relbit[NBITS(REL_MAX)];    //存放支持的相对坐标值
    unsigned long absbit[NBITS(ABS_MAX)];   //存放支持的绝对坐标值
    unsigned long mscbit[NBITS(MSC_MAX)];   //存放支持的其它事件,也就是功能
    unsigned long ledbit[NBITS(LED_MAX)];    //存放支持的各种状态LED
    unsigned long sndbit[NBITS(SND_MAX)];    //存放支持的各种声音
    unsigned long ffbit[NBITS(FF_MAX)];       //存放支持的受力设备
    unsigned long swbit[NBITS(SW_MAX)];     //存放支持的开关功能

    ... ...
}
```</code></pre><ul>
<li><p><strong>2)函数如下:</strong></p>
<pre><code class="c">  struct input_dev *input_allocate_device(void);  //向内核中申请一个input_dev设备,然后返回这个设备</code></pre>
<pre><code class="c">  input_unregister_device(struct input_dev *dev);   //卸载/sys/class/input目录下的input_dev这个类设备, 一般在驱动出口函数写</code></pre>
<pre><code class="c">  input_free_device(struct input_dev *dev);   //释放input_dev这个结构体, 一般在驱动出口函数写</code></pre>
<pre><code class="c">  set_bit(nr,p);                  //设置某个结构体成员p里面的某位等于nr,支持这个功能
  /* 比如:
  set_bit(EV_KEY,buttons_dev-&gt;evbit);   //设置input_dev结构体buttons_dev-&gt;evbit支持EV_KEY
  set_bit(KEY_S,buttons_dev-&gt;keybit);  //设置input_dev结构体buttons_dev-&gt;keybit支持按键”S”
  */</code></pre>
<pre><code class="c">  void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);  //上报事件
   // input_dev *dev :要上报哪个input_dev驱动设备的事件
   // type : 要上报哪类事件, 比如按键事件,则填入: EV_KEY
   // code: 对应的事件里支持的哪个变量，比如按下按键L则填入: KEY_L
   //value:对应的变量里的数值,比如松开按键则填入1,松开按键则填入0</code></pre>
<pre><code class="c">  void input_sync(struct input_dev *dev); //同步事件通知</code></pre>
<p>  这里input_event()函数只是个事件函数,需要input_sync()同步事件函数来通知系统,然后系统才会知道</p>
<p>  其中，input_sync()代码如下:</p>
<pre><code class="c">  static inline void input_sync(struct input_dev *dev)
  {
      input_event(dev, EV_SYN, SYN_REPORT, 0); //就是上报同步事件,告诉内核:input_event()事件执行完毕
  }</code></pre>
</li>
</ul>
<h3 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2.代码分析"></a>2.代码分析</h3><p>1)向内核申请input_dev结构体</p>
<p>2)设置input_dev的成员</p>
<p>3)注册input_dev 驱动设备</p>
<p>4)初始化定时器和中断</p>
<p>5)写中断服务函数</p>
<p>6)写定时器超时函数</p>
<p>7)在出口函数中 释放中断函数,删除定时器,卸载释放驱动</p>
<pre><code class="c">#include &lt;linux/module.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/pm.h&gt;
#include &lt;linux/sysctl.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/gpio_keys.h&gt;
#include &lt;asm/gpio.h&gt;


struct input_dev *buttons_dev;            //  定义一个input_dev结构体  
static struct ping_desc *buttons_id;          //保存dev_id,在定时器中用
static struct timer_list buttons_timer;    //定时器结构体  

struct  ping_desc{

    unsigned  char  *name;          //中断设备名称
    int            pin_irq;          //按键的外部中断标志位
    unsigned  int    pin;                //引脚
    unsigned int  irq_ctl;           //触发中断状态:   IRQ_TYPE_EDGE_BOTH
    unsigned  int    button;         //dev_id,对应键盘的 L ,  S,  空格,  enter
};

// KEY1 -&gt; L
// KEY2 -&gt; S
// KEY3 -&gt; 空格
// KEY4 -&gt; enter
static  struct ping_desc   buttons_desc[5]=
{
    {&quot;s1&quot;, IRQ_EINT0,   S3C2410_GPF0,  IRQ_TYPE_EDGE_BOTH,KEY_L},
    {&quot;s2&quot;, IRQ_EINT2,   S3C2410_GPF2,  IRQ_TYPE_EDGE_BOTH,KEY_S},
    {&quot;s3&quot;, IRQ_EINT11, S3C2410_GPG3 , IRQ_TYPE_EDGE_BOTH,KEY_SPACE},
    {&quot;s4&quot;, IRQ_EINT19, S3C2410_GPG11,IRQ_TYPE_EDGE_BOTH,KEY_ENTER},
};



/*5. 写中断服务函数*/
static irqreturn_t  buttons_irq (int irq, void *dev_id)       //中断服务函数
{
    buttons_id=(struct ping_desc *)dev_id;             //保存当前的dev_id
    mod_timer(&amp;buttons_timer, jiffies+HZ/100 );   //更新定时器值 10ms
    return 0;
}



/*6.写定时器超时函数*/
void buttons_timer_function(unsigned long i)
{
    int val;
    val=s3c2410_gpio_getpin(buttons_id-&gt;pin);             //获取是什么电平
    if(val)         //高电平,松开
    {
        /*上报事件*/
        input_event(buttons_dev,EV_KEY,buttons_id-&gt;button, 0);  //上报EV_KEY类型,button按键,0(没按下)
        input_sync(buttons_dev);         // 上传同步事件,告诉系统有事件出现
    }

    else      //低电平，按下
    {
        /*上报事件*/
        input_event(buttons_dev, EV_KEY, buttons_id-&gt;button, 1);  //上报EV_KEY类型,button按键,1(按下)
        input_sync(buttons_dev);       // 上传同步事件,告诉系统有事件出现
    }
}


static int buttons_init(void)   //入口函数
{
    int i;
    buttons_dev=input_allocate_device();  //1.向内核 申请input_dev结构体
    /*2.设置input_dev ,  */
    set_bit(EV_KEY,buttons_dev-&gt;evbit);       //支持键盘事件
    set_bit(EV_REP,buttons_dev-&gt;evbit);       //支持键盘重复按键事件，该事件在input_event上报EV_KEY事件时会自动修改定时器来进行处理

    set_bit(KEY_L,buttons_dev-&gt;keybit);                  //支持按键 L
    set_bit(KEY_S,buttons_dev-&gt;keybit);                //支持按键 S
    set_bit(KEY_SPACE,buttons_dev-&gt;keybit);      //支持按键 空格
    set_bit(KEY_ENTER,buttons_dev-&gt;keybit);     //支持按键 enter

    /*3.注册input_dev */
    input_register_device(buttons_dev);


    /*4. 初始化硬件:初始化定时器和中断*/
    // KEY1 -&gt; L
    // KEY2 -&gt; S
    // KEY3 -&gt; 空格
    // KEY4 -&gt; enter
    init_timer(&amp;buttons_timer);
    buttons_timer.function=buttons_timer_function;
    add_timer(&amp;buttons_timer);

    for(i=0;i&lt;4;i++)
        request_irq(buttons_desc[i].pin_irq, buttons_irq, buttons_desc[i].irq_ctl, buttons_desc[i].name, &amp;buttons_desc[i]);

    return 0;
}


static int buttons_exit(void)  //出口函数
{
    /*7.释放中断函数,删除定时器,卸载释放驱动*/
    int i;
    for(i=0;i&lt;4;i++)
        free_irq(buttons_desc[i].pin_irq,&amp;buttons_desc[i]);    //释放中断函数

    del_timer(&amp;buttons_timer);   //删除定时器

    input_unregister_device(buttons_dev);     //卸载类下的驱动设备
    input_free_device(buttons_dev);                //释放驱动结构体
    return 0;
}

module_init(buttons_init);
module_exit(buttons_exit);
MODULE_LICENSE(&quot;GPL v2&quot;);</code></pre>
<h3 id="3-测试运行"><a href="#3-测试运行" class="headerlink" title="3.测试运行"></a>3.测试运行</h3><p>挂载键盘驱动后, 如下所示,可以通过  ls -l /dev/event*   命令查看已挂载的设备节点:</p>
<pre><code class="shell"># ls -l /dev/event*
crw-rw----    1 0      0       13, 64 Jan  1 00:00 /dev/event0(自带的触摸屏驱动设备)
crw-rw----    1 0      0       13, 65 Jan  1 01:02 /dev/event1(后来安装的键盘驱动设备)</code></pre>
<p>在<strong>上一节输入子系统里分析</strong>到:输入子系统的主设备号为13,其中event驱动本身的此设备号是从64开始的,如上所示,内核启动时,会加载自带触摸屏驱动,所以我们的键盘驱动的次设备号=64+1</p>
<h4 id="3-1测试运行有两种-一种是直接打开-dev-tyy1-第二种是使用exec命令"><a href="#3-1测试运行有两种-一种是直接打开-dev-tyy1-第二种是使用exec命令" class="headerlink" title="3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令"></a>3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令</h4><p>方法1:</p>
<pre><code class="shell">cat /dev/tty1     //tty1:LCD终端,就会通过tty_io.c来访问键盘驱动,然后打印在tty1终端上</code></pre>
<p>方法2:</p>
<pre><code class="shell">exec 0&lt;/dev/tty1    //利用&gt;将/dev/tty1作为输入传给该shell进程的0号文件（该shell的输入设备）,此时的键盘驱动就会直接打印在shell上</code></pre>
<h4 id="3-2-调试"><a href="#3-2-调试" class="headerlink" title="3.2 调试"></a>3.2 调试</h4><p><strong>若测试不成功,板子又在QT下进行的:</strong></p>
<p>1)可以使用vi命令,在记事本中按按键试</p>
<p>2)或者删除/etc/init.d/rcS 里面有关QT自启动的命令,然后重启</p>
<p><strong>若板子没在QT下进行,也无法测试成功:</strong></p>
<p>1)可以使用hexdump命令来调试代码</p>
<pre><code class="sh">hexdump /dev/event1
           秒        微秒     类  code    value
0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000
0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000
0000020 0bb2 0000 5815 000e 0001 0026 0000 0000
0000030 0bb2 0000 581f 000e 0000 0000 0000 0000</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达。邮件：1125934312@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>输入子系统</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">5.9k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="NU-LL">NU-LL</a></p>
    <p><span class="copy-title">发布时间:</span>2019-07-25, 00:05:15</p>
    <p><span class="copy-title">最后更新:</span>2019-09-18, 13:51:06</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/07/25/输入子系统/" title="输入子系统">http://NU-LL.github.io/2019/07/25/输入子系统/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 NU-LL</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="/js/script.js?v=1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#DM9000C','#网卡移植','#Kconfig语法','#Docker','#Linux内核','#Latex','#Ctex','#LiCheePi Zero','#IIC驱动','#Markdown','#字符驱动','#Mininet','#文件描述符','#Kubernetes','#NanoPi Neo Core','#git','#数据分析','#network namespace','#Xmanager','#远程链接','#python','#爬虫','#等待队列','#wait_queue_head_t','#wait_queue_t','#python实战','#markdownlint','#u-boot','#快速排序','#存储器','#二维数组','#指针','#IAP','#BootLoader','#dual bank','#深度学习','#TensorFlow2','#按键驱动','#poll机制','#异步通知机制','#根文件系统','#设备树','#网卡驱动框架','#虚拟网卡','#输入子系统','#Go语言入门经典','#廖雪峰python教程',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    

    
</style>







</html>
