<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>网卡驱动程序 | spaceman</title><meta name="keywords" content="网卡驱动框架,虚拟网卡"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网卡驱动程序 一、网卡驱动程序框架 相关驱动特点   字符设备驱动  设置主设备号 填充file_operations结构体 用register_chrdev(主设备号，name，file_operations结构体)注册驱动 入口函数 出口函数    块符设备驱动  分配geadisk结构体（利用alloc_disk函数） 设置  构造队列queue&#x3D;blk_init_queue(处理队列的函数">
<meta property="og:type" content="article">
<meta property="og:title" content="网卡驱动程序">
<meta property="og:url" content="http://nu-ll.github.io/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="spaceman">
<meta property="og:description" content="网卡驱动程序 一、网卡驱动程序框架 相关驱动特点   字符设备驱动  设置主设备号 填充file_operations结构体 用register_chrdev(主设备号，name，file_operations结构体)注册驱动 入口函数 出口函数    块符设备驱动  分配geadisk结构体（利用alloc_disk函数） 设置  构造队列queue&#x3D;blk_init_queue(处理队列的函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/NU-LL/image-host/raw/master/12.jpg">
<meta property="article:published_time" content="2019-08-04T13:24:07.000Z">
<meta property="article:modified_time" content="2019-08-04T15:01:01.428Z">
<meta property="article:author" content="spaceman">
<meta property="article:tag" content="网卡驱动框架">
<meta property="article:tag" content="虚拟网卡">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/NU-LL/image-host/raw/master/12.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网卡驱动程序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-08-04 23:01:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/NU-LL/image-host/raw/master/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">spaceman</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网卡驱动程序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-04T13:24:07.000Z" title="发表于 2019-08-04 21:24:07">2019-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-08-04T15:01:01.428Z" title="更新于 2019-08-04 23:01:01">2019-08-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网卡驱动程序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>网卡驱动程序</h1>
<h2 id="一、网卡驱动程序框架">一、网卡驱动程序框架</h2>
<h3 id="相关驱动特点">相关驱动特点</h3>
<ul>
<li>
<p>字符设备驱动</p>
<ol>
<li>设置主设备号</li>
<li>填充file_operations结构体</li>
<li>用register_chrdev(主设备号，name，file_operations结构体)注册驱动</li>
<li>入口函数</li>
<li>出口函数</li>
</ol>
</li>
<li>
<p>块符设备驱动</p>
<ol>
<li>分配geadisk结构体（利用alloc_disk函数）</li>
<li>设置
<ul>
<li>构造队列queue=blk_init_queue(处理队列的函数)</li>
<li>其他属性（主设备号、容量）</li>
</ul>
</li>
<li>注册geadisk结构体（利用add_disk函数）</li>
</ol>
<blockquote>
<p>上述字符设备驱动和块符设备驱动的共同特点：</p>
<ul>
<li>都有设备节点</li>
<li>字符设备需要先open、块设备需要先格式化然后挂接（mount）</li>
</ul>
</blockquote>
</li>
<li>
<p>网卡驱动</p>
<p>不需要打开某设备，直接使用socket即可编程</p>
<p>网卡的驱动与硬件相关,主要是负责收发网络的数据包,它将上层协议传递下来的数据包以特定的媒介访问控制方式进行发送， 并将接收到的数据包传递给上层协议。</p>
<p>网卡设备与字符设备和块设备不同， 网络设备并不对应于**/dev<strong>目录下的文件,不过会存放在</strong>/sys/class/net**目录下</p>
</li>
</ul>
<h3 id="Linux网络设备驱动的4层模型">Linux网络设备驱动的4层模型</h3>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1022162-20170327104036061-1284399912.png" alt="OSI 7层模型"></p>
<p>上图就是经典的OSI 7层模型，Linux的网卡驱动程序处于OSI模型中的数据链路层，他的职责就是将上上层的协议栈传过来的信息通过网卡发送出去，Linux的网络驱动模型采用4层结构:</p>
<p><strong>1)网络协议接口层:</strong></p>
<p>实现统一的数据包收发的协议,该层主要负责调用dev_queue_xmit()函数发送数据，netif_rx()函数接收数据</p>
<p><strong>2)网络设备接口层:</strong></p>
<p>通过net_device结构体来描述一个具体的网络设备的信息,实现不同的硬件的统一</p>
<p><strong>3)设备驱动功能层：</strong></p>
<p>用来负责驱动网络设备硬件来完成各个功能, 它通过hard_start_xmit() 函数启动发送操作， 并通过网络设备上的中断触发接收操作,</p>
<p><strong>4)网络设备与媒介层：</strong></p>
<p>用来负责完成数据包发送和接收的物理实体, 设备驱动功能层的函数都在这物理上驱动的</p>
<h3 id="网卡驱动初始化">网卡驱动初始化</h3>
<p>我们的网卡驱动程序,只需要编写网络设备接口层,填充net_device数据结构的内容并将net_device注册入内核,设置硬件相关操作,使能中断处理等</p>
<h4 id="net-device结构体的重要成员">net_device结构体的重要成员</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>               name[IFNAMSIZ];   <span class="comment">//网卡设备名称</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      mem_end;          <span class="comment">//该设备的内存结束地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      mem_start;        <span class="comment">//该设备的内存起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      base_addr;        <span class="comment">//该设备的内存I/O基地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       irq;              <span class="comment">//该设备的中断号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      if_port;          <span class="comment">//多端口设备使用的端口类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      dma;              <span class="comment">//该设备的DMA通道</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      state;            <span class="comment">//网络设备和网络适配器的状态信息</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span>* (*<span class="title">get_stats</span>)(<span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>);</span> <span class="comment">//获取流量的统计信息</span></span><br><span class="line">    <span class="comment">//运行ifconfig便会调用该成员函数,并返回一个net_device_stats结构体获取信息</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span>  <span class="title">stats</span>;</span>      <span class="comment">//用来保存统计信息的net_device_stats结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      features;        <span class="comment">//接口特征,     </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       flags; 			<span class="comment">//flags指网络接口标志,以IFF_(Interface Flags)开头</span></span><br><span class="line">    <span class="comment">/*当flags = </span></span><br><span class="line"><span class="comment">    	IFF_UP（ 当设备被激活并可以开始发送数据包时， 内核设置该标志）</span></span><br><span class="line"><span class="comment">        IFF_AUTOMEDIA（设置设备可在多种媒介间切换）</span></span><br><span class="line"><span class="comment">        IFF_BROADCAST（ 允许广播）</span></span><br><span class="line"><span class="comment">        IFF_DEBUG（ 调试模式， 可用于控制printk调用的详细程度）</span></span><br><span class="line"><span class="comment">        IFF_LOOPBACK（ 回环）、IFF_MULTICAST（ 允许组播）</span></span><br><span class="line"><span class="comment">        IFF_NOARP（ 接口不能执行ARP,点对点接口就不需要运行 ARP）</span></span><br><span class="line"><span class="comment">        IFF_POINTOPOINT（ 接口连接到点到点链路） 等。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>           mtu;        		<span class="comment">//最大传输单元,也叫最大数据包</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>     type;   　　	   <span class="comment">//接口的硬件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>     hard_header_len; <span class="comment">//硬件帧头长度,一般被赋为ETH_HLEN,即14</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      dev_addr[MAX_ADDR_LEN];<span class="comment">//存放设备的MAC地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      last_rx;    		<span class="comment">//接收数据包的时间戳,调用netif_rx()后赋上jiffies即可</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      trans_start;     <span class="comment">//发送数据包的时间戳,当要发送的时候赋上jiffies即可</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      dev_addr[MAX_ADDR_LEN];<span class="comment">//MAC地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*hard_start_xmit) (<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev);<span class="comment">//数据包发送函数, sk_buff就是用来收发数据包的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*tx_timeout) (<span class="keyword">struct</span> net_device *dev);<span class="comment">//发包超时处理函数</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面讲到的统计信息net_device_stats结构体,其中重要成员如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       rx_packets;          　　<span class="comment">/*收到的数据包数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       tx_packets;          　　<span class="comment">/*发送的数据包数    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       rx_bytes;               <span class="comment">/*收到的字节数,可以通过sk_buff结构体的成员len来获取*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       tx_bytes;               <span class="comment">/*发送的字节数,可以通过sk_buff结构体的成员len来获取*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       rx_errors;              <span class="comment">/*收到的错误数据包数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       tx_errors;              <span class="comment">/*发送的错误数据包数*/</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化网卡步骤">初始化网卡步骤</h4>
<ul>
<li>1)使用alloc_netdev()来分配一个net_device结构体</li>
<li>2)设置网卡硬件相关的寄存器</li>
<li>3)设置net_device结构体的成员</li>
<li>4)使用register_netdev()来注册net_device结构体</li>
</ul>
<h3 id="网卡驱动发包过程">网卡驱动发包过程</h3>
<p>在内核中,当上层要发送一个数据包时, 就会调用网络设备层里net_device数据结构的成员**hard_start_xmit()**将数据包发送出去。</p>
<p>**hard_start_xmit()**发包函数需要我们自己构建,该函数原型如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*hard_start_xmit) (<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev);</span><br></pre></td></tr></table></figure>
<p>在这个函数中需要涉及到sk_buff结构体，即套接字缓冲区(socket buffer)，用来网络各个层次之间传递数据。</p>
<h4 id="sk-buff结构体及其重要成员">sk_buff结构体及其重要成员</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">    <span class="comment">/* These two members must be first. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>        *<span class="title">next</span>;</span><span class="comment">//指向下一个sk_buff结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>        *<span class="title">prev</span>;</span><span class="comment">//指向前一个sk_buff结构体</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>          len,  <span class="comment">//数据包的总长度,包括线性数据和非线性数据</span></span><br><span class="line">    data_len,        <span class="comment">//非线性的数据长度</span></span><br><span class="line">    mac_len;         <span class="comment">//mac包头长度</span></span><br><span class="line"></span><br><span class="line">    __u32    　　　　  		priority;<span class="comment">//该sk_buff结构体的优先级   </span></span><br><span class="line">    __be16  　　 　　 		protocol;<span class="comment">//存放上层的协议类型,可以通过eth_type_trans()来获取</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="type">sk_buff_data_t</span>         transport_header;<span class="comment">//传输层头部的偏移值</span></span><br><span class="line">    <span class="type">sk_buff_data_t</span>         network_header;  <span class="comment">//网络层头部的偏移值</span></span><br><span class="line">    <span class="type">sk_buff_data_t</span>         mac_header;      <span class="comment">//MAC数据链路层头部的偏移值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sk_buff_data_t</span>         tail;            <span class="comment">//指向缓冲区的数据包末尾</span></span><br><span class="line">    <span class="type">sk_buff_data_t</span>         end;             <span class="comment">//指向缓冲区的末尾</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>        　*head,           <span class="comment">//指向缓冲区的协议头开始位置</span></span><br><span class="line">    					   *data;           <span class="comment">//指向缓冲区的数据包开始位置</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出该结构体为一个双向链表</p>
<p>其中sk_buff结构体的空间,如下图所示:</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031190937701-249952599.png" alt="sk_buff结构体空间"></p>
<p>其中sk_buff-&gt; data数据包格式如下图所示:</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031190949216-296868542.png" alt="data数据包格式"></p>
<p>即：</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1022162-20170301210540141-1527132087.png" alt="sk_buff"></p>
<h4 id="hard-start-xmit-发包的处理步骤">hard_start_xmit()发包的处理步骤</h4>
<ul>
<li>
<p>1)把数据包发出去之前,需要使用**netif_stop_queue()**来停止上层传下来的数据包,</p>
</li>
<li>
<p>2)设置寄存器,通过网络设备硬件,来发送数据</p>
</li>
<li>
<p>3)当数据包发出去后, 再调用**dev_kfree_skb()**函数来释放sk_buff,该函数原型如下:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dev_kfree_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>4)当数据包发出成功,就会进入TX中断函数,然后更新统计信息,调用**netif_wake_queue()**来唤醒,启动上层继续发包下来.</p>
</li>
<li>
<p>5)若数据包发出去超时,一直进不到TX中断函数,就会调用net_device结构体的(*tx_timeout)超时成员函数,在该函数中更新统计信息, 调用**netif_wake_queue()**来唤醒</p>
</li>
</ul>
<p>其中netif_wake_queue()和netif_stop_queue()函数原型如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_wake_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>;  <span class="comment">//唤醒被阻塞的上层,启动继续向网络设备驱动层发送数据包</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_stop_queue</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span>; <span class="comment">//阻止上层向网络设备驱动层发送数据包</span></span><br></pre></td></tr></table></figure>
<h3 id="网卡驱动收包过程">网卡驱动收包过程</h3>
<p>而接收数据包主要是通过中断函数处理,来判断中断类型,如果等于<strong>ISQ_RECEIVER_EVENT</strong>,表示为接收中断,然后进入接收数据函数,通过**netif_rx()**将数据上交给上层。</p>
<p>如下所示,参考的内核中自带的网卡驱动:/drivers/net/cs89x0.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">net_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_local</span> *<span class="title">lp</span>;</span></span><br><span class="line">	<span class="type">int</span> ioaddr, status;</span><br><span class="line"> 	<span class="type">int</span> handled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ioaddr = dev-&gt;base_addr;</span><br><span class="line">	lp = netdev_priv(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we MUST read all the events out of the ISQ, otherwise we&#x27;ll never</span></span><br><span class="line"><span class="comment">           get interrupted again.  As a consequence, we can&#x27;t have any limit</span></span><br><span class="line"><span class="comment">           on the number of times we loop in the interrupt handler.  The</span></span><br><span class="line"><span class="comment">           hardware guarantees that eventually we&#x27;ll run out of events.  Of</span></span><br><span class="line"><span class="comment">           course, if you&#x27;re on a slow machine, and packets are arriving</span></span><br><span class="line"><span class="comment">           faster than you can read them off, you&#x27;re screwed.  Hasta la</span></span><br><span class="line"><span class="comment">           vista, baby!  */</span></span><br><span class="line">	<span class="keyword">while</span> ((status = readword(dev-&gt;base_addr, ISQ_PORT))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (net_debug &gt; <span class="number">4</span>)printk(<span class="string">&quot;%s: event=%04x\n&quot;</span>, dev-&gt;name, status);</span><br><span class="line">		handled = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span>(status &amp; ISQ_EVENT_MASK) &#123;</span><br><span class="line">		<span class="keyword">case</span> ISQ_RECEIVER_EVENT:		<span class="comment">//判断是否为接受中断</span></span><br><span class="line">			<span class="comment">/* Got a packet(s). */</span></span><br><span class="line">			net_rx(dev);				<span class="comment">//通过net_rx函数将接受到的数据上交给上层</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ISQ_TRANSMITTER_EVENT:		<span class="comment">//判断是否为发送中断</span></span><br><span class="line">                ......</span><br></pre></td></tr></table></figure>
<p>该函数就是通过获取的status标志来判断是什么中断,如果是接收中断,就进入<strong>net_rx()</strong></p>
<h4 id="net-rx-收包的处理步骤">net_rx()收包的处理步骤</h4>
<ul>
<li>1)使用dev_alloc_skb()来构造一个新的sk_buff</li>
<li>2)使用skb_reserve(rx_skb, 2); 将sk_buff缓冲区里的数据包先后位移2字节,来腾出sk_buff缓冲区里的头部空间</li>
<li>3)读取网络设备硬件上接收到的数据</li>
<li>4)使用memcpy()将数据复制到新的sk_buff里的data成员指向的地址处,可以使用skb_put()来动态扩大sk_buff结构体里中的数据区</li>
<li>5)使用eth_type_trans()来获取上层协议,将返回值赋给sk_buff的protocol成员里</li>
<li>6)然后更新统计信息,最后使用netif_rx( )来将sk_fuffer传递给上层协议中</li>
</ul>
<p>其中**skb_put()**函数原型如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_put</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="comment">//len:将数据区向下扩大len字节</span></span><br></pre></td></tr></table></figure>
<p>使用skb_put()函数后,其中sk_buff缓冲区变化如下图:</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031191040904-388639517.png" alt="sk_buff缓冲区变化"></p>
<h2 id="二、编写虚拟网卡驱动">二、编写虚拟网卡驱动</h2>
<p>这里写一个简单的虚拟网卡驱动,也就是说不需要硬件相关操作,所以就没有中断函数,我们通过linux的ping命令来实现发包,然后在发包函数中伪造一个收的ping包函数,实现能ping通任何ip地址</p>
<p><strong>在init初始函数中:</strong></p>
<ul>
<li>1)使用**alloc_netdev()**来分配一个net_device结构体</li>
<li>2)设置net_device结构体的成员</li>
<li>3)使用**register_netdev()**来注册net_device结构体</li>
</ul>
<p><strong>在发包函数中:</strong></p>
<ul>
<li>1)使用**netif_stop_queue()**来阻止上层向网络设备驱动层发送数据包</li>
<li>2)调用收包函数,并传入发送的sk_buff缓冲区, 用来伪造一个收到ping包的函数</li>
<li>3)使用**dev_kfree_skb()**函数来释放发送的sk_buff缓存区</li>
<li>4)更新发送的统计信息</li>
<li>5)使用**netif_wake_queue()**来唤醒被阻塞的上层,</li>
</ul>
<p><strong>在收包函数中:</strong></p>
<blockquote>
<p>该部分可以参考LDD3（linux device drivers,third edition）</p>
</blockquote>
<p>首先修改发送的sk_buff里数据包的数据,使它变为一个接收的sk_buff,其中数据包结构如下图所示:</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031191106623-1661659162.png" alt="数据包"></p>
<ul>
<li>
<p>1)需要对调上图的ethhdr结构体中的 ”源/目的”MAC地址</p>
</li>
<li>
<p>2)需要对调上图的iphdr结构体中的”源/目的” IP地址</p>
</li>
<li>
<p>3)使用**ip_fast_csum()**来重新获取iphdr结构体的校验码</p>
</li>
<li>
<p>4)设置上图数据包的数据类型,之前是发送ping包为0x08,需要改为0x00,表示接收ping包</p>
</li>
<li>
<p>5)使用dev_alloc_skb()来构造一个新的sk_buff</p>
</li>
<li>
<p>6)使用skb_reserve(rx_skb, 2);将sk_buff缓冲区里的数据包先后位移2字节,来腾出sk_buff缓冲区里的头部空间</p>
</li>
<li>
<p>7)使用memcpy()将之前修改好的sk_buff-&gt;data复制到新的sk_buff里的data成员指向的地址处:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len);<span class="comment">// skb_put():来动态扩大sk_buff结构体里中的数据区，避免溢出</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>8)设置新的sk_buff 其它成员</p>
</li>
<li>
<p>9)使用**eth_type_trans()**来获取上层协议,将返回值赋给sk_buff的protocol成员里</p>
</li>
<li>
<p>10)然后更新接收统计信息,最后使用**netif_rx()**来将sk_fuffer传递给上层协议中</p>
</li>
</ul>
<h3 id="驱动具体代码分析">驱动具体代码分析</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>    *<span class="title">virt_net</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_rs_packet</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ih</span>;</span></span><br><span class="line">    __be32 *saddr, *daddr, tmp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp_dev_addr[ETH_ALEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">ethhdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">rx_skb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1) 对调ethhdr结构体 &quot;源/目的&quot;MAC地址*/</span></span><br><span class="line">    ethhdr = (<span class="keyword">struct</span> ethhdr *)skb-&gt;data;</span><br><span class="line">    <span class="built_in">memcpy</span>(tmp_dev_addr, ethhdr-&gt;h_dest, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_dest, ethhdr-&gt;h_source, ETH_ALEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(ethhdr-&gt;h_source, tmp_dev_addr, ETH_ALEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2)对调 iphdr结构体&quot;源/目的&quot; IP地址*/</span></span><br><span class="line">    ih = (<span class="keyword">struct</span> iphdr *)(skb-&gt;data + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ethhdr));</span><br><span class="line">    saddr = &amp;ih-&gt;saddr;</span><br><span class="line">    daddr = &amp;ih-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    tmp = *saddr;</span><br><span class="line">    *saddr = *daddr;</span><br><span class="line">    *daddr = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3)使用ip_fast_csum()来重新获取iphdr结构体的校验码*/</span></span><br><span class="line">    ih-&gt;check = <span class="number">0</span>;               </span><br><span class="line">    ih-&gt;check = ip_fast_csum((<span class="type">unsigned</span> <span class="type">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4)设置数据类型*/</span></span><br><span class="line">    type = skb-&gt;data + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ethhdr) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr);</span><br><span class="line">    *type = <span class="number">0</span>;      <span class="comment">//之前是发送ping包0x08,需要改为0x00,表示接收ping包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5)使用dev_alloc_skb()来构造一个新的sk_buff   */</span></span><br><span class="line">    rx_skb = dev_alloc_skb(skb-&gt;len + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6)使用skb_reserve()来腾出2字节头部空间  */</span></span><br><span class="line">    skb_reserve(rx_skb, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*7)使用memcpy()将之前修改好的sk_buff-&gt;data复制到新的sk_buff里*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len); <span class="comment">// skb_put():来动态扩大sk_buff结构体里中的数据区，避免溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*8)设置新的sk_buff 其它成员*/</span></span><br><span class="line">    rx_skb-&gt;dev = dev;</span><br><span class="line">    rx_skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*9)使用eth_type_trans()来获取上层协议 */</span></span><br><span class="line">    rx_skb-&gt;protocol = eth_type_trans(rx_skb, dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*10) 更新接收统计信息,并使用netif_rx( )来 传递sk_fuffer收包 */</span></span><br><span class="line">    dev-&gt;stats.rx_packets++;                     </span><br><span class="line">    dev-&gt;stats.rx_bytes += skb-&gt;len;</span><br><span class="line">    dev-&gt;last_rx= jiffies;<span class="comment">//收包时间戳</span></span><br><span class="line"></span><br><span class="line">    netif_rx(rx_skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virt_send_packet</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1)使用netif_stop_queue()来阻止上层向网络设备驱动层发送数据包*/</span></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//期间设置硬件发送数据包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2)调用收包函数,里面来伪造一个收的ping包函数*/</span></span><br><span class="line">    virt_rs_packet(skb,dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3)使用dev_kfree_skb()函数来释放发送的sk_buff缓存区*/</span></span><br><span class="line">    dev_kfree_skb(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4)更新发送的统计信息*/</span></span><br><span class="line">    dev-&gt;stats.tx_packets++;            <span class="comment">//成功发送一个包</span></span><br><span class="line">    dev-&gt;stats.tx_bytes+=skb-&gt;len;  	<span class="comment">//成功发送len长字节</span></span><br><span class="line">    dev-&gt;trans_start = jiffies;         <span class="comment">//发送时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5)使用netif_wake_queue()来唤醒被阻塞的上层*/</span></span><br><span class="line">    netif_wake_queue(dev); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virt_net_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1)使用alloc_netdev()来分配一个net_device结构体*/</span></span><br><span class="line">    virt_net= alloc_netdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> net_device), <span class="string">&quot;virt_eth0&quot;</span>, ether_setup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2)设置net_device结构体的成员 */</span></span><br><span class="line">    virt_net-&gt;hard_start_xmit      = virt_send_packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置MAC地址 */</span></span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;　　　　 </span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x89</span>;</span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x89</span>;</span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x89</span>;</span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x89</span>;</span><br><span class="line">    virt_net-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x89</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置下面两项才能ping通 */</span></span><br><span class="line">    virt_net-&gt;flags           |= IFF_NOARP;</span><br><span class="line">    virt_net-&gt;features        |= NETIF_F_NO_CSUM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3)使用register_netdev()来注册net_device结构体 */</span></span><br><span class="line">    register_netdev(virt_net);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virt_net_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_netdev(virt_net);</span><br><span class="line">    free_netdev(virt_net);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(virt_net_init);</span><br><span class="line">module_exit(virt_net_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;by:NU-LL&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="三、测试运行">三、测试运行</h2>
<p>挂载驱动,如下图所示,可以看到net类下就有了这个网卡设备</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031191142623-1185832566.png" alt="网卡信息"></p>
<p>开始测试,首先设置这个网卡设备的ip,然后去ping一下其它的ip,如下图所示:</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031191155154-1353223217.png" alt="网卡测试"></p>
<p>上图的ping,之所以成功,是因为我们在发包函数中,伪造了一个来收包,通过netif_rx()来将收包上传给上层</p>
<p>使用ifconfig,可以看到这个网卡设备的统计信息共收发了6个包,以及收发的总数据</p>
<p><img src="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1182576-20171031191207373-1423144563.png" alt="测试验证"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">http://nu-ll.github.io/2019/08/04/网卡驱动程序/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/">网卡驱动框架</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/">虚拟网卡</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/04/DM9000C%E7%BD%91%E5%8D%A1%E7%A7%BB%E6%A4%8D/"><img class="prev-cover" src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DM9000C网卡移植</div></div></a></div><div class="next-post pull-right"><a href="/2019/07/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快速排序</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/spaceman.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">spaceman</div><div class="author-info__description">CtrlC CtrlV大师</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NU-LL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">白嫖一时爽，一直白嫖一直爽</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网卡驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-text">一、网卡驱动程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A9%B1%E5%8A%A8%E7%89%B9%E7%82%B9"><span class="toc-text">相关驱动特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%844%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">Linux网络设备驱动的4层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">网卡驱动初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#net-device%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">net_device结构体的重要成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E5%8D%A1%E6%AD%A5%E9%AA%A4"><span class="toc-text">初始化网卡步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="toc-text">网卡驱动发包过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sk-buff%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">sk_buff结构体及其重要成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hard-start-xmit-%E5%8F%91%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-text">hard_start_xmit()发包的处理步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%94%B6%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="toc-text">网卡驱动收包过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#net-rx-%E6%94%B6%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-text">net_rx()收包的处理步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8"><span class="toc-text">二、编写虚拟网卡驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">驱动具体代码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E8%BF%90%E8%A1%8C"><span class="toc-text">三、测试运行</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/05/ESP32%E5%BC%95%E8%84%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="ESP8266">ESP8266</a><time datetime="2022-06-05T03:29:55.000Z" title="发表于 2022-06-05 11:29:55">2022-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/04/ESP8266%E5%BC%95%E8%84%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="ESP8266">ESP8266</a><time datetime="2022-06-04T15:41:25.000Z" title="发表于 2022-06-04 23:41:25">2022-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/JetsonNano%20Multimedia%20API%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%BC%96%E8%AF%91/" title="JetsonNano Multimedia API工程搭建及编译">JetsonNano Multimedia API工程搭建及编译</a><time datetime="2022-05-12T12:46:23.000Z" title="发表于 2022-05-12 20:46:23">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/29/RT1050%E5%9C%A8%E7%BA%BF%E6%93%A6%E9%99%A4%E5%A4%96%E9%83%A8QSPI%20Flash/" title="基于STM32L476的IAP升级">基于STM32L476的IAP升级</a><time datetime="2022-04-28T18:36:36.000Z" title="发表于 2022-04-29 02:36:36">2022-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/15/JetsonNano%E6%91%84%E5%83%8F%E5%A4%B4%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" title="JetsonNano摄像头驱动开发指南">JetsonNano摄像头驱动开发指南</a><time datetime="2022-03-15T06:07:34.000Z" title="发表于 2022-03-15 14:07:34">2022-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By spaceman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> <iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tx&color=eee" frameborder="0" allowtransparency="false" align="middle" height="20"></iframe></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>