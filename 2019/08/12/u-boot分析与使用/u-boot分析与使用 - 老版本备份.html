<hr>
<p>title: u-boot分析与使用<br>
date: 2019-08-12 19:16:50<br>
categories:</p>
<ul>
<li>Linux<br>
tags:</li>
<li>u-boot</li>
</ul>
<hr>
<h1>u-boot分析与使用</h1>
<h2 id="一、Makefile结构分析">一、Makefile结构分析</h2>
<h3 id="1、make-100ask24x0-config配置芯片类型">1、make 100ask24x0_config配置芯片类型</h3>
<p>打开u-boot-1.1.6/Makefile文件，发现：</p>
<pre><code class="language-makefile">SRCTREE    := $(CURDIR) *CURDIR是make的内嵌变量， 为当前目录
......
MKCONFIG    := $(SRCTREE)/mkconfig
......
100ask24x0_config    :    unconfig
@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0
</code></pre>
<p>上述$(SRCTREE)等于​$(CURDIR)，也就是当前目录u-boot-1.1.6，所以MKCONFIG=./mkconfig<br>
上述$(@:_config=)的结果就是将 “100ask24x0_config” 中的 “_config” 去掉， 结果为 “100ask24x0” 。<br>
<strong>实际执行:</strong></p>
<pre><code class="language-makefile">mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0
  $0         $1     $2    $3        $4      $5     $6 
</code></pre>
<h4 id="mkconfig脚本分析">mkconfig脚本分析</h4>
<p>显然这里是调用的mkconfig，打开当前目录u-boot-1.1.6下的该文件(用的linux_shell语法，可以参考《精通linux_shell编程教程pdf完整版》以及Linux应用开发手册第264页U-Boot配置过程)，在第6行中给出了mkconfig的用法：</p>
<pre><code class="language-makefile"># Parameters: Target Architecture CPU Board [VENDOR] [SOC]
</code></pre>
<p>刚好对应mkconfig(参数) 100ask24x0(目标) arm(架构) arm920t(cpu)100ask24x0(开发板选型) NULL(供应商) s3c24x0(片上系统/芯片) 。</p>
<p>通过分析，精简后的mkconfig文件：</p>
<pre><code class="language-bash">#!/bin/sh -e
# Parameters:  Target  Architecture  CPU  Board [VENDOR] [SOC]
# mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0

APPEND=no	# Default: Create new config file
BOARD_NAME=&quot;&quot;	# Name to print in make output

while [ $# -gt 0 ] ; do
	#不运行
done

[ &quot;${BOARD_NAME}&quot; ] || BOARD_NAME=&quot;$1&quot;#BOARD_NAME=100ask24x0
# $#:参数的个数
[ $# -lt 4 ] &amp;&amp; exit 1#不运行
[ $# -gt 6 ] &amp;&amp; exit 1#不运行

echo &quot;Configuring for ${BOARD_NAME} board...&quot;

#
# Create link to architecture specific headers
#
if [ &quot;$SRCTREE&quot; != &quot;$OBJTREE&quot; ] ; then#通过Makefile发现相等
	#不运行
else
	cd ./include#进入include目录
	rm -f asm
	ln -s asm-$2 asm#ln -s asm-arm asm：建立链接文件asm，指向asm-arm
fi

rm -f asm-$2/arch#rm -f asm-arm/arch：删除文件

if [ -z &quot;$6&quot; -o &quot;$6&quot; = &quot;NULL&quot; ] ; then#第6个参数为空或等于NULL
	ln -s ${LNPREFIX}arch-$3 asm-$2/arch#不运行
else
	ln -s ${LNPREFIX}arch-$6 asm-$2/arch#ln -s arch-s3c24x0 asm-arm/arch：建立链接文件asm-arm/arch，指向arch-s3c24x0
fi

if [ &quot;$2&quot; = &quot;arm&quot; ] ; then
	rm -f asm-$2/proc#删除文件
	ln -s ${LNPREFIX}proc-armv asm-$2/proc#ln -s proc-armv asm-arm/proc：建立链接文件asm-arm/proc，指向proc-armv
fi

#
# Create include file for Make
#
echo &quot;ARCH   = $2&quot; &gt;  config.mk#新建config.mk
echo &quot;CPU    = $3&quot; &gt;&gt; config.mk#追加
echo &quot;BOARD  = $4&quot; &gt;&gt; config.mk

[ &quot;$5&quot; ] &amp;&amp; [ &quot;$5&quot; != &quot;NULL&quot; ] &amp;&amp; echo &quot;VENDOR = $5&quot; &gt;&gt; config.mk#不会执行

[ &quot;$6&quot; ] &amp;&amp; [ &quot;$6&quot; != &quot;NULL&quot; ] &amp;&amp; echo &quot;SOC    = $6&quot; &gt;&gt; config.mk

#
# Create board specific header file
#
if [ &quot;$APPEND&quot; = &quot;yes&quot; ]	#第五行：APPEND=no
then
	echo &gt;&gt; config.h
else
	&gt; config.h		#新建config.h
fi
echo &quot;/* Automatically generated - do not edit */&quot; &gt;&gt;config.h
echo &quot;#include &lt;configs/$1.h&gt;&quot; &gt;&gt;config.h

exit 0
</code></pre>
<p>发现会创建include/config.mk文件：</p>
<pre><code>  ARCH = arm
  CPU = arm920t
  BOARD = 100ask24x0
  SOC = s3c24x0
</code></pre>
<p>以及include/config.h</p>
<pre><code class="language-c">/* Automatically generated - do not edit */
#include &lt;configs/100ask24x0.h&gt;
</code></pre>
<h4 id="mkconfig脚本总结">mkconfig脚本总结</h4>
<ol>
<li>
<p>创建相关的头文件链接：</p>
<pre><code class="language-bash">ln -s asm-arm asm
ln -s arch-s3c24x0 asm-arm/arch
ln -s proc-armv asm-arm/proc
</code></pre>
</li>
<li>
<p>创建顶层makefile包含的文件include/config.mk</p>
<pre><code>  ARCH = arm
  CPU = arm920t
  BOARD = 100ask24x0
  SOC = s3c24x0
</code></pre>
</li>
<li>
<p>创建开发板相关的头文件include/config.h</p>
<pre><code class="language-c">/* Automatically generated - do not edit */
#include &lt;configs/100ask24x0.h&gt;
</code></pre>
</li>
</ol>
<h3 id="2、make-编译u-boot">2、make 编译u-boot</h3>
<p>u-boot-1.1.6/Makefile文件:</p>
<pre><code class="language-makefile">include $(OBJTREE)/include/config.mk//调用config.mk这个文件
...
ifeq ($(ARCH),ppc)//判断config.mk这个文件中ARCH是否等于ppc
CROSS_COMPILE = powerpc-linux- 
endif
ifeq ($(ARCH),arm)//判断config.mk这个文件中ARCH是否等于arm
CROSS_COMPILE = arm-linux- 
endif
...
include $(TOPDIR)/config.mk
</code></pre>
<p>最后的config.mk是属于顶层目录的config,主要通过arm，arm920t，100ask24x0，s3c24x0来确定编译器、编译选项等</p>
<p>顶层的config.mk部分为：</p>
<pre><code class="language-bash">...
LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)
...
</code></pre>
<p>这里的<code>LDFLAGS</code>就是下文中的<code>$(LDFLAGS)</code></p>
<ul>
<li><code>$(LDSCRIPT)</code>：链接脚本</li>
<li><code>$(TEXT_BASE)</code>：board/100ask24x0/config.mk中定义，为链接脚本的起始地址</li>
</ul>
<p>继续看，发现all目标：</p>
<pre><code class="language-makefile">...
ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)//all的依赖文件

all:    $(ALL)//使用make命令,相当于执行make all 
...
$(obj)u-boot.bin:   $(obj)u-boot//生成u-boot.bin需要elf格式的u-boot，elf也就是通过ld链接文件生成的。
$(OBJCOPY) ${OBJCFLAGS} -O binary $&lt; $@//执行:arm-linux-objcopy -O binary u-boot u-boot.bin
...

$(obj)u-boot:   depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)//生成elf格式的u-boot所需要的依赖文件
		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
		cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \                       
			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
			-Map u-boot.map -o u-boot
</code></pre>
<p>上述10行开始就是开始制作elf格式的u-boot，具体展开的命令可以看make后命令行最后输出的命令，值得注意的是这中间包含的<strong>链接脚本</strong>，他决定了各种.o文件是怎么组织的（注意<code>$(LDFLAGS)</code>）</p>
<p>通过make后命令行输出的命令：</p>
<pre><code class="language-bash">......&amp;&amp;arm-linux-ld -Bstatic -T /work/system/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000 $UNDEF_SYM cpu/arm920t/start.o......
</code></pre>
<p>可以发现链接脚本为<code>board/100ask24x0/u-boot.lds</code>，并且通过**-Ttext**参数确定链接脚本的起始地址为0x33F80000</p>
<blockquote>
<p>开发板有64M的SDRAM，SDRAM从0x3000 0000开始，0x33F80000到SDRAM的结束地址刚好为512k</p>
</blockquote>
<p>同时，第一个链接的文件为cpu/arm920t/start.o，若链接脚本中没有明确指定那个文件在代码段（text段）的开头，该文件就是第一个被执行的文件</p>
<h4 id="链接脚本分析">链接脚本分析</h4>
<pre><code>OUTPUT_ARCH(arm)//设置输出文件的体系架构。
ENTRY(_start)//将_start这个全局符号设置成入口地址,进行复位初始化
SECTIONS//输出文件的内容布局
{
    . = 0x00000000;//指定地址0x00000000,最终运行地址在0x33F80000+0x00000000

    . = ALIGN(4);//代码以4字节对齐
    .text ://指定.text section段(位于0x33F80000)
    {
        cpu/arm920t/start.o (.text)//添加第一个目标文件cpu/arm920t/start.o里面的.text代码段
        board/100ask24x0/boot_init.o (.text)//添加第二个目标文件board/100ask24x0/boot_init.o里面的.text代码段
        *(.text)//*(.data) 表示添加剩下的全部文件的.text代码段
    }

    . = ALIGN(4);
    .rodata : { *(.rodata) }//指定.rodata section段(位于0x33F80000+.text section),将所有的.rodata只读数据段合并成一个.rodata只读数据段

    . = ALIGN(4);
    .data : { *(.data) }//指定读写数据段

    . = ALIGN(4);
    .got : { *(.got) }//指定got段，got段是uboot自定义的一个段

    . = .;
    __u_boot_cmd_start = .;//把__u_boot_cmd_start赋值为当前位置, 即起始位置
    .u_boot_cmd : { *(.u_boot_cmd) }// u_boot_cmd段，所有的u-boot命令相关的定义都放在这个位置
    __u_boot_cmd_end = .;// *u_boot_cmd段结束位置

    . = ALIGN(4);
    __bss_start = .;//把__bss_start赋值为当前位置,即bss段的开始位置
    .bss : { *(.bss) }//指定bss段，这里NOLOAD的意思是这段不需装载，仅在执行域中才会有这段
    _end = .;//把_end赋值为当前位置,即bss段的结束位置
}
</code></pre>
<p>发现第一个文件是<code>cpu/arm920t/start.S</code></p>
<h2 id="二、start-S——硬件初始化">二、start.S——硬件初始化</h2>
<ol>
<li>
<p>跳到reset处，执行复位函数</p>
</li>
<li>
<p>设为SVC(管理员)模式、f关闭看门狗、关闭中断、CPU的相关初始化（SDRAM初始化）</p>
</li>
<li>
<p>设置堆栈，为之后进入C函数做准备</p>
<pre><code class="language-assembly">/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE/*_TEXT_BASE，代码段起始地址，就是之前的0x33F80000*/
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */

#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack  最后sp指针的位置  */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl clock_init/*跳到C函数初始化时钟（自己写的，一般为汇编写的）*/
#endif

</code></pre>
</li>
<li>
<p><strong>重定位</strong></p>
<pre><code class="language-assembly">//搬移代码，将完整的u-boot从flash（NOR、NAND）中搬移到SDRAM中的链接地址去
#ifndef CONFIG_SKIP_RELOCATE_UBOOT
relocate:				/* relocate U-Boot to RAM	    */
	adr	r0, _start		/* r0 &lt;- current position of code   */
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
	cmp     r0, r1                  /* don't reloc during debug         */
	beq     clear_bss
	
	ldr	r2, _armboot_start
	ldr	r3, _bss_start
	sub	r2, r3, r2		/* r2 &lt;- size of armboot            */
#if 1
	bl  CopyCode2Ram	/* r0: source, r1: dest, r2: size */
#else
</code></pre>
</li>
<li>
<p>清除BSS段，全部清为0</p>
<blockquote>
<p>_bss_start 和 _bss_end由链接脚本决定</p>
</blockquote>
<pre><code class="language-assembly">clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment        */
	ldr	r1, _bss_end		/* stop here                        */
	mov 	r2, #0x00000000		/* clear                            */

clbss_l:str	r2, [r0]		/* clear loop...                    */
	add	r0, r0, #4
	cmp	r0, r1
	ble	clbss_l
</code></pre>
</li>
<li>
<p>调用C函数<code>start_armboot</code></p>
<pre><code class="language-assembly">ldr	pc, _start_armboot
_start_armboot:	.word start_armboot
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：</p>
<p>ldr是<strong>位置有关码</strong>，将_start_armboot这个标号的值作为地址，<strong>取出其中的值</strong>（即start_armboot的位置，该位置是通过链接脚本指定的）赋值给pc，所以无论该代码现在运行在哪里（芯片内部SRAM、外部NOR FLASH或者外部SDRAM）都会跳转到已经拷贝到的外部SDRAM中的start_armboot中去</p>
<p>实例：</p>
<p>若此时该汇编代码运行在芯片内部SRAM中，前期通过搬移已经将完整的u-boot搬移至片外SDRAM中，链接脚本指定的链接地址（运行地址）为<code>33f80000</code>，设此时汇编所对应的反汇编为：</p>
<pre><code class="language-assembly">#链接地址     机器码          反汇编指令
33f80070:	e59ff04c 	ldr	pc, [pc, #76]	; 33f800c4
......
33f800c4:	33f805a0 	mvnccs	r0, #671088640	; 0x28000000
......
33f805a0 &lt;start_armboot&gt;:
33f805a0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
</code></pre>
<p>此时第一行中的代码肯定是在片内SRAM中运行的，所以该行代码所处的实际物理地址应该是0x33f8 0070-0x33f8 0000=0x70，通过pc+8+76=pc+84=pc+0x54，得出pc应该赋值为地址0x70+0x54=0xc4中的值，即此时pc等于0xc4处所储存的数据33f805a0，正好对应start_armboot的链接地址。即下一刻跳转到片外的SDRAM中的start_armboot函数</p>
<p><strong>总结</strong>：</p>
<p>重定位前的代码应该使用<strong>位置无关码</strong>来写，以确保不同位置都可运行</p>
<blockquote>
<ol>
<li>使用相对跳转指令：B、BL</li>
<li>不可使用绝对地址，不可访问全局变量、静态变量（根本方法是看反汇编）</li>
<li>不能访问有初始值的数组，这种数组（指局部数组，全局变量不能使用）本身会存在栈中，但是初始值会在rodata段中，访问这些数据的值会用绝对地址进行访问</li>
</ol>
</blockquote>
<p>重定位后的跳转到SDRAM代码应该用<strong>位置有关码</strong>（LDR）来写，以确保可以跳到外部SDRAM中的运行地址去运行</p>
</blockquote>
<h2 id="三、start-armboot">三、start_armboot</h2>
<p>该函数会：</p>
<ol>
<li>
<p>初始化堆栈，用于自定义的malloc和free</p>
</li>
<li>
<p>拥有<strong>读写flash的能力</strong></p>
<blockquote>
<p>NOR：Flash_init</p>
<p>NAND：nand_init</p>
</blockquote>
</li>
<li>
<p>跳到<code>main_loop</code>函数</p>
<pre><code class="language-c">/* main_loop() can return to retry autoboot, if so just run it again. */
for (;;) {
    main_loop ();
}
</code></pre>
<p>main_loop函数可以等待用户输入相关的命令或者是通过uboot中的环境变量bootcmd中的命令启动linux内核</p>
<p>而main_loop函数的核心在于<code>getenv</code>函数和<code>run_command</code>函数，前者负责从uboot中的环境变量中取出对应的数据，后者负责执行相关的命令</p>
</li>
</ol>
<h2 id="四、u-boot命令实现">四、u-boot命令实现</h2>
<h3 id="核心机制">核心机制</h3>
<ol>
<li>
<p>所有命令通过一个结构体进行封装（cmd_tb1_t）</p>
</li>
<li>
<p>所有命令通过结构体中的name成员进行查找</p>
</li>
<li>
<p>这些结构体存在一个uboot自定义的段内，在之前的链接脚本中已经进行声明了段的起始和结束地址：</p>
<pre><code></code></pre>
</li>
</ol>
<p>. = .;<br>
__u_boot_cmd_start = .;//把__u_boot_cmd_start赋值为当前位置, 即起始位置<br>
.u_boot_cmd : { *(.u_boot_cmd) }// u_boot_cmd段，所有的u-boot命令相关的定义都放在这个位置<br>
__u_boot_cmd_end = .;// *u_boot_cmd段结束位置<br>
```</p>
<blockquote>
<p>通过搜索.u_boot_cmd可以找到怎样将这些结构体放入这个段中（利用__attribute__关键字）</p>
<p>通过搜索常用命令（如：bootm）可以找到相关的定义这些结构体的方法</p>
</blockquote>
<ol start="4">
<li>通过宏U_BOOT_CMD定义这些命令结构体</li>
</ol>
<pre><code class="language-c">U_BOOT_CMD(
名字,最大参数,是否可重复,cmd函数,
短字符串,
长字符串
);
</code></pre>
<blockquote>
<p>例子：</p>
<pre><code class="language-c">U_BOOT_CMD(
 	bootm,	CFG_MAXARGS,	1,	do_bootm,
 	&quot;bootm   - boot application image from memory\n&quot;,
 	&quot;[addr [arg ...]]\n    - boot application image stored in memory\n&quot;
 	&quot;\tpassing arguments 'arg ...'; when booting a Linux kernel,\n&quot;
 	&quot;\t'arg' can be the address of an initrd image\n&quot;
#ifdef CONFIG_OF_FLAT_TREE
	&quot;\tWhen booting a Linux kernel which requires a flat device-tree\n&quot;
	&quot;\ta third argument is required which is the address of the of the\n&quot;
	&quot;\tdevice-tree blob. To boot that kernel without an initrd image,\n&quot;
	&quot;\tuse a '-' for the second argument. If you do not pass a third\n&quot;
	&quot;\ta bd_info struct will be passed instead\n&quot;
#endif
);
</code></pre>
</blockquote>
<h2 id="五、启动内核">五、启动内核</h2>
<p>uboot启动内核是依赖以下两条命令：</p>
<pre><code class="language-c">s = getenv (&quot;bootcmd&quot;);
</code></pre>
<pre><code class="language-c">run_command (s, 0);
</code></pre>
<p>这里的<code>s</code>为环境变量<code>bootcmd</code>中的值，即</p>
<pre><code class="language-bash">nand read.jffs2 0x30007EC0 kernel;//从kernel分区读出内核放到0x30007EC0位置
bootm 0x30007EC0//从0x30007EC0位置启动内核
</code></pre>
<p>这里的分区在源码中已经写死，位置为：<code>include/configs/a00ask24x0.h</code>中的<code>MTDPARTS_DEFAULT</code>宏：</p>
<pre><code class="language-c">#define MTDPARTS_DEFAULT &quot;mtdparts=nandflash0:256k@0(bootloader),&quot; \/*0开始的256k为bootloader*/
                            &quot;128k(params),&quot; \/*接下来的128k为环境变量*/
                            &quot;2m(kernel),&quot; \
                            &quot;-(root)&quot;
</code></pre>
<p>在uboot下可以通过<code>mtd</code>命令读取，kernel结果为0x0006 0000起始，大小为0x0020 0000，故原来的指令可以改写为：</p>
<pre><code>nand read.jffs2 0x30007EC0 0x00060000 0x00200000;//从0x00060000读出0x00200000大小数据放到0x30007EC0位置
bootm 0x30007EC0//从0x30007EC0位置启动内核
</code></pre>
<h3 id="nand命令">nand命令</h3>
<p>通过全局搜索<code>nand</code>可以搜索到其命令函数在<code>common/cmd_nand.c</code>下的do_nand函数，简化后：</p>
<pre><code class="language-c">int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
    int i, dev, ret;
    ulong addr, off, size;
    char *cmd, *s;
    nand_info_t *nand;
    int quiet = 0;
    const char *quiet_str = getenv(&quot;quiet&quot;);

    /* at least two arguments please */
    if (argc &lt; 2)
        goto usage;

    if (quiet_str)
        quiet = simple_strtoul(quiet_str, NULL, 0) != 0;

    cmd = argv[1];

    ......
    /* read write */
    if (strncmp(cmd, &quot;read&quot;, 4) == 0 || strncmp(cmd, &quot;write&quot;, 5) == 0) {
        int read;

        if (argc &lt; 4)
            goto usage;

        addr = (ulong)simple_strtoul(argv[2], NULL, 16);

        read = strncmp(cmd, &quot;read&quot;, 4) == 0; /* 1 = read, 0 = write */
        printf(&quot;\nNAND %s: &quot;, read ? &quot;read&quot; : &quot;write&quot;);
        if (arg_off_size(argc - 3, argv + 3, nand, &amp;off, &amp;size) != 0)
            return 1;

        s = strchr(cmd, '.');
        if (s != NULL &amp;&amp;
            (!strcmp(s, &quot;.jffs2&quot;) || !strcmp(s, &quot;.e&quot;) || !strcmp(s, &quot;.i&quot;))) {
            if (read) {
                /* read */
                nand_read_options_t opts;
                memset(&amp;opts, 0, sizeof(opts));
                opts.buffer = (u_char*) addr;
                opts.length = size;
                opts.offset = off;
                opts.quiet      = quiet;
                ret = nand_read_opts(nand, &amp;opts);
            } else {
                /* write */
                ......
            }
        }
        ......

        printf(&quot; %d bytes %s: %s\n&quot;, size,
               read ? &quot;read&quot; : &quot;written&quot;, ret ? &quot;ERROR&quot; : &quot;OK&quot;);

        return ret == 0 ? 0 : 1;
    }
usage:
    printf(&quot;Usage:\n%s\n&quot;, cmdtp-&gt;usage);
    return 1;
}
</code></pre>
<p>最后是调用的<code>nand_read_opts</code>读出的内核</p>
<h3 id="bootm命令">bootm命令</h3>
<p>Flash上储存的是uImage=头部+zImage，其中头部为：</p>
<pre><code class="language-c">typedef struct image_header {
	uint32_t	ih_magic;	/* Image Header Magic Number	*/
	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
	uint32_t	ih_time;	/* Image Creation Timestamp	*/
	uint32_t	ih_size;	/* Image Data Size		*/
	uint32_t	ih_load;	/* Data	 Load  Address		*/
	uint32_t	ih_ep;		/* Entry Point Address		*/
	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
	uint8_t		ih_os;		/* Operating System		*/
	uint8_t		ih_arch;	/* CPU architecture		*/
	uint8_t		ih_type;	/* Image Type			*/
	uint8_t		ih_comp;	/* Compression Type		*/
	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
} image_header_t;
</code></pre>
<p>这里有以下两个成员值得关注：</p>
<ul>
<li>ih_load：加载地址，即运行时放在那里（加载地址&lt;—&gt;存储地址）</li>
<li>ih_ep：入口地址，运行内核是跳转的地址（运行地址&lt;—&gt;链接地址）</li>
</ul>
<p>bootm命令流程：</p>
<ol>
<li>
<p>读取头部信息，并根据头部信息移动内核到<code>ih_load</code>处</p>
<blockquote>
<p>uboot环境变量中的启动命令：</p>
<p>nand read.jffs2 0x30007EC0 0x00060000 0x00200000;</p>
<p>上述ih_load在本文所处的环境中为0x30008000 ，而头部信息刚好64字节，所以这里0x30007EC0=0x30008000 - 64，即提前将linux内核搬移到指定位置，避免bootm命令中重复搬移</p>
</blockquote>
</li>
<li>
<p>通过<code>do_bootm_linux</code>启动内核</p>
<ol>
<li>
<p>设置启动参数（各种tag：开始tag、命令行tag、结束tag…）</p>
<blockquote>
<p>这里的命令行tag就是uboot中的环境变量bootargs中的值</p>
<p>本文所处的环境中：</p>
<p>bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</p>
</blockquote>
</li>
<li>
<p>跳转到入口地址<code>ih_ep</code>处，并将机器id和启动参数的所在地址一并传入</p>
<blockquote>
<p>linux内核会根据不同的机器id来决定是否支持该板卡</p>
</blockquote>
</li>
</ol>
</li>
</ol>
