<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>设备树 | spaceman</title><meta name="keywords" content="设备树"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设备树 内核相关文档： Documentation&#x2F;devicetree&#x2F;bindings&#x2F;  相关约定如下： dts：device tree source，设备树源文件 dtb：device tree blob，设备树二进制文件, 由dts编译得来 dtc：设备树编译工具 blob：binary large object  一、设备树的规范(dts和dtb) 1. DTS格式 参考文档：官方文档">
<meta property="og:type" content="article">
<meta property="og:title" content="设备树">
<meta property="og:url" content="http://nu-ll.github.io/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/index.html">
<meta property="og:site_name" content="spaceman">
<meta property="og:description" content="设备树 内核相关文档： Documentation&#x2F;devicetree&#x2F;bindings&#x2F;  相关约定如下： dts：device tree source，设备树源文件 dtb：device tree blob，设备树二进制文件, 由dts编译得来 dtc：设备树编译工具 blob：binary large object  一、设备树的规范(dts和dtb) 1. DTS格式 参考文档：官方文档">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2019-10-13T07:53:24.000Z">
<meta property="article:modified_time" content="2020-04-07T14:47:18.268Z">
<meta property="article:author" content="spaceman">
<meta property="article:tag" content="设备树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设备树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-07 22:47:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">spaceman</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设备树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-13T07:53:24.000Z" title="发表于 2019-10-13 15:53:24">2019-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-07T14:47:18.268Z" title="更新于 2020-04-07 22:47:18">2020-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设备树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>设备树</h1>
<p>内核相关文档：</p>
<p>Documentation/devicetree/bindings/</p>
<blockquote>
<p>相关约定如下：</p>
<p>dts：device tree source，设备树源文件</p>
<p>dtb：device tree blob，设备树二进制文件, 由dts编译得来</p>
<p>dtc：设备树编译工具</p>
<p>blob：binary large object</p>
</blockquote>
<h2 id="一、设备树的规范-dts和dtb">一、设备树的规范(dts和dtb)</h2>
<h3 id="1-DTS格式">1. DTS格式</h3>
<p>参考文档：<a target="_blank" rel="noopener" href="https://www.devicetree.org/specifications/">官方文档</a></p>
<h4 id="DTS文件布局-layout">DTS文件布局(layout)</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;<span class="comment">//设备树版本</span></span><br><span class="line">[memory reservations]    <span class="comment">// 保留该处的内存（一般这里就是存放设备树文件的地方），内核不会使用该处内存，格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;//address和length均为64位，如：/memreserve/ 0x33f00000 0x100000</span></span><br><span class="line">/ &#123;</span><br><span class="line">    [property definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关规定：</p>
<ul>
<li>
<p>一般来说一些公共部分会组合起来写成<code>.dtsi</code>文件</p>
</li>
<li>
<p>普通的<code>.dts</code>文件可以包含这些<code>.dtsi</code>文件（类似C语言）</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;XXXX.dtsi&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通的<code>.dts</code>文件可以通过重写所包含的<code>.dtsi</code>文件中的属性来进行覆盖操作</p>
</li>
<li>
<p>编译<code>.dts</code>文件为<code>.dtb</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Linux内核源码下操作</span></span><br><span class="line"><span class="comment">#编译所有改动过的设备树</span></span><br><span class="line">make dtbs</span><br><span class="line"><span class="comment">#编译指定设备树</span></span><br><span class="line">make xxxx.dtb</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反汇编<code>.dtb</code>文件为<code>.dts</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts -o 输出文件.dts 输入文件.dtb</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="语法">语法</h4>
<p>Devicetree node（设备节点）格式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">    [properties definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>同一级别下，node-name[@unit-address]不能一样，不同级别可以一样</p>
</li>
<li>
<p>每个属性后必须加上分号，每个节点大括号后必须加上分号</p>
</li>
</ul>
<p>Property 格式1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure>
<p>Property 格式2(没有值):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name;</span><br></pre></td></tr></table></figure>
<p>Property取值只有3种:</p>
<ul>
<li>arrays of cells(1个或多个32位数据, 64位数据使用2个32位数据表示)</li>
<li>string(字符串)</li>
<li>bytestring(1个或多个字节)</li>
</ul>
<h5 id="相关示例">相关示例</h5>
<p>a. Arrays of cells : cell就是一个32位的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">17</span> <span class="number">0xc</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>b. 64bit数据使用2个cell来表示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>c. A null-terminated string (有结束符的字符串):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>d. A bytestring(字节序列) :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local-mac-address = [<span class="number">00</span> <span class="number">00</span> <span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];  <span class="comment">// 每个byte使用2个16进制数来表示</span></span><br><span class="line">local-mac-address = [<span class="number">000012345678</span>];       <span class="comment">// 每个byte使用2个16进制数来表示</span></span><br></pre></td></tr></table></figure>
<p>e. 可以是各种值的组合, 用逗号隔开:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;ns16550&quot;</span>, <span class="string">&quot;ns8250&quot;</span>;</span><br><span class="line">example = &lt;<span class="number">0xf00f0000</span> <span class="number">19</span>&gt;, <span class="string">&quot;a strange property format&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="特殊以及默认属性">特殊以及默认属性</h4>
<h5 id="a-（根节点">a. /（根节点)</h5>
<p>这部分可以理解为<strong>通用属性</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells   <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)</span></span></span><br><span class="line"><span class="meta">#size-cells      <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)</span></span></span><br><span class="line"></span><br><span class="line">compatible       <span class="comment">// 兼容性列表。通过定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备</span></span><br><span class="line">                 <span class="comment">// 即这个板子兼容哪些平台</span></span><br><span class="line">                 <span class="comment">// 内核会通过该属性找到对应平台的machine_desc结构体初始化该板卡</span></span><br><span class="line">                 <span class="comment">//（该属性可以有很多个字符串组成，内核会按照先后顺序依次查找，直到找到为止）</span></span><br><span class="line"></span><br><span class="line">model            <span class="comment">// 描述设备模块信息。可以理解为相同板卡的不同软件版本，即使用的板卡是采用那个版本的配置文件初始化的</span></span><br><span class="line">                 <span class="comment">// 比如有2款板子配置基本一致, 它们的compatible是一样的</span></span><br><span class="line">                 <span class="comment">// 那么就通过model来分辨这2款板子</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：只有在<code>/</code>节点下，<code>compatible</code>中的字符串才需要和machine_desc结构体进行匹配。</p>
<p>在其余节点中，<code>compatible</code>一般用于将设备和驱动绑定起来</p>
</blockquote>
<h5 id="b-memory节点">b. /memory节点</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_type = <span class="string">&quot;memory&quot;</span>;<span class="comment">// 约定俗成，必须加该属性</span></span><br><span class="line">reg             <span class="comment">// 根据上层的#address-cells、#size-cells来指定内存的地址、大小</span></span><br></pre></td></tr></table></figure>
<h5 id="c-chosen节点">c. /chosen节点</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootargs        <span class="comment">// 内核command line参数, 跟u-boot中设置的bootargs作用一样</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该参数由uboot根据启动参数bootargs自行设置，一般无需自己处理</li>
</ul>
<h5 id="d-cpus节点">d. /cpus节点</h5>
<p><code>/cpus</code>节点下有1个或多个cpu子节点, cpu子节点中用reg属性用来标明自己是哪一个cpu，所以 <code>/cpus</code> 中有以下2个属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells   <span class="comment">// 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述地址(address)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#size-cells      <span class="comment">// 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述大小(size)，必须设置为 0</span></span></span><br></pre></td></tr></table></figure>
<h5 id="e-cpus-cpu">e. /cpus/cpu*</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">reg             <span class="comment">// 表明自己是哪一个cpu</span></span><br></pre></td></tr></table></figure>
<h4 id="引用其他节点">引用其他节点</h4>
<h5 id="a-phandle属性">a. phandle属性</h5>
<p>节点中的phandle属性, 它的取值必须是唯一的(不要跟其他的phandle值一样)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span> &#123;</span><br><span class="line">    phandle = &lt;<span class="number">1</span>&gt;;			<span class="comment">//phandle属性必须唯一</span></span><br><span class="line">    interrupt-controller;	<span class="comment">//该属性表明这是中断控制器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">another-device-node &#123;</span><br><span class="line">    interrupt-parent = &lt;<span class="number">1</span>&gt;;   <span class="comment">// 引用phandle值为1的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="b-label属性">b. label属性</h5>
<p>通过<code>&amp;</code>进行引用，底层原理和phandle属性的方法是一样的，只是phandle属性部分由编译器将替我们完成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PIC: pic@<span class="number">10000000</span> &#123;</span><br><span class="line">    interrupt-controller;	<span class="comment">//该属性表明这是中断控制器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">another-device-node &#123;</span><br><span class="line">    interrupt-parent = &lt;&amp;PIC&gt;;   <span class="comment">// 使用label来引用上述节点,</span></span><br><span class="line">                                 <span class="comment">// 使用lable时实际上也是使用phandle来引用,</span></span><br><span class="line">                                 <span class="comment">// 在编译dts文件为dtb文件时, 编译器dtc会在dtb中插入phandle属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>label属性可以在**<code>/</code>节点外**直接引用并修改对应节点中的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为XXXX.dtsi文件内容：</span></span><br><span class="line">/ &#123;</span><br><span class="line">	......</span><br><span class="line">    PIC: pic@<span class="number">10000000</span> &#123;</span><br><span class="line">    	pin = &lt;XXX&gt;;</span><br><span class="line">        interrupt-controller;	<span class="comment">//该属性表明这是中断控制器</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;XXXX.dtsi&quot;</span></span></span><br><span class="line">&amp;PIC &#123;</span><br><span class="line">	pin = &lt;XXXXXXX&gt;;<span class="comment">//直接修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-DTB二进制文件的格式">2. DTB二进制文件的格式</h3>
<p><a target="_blank" rel="noopener" href="https://www.devicetree.org/specifications/">官方文档</a></p>
<p>内核文档路径：<code>Documentation/devicetree/booting-without-of.txt</code></p>
<p>dtb文件是由dts文件编译而来</p>
<h4 id="DTB文件布局">DTB文件布局</h4>
<p>dtb文件以<code>大字节序</code>存储（低地址放高位）。根据官方说明，dtb文件结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        ------------------------------</span><br><span class="line">base -&gt; |  <span class="class"><span class="keyword">struct</span> <span class="title">boot_param_header</span>  | //头部信息，包含后几个部分的指针</span></span><br><span class="line"><span class="class">        ------------------------------</span></span><br><span class="line"><span class="class">        |      (<span class="title">alignment</span> <span class="title">gap</span>) (*)   |</span></span><br><span class="line"><span class="class">        ------------------------------</span></span><br><span class="line"><span class="class">        |      <span class="title">memory</span> <span class="title">reserve</span> <span class="title">map</span>    |//保留给自己使用的内存，即<span class="title">dts</span>中格式为:</span> /memreserve/ &lt;address&gt; &lt;length&gt;;的地方</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      (alignment gap)       |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |                            |</span><br><span class="line">        |    device-tree structure   |<span class="comment">//设备数的二进制文件</span></span><br><span class="line">        |                            |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      (alignment gap)       |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |                            |</span><br><span class="line">        |     device-tree strings    |<span class="comment">//设备数节点中的属性名字字符串</span></span><br><span class="line">        |                            |</span><br><span class="line"> -----&gt; ------------------------------</span><br><span class="line"> |</span><br><span class="line"> |</span><br><span class="line"> --- (base + totalsize)</span><br></pre></td></tr></table></figure>
<p>具体格式可见下图：</p>
<p><img src="/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/DTB%E6%A0%BC%E5%BC%8F.jpg" alt="DTB格式"></p>
<h3 id="3-通用函数">3. 通用函数</h3>
<p>device_node结构体与property结构体内容可以看下文中 <code>第二章第4节</code></p>
<h4 id="查找节点">查找节点</h4>
<ol>
<li>
<p>通过名字查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_name</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>name：要查找的节点名字（不是table和name属性）。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li>
<p>通过device_type 属性查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_type</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li>
<p>根据 device_type 和 compatible查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_compatible_node</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *compatible)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li>
<li>compatible： 要查找的节点所对应的 compatible 属性列表。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>通过 of_device_id 匹配表来查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_matching_node_and_match</span><span class="params">(struct device_node *from, <span class="keyword">const</span> struct of_device_id *matches, <span class="keyword">const</span> struct of_device_id **match)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li>
<li>match： 找到的匹配的 of_device_id。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>通过路径查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> struct device_node *<span class="title">of_find_node_by_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>path：带有全路径的节点名，可以使用节点的别名。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>查找指定节点的父节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_parent</span><span class="params">(<span class="keyword">const</span> struct device_node *node)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>node：要查找的父节点的节点。</li>
<li>返回值： 找到的父节点。</li>
</ul>
</li>
<li>
<p>查找指定节点的子节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_next_child</span><span class="params">(<span class="keyword">const</span> struct device_node *node, struct device_node *prev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>node：父节点。</li>
<li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li>
<li>返回值： 找到的下一个子节点。</li>
</ul>
</li>
</ol>
<h4 id="提取属性">提取属性</h4>
<ol>
<li>
<p>查找节点中的指定属性</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">property *<span class="title">of_find_property</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> *lenp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>name： 属性名字。</li>
<li>lenp：属性值的字节数，一般为NULL</li>
<li>返回值： 找到的属性。</li>
</ul>
</li>
<li>
<p>获取属性中元素的数量</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_count_elems_of_size</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">int</span> elem_size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 需要统计元素数量的属性名字。</li>
<li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li>
<li>返回值： 得到的属性元素数量。</li>
</ul>
</li>
<li>
<p>从属性中获取指定标号的 u32 类型数据值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_index</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 index, u32 *out_value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>index：要读取的值标号。</li>
<li>out_value：读取到的值</li>
<li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u8 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u16 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u64 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li>
<li>sz： 要读取的数组元素数量。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取只有一个整形值的属性</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8</span><span class="params">(<span class="keyword">const</span> struct device_node *np,<span class="keyword">const</span> <span class="keyword">char</span> *propname, u8 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u16 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u64 *out_value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_value：读取到的数组值。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取属性中字符串值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_string</span><span class="params">(struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">const</span> <span class="keyword">char</span> **out_string)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_string：读取到的字符串值。</li>
<li>返回值： 0，读取成功，负值，读取失败。</li>
</ul>
</li>
<li>
<p>获取#address-cells 属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_addr_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#address-cells 属性值。</li>
</ul>
</li>
<li>
<p>获取#size-cells 属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_size_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#size-cells 属性值。</li>
</ul>
</li>
</ol>
<h4 id="其他常用函数">其他常用函数</h4>
<ol>
<li>
<p>查看节点的 compatible 属性是否有包含指定的字符串</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_device_is_compatible</span><span class="params">(<span class="keyword">const</span> struct device_node *device, <span class="keyword">const</span> <span class="keyword">char</span> *compat)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>device：设备节点。</li>
<li>compat：要查看的字符串。</li>
<li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li>
</ul>
</li>
<li>
<p>获取地址相关属性</p>
<p>主要是“reg”或者“assigned-addresses”属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> __be32 *<span class="title">of_get_address</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index, u64 *size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>index：要读取的地址标号。</li>
<li>size：地址长度。</li>
<li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li>
<li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li>
</ul>
</li>
<li>
<p>将从设备树读取到的地址转换为物理地址</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">of_translate_address</span><span class="params">(struct device_node *dev, <span class="keyword">const</span> __be32 *in_addr)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>in_addr：要转换的地址。</li>
<li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li>
</ul>
</li>
<li>
<p>从设备树里面提取资源值</p>
<p>本质上是将 reg 属性值转换为 resource 结构体类型</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_address_to_resource</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index, struct resource *r)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>index：地址资源标号。</li>
<li>r：得到的 resource 类型的资源值。</li>
<li>返回值： 0，成功；负值，失败。</li>
</ul>
</li>
<li>
<p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p>
<p>本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">of_iomap</span><span class="params">(struct device_node *np, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li>
<li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li>
</ul>
</li>
</ol>
<h2 id="二、内核对设备树的处理">二、内核对设备树的处理</h2>
<p>根据内核文档中的描述，内核对设备数的处理大概分为以下三个部分：</p>
<ol>
<li>platform identification，平台识别信息</li>
<li>runtime configuration，运行时配置信息</li>
<li>device population，设备信息</li>
</ol>
<h3 id="1-内核head-S对dtb的简单处理">1. 内核head.S对dtb的简单处理</h3>
<p>uboot启动后，会设置r0 r1 r2 三个寄存器，将参数传给linux内核：</p>
<ul>
<li>r0一般设置为0;</li>
<li>r1一般设置为machine id (机器ID，在使用设备树时该参数没有被使用);</li>
<li>r2一般设置ATAGS或DTB的开始地址</li>
</ul>
<p>inux内核启动后会运行head.S文件，head.S和head-common.S文件一起将传入的这几个参数又传给了内核中的C语言变量：</p>
<ul>
<li>把bootloader传来的r1值, 赋给了C变量: <code>__machine_arch_type</code></li>
<li>把bootloader传来的r2值, 赋给了C变量: <code>__atags_pointer</code>     // dtb首地址</li>
</ul>
<p>之后会调用start_kernel启动内核。</p>
<h3 id="2-对设备树中平台信息的处理-选择machine-desc结构体">2. 对设备树中平台信息的处理(选择machine_desc结构体)</h3>
<p>大概流程如下：</p>
<ul>
<li>
<p>a. 设备树根节点的<code>compatible</code>属性列出了一系列的字符串,表示它兼容的单板名,从&quot;最兼容&quot;到次之</p>
</li>
<li>
<p>b. 内核中有多个machine_desc,其中有<code>dt_compat</code>成员, 它指向一个字符串数组, 里面表示该machine_desc支持哪些单板</p>
<blockquote>
<p>没有用设备树的时候，uboot向linux内核传递ATAGS，此时是根据machine_desc.nr成员来匹配机器id是否相等进而选取的</p>
</blockquote>
</li>
<li>
<p>c. 使用<code>compatile</code>属性的值，跟每一个<code>machine_desc.dt_compat</code>比较，如若多项均匹配上，<code>compatile</code>属性中越靠前的字符串优先级越高</p>
</li>
</ul>
<p>函数调用过程如下：</p>
<hr>
<ul>
<li>
<p>start_kernel   // init/main.c</p>
<ul>
<li>
<p>setup_arch(&amp;command_line);  （先尝试将__atags_pointer处的数据认为是dtb并进行分析，如若出错就将其当做ATAGS分析）// arch/arm/kernel/setup.c</p>
<ul>
<li>
<p>mdesc = setup_machine_fdt(__atags_pointer);  // arch/arm/kernel/devtree.c</p>
<ul>
<li>
<p>early_init_dt_verify(phys_to_virt(dt_phys)  // 检查头部信息，判断是否有效的dtb, drivers/of/ftd.c</p>
<ul>
<li>initial_boot_params = params;//保存在全局变量initial_boot_params中</li>
</ul>
</li>
<li>
<p>mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);  // 找到最匹配的machine_desc，arch_get_next_mach为一个函数指针，该函数每调用一次就会返回一个machine_desc.dt_compat, drivers/of/ftd.c</p>
<ul>
<li>
<pre><code class="language-c">  while ((data = get_next_compat(&amp;compat))) &#123;
      score = of_flat_dt_match(dt_root, compat);
      if (score &gt; 0 &amp;&amp; score &lt; best_score) &#123;
          best_data = data;
          best_score = score;
      &#125;
  &#125;
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">		* machine_desc &#x3D; mdesc;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 3. 对设备树中运行时配置信息的处理</span><br><span class="line"></span><br><span class="line">大致流程如下：</span><br><span class="line"></span><br><span class="line">* a. &#x2F;chosen节点中bootargs属性的值, 存入全局变量： boot_command_line</span><br><span class="line">* b. 确定根节点的这2个属性的值: #address-cells, #size-cells存入全局变量: dt_root_addr_cells, dt_root_size_cells</span><br><span class="line">* c. 解析&#x2F;memory中的reg属性, 提取出&quot;base, size&quot;, 最终调用memblock_add(base, size);</span><br><span class="line"></span><br><span class="line">函数调用过程如下：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* start_kernel &#x2F;&#x2F; init&#x2F;main.c</span><br><span class="line"></span><br><span class="line">	* setup_arch(&amp;command_line);  &#x2F;&#x2F; arch&#x2F;arm&#x2F;kernel&#x2F;setup.c</span><br><span class="line"></span><br><span class="line">		* mdesc &#x3D; setup_machine_fdt(__atags_pointer);  &#x2F;&#x2F; arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c</span><br><span class="line"></span><br><span class="line">			* early_init_dt_scan_nodes();      &#x2F;&#x2F; drivers&#x2F;of&#x2F;ftd.c</span><br><span class="line"></span><br><span class="line">				* &#96;&#96;&#96;c</span><br><span class="line">					&#x2F;* Retrieve various information from the &#x2F;chosen node *&#x2F;</span><br><span class="line">					of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);&#x2F;&#x2F;将bootargs属性的值, 存入全局变量boot_command_line</span><br><span class="line">					</span><br><span class="line">					&#x2F;* Initialize &#123;size,address&#125;-cells info *&#x2F;</span><br><span class="line">					of_scan_flat_dt(early_init_dt_scan_root, NULL);&#x2F;&#x2F;处理并保存 根节点信息中的#address-cells, #size-cells属性</span><br><span class="line">					</span><br><span class="line">					&#x2F;* Setup memory, calling early_init_dt_add_memory_arch *&#x2F;</span><br><span class="line">					of_scan_flat_dt(early_init_dt_scan_memory, NULL);&#x2F;&#x2F;取出&#x2F;memory节点reg属性中的&quot;base, size&quot;并告诉内核</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-dtb转换为device-node-unflatten-device-tree函数">4. dtb转换为device_node(unflatten_device_tree函数)</h3>
<p>大致过程：</p>
<ul>
<li>
<p>a. 在DTB文件中, 每一个节点都以TAG(FDT_BEGIN_NODE, 0x00000001)开始, 节点内部可以嵌套其他节点,每一个属性都以TAG(FDT_PROP, 0x00000003)开始</p>
</li>
<li>
<p>b. 每一个节点最后都会转换为一个device_node结构体:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 来自节点中的name属性, 如果没有该属性, 则设为&quot;NULL&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 来自节点中的device_type属性, 如果没有该属性, 则设为&quot;NULL&quot;</span></span><br><span class="line">    phandle phandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *full_name;  <span class="comment">// 节点的名字, node-name[@unit-address]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">properties</span>;</span>  <span class="comment">// 节点的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">deadprops</span>;</span>    <span class="comment">/* removed properties */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">parent</span>;</span>   <span class="comment">// 节点的父亲</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">child</span>;</span>    <span class="comment">// 节点的孩子(子节点)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">sibling</span>;</span>  <span class="comment">// 节点的兄弟(同级节点)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</span><br><span class="line">    <span class="keyword">void</span>    *data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path_component_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>c. device_node结构体中有properties, 用来表示该节点的属性，每一个属性对应一个property结构体:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    *name;    <span class="comment">// 属性名字, 指向dtb文件中的字符串</span></span><br><span class="line">    <span class="keyword">int</span> length;       <span class="comment">// 属性值的长度，按字节计算</span></span><br><span class="line">    <span class="keyword">void</span>    *value;   <span class="comment">// 属性值, 指向dtb文件中value所在位置, 数据仍以big endian存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_PROMTREE)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unique_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>d. 这些device_node构成一棵树, 根节点为: <code>of_root</code></p>
</li>
</ul>
<p>函数调用过程：</p>
<hr>
<ul>
<li>
<p>start_kernel // init/main.c</p>
<ul>
<li>
<p>setup_arch(&amp;command_line);  // arch/arm/kernel/setup.c</p>
<ul>
<li>
<p>arm_memblock_init(mdesc);   // arch/arm/kernel/setup.c</p>
<ul>
<li>early_init_fdt_reserve_self();//将DTB所占区域保留下来, 最后会调用: memblock_reserve</li>
<li>early_init_fdt_scan_reserved_mem();  // 根据dtb中的memreserve信息, 调用memblock_reserve保留其他区域</li>
</ul>
</li>
<li>
<p>unflatten_device_tree();    // arch/arm/kernel/setup.c//开始分配设置device_node结构体</p>
<ul>
<li>
<p>__unflatten_device_tree(initial_boot_params, NULL, &amp;of_root,early_init_dt_alloc_memory_arch, false);            // drivers/of/fdt.c</p>
<ul>
<li>
<pre><code class="language-c">  /* First pass, scan for size */
  size = unflatten_dt_nodes(blob, NULL, dad, NULL);
  
  /* Allocate memory for the expanded device tree */
  mem = dt_alloc(size + 4, __alignof__(struct device_node));
  
  /* Second pass, do actual unflattening */
  unflatten_dt_nodes(blob, mem, dad, mynodes);
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 5. device_node结构体转换为platform_device</span><br><span class="line"></span><br><span class="line">基本流程：dts -&gt; dtb -&gt; device_node -&gt; platform_device</span><br><span class="line"></span><br><span class="line">* 转化为platform_device的只有一部分device_node </span><br><span class="line"></span><br><span class="line">	&gt; 条件：</span><br><span class="line">	&gt;</span><br><span class="line">	&gt; 1. 一般来说&lt;u&gt;根节点下&lt;&#x2F;u&gt;包含compatile属性的&lt;u&gt;子节点&lt;&#x2F;u&gt;都会转化为platform_device。而其他子节点不应该转化为platform_device。如：i2c, spi等总线节点下的子节点, 应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device</span><br><span class="line">	&gt; 2. 特殊情况：如果一个节点的compatile属性含有这些特殊的值（&#96;simple-bus&#96;、&#96;simple-mfd&#96;、&#96;isa&#96;、&#96;arm,amba-bus&#96;）（由drivers\of\platform.c中的of_default_bus_match_table表定义）之一, 那么它的子节点（也需含compatile属性。详见下面of_platform_bus_create的实现）也可以转换为platform_device</span><br><span class="line">	&gt;</span><br><span class="line">	&gt; 附：</span><br><span class="line">	&gt;</span><br><span class="line">	&gt; 根节点下的iic、spi总线节点一般都会转化为platform_device结构体，这些总线节点下的子节点一般不再会转换为platform_device，而是交给bus的probe函数去注册为i2c_client、spi_device等设备结构体</span><br><span class="line"></span><br><span class="line">转化过程：</span><br><span class="line"></span><br><span class="line">* 利用device_node中的reg, interrupts属性设置platform_device中的&#96;resource&#96;数组</span><br><span class="line">* 将device_node结构体挂载在&#96;platform_device.dev.of_node&#96;上</span><br><span class="line"></span><br><span class="line">函数调用过程：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">核心函数：of_platform_default_populate_init</span><br><span class="line"></span><br><span class="line">&gt; 注：</span><br><span class="line">&gt;</span><br><span class="line">&gt; 该函数不会直接调用，会通过do_initcall_level(level);函数间接调用，of_platform_default_populate_init函数通过一个宏将其放到了.initcall3s.init段处。do_initcall_level(3)会调用.initcall3s.init段的所有函数。</span><br><span class="line"></span><br><span class="line">调用of_platform_default_populate_init：</span><br><span class="line"></span><br><span class="line">* start_kernel     &#x2F;&#x2F; init&#x2F;main.c</span><br><span class="line"></span><br><span class="line">	* rest_init();</span><br><span class="line"></span><br><span class="line">		* pid &#x3D; kernel_thread(kernel_init, NULL, CLONE_FS);&#x2F;&#x2F;启动线程kernel_init</span><br><span class="line"></span><br><span class="line">			* kernel_init线程中：</span><br><span class="line"></span><br><span class="line">			* kernel_init_freeable();</span><br><span class="line"></span><br><span class="line">				* do_basic_setup();</span><br><span class="line"></span><br><span class="line">					* do_initcalls();</span><br><span class="line"></span><br><span class="line">						* &#96;&#96;&#96;c</span><br><span class="line">							for (level &#x3D; 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++)</span><br><span class="line">							    do_initcall_level(level);  &#x2F;&#x2F; 比如 do_initcall_level(3)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>生成platform_device:</p>
<ul>
<li>
<p>of_platform_default_populate_init//遍历所有节点并生成platform_device结构体</p>
<ul>
<li>
<p>of_platform_default_populate(NULL, NULL, NULL);</p>
<ul>
<li>
<p>of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL)</p>
<ul>
<li>
<pre><code class="language-c">  for_each_child_of_node(root, child) &#123;
      rc = of_platform_bus_create(child, matches, lookup, parent, true);  // 调用过程看下面
      dev = of_device_alloc(np, bus_id, parent);   // 根据device_node节点的属性设置platform_device的resource
      if (rc) &#123;
          of_node_put(child);
          break;
      &#125;
  &#125;
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">of_platform_bus_create创建总线节点（处理bus节点生成platform_devie, 并决定是否处理它的子节点）</span><br><span class="line"></span><br><span class="line">* of_platform_bus_create</span><br><span class="line"></span><br><span class="line">	* &#96;&#96;&#96;c</span><br><span class="line">		dev &#x3D; of_platform_device_create_pdata(bus, bus_id, platform_data, parent);  &#x2F;&#x2F; 生成bus节点的platform_device结构体</span><br><span class="line">		if (!dev || !of_match_node(matches, bus))  &#x2F;&#x2F; 如果bus节点的compatile属性不吻合matches成表, 就不处理它的子节点</span><br><span class="line">		    return 0;</span><br><span class="line">		</span><br><span class="line">		for_each_child_of_node(bus, child) &#123;    &#x2F;&#x2F; 取出每一个子节点</span><br><span class="line">		    pr_debug(&quot;   create child: %pOF\n&quot;, child);</span><br><span class="line">		    rc &#x3D; of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);   &#x2F;&#x2F; 处理它的子节点, of_platform_bus_create是一个递归调用</span><br><span class="line">		    if (rc) &#123;</span><br><span class="line">		        of_node_put(child);</span><br><span class="line">		        break;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-platform-device跟platform-driver的匹配">6. platform_device跟platform_driver的匹配</h3>
<p>匹配时通过platform_bus_type的match成员函数实现的，即platform_match</p>
<p>匹配的优先级如下：</p>
<ul>
<li>比较 platform_dev.driver_override 和 platform_driver.drv-&gt;name</li>
<li>比较 platform_dev.dev.of_node的compatible属性 和 platform_driver.drv-&gt;of_match_table</li>
<li>比较 platform_dev.name 和 platform_driver.id_table</li>
<li>比较 platform_dev.name 和 platform_driver.drv-&gt;name</li>
</ul>
<h3 id="7-内核中设备树的操作函数">7. 内核中设备树的操作函数</h3>
<ul>
<li>
<p>a. 处理DTB<br>
of_fdt.h           // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)</p>
</li>
<li>
<p>b. 处理device_node<br>
of.h               // 提供设备树的一般处理函数, 比如 of_property_read_u32(读取某个属性的u32值), of_get_child_count(获取某个device_node的子节点数)<br>
of_address.h       // 地址相关的函数, 比如 of_get_address(获得reg属性中的addr, size值)<br>
of_match_device(从matches数组中取出与当前设备最匹配的一项)<br>
of_dma.h           // 设备树中DMA相关属性的函数<br>
of_gpio.h          // GPIO相关的函数<br>
of_graph.h         // GPU相关驱动中用到的函数, 从设备树中获得GPU信息<br>
of_iommu.h         // 很少用到<br>
of_irq.h           // 中断相关的函数<br>
of_mdio.h          // MDIO (Ethernet PHY) API<br>
of_net.h           // OF helpers for network devices.<br>
of_pci.h           // PCI相关函数<br>
of_pdt.h           // 很少用到<br>
of_reserved_mem.h  // reserved_mem的相关函数</p>
</li>
<li>
<p>c. 处理设备相关的信息 platform_device<br>
of_platform.h      // 把device_node转换为platform_device时用到的函数,<br>
// 比如of_device_alloc(根据device_node分配设置platform_device),<br>
//     of_find_device_by_node (根据device_node查找到platform_device),<br>
//     of_platform_bus_probe (处理device_node及它的子节点)<br>
of_device.h        // 设备相关的函数, 比如 of_match_device</p>
</li>
</ul>
<h3 id="8-在根文件系统中查看设备树-有助于调试">8. 在根文件系统中查看设备树(有助于调试)</h3>
<ul>
<li>
<p>a. <code>/sys/firmware/fdt</code>        // 原始dtb文件</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印设备数文件（dtb文件）</span></span><br><span class="line">hexdump -C /sys/firmware/fdt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>b. <code>/sys/firmware/devicetree</code> // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件</p>
</li>
<li>
<p>c. <code>/sys/devices/platform</code>    // 系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的<br>
对于来自设备树的platform_device,可以进入 <code>/sys/devices/platform/&lt;设备名&gt;/of_node</code> 查看它的设备树属性</p>
</li>
<li>
<p>d.  <code>/proc/device-tree</code> 是链接文件, 指向 /sys/firmware/devicetree/base</p>
</li>
</ul>
<h2 id="三、u-boot对设备树的支持">三、u-boot对设备树的支持</h2>
<h3 id="1-传递dtb给内核（r2）">1. 传递dtb给内核（r2）</h3>
<ul>
<li>
<p>u-boot中内核启动命令</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootm &lt;uImage_addr&gt;                            // 无设备树,bootm 0x30007FC0</span><br><span class="line">bootm &lt;uImage_addr&gt; &lt;initrd_addr&gt; &lt;dtb_addr&gt;   // 有设备树</span><br></pre></td></tr></table></figure>
<p>eg：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 0x30007FC0 kernel;     // 读内核uImage到内存0x30007FC0</span><br><span class="line">nand read.jffs2 32000000 device_tree;  // 读dtb到内存32000000</span><br><span class="line">bootm 0x30007FC0 - 0x32000000          // 启动, 没有initrd时对应参数写为<span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设备数的存放地址 <code>dtb_addr</code> 的选取原则</p>
<ul>
<li>不要破坏u-boot本身</li>
<li>不要挡内核的路: 内核本身的空间不能占用, 内核要用到的内存区域也不能占用内核启动时一般会在它所处位置的下边放置页表, 这块空间(一般是0x4000即16K字节)不能被占用</li>
</ul>
</li>
</ul>
<blockquote>
<p>JZ2440内存使用情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                   ------------------------------</span><br><span class="line">0x33f80000       -&gt;|    u-boot                  |</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |    u-boot所使用的内存(栈等)|</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |        空闲区域            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   ------------------------------</span><br><span class="line">0x30008000       -&gt;|      zImage                |</span><br><span class="line">                   ------------------------------  uImage &#x3D; 64字节的头部+zImage</span><br><span class="line">0x30007FC0       -&gt;|      uImage头部            |</span><br><span class="line">                   ------------------------------</span><br><span class="line">0x30004000       -&gt;|      内核创建的页表        |  head.S</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">            -----&gt; ------------------------------</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            --- (内存基址 0x30000000)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>正常启动linux：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 30000000 device_tree</span><br><span class="line">nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">bootm 0x30007FC0 - 30000000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设备数放到内核创建的页表处，会导致linux启动后设备树文件缺失</span></span><br><span class="line">nand read.jffs2 30004000 device_tree</span><br><span class="line">nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">bootm 0x30007FC0 - 30004000</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="2-uboot中对dtb文件修改的原理">2. uboot中对dtb文件修改的原理</h3>
<ul>
<li>
<p>修改属性的值</p>
<ul>
<li>a. 把原属性val所占空间从len字节扩展为newlen字节，把老值之后的所有内容向后移动(newlen - len)字节</li>
<li>b. 把新值写入val所占的newlen字节空间</li>
<li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li>
<li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li>
<li>e. 修改dtb头部信息中的总长度: totalsize</li>
</ul>
</li>
<li>
<p>添加一个全新的属性</p>
<ul>
<li>a. 如果在string block中没有这个属性的名字，就在string block尾部添加一个新字符串: 属性的名。并且修改dtb头部信息中string block的长度: size_dt_strings，修改dtb头部信息中的总长度: totalsize</li>
<li>b. 找到属性所在节点, 在节点尾部扩展一块空间, 内容及长度为:<br>
TAG      // 4字节, 对应0x00000003<br>
len      // 4字节, 表示属性的val的长度<br>
nameoff  // 4字节, 表示属性名的offset<br>
val      // len字节, 用来存放val</li>
<li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li>
<li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li>
<li>e. 修改dtb头部信息中的总长度: totalsize</li>
</ul>
</li>
</ul>
<h3 id="3-uboot中dtb修改命令fdt的移植">3.uboot中dtb修改命令fdt的移植</h3>
<p><strong>使用：</strong></p>
<ol>
<li>
<p>配置交叉编译工具链 <code>gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabi</code></p>
</li>
<li>
<p>解压</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xjf u-boot-1.1.6.tar.bz2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打补丁</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../u-boot-1.1.6_device_tree_for_jz2440_add_fdt_20181022.patch   // 打补丁</span><br><span class="line">make 100ask24x0_config                                                      // 配置</span><br><span class="line">make                                                                        // 编译, 可以得到u-boot.bin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>移植：</strong></p>
<p>高版本中已经存在，无需移植</p>
<h4 id="创建补丁文件">创建补丁文件</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -urN 原始未修改文件夹 修改后文件夹 &gt; 补丁文件.patch</span><br></pre></td></tr></table></figure>
<h4 id="打补丁">打补丁</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../补丁文件.patch</span><br></pre></td></tr></table></figure>
<h2 id="四、中断系统中的设备树">四、中断系统中的设备树</h2>
<h3 id="1-Linux对中断处理的框架及代码流程简述">1. Linux对中断处理的框架及代码流程简述</h3>
<p>如图：</p>
<p><img src="/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%A1%86%E6%9E%B6.jpg" alt="Linux中断处理的框架"></p>
<h3 id="2-中断号的演变与irq-domain">2. 中断号的演变与irq_domain</h3>
<h4 id="之前的irq">之前的irq</h4>
<ul>
<li>以前中断号(virq)跟硬件密切相关，现在的趋势是中断号跟硬件无关, 仅仅是一个标号而已</li>
<li>以前, 对于每一个硬件中断(hwirq)都预先确定它的中断号(virq),这些中断号一般都写在一个头文件里, 比如arch\arm\mach-s3c24xx\include\mach\irqs.h使用时：
<ul>
<li>执行 request_irq(virq, my_handler) :内核根据virq可以知道对应的硬件中断, 然后去设置、使能中断等</li>
<li>发生硬件中断时,内核读取硬件信息, 确定hwirq, 反算出virq,然后调用 irq_desc[virq].handle_irq, 最终会用到用户注册的my_handler函数</li>
</ul>
</li>
</ul>
<h4 id="现在的irq">现在的irq</h4>
<ul>
<li>
<p>hwirq跟virq之间不再通过代码绑定，而是进行动态绑定：</p>
<ul>
<li>
<p>每一个hwirq会去irq_desc全局表中从hwirq项开始向后查找，直到找到空闲项就进行绑定：</p>
<ul>
<li>每一个中断控制器都有一个对应的<code>irq_domain</code>（域）</li>
</ul>
</li>
<li>
<p>绑定信息保存在<code>irq_domain</code>（域）中</p>
</li>
<li>
<p><code>irq_domain</code>中有个<code>linear_revmap</code>数组成员用于保存hwirq到virq的关系：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irq_domain.linear_revmap[hwirq] = virq;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不难看出<code>linear_revmap</code>数组成员中用到的项比较少，大部分为空闲项</p>
</li>
<li>
<p><code>irq_domain</code>对之前的irq的兼容：</p>
<ul>
<li><code>irq_domain</code>中有<code>linear_revmap</code>成员用于保存之前irq架构中的hwirq到预先设置好的virq之间的对应关系</li>
<li><code>linear_revmap</code>成员中基本上都使用了，很少的空闲项</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>例子：子中断控制器中的中断发生：</p>
<ol>
<li>进入中断入口，再跳转到C语言入口，执行相应的保存现场等动作</li>
<li>总中断控制器通过hwirq和irq_domain.linear_revmap查到具体的virq</li>
<li>通过virq查到全局表中具体的中断函数irq_desc[virq].handle_irq，发现是分发函数（s3c_irq_demux）</li>
<li>接着查询子中断控制器的hwirq，并找到对应的virq：irq_domain.linear_revmap[hwirq]</li>
<li>找到新的全局表中的中断函数irq_desc[virq].handle_irq并执行</li>
<li>该函数是用户通过request_irq(virq, my_handler)向系统注册的用户函数my_handler，真正交给用户</li>
<li>此时request_irq中的virq不再通过固定文件获得，而是通过设备树中相互约定得来的。</li>
</ol>
</blockquote>
<h4 id="设备树中irq的设置">设备树中irq的设置</h4>
<p>设备树中应该对中断节点设置对应的中断控制器（决定使用哪个<code>irq_domain</code>）和hwirq（硬件中断号）</p>
<p>设备树中的设置会被irq_domain中的xlate成员函数解析，得到相应的virq和irq_type</p>
<p>irq_domain中的map成员函数会建立hwirq和virq之间的联系（详细分析见后文）</p>
<h3 id="3-设备树中对中断的描述">3. 设备树中对中断的描述</h3>
<p>ARM中顶层的中断控制器一般为<code>intc: interrupt-controller@xxxxxxxx</code>，其余节点均为其子节点</p>
<h4 id="中断节点">中断节点</h4>
<ul>
<li>
<p><code>interrupts</code>属性：指定要使用的硬件中断号, 中断的触发类型等等，具体格式由对应的中断控制器决定</p>
</li>
<li>
<p><code>interrupt-parent</code>属性：指定该节点所在的中断控制器节点（若该节点中没有，在该节点的父节点中肯定已经包含）</p>
<ul>
<li>phandle属性指定</li>
<li>label属性指定</li>
</ul>
</li>
<li>
<p><code>interrupt-extended</code>属性（可选）：通过该属性可以解决一个节点产生多个中断的问题，其具体格式为：</p>
<p>&lt;phandle&gt; &lt;prop-encoded-array&gt;</p>
<p>其中：</p>
<ul>
<li>
<p>&lt;phandle&gt;：具体的发给那个中断控制器</p>
</li>
<li>
<p>&lt;prop-encoded-array&gt;：相关的中断描述，取决于中断控制器中的<code>#interrupt-cells</code>属性</p>
</li>
</ul>
</li>
</ul>
<h4 id="中断控制器节点">中断控制器节点</h4>
<p>官方文档：<code>Documentation/devicetree/bindings/arm/gic.txt</code></p>
<ul>
<li><code>interrupt-controller</code>属性：表明自己是中断控制器</li>
<li><code>#interrupt-cells</code>属性：表明对应的子设备里interrupts属性应该用几个u32的数据来描述</li>
</ul>
<blockquote>
<p>对于 ARM 处理的 GIC（通用中断控制器）来说，一般<code>#interrupt-cells</code>为 3，其子节点<code>interrupts</code>属性中cells一般为：</p>
<ul>
<li>第一个 cells：中断类型， 0 表示 SPI 中断， 1 表示 PPI 中断</li>
<li>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0~987，对于 PPI 中断来说中断号的范围为 0~15</li>
<li>第三个 cells：标志， bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。 bit[15:8]为 PPI 中断的 CPU 掩码。</li>
</ul>
</blockquote>
<ul>
<li><code>interrupt-parent</code>属性（可选）：指定该节点所在的中断控制器节点（除去最顶层的<code>intc</code>节点之外，其他所有中断节点中若没有，则在该节点的父节点中肯定已经包含）</li>
</ul>
<h3 id="4-使用设备树描述按键中断">4.使用设备树描述按键中断</h3>
<ul>
<li>一般来说，一个节点会生成一个platform_device结构体，通过设备树中的compatible属性与platform_driver驱动结构体中的of_math_table结构体成员进行匹配，匹配上后会调用其下的probe函数，在该函数中会通过platform_get_resource函数来获取到platform_device对应的设备树中定义的相关资源（自定义属性的话需要利用of_XXXX系列函数自己转换），此时需要在这里保存下节点中的中断相关信息，以便于之后使用request_irq函数注册中断</li>
</ul>
<h3 id="5-内核对设备树中断信息的处理过程">5.内核对设备树中断信息的处理过程</h3>
<ul>
<li>在Linux内核初始化时，会首先创建并初始化总中断控制器中的irq_domain结构体</li>
<li>各个子中断控制器会在各个设备节点所对应的platform_driver驱动结构体中的probe函数中对irq_domain结构体初始化</li>
<li>中断节点中，各个和中断相关的资源均会在内核初始化阶段（具体为of_device_alloc函数中，详见第二章第五节），将其初始化为platform_driver的resource结构体</li>
<li>各种中断数据的解析和处理均利用到了irq_domain-&gt;ops-&gt;xlate或者irq_domain-&gt;ops-&gt;map函数，此处不做详解，了解即可</li>
</ul>
<h2 id="五、实践操作">五、实践操作</h2>
<h3 id="1-使用设备树给DM9000网卡-触摸屏指定中断">1. 使用设备树给DM9000网卡_触摸屏指定中断</h3>
<h3 id="2-在设备树中时钟的简单使用">2. 在设备树中时钟的简单使用</h3>
<p>参考文档：</p>
<ol>
<li>内核 Documentation/devicetree/bindings/clock/clock-bindings.txt</li>
<li>内核 Documentation/devicetree/bindings/clock/samsung,s3c2410-clock.txt</li>
</ol>
<h4 id="Clock-providers节点">Clock providers节点</h4>
<ul>
<li>这种节点属于内核中时钟树的提供者，用于提供时钟给别的模块</li>
<li><code>#clock-cells</code>属性：指定引用该节点的子节点中时钟的参数结构是由几个u32位数据描述的</li>
<li></li>
</ul>
<h4 id="Clock-consumers节点">Clock consumers节点</h4>
<ul>
<li>
<p><code>clocks</code>属性：通过该属性指定具体的Clock providers节点和需要用到的时钟信号，其具体格式为：</p>
<p>&lt;Clock providers节点id&gt; &lt;相关时钟参数&gt;</p>
<p>其中：</p>
<ul>
<li>
<p>&lt;Clock providers节点id&gt;：具体的Clock providers节点，通过lable或phandle属性引用均可</p>
</li>
<li>
<p>&lt;相关时钟参数&gt;：相关的中断描述，取决于Clock providers节点中的<code>#clock-cells</code>属性</p>
</li>
</ul>
</li>
</ul>
<h4 id="以前时钟驱动写法">以前时钟驱动写法</h4>
<ol>
<li>clk=clk_get(NULL,“时钟名”)：通过时钟名字获得相应时钟</li>
<li>clk_prepare_enable(clk)：使能相关时钟</li>
</ol>
<h4 id="用上设备树后">用上设备树后</h4>
<ol>
<li>of_count_phandle_with_args函数获取设备树中时钟的个数</li>
<li>of_clk_get函数获取具体的时钟</li>
<li>clk_prepare_enable使能时钟</li>
<li>clk_disable_unprepare禁止时钟</li>
</ol>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定时钟个数</span></span><br><span class="line"><span class="keyword">int</span> nr_pclks = of_count_phandle_with_args(dev-&gt;of_node, <span class="string">&quot;clocks&quot;</span>,</span><br><span class="line">                                          <span class="string">&quot;#clock-cells&quot;</span>);</span><br><span class="line"><span class="comment">// 获得时钟</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_pclks; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span> =</span> of_clk_get(dev-&gt;of_node, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能时钟</span></span><br><span class="line">clk_prepare_enable(clk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止时钟</span></span><br><span class="line">clk_disable_unprepare(clk);</span><br></pre></td></tr></table></figure>
<h3 id="3-在设备树中pinctrl的简单使用">3. 在设备树中pinctrl的简单使用</h3>
<p>参考文档：内核 Documentation/devicetree/bindings/pinctrl/samsung-pinctrl.txt</p>
<p><code>Bank</code>：以引脚名为依据, 这些引脚分为若干组, 每组称为一个Bank。比如s3c2440里有GPA、GPB、GPC等Bank，每个Bank中有若干个引脚, 比如GPA0,GPA1, …, GPC0, GPC1,…等引脚</p>
<p><code>Group</code>：以功能为依据, 具有相同功能的引脚称为一个Group。比如s3c2440中串口0的TxD、RxD引脚使用 GPH2,GPH3, 那这2个引脚可以列为一组。比如s3c2440中串口0的流量控制引脚使用 GPH0,GPH1, 那这2个引脚也可以列为一组</p>
<p><code>State</code>：设备的某种状态, 比如内核自己定义的&quot;default&quot;,“init”,“idel”,&quot;sleep&quot;状态。也可以是其他自己定义的状态, 比如串口的&quot;flow_ctrl&quot;状态(使用流量控制)</p>
<h4 id="pinctrl节点">pinctrl节点</h4>
<ul>
<li>
<p>节点中会定义各种pin bank节点，比如s3c2440有GPA,GPB,GPC,…,GPB各种BANK, 每个BANK中有若干引脚</p>
<ul>
<li>bank节点
<ul>
<li>
<p><code>gpio-controller</code>属性：表明是gpio的控制器</p>
</li>
<li>
<p><code>#gpio-cells</code>属性：以后想使用bank中的引脚时, 需要用该属性来表明用多少个u32数据指定引脚</p>
</li>
<li>
<p>eg：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_0: pinctrl@56000000 &#123;</span><br><span class="line">    reg &#x3D; &lt;0x56000000 0x1000&gt;;</span><br><span class="line"></span><br><span class="line">    gpa: gpa &#123;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        #gpio-cells &#x3D; &lt;2&gt;;  &#x2F;* 以后想使用gpa bank中的引脚时, 需要2个u32来指定引脚 *&#x2F;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>pinctrl节点中也会有各种group(组合)子节点</p>
<ul>
<li>
<p>group节点（这里以samsung为例，具体属性由每家平台的驱动决定）</p>
<ul>
<li>
<p>属性依平台不一致而有所变化</p>
</li>
<li>
<p><code>samsung,pins</code>属性：该组内要使用到的gpio</p>
</li>
<li>
<p><code>samsung,pin-function</code>属性：在对应的gpio控制寄存器中，每个组中引脚对应的复用功能。</p>
</li>
<li>
<p><code>samsung,pin-val</code>属性：初始电平</p>
</li>
<li>
<p>eg：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uart0_data: uart0-data &#123;</span><br><span class="line">    samsung,pins &#x3D; &quot;gph-0&quot;, &quot;gph-0&quot;;</span><br><span class="line">    samsung,pin-function &#x3D; &lt;2&gt;;   &#x2F;* 在GPHCON寄存器中gph0,gph1可以设置以下值:</span><br><span class="line">                                    0 --- 输入功能</span><br><span class="line">                                    1 --- 输出功能</span><br><span class="line">                                    2 --- 串口功能</span><br><span class="line">                                    我们要使用串口功能,  </span><br><span class="line">                                    samsung,pin-function 设置为2</span><br><span class="line">                                    *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一般来说一个设备节点引用pin group时才有可能涉及到<code>State</code>：</p>
<ul>
<li><code>pinctrl-names</code>属性：定义各种<code>State</code>，可以多个一起使用</li>
</ul>
</li>
<li>
<p><code>pinctrl-x</code>属性：每个<code>State</code>都需要一个对应的<code>pinctrl-x</code>属性指定使用哪一个或多个group节点</p>
</li>
<li>
<p>设备树中若指定了pinctrl节点，在对应的probe函数被调用之前，内核会先&quot;bind pins&quot;, 即先绑定、设置引脚</p>
<ul>
<li>
<p>会优先设置&quot;init&quot;状态的引脚</p>
</li>
<li>
<p>如果没有&quot;init&quot;状态, 则设置&quot;default&quot;状态的引脚</p>
<p>eg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serial@50000000 &#123;</span><br><span class="line">  ......</span><br><span class="line">    pinctrl-names &#x3D; &quot;default&quot;, &quot;sleep&quot;;  &#x2F;* 既是名字, 也称为state(状态) *&#x2F;</span><br><span class="line">    pinctrl-0 &#x3D; &lt;&amp;uart0_data&gt;;</span><br><span class="line">  pinctrl-1 &#x3D; &lt;&amp;uart0_sleep&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>pinctrl-names中定义了2种state: default 和 sleep
<ul>
<li>default 对应的引脚是: pinctrl-0, 它指定了使用哪些pin group: uart0_data</li>
<li>sleep   对应的引脚是: pinctrl-1, 它指定了使用哪些pin group: uart0_sleep</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/">http://nu-ll.github.io/2019/10/13/设备树/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E5%A4%87%E6%A0%91/">设备树</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/18/LiCheePi_Zero%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/"><img class="prev-cover" src="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LiCheePi_Zero底层开发</div></div></a></div><div class="next-post pull-right"><a href="/2019/09/17/markdownlint%E8%A7%84%E5%88%99%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"><img class="next-cover" src="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VSC插件之markdownlint规则详细介绍</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/spaceman.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">spaceman</div><div class="author-info__description">CtrlC CtrlV大师</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NU-LL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">白嫖一时爽，一直白嫖一直爽</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E8%A7%84%E8%8C%83-dts%E5%92%8Cdtb"><span class="toc-text">一、设备树的规范(dts和dtb)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DTS%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. DTS格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DTS%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80-layout"><span class="toc-text">DTS文件布局(layout)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B"><span class="toc-text">相关示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><span class="toc-text">特殊以及默认属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%EF%BC%88%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="toc-text">a. &#x2F;（根节点)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-memory%E8%8A%82%E7%82%B9"><span class="toc-text">b. &#x2F;memory节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-chosen%E8%8A%82%E7%82%B9"><span class="toc-text">c. &#x2F;chosen节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-cpus%E8%8A%82%E7%82%B9"><span class="toc-text">d. &#x2F;cpus节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-cpus-cpu"><span class="toc-text">e. &#x2F;cpus&#x2F;cpu*</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9"><span class="toc-text">引用其他节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-phandle%E5%B1%9E%E6%80%A7"><span class="toc-text">a. phandle属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-label%E5%B1%9E%E6%80%A7"><span class="toc-text">b. label属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DTB%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. DTB二进制文件的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DTB%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="toc-text">DTB文件布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">3. 通用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="toc-text">提取属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">其他常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">二、内核对设备树的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E6%A0%B8head-S%E5%AF%B9dtb%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86"><span class="toc-text">1. 内核head.S对dtb的简单处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%AD%E5%B9%B3%E5%8F%B0%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86-%E9%80%89%E6%8B%A9machine-desc%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2. 对设备树中平台信息的处理(选择machine_desc结构体)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-dtb%E8%BD%AC%E6%8D%A2%E4%B8%BAdevice-node-unflatten-device-tree%E5%87%BD%E6%95%B0"><span class="toc-text">4. dtb转换为device_node(unflatten_device_tree函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-platform-device%E8%B7%9Fplatform-driver%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="toc-text">6. platform_device跟platform_driver的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E6%A0%B8%E4%B8%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">7. 内核中设备树的操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9C%A8%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%A0%91-%E6%9C%89%E5%8A%A9%E4%BA%8E%E8%B0%83%E8%AF%95"><span class="toc-text">8. 在根文件系统中查看设备树(有助于调试)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81u-boot%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">三、u-boot对设备树的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E9%80%92dtb%E7%BB%99%E5%86%85%E6%A0%B8%EF%BC%88r2%EF%BC%89"><span class="toc-text">1. 传递dtb给内核（r2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-uboot%E4%B8%AD%E5%AF%B9dtb%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">2. uboot中对dtb文件修改的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-uboot%E4%B8%ADdtb%E4%BF%AE%E6%94%B9%E5%91%BD%E4%BB%A4fdt%E7%9A%84%E7%A7%BB%E6%A4%8D"><span class="toc-text">3.uboot中dtb修改命令fdt的移植</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A5%E4%B8%81%E6%96%87%E4%BB%B6"><span class="toc-text">创建补丁文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E8%A1%A5%E4%B8%81"><span class="toc-text">打补丁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">四、中断系统中的设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E5%AF%B9%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-text">1. Linux对中断处理的框架及代码流程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E5%8F%B7%E7%9A%84%E6%BC%94%E5%8F%98%E4%B8%8Eirq-domain"><span class="toc-text">2. 中断号的演变与irq_domain</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%8B%E5%89%8D%E7%9A%84irq"><span class="toc-text">之前的irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E7%9A%84irq"><span class="toc-text">现在的irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%ADirq%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">设备树中irq的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">3. 设备树中对中断的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%8A%82%E7%82%B9"><span class="toc-text">中断节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E8%8A%82%E7%82%B9"><span class="toc-text">中断控制器节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E6%8F%8F%E8%BF%B0%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD"><span class="toc-text">4.使用设备树描述按键中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">5.内核对设备树中断信息的处理过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E8%B7%B5%E6%93%8D%E4%BD%9C"><span class="toc-text">五、实践操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%99DM9000%E7%BD%91%E5%8D%A1-%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%8C%87%E5%AE%9A%E4%B8%AD%E6%96%AD"><span class="toc-text">1. 使用设备树给DM9000网卡_触摸屏指定中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%AD%E6%97%B6%E9%92%9F%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 在设备树中时钟的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock-providers%E8%8A%82%E7%82%B9"><span class="toc-text">Clock providers节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock-consumers%E8%8A%82%E7%82%B9"><span class="toc-text">Clock consumers节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%89%8D%E6%97%B6%E9%92%9F%E9%A9%B1%E5%8A%A8%E5%86%99%E6%B3%95"><span class="toc-text">以前时钟驱动写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%B8%8A%E8%AE%BE%E5%A4%87%E6%A0%91%E5%90%8E"><span class="toc-text">用上设备树后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%ADpinctrl%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">3. 在设备树中pinctrl的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pinctrl%E8%8A%82%E7%82%B9"><span class="toc-text">pinctrl节点</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/31/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/" title="现代操作系统总结">现代操作系统总结</a><time datetime="2021-05-31T12:29:35.000Z" title="发表于 2021-05-31 20:29:35">2021-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/31/Linux%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/" title="Linux条件变量">Linux条件变量</a><time datetime="2021-05-31T07:44:24.000Z" title="发表于 2021-05-31 15:44:24">2021-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/11/%E8%9E%8D%E5%90%88%E6%80%BB%E7%BB%93/" title="融合总结">融合总结</a><time datetime="2021-05-11T05:58:15.000Z" title="发表于 2021-05-11 13:58:15">2021-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/12/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="conda常用命令">conda常用命令</a><time datetime="2021-04-12T08:47:06.096Z" title="发表于 2021-04-12 16:47:06">2021-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/02/lidar%E6%91%84%E5%83%8F%E5%A4%B4%E8%9E%8D%E5%90%88/" title="lidar摄像头融合">lidar摄像头融合</a><time datetime="2021-04-02T02:50:34.000Z" title="发表于 2021-04-02 10:50:34">2021-04-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By spaceman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> <iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tx&color=eee" frameborder="0" allowtransparency="false" align="middle" height="20"></iframe></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>