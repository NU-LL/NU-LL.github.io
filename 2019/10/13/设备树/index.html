<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>设备树 | 无名小卒</title>
  <meta name="keywords" content=" 设备树 ">
  <meta name="description" content="设备树 | 无名小卒">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://NU-LL.github.io/about/index.html">
<meta property="og:site_name" content="无名小卒">
<meta property="og:description" content="关于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-21T14:30:10.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="关于">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>NU-LL</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/NU-LL" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="csdn" href="https://blog.csdn.net/CSDN_JZ_" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="email" href="mailto:1125934312@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1125934312&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=323374922" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(44)</small></div></li>
    
        
            
            <li><div data-rel="Linux">Linux<small>(25)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程语言">编程语言<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="MCU">MCU<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="人工智能">人工智能<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="感悟与总结">感悟与总结<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a style="border-right: 1px solid #fff; width: 49%"  class="about site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="44">
<input type="hidden" id="yelog_site_word_count" value="288.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://github.com/NU-LL">NU-LL</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">DM9000C</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">网卡移植</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">GO</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">ESP32</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">ESP8266</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Kconfig语法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">IIC驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Latex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Ctex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">LiCheePi Zero</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux服务</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux内核</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">文件描述符</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Markdown</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Mininet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">数据分析</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">NanoPi Neo Core</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">字符驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">TensorFlow2</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">SVM</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Xmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">远程链接</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">network namespace</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Kubernetes</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">等待队列</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_head_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">markdownlint</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">python实战</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">u-boot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">爬虫</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">二维数组</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">指针</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">存储器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">IAP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">BootLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">dual bank</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">快速排序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">按键驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">poll机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">异步通知机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">根文件系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">网卡驱动框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">虚拟网卡</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">设备树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">输入子系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Go语言入门经典</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">驱动API</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">廖雪峰python教程</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Linux "
           href="/2019/08/04/DM9000C网卡移植/"
           data-tag="DM9000C,网卡移植"
           data-author="" >
            <span class="post-title" title="DM9000C网卡移植">DM9000C网卡移植</span>
            <span class="post-date" title="2019-08-04 23:07:22">2019/08/04</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/05/09/C和GO的语法对比/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="C和GO的语法对比">C和GO的语法对比</span>
            <span class="post-date" title="2020-05-09 19:55:39">2020/05/09</span>
        </a>
        
        <a  class="Linux "
           href="/2020/01/16/Docker/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="Docker">Docker</span>
            <span class="post-date" title="2020-01-16 20:14:51">2020/01/16</span>
        </a>
        
        <a  class="MCU "
           href="/2020/05/16/ESP32/"
           data-tag="ESP32"
           data-author="" >
            <span class="post-title" title="ESP8266">ESP8266</span>
            <span class="post-date" title="2020-05-16 10:30:54">2020/05/16</span>
        </a>
        
        <a  class="MCU "
           href="/2020/04/28/ESP8266/"
           data-tag="ESP8266"
           data-author="" >
            <span class="post-title" title="ESP8266">ESP8266</span>
            <span class="post-date" title="2020-04-28 14:27:54">2020/04/28</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/15/Kconfig文件语法分析/"
           data-tag="Kconfig语法"
           data-author="" >
            <span class="post-title" title="Kconfig文件语法分析">Kconfig文件语法分析</span>
            <span class="post-date" title="2019-08-15 19:38:40">2019/08/15</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/05/IIC驱动/"
           data-tag="IIC驱动"
           data-author="" >
            <span class="post-title" title="IIC驱动">IIC驱动</span>
            <span class="post-date" title="2019-08-05 14:39:10">2019/08/05</span>
        </a>
        
        <a  class="工具 "
           href="/2019/08/19/Latex排版全解/"
           data-tag="Latex,Ctex"
           data-author="" >
            <span class="post-title" title="Latex排版全解">Latex排版全解</span>
            <span class="post-date" title="2019-08-19 16:02:27">2019/08/19</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/LiCheePi_Zero底层开发/"
           data-tag="LiCheePi Zero"
           data-author="" >
            <span class="post-title" title="LiCheePi_Zero底层开发">LiCheePi_Zero底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/28/Linux上常见服务搭建/"
           data-tag="Linux服务"
           data-author="" >
            <span class="post-title" title="Linux上常见服务搭建">Linux上常见服务搭建</span>
            <span class="post-date" title="2020-03-28 01:27:58">2020/03/28</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/13/Linux内核启动流程/"
           data-tag="Linux内核"
           data-author="" >
            <span class="post-title" title="Linux内核启动流程">Linux内核启动流程</span>
            <span class="post-date" title="2019-08-13 16:13:46">2019/08/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/Linux编程--文件描述符fd/"
           data-tag="文件描述符"
           data-author="" >
            <span class="post-title" title="Linux编程--文件描述符fd">Linux编程--文件描述符fd</span>
            <span class="post-date" title="2019-07-21 10:13:47">2019/07/21</span>
        </a>
        
        <a  class="工具 "
           href="/2019/07/12/Markdown 语法整理/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 语法整理">Markdown 语法整理</span>
            <span class="post-date" title="2019-07-12 13:57:24">2019/07/12</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/13/Mininet/"
           data-tag="Mininet"
           data-author="" >
            <span class="post-title" title="Mininet">Mininet</span>
            <span class="post-date" title="2020-02-13 18:37:12">2020/02/13</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/03/10/Python数据分析与展示/"
           data-tag="数据分析"
           data-author="" >
            <span class="post-title" title="Python数据分析与展示">Python数据分析与展示</span>
            <span class="post-date" title="2020-03-10 15:10:50">2020/03/10</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/NanoPi_Neo_Core底层开发/"
           data-tag="NanoPi Neo Core"
           data-author="" >
            <span class="post-title" title="NanoPi_Neo_Core底层开发">NanoPi_Neo_Core底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/RTC驱动分析/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="RTC驱动分析">RTC驱动分析</span>
            <span class="post-date" title="2019-08-07 13:37:33">2019/08/07</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/05/03/TensorFlow2/"
           data-tag="TensorFlow2"
           data-author="" >
            <span class="post-title" title="TensorFlow2入门与实践">TensorFlow2入门与实践</span>
            <span class="post-date" title="2020-05-03 00:52:53">2020/05/03</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/06/05/SVM/"
           data-tag="SVM"
           data-author="" >
            <span class="post-title" title="SVM（线性模型）数学推导">SVM（线性模型）数学推导</span>
            <span class="post-date" title="2020-06-05 21:12:53">2020/06/05</span>
        </a>
        
        <a  class="Linux "
           href="/2019/11/08/Xmanager远程Ubuntu系统图像化界面/"
           data-tag="Xmanager,远程链接"
           data-author="" >
            <span class="post-title" title="Xmanager远程Ubuntu系统图像化界面">Xmanager远程Ubuntu系统图像化界面</span>
            <span class="post-date" title="2019-11-08 22:58:53">2019/11/08</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/git/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <span class="post-date" title="2019-09-17 09:59:56">2019/09/17</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/10/linux 网络虚拟化： network namespace 简介/"
           data-tag="network namespace"
           data-author="" >
            <span class="post-title" title="linux 网络虚拟化： network namespace 简介">linux 网络虚拟化： network namespace 简介</span>
            <span class="post-date" title="2020-02-10 14:24:09">2020/02/10</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/15/kubernetes/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes">Kubernetes</span>
            <span class="post-date" title="2020-03-15 13:48:53">2020/03/15</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/linux等待队列wait_queue_head_t和wait_queue_t/"
           data-tag="等待队列,wait_queue_head_t,wait_queue_t"
           data-author="" >
            <span class="post-title" title="linux等待队列wait_queue_head_t和wait_queue_t">linux等待队列wait_queue_head_t和wait_queue_t</span>
            <span class="post-date" title="2019-07-21 18:18:54">2019/07/21</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/markdownlint规则详细介绍/"
           data-tag="markdownlint"
           data-author="" >
            <span class="post-title" title="VSC插件之markdownlint规则详细介绍">VSC插件之markdownlint规则详细介绍</span>
            <span class="post-date" title="2019-09-17 15:00:13">2019/09/17</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/29/python实战/"
           data-tag="python实战"
           data-author="" >
            <span class="post-title" title="python实战">python实战</span>
            <span class="post-date" title="2020-01-29 21:36:32">2020/01/29</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/02/18/python爬虫/"
           data-tag="python,爬虫"
           data-author="" >
            <span class="post-title" title="python爬虫">python爬虫</span>
            <span class="post-date" title="2020-02-18 23:40:18">2020/02/18</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/06/二维数组与指针的一些问题/"
           data-tag="二维数组,指针"
           data-author="" >
            <span class="post-title" title="二维数组与指针的一些问题">二维数组与指针的一些问题</span>
            <span class="post-date" title="2019-08-06 13:11:26">2019/08/06</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/11/各种存储器的区别/"
           data-tag="存储器"
           data-author="" >
            <span class="post-title" title="各种存储器的区别">各种存储器的区别</span>
            <span class="post-date" title="2019-08-11 10:57:19">2019/08/11</span>
        </a>
        
        <a  class="MCU "
           href="/2019/11/12/基于STM32L476的IAP升级/"
           data-tag="IAP,BootLoader,dual bank"
           data-author="" >
            <span class="post-title" title="基于STM32L476的IAP升级">基于STM32L476的IAP升级</span>
            <span class="post-date" title="2019-11-12 22:47:40">2019/11/12</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/字符驱动设备的另一种写法/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="字符驱动设备的另一种写法">字符驱动设备的另一种写法</span>
            <span class="post-date" title="2019-08-07 12:20:30">2019/08/07</span>
        </a>
        
        <a  class="算法 "
           href="/2019/07/29/快速排序/"
           data-tag="快速排序"
           data-author="" >
            <span class="post-title" title="快速排序">快速排序</span>
            <span class="post-date" title="2019-07-29 22:27:34">2019/07/29</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/按键驱动——poll机制/"
           data-tag="按键驱动,poll机制"
           data-author="" >
            <span class="post-title" title="按键驱动——poll机制">按键驱动——poll机制</span>
            <span class="post-date" title="2019-07-21 20:30:38">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/22/按键驱动：异步通知机制/"
           data-tag="按键驱动,异步通知机制"
           data-author="" >
            <span class="post-title" title="按键驱动：异步通知机制">按键驱动：异步通知机制</span>
            <span class="post-date" title="2019-07-22 19:04:24">2019/07/22</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/14/构造根文件系统/"
           data-tag="根文件系统"
           data-author="" >
            <span class="post-title" title="构造根文件系统">构造根文件系统</span>
            <span class="post-date" title="2019-08-14 20:18:45">2019/08/14</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/04/网卡驱动程序/"
           data-tag="网卡驱动框架,虚拟网卡"
           data-author="" >
            <span class="post-title" title="网卡驱动程序">网卡驱动程序</span>
            <span class="post-date" title="2019-08-04 21:24:07">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/13/设备树/"
           data-tag="设备树"
           data-author="" >
            <span class="post-title" title="设备树">设备树</span>
            <span class="post-date" title="2019-10-13 15:53:24">2019/10/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/25/输入子系统/"
           data-tag="按键驱动,输入子系统"
           data-author="" >
            <span class="post-title" title="输入子系统">输入子系统</span>
            <span class="post-date" title="2019-07-25 00:05:15">2019/07/25</span>
        </a>
        
        <a  class="编程语言 "
           href="/2019/10/23/Go语言/"
           data-tag="Go语言入门经典"
           data-author="" >
            <span class="post-title" title="Go语言">Go语言</span>
            <span class="post-date" title="2019-10-23 21:07:25">2019/10/23</span>
        </a>
        
        <a  class="Linux "
           href="/2020/04/06/Linux驱动常用API整理/"
           data-tag="驱动API"
           data-author="" >
            <span class="post-title" title="Linux驱动常用API整理">Linux驱动常用API整理</span>
            <span class="post-date" title="2020-04-06 22:48:09">2020/04/06</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/u-boot分析与使用 - 老版本备份/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/01/03/深度学习与TensorFlow2/"
           data-tag="TensorFlow2,深度学习"
           data-author="" >
            <span class="post-title" title="深度学习与TensorFlow2">深度学习与TensorFlow2</span>
            <span class="post-date" title="2020-01-03 21:04:26">2020/01/03</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/10/python/"
           data-tag="廖雪峰python教程"
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2020-01-10 20:18:52">2020/01/10</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-设备树" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">设备树</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="Linux">Linux</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color4">设备树</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-04-07 22:47:18'>2019-10-13 15:53</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:8.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设备树"><span class="toc-text">设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、设备树的规范-dts和dtb"><span class="toc-text">一、设备树的规范(dts和dtb)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DTS格式"><span class="toc-text">1. DTS格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DTS文件布局-layout"><span class="toc-text">DTS文件布局(layout)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#相关示例"><span class="toc-text">相关示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊以及默认属性"><span class="toc-text">特殊以及默认属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-（根节点"><span class="toc-text">a. /（根节点)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-memory节点"><span class="toc-text">b. /memory节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-chosen节点"><span class="toc-text">c. /chosen节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-cpus节点"><span class="toc-text">d. /cpus节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e-cpus-cpu"><span class="toc-text">e. /cpus/cpu*</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用其他节点"><span class="toc-text">引用其他节点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-phandle属性"><span class="toc-text">a. phandle属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-label属性"><span class="toc-text">b. label属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DTB二进制文件的格式"><span class="toc-text">2. DTB二进制文件的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DTB文件布局"><span class="toc-text">DTB文件布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-通用函数"><span class="toc-text">3. 通用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查找节点"><span class="toc-text">查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提取属性"><span class="toc-text">提取属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他常用函数"><span class="toc-text">其他常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、内核对设备树的处理"><span class="toc-text">二、内核对设备树的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-内核head-S对dtb的简单处理"><span class="toc-text">1. 内核head.S对dtb的简单处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-对设备树中平台信息的处理-选择machine-desc结构体"><span class="toc-text">2. 对设备树中平台信息的处理(选择machine_desc结构体)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-对设备树中运行时配置信息的处理"><span class="toc-text">3. 对设备树中运行时配置信息的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-dtb转换为device-node-unflatten-device-tree函数"><span class="toc-text">4. dtb转换为device_node(unflatten_device_tree函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-device-node结构体转换为platform-device"><span class="toc-text">5. device_node结构体转换为platform_device</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-platform-device跟platform-driver的匹配"><span class="toc-text">6. platform_device跟platform_driver的匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-内核中设备树的操作函数"><span class="toc-text">7. 内核中设备树的操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-在根文件系统中查看设备树-有助于调试"><span class="toc-text">8. 在根文件系统中查看设备树(有助于调试)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、u-boot对设备树的支持"><span class="toc-text">三、u-boot对设备树的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-传递dtb给内核（r2）"><span class="toc-text">1. 传递dtb给内核（r2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-uboot中对dtb文件修改的原理"><span class="toc-text">2. uboot中对dtb文件修改的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-uboot中dtb修改命令fdt的移植"><span class="toc-text">3.uboot中dtb修改命令fdt的移植</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建补丁文件"><span class="toc-text">创建补丁文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打补丁"><span class="toc-text">打补丁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、中断系统中的设备树"><span class="toc-text">四、中断系统中的设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux对中断处理的框架及代码流程简述"><span class="toc-text">1. Linux对中断处理的框架及代码流程简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-中断号的演变与irq-domain"><span class="toc-text">2. 中断号的演变与irq_domain</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#之前的irq"><span class="toc-text">之前的irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#现在的irq"><span class="toc-text">现在的irq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备树中irq的设置"><span class="toc-text">设备树中irq的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-设备树中对中断的描述"><span class="toc-text">3. 设备树中对中断的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断节点"><span class="toc-text">中断节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断控制器节点"><span class="toc-text">中断控制器节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-使用设备树描述按键中断"><span class="toc-text">4.使用设备树描述按键中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-内核对设备树中断信息的处理过程"><span class="toc-text">5.内核对设备树中断信息的处理过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、实践操作"><span class="toc-text">五、实践操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用设备树给DM9000网卡-触摸屏指定中断"><span class="toc-text">1. 使用设备树给DM9000网卡_触摸屏指定中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在设备树中时钟的简单使用"><span class="toc-text">2. 在设备树中时钟的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock-providers节点"><span class="toc-text">Clock providers节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock-consumers节点"><span class="toc-text">Clock consumers节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#以前时钟驱动写法"><span class="toc-text">以前时钟驱动写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用上设备树后"><span class="toc-text">用上设备树后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-在设备树中pinctrl的简单使用"><span class="toc-text">3. 在设备树中pinctrl的简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pinctrl节点"><span class="toc-text">pinctrl节点</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><p>内核相关文档：</p>
<p>Documentation/devicetree/bindings/</p>
<blockquote>
<p>相关约定如下：</p>
<p>dts：device tree source，设备树源文件</p>
<p>dtb：device tree blob，设备树二进制文件, 由dts编译得来</p>
<p>dtc：设备树编译工具</p>
<p>blob：binary large object</p>
</blockquote>
<h2 id="一、设备树的规范-dts和dtb"><a href="#一、设备树的规范-dts和dtb" class="headerlink" title="一、设备树的规范(dts和dtb)"></a>一、设备树的规范(dts和dtb)</h2><h3 id="1-DTS格式"><a href="#1-DTS格式" class="headerlink" title="1. DTS格式"></a>1. DTS格式</h3><p>参考文档：<a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">官方文档</a></p>
<h4 id="DTS文件布局-layout"><a href="#DTS文件布局-layout" class="headerlink" title="DTS文件布局(layout)"></a>DTS文件布局(layout)</h4><pre><code class="c">/dts-v1/;//设备树版本
[memory reservations]    // 保留该处的内存（一般这里就是存放设备树文件的地方），内核不会使用该处内存，格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;//address和length均为64位，如：/memreserve/ 0x33f00000 0x100000
/ {
    [property definitions]
    [child nodes]
};</code></pre>
<p>相关规定：</p>
<ul>
<li><p>一般来说一些公共部分会组合起来写成<code>.dtsi</code>文件</p>
</li>
<li><p>普通的<code>.dts</code>文件可以包含这些<code>.dtsi</code>文件（类似C语言）</p>
<pre><code class="c">  #include&quot;XXXX.dtsi&quot;</code></pre>
</li>
<li><p>普通的<code>.dts</code>文件可以通过重写所包含的<code>.dtsi</code>文件中的属性来进行覆盖操作</p>
</li>
<li><p>编译<code>.dts</code>文件为<code>.dtb</code></p>
<pre><code class="bash">#Linux内核源码下操作
#编译所有改动过的设备树
make dtbs
#编译指定设备树
make xxxx.dtb</code></pre>
</li>
<li><p>反汇编<code>.dtb</code>文件为<code>.dts</code></p>
<pre><code class="bash">  ./scripts/dtc/dtc -I dtb -O dts -o 输出文件.dts 输入文件.dtb</code></pre>
</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>Devicetree node（设备节点）格式:</p>
<pre><code class="c">[label:] node-name[@unit-address] {
    [properties definitions]
    [child nodes]
};</code></pre>
<ul>
<li><p>同一级别下，node-name[@unit-address]不能一样，不同级别可以一样</p>
</li>
<li><p>每个属性后必须加上分号，每个节点大括号后必须加上分号</p>
</li>
</ul>
<p>Property 格式1:</p>
<pre><code class="c">[label:] property-name = value;</code></pre>
<p>Property 格式2(没有值):</p>
<pre><code class="c">[label:] property-name;</code></pre>
<p>Property取值只有3种:</p>
<ul>
<li>arrays of cells(1个或多个32位数据, 64位数据使用2个32位数据表示)</li>
<li>string(字符串)</li>
<li>bytestring(1个或多个字节)</li>
</ul>
<h5 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h5><p>a. Arrays of cells : cell就是一个32位的数据</p>
<pre><code class="c">interrupts = &lt;17 0xc&gt;;</code></pre>
<p>b. 64bit数据使用2个cell来表示:</p>
<pre><code class="c">clock-frequency = &lt;0x00000001 0x00000000&gt;;</code></pre>
<p>c. A null-terminated string (有结束符的字符串):</p>
<pre><code class="c">compatible = &quot;simple-bus&quot;;</code></pre>
<p>d. A bytestring(字节序列) :</p>
<pre><code class="c">local-mac-address = [00 00 12 34 56 78];  // 每个byte使用2个16进制数来表示
local-mac-address = [000012345678];       // 每个byte使用2个16进制数来表示</code></pre>
<p>e. 可以是各种值的组合, 用逗号隔开:</p>
<pre><code class="c">compatible = &quot;ns16550&quot;, &quot;ns8250&quot;;
example = &lt;0xf00f0000 19&gt;, &quot;a strange property format&quot;;</code></pre>
<h4 id="特殊以及默认属性"><a href="#特殊以及默认属性" class="headerlink" title="特殊以及默认属性"></a>特殊以及默认属性</h4><h5 id="a-（根节点"><a href="#a-（根节点" class="headerlink" title="a. /（根节点)"></a>a. /（根节点)</h5><p>这部分可以理解为<strong>通用属性</strong></p>
<pre><code class="c">#address-cells   // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)
#size-cells      // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)

compatible       // 兼容性列表。通过定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备
                 // 即这个板子兼容哪些平台
                 // 内核会通过该属性找到对应平台的machine_desc结构体初始化该板卡
                 //（该属性可以有很多个字符串组成，内核会按照先后顺序依次查找，直到找到为止）

model            // 描述设备模块信息。可以理解为相同板卡的不同软件版本，即使用的板卡是采用那个版本的配置文件初始化的
                 // 比如有2款板子配置基本一致, 它们的compatible是一样的
                 // 那么就通过model来分辨这2款板子</code></pre>
<blockquote>
<p>注意：只有在<code>/</code>节点下，<code>compatible</code>中的字符串才需要和machine_desc结构体进行匹配。</p>
<p>在其余节点中，<code>compatible</code>一般用于将设备和驱动绑定起来</p>
</blockquote>
<h5 id="b-memory节点"><a href="#b-memory节点" class="headerlink" title="b. /memory节点"></a>b. /memory节点</h5><pre><code class="c">device_type = &quot;memory&quot;;// 约定俗成，必须加该属性
reg             // 根据上层的#address-cells、#size-cells来指定内存的地址、大小</code></pre>
<h5 id="c-chosen节点"><a href="#c-chosen节点" class="headerlink" title="c. /chosen节点"></a>c. /chosen节点</h5><pre><code class="c">bootargs        // 内核command line参数, 跟u-boot中设置的bootargs作用一样</code></pre>
<ul>
<li>该参数由uboot根据启动参数bootargs自行设置，一般无需自己处理</li>
</ul>
<h5 id="d-cpus节点"><a href="#d-cpus节点" class="headerlink" title="d. /cpus节点"></a>d. /cpus节点</h5><p><code>/cpus</code>节点下有1个或多个cpu子节点, cpu子节点中用reg属性用来标明自己是哪一个cpu，所以 <code>/cpus</code> 中有以下2个属性：</p>
<pre><code class="c">#address-cells   // 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述地址(address)

#size-cells      // 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述大小(size)，必须设置为 0</code></pre>
<h5 id="e-cpus-cpu"><a href="#e-cpus-cpu" class="headerlink" title="e. /cpus/cpu*"></a>e. /cpus/cpu*</h5><pre><code class="c">device_type = &quot;cpu&quot;;
reg             // 表明自己是哪一个cpu</code></pre>
<h4 id="引用其他节点"><a href="#引用其他节点" class="headerlink" title="引用其他节点"></a>引用其他节点</h4><h5 id="a-phandle属性"><a href="#a-phandle属性" class="headerlink" title="a. phandle属性"></a>a. phandle属性</h5><p>节点中的phandle属性, 它的取值必须是唯一的(不要跟其他的phandle值一样)</p>
<pre><code class="c">pic@10000000 {
    phandle = &lt;1&gt;;            //phandle属性必须唯一
    interrupt-controller;    //该属性表明这是中断控制器
};

another-device-node {
    interrupt-parent = &lt;1&gt;;   // 引用phandle值为1的节点
};</code></pre>
<h5 id="b-label属性"><a href="#b-label属性" class="headerlink" title="b. label属性"></a>b. label属性</h5><p>通过<code>&amp;</code>进行引用，底层原理和phandle属性的方法是一样的，只是phandle属性部分由编译器将替我们完成了</p>
<pre><code class="c">PIC: pic@10000000 {
    interrupt-controller;    //该属性表明这是中断控制器
};

another-device-node {
    interrupt-parent = &lt;&amp;PIC&gt;;   // 使用label来引用上述节点,
                                 // 使用lable时实际上也是使用phandle来引用,
                                 // 在编译dts文件为dtb文件时, 编译器dtc会在dtb中插入phandle属性
};</code></pre>
<p>label属性可以在<strong><code>/</code>节点外</strong>直接引用并修改对应节点中的值</p>
<pre><code class="c">//以下为XXXX.dtsi文件内容：
/ {
    ......
    PIC: pic@10000000 {
        pin = &lt;XXX&gt;;
        interrupt-controller;    //该属性表明这是中断控制器
    };
    ......
};</code></pre>
<pre><code class="c">#include&quot;XXXX.dtsi&quot;
&amp;PIC {
    pin = &lt;XXXXXXX&gt;;//直接修改
};</code></pre>
<h3 id="2-DTB二进制文件的格式"><a href="#2-DTB二进制文件的格式" class="headerlink" title="2. DTB二进制文件的格式"></a>2. DTB二进制文件的格式</h3><p><a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">官方文档</a></p>
<p>内核文档路径：<code>Documentation/devicetree/booting-without-of.txt</code></p>
<p>dtb文件是由dts文件编译而来</p>
<h4 id="DTB文件布局"><a href="#DTB文件布局" class="headerlink" title="DTB文件布局"></a>DTB文件布局</h4><p>dtb文件以<code>大字节序</code>存储（低地址放高位）。根据官方说明，dtb文件结构如下所示：</p>
<pre><code class="c">             ------------------------------
     base -&gt; |  struct boot_param_header  | //头部信息，包含后几个部分的指针
             ------------------------------
             |      (alignment gap) (*)   |
             ------------------------------
             |      memory reserve map    |//保留给自己使用的内存，即dts中格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;的地方
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |    device-tree structure   |//设备数的二进制文件
             |                            |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |     device-tree strings    |//设备数节点中的属性名字字符串
             |                            |
      -----&gt; ------------------------------
      |
      |
      --- (base + totalsize)</code></pre>
<p>具体格式可见下图：</p>
<p><img src="//NU-LL.github.io/2019/10/13/设备树/DTB%E6%A0%BC%E5%BC%8F.jpg" alt="DTB格式"></p>
<h3 id="3-通用函数"><a href="#3-通用函数" class="headerlink" title="3. 通用函数"></a>3. 通用函数</h3><p>device_node结构体与property结构体内容可以看下文中 <code>第二章第4节</code></p>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol>
<li><p>通过名字查找</p>
<pre><code class="c"> struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>name：要查找的节点名字（不是table和name属性）。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li>
</ul>
</li>
<li><p>通过device_type 属性查找</p>
<pre><code class="c"> struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li>
</ul>
</li>
<li><p>根据 device_type 和 compatible查找</p>
<pre><code class="c"> struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li>
<li>compatible： 要查找的节点所对应的 compatible 属性列表。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败  </li>
</ul>
</li>
<li><p>通过 of_device_id 匹配表来查找</p>
<pre><code class="c"> struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li>
<li>match： 找到的匹配的 of_device_id。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li><p>通过路径查找</p>
<pre><code class="c"> inline struct device_node *of_find_node_by_path(const char *path)</code></pre>
<ul>
<li>path：带有全路径的节点名，可以使用节点的别名。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li><p>查找指定节点的父节点</p>
<pre><code class="c"> struct device_node *of_get_parent(const struct device_node *node)</code></pre>
<ul>
<li>node：要查找的父节点的节点。</li>
<li>返回值： 找到的父节点。</li>
</ul>
</li>
<li><p>查找指定节点的子节点</p>
<pre><code class="c"> struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)</code></pre>
<ul>
<li>node：父节点。</li>
<li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li>
<li>返回值： 找到的下一个子节点。</li>
</ul>
</li>
</ol>
<h4 id="提取属性"><a href="#提取属性" class="headerlink" title="提取属性"></a>提取属性</h4><ol>
<li><p>查找节点中的指定属性</p>
<pre><code class="c"> property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>name： 属性名字。</li>
<li>lenp：属性值的字节数，一般为NULL</li>
<li>返回值： 找到的属性。</li>
</ul>
</li>
<li><p>获取属性中元素的数量</p>
<pre><code class="c"> int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 需要统计元素数量的属性名字。</li>
<li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li>
<li>返回值： 得到的属性元素数量。</li>
</ul>
</li>
<li><p>从属性中获取指定标号的 u32 类型数据值</p>
<pre><code class="c"> int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>index：要读取的值标号。</li>
<li>out_value：读取到的值</li>
<li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p>
<pre><code class="c"> int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz)
 int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz)
 int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz)
 int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li>
<li>sz： 要读取的数组元素数量。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取只有一个整形值的属性</p>
<pre><code class="c"> int of_property_read_u8(const struct device_node *np,const char *propname, u8 *out_value)
 int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value)
 int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)
 int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_value：读取到的数组值。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取属性中字符串值</p>
<pre><code class="c"> int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_string：读取到的字符串值。</li>
<li>返回值： 0，读取成功，负值，读取失败。</li>
</ul>
</li>
<li><p>获取#address-cells 属性值</p>
<pre><code class="c"> int of_n_addr_cells(struct device_node *np)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#address-cells 属性值。</li>
</ul>
</li>
<li><p>获取#size-cells 属性值</p>
<pre><code class="c"> int of_n_size_cells(struct device_node *np)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#size-cells 属性值。</li>
</ul>
</li>
</ol>
<h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><ol>
<li><p>查看节点的 compatible 属性是否有包含指定的字符串</p>
<pre><code class="c"> int of_device_is_compatible(const struct device_node *device, const char *compat)</code></pre>
<ul>
<li>device：设备节点。</li>
<li>compat：要查看的字符串。</li>
<li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li>
</ul>
</li>
<li><p>获取地址相关属性</p>
<p> 主要是“reg”或者“assigned-addresses”属性值</p>
<pre><code class="c"> const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>index：要读取的地址标号。</li>
<li>size：地址长度。</li>
<li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li>
<li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li>
</ul>
</li>
<li><p>将从设备树读取到的地址转换为物理地址</p>
<pre><code class="c"> u64 of_translate_address(struct device_node *dev, const __be32 *in_addr)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>in_addr：要转换的地址。</li>
<li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li>
</ul>
</li>
<li><p>从设备树里面提取资源值</p>
<p> 本质上是将 reg 属性值转换为 resource 结构体类型</p>
<pre><code class="c"> int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>index：地址资源标号。</li>
<li>r：得到的 resource 类型的资源值。</li>
<li>返回值： 0，成功；负值，失败。</li>
</ul>
</li>
<li><p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p>
<p> 本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p>
<pre><code class="c"> void __iomem *of_iomap(struct device_node *np, int index)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li>
<li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li>
</ul>
</li>
</ol>
<h2 id="二、内核对设备树的处理"><a href="#二、内核对设备树的处理" class="headerlink" title="二、内核对设备树的处理"></a>二、内核对设备树的处理</h2><p>根据内核文档中的描述，内核对设备数的处理大概分为以下三个部分：</p>
<ol>
<li>platform identification，平台识别信息</li>
<li>runtime configuration，运行时配置信息</li>
<li>device population，设备信息</li>
</ol>
<h3 id="1-内核head-S对dtb的简单处理"><a href="#1-内核head-S对dtb的简单处理" class="headerlink" title="1. 内核head.S对dtb的简单处理"></a>1. 内核head.S对dtb的简单处理</h3><p>uboot启动后，会设置r0 r1 r2 三个寄存器，将参数传给linux内核：</p>
<ul>
<li>r0一般设置为0;</li>
<li>r1一般设置为machine id (机器ID，在使用设备树时该参数没有被使用); </li>
<li>r2一般设置ATAGS或DTB的开始地址</li>
</ul>
<p>inux内核启动后会运行head.S文件，head.S和head-common.S文件一起将传入的这几个参数又传给了内核中的C语言变量：</p>
<ul>
<li>把bootloader传来的r1值, 赋给了C变量: <code>__machine_arch_type</code></li>
<li>把bootloader传来的r2值, 赋给了C变量: <code>__atags_pointer</code>     // dtb首地址</li>
</ul>
<p>之后会调用start_kernel启动内核。</p>
<h3 id="2-对设备树中平台信息的处理-选择machine-desc结构体"><a href="#2-对设备树中平台信息的处理-选择machine-desc结构体" class="headerlink" title="2. 对设备树中平台信息的处理(选择machine_desc结构体)"></a>2. 对设备树中平台信息的处理(选择machine_desc结构体)</h3><p>大概流程如下：</p>
<ul>
<li><p>a. 设备树根节点的<code>compatible</code>属性列出了一系列的字符串,表示它兼容的单板名,从”最兼容”到次之</p>
</li>
<li><p>b. 内核中有多个machine_desc,其中有<code>dt_compat</code>成员, 它指向一个字符串数组, 里面表示该machine_desc支持哪些单板</p>
<blockquote>
<p>没有用设备树的时候，uboot向linux内核传递ATAGS，此时是根据machine_desc.nr成员来匹配机器id是否相等进而选取的</p>
</blockquote>
</li>
<li><p>c. 使用<code>compatile</code>属性的值，跟每一个<code>machine_desc.dt_compat</code>比较，如若多项均匹配上，<code>compatile</code>属性中越靠前的字符串优先级越高</p>
</li>
</ul>
<p>函数调用过程如下：</p>
<hr>
<ul>
<li><p>start_kernel   // init/main.c</p>
<ul>
<li><p>setup_arch(&amp;command_line);  （先尝试将__atags_pointer处的数据认为是dtb并进行分析，如若出错就将其当做ATAGS分析）// arch/arm/kernel/setup.c</p>
<ul>
<li><p>mdesc = setup_machine_fdt(__atags_pointer);  // arch/arm/kernel/devtree.c</p>
<ul>
<li><p>early_init_dt_verify(phys_to_virt(dt_phys)  // 检查头部信息，判断是否有效的dtb, drivers/of/ftd.c</p>
<ul>
<li>initial_boot_params = params;//保存在全局变量initial_boot_params中</li>
</ul>
</li>
<li><p>mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);  // 找到最匹配的machine_desc，arch_get_next_mach为一个函数指针，该函数每调用一次就会返回一个machine_desc.dt_compat, drivers/of/ftd.c</p>
<ul>
<li><pre><code class="c">  while ((data = get_next_compat(&amp;compat))) {
      score = of_flat_dt_match(dt_root, compat);
      if (score &gt; 0 &amp;&amp; score &lt; best_score) {
          best_data = data;
          best_score = score;
      }
  }</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>machine_desc = mdesc;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-对设备树中运行时配置信息的处理"><a href="#3-对设备树中运行时配置信息的处理" class="headerlink" title="3. 对设备树中运行时配置信息的处理"></a>3. 对设备树中运行时配置信息的处理</h3><p>大致流程如下：</p>
<ul>
<li>a. /chosen节点中bootargs属性的值, 存入全局变量： boot_command_line</li>
<li>b. 确定根节点的这2个属性的值: #address-cells, #size-cells存入全局变量: dt_root_addr_cells, dt_root_size_cells</li>
<li>c. 解析/memory中的reg属性, 提取出”base, size”, 最终调用memblock_add(base, size);</li>
</ul>
<p>函数调用过程如下：</p>
<hr>
<ul>
<li><p>start_kernel // init/main.c</p>
<ul>
<li><p>setup_arch(&amp;command_line);  // arch/arm/kernel/setup.c</p>
<ul>
<li><p>mdesc = setup_machine_fdt(__atags_pointer);  // arch/arm/kernel/devtree.c</p>
<ul>
<li><p>early_init_dt_scan_nodes();      // drivers/of/ftd.c</p>
<ul>
<li><pre><code class="c">  /* Retrieve various information from the /chosen node */
  of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);//将bootargs属性的值, 存入全局变量boot_command_line

  /* Initialize {size,address}-cells info */
  of_scan_flat_dt(early_init_dt_scan_root, NULL);//处理并保存 根节点信息中的#address-cells, #size-cells属性

  /* Setup memory, calling early_init_dt_add_memory_arch */
  of_scan_flat_dt(early_init_dt_scan_memory, NULL);//取出/memory节点reg属性中的&quot;base, size&quot;并告诉内核</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-dtb转换为device-node-unflatten-device-tree函数"><a href="#4-dtb转换为device-node-unflatten-device-tree函数" class="headerlink" title="4. dtb转换为device_node(unflatten_device_tree函数)"></a>4. dtb转换为device_node(unflatten_device_tree函数)</h3><p>大致过程：</p>
<ul>
<li><p>a. 在DTB文件中, 每一个节点都以TAG(FDT_BEGIN_NODE, 0x00000001)开始, 节点内部可以嵌套其他节点,每一个属性都以TAG(FDT_PROP, 0x00000003)开始</p>
</li>
<li><p>b. 每一个节点最后都会转换为一个device_node结构体:</p>
<pre><code class="c">  struct device_node {
      const char *name;  // 来自节点中的name属性, 如果没有该属性, 则设为&quot;NULL&quot;
      const char *type;  // 来自节点中的device_type属性, 如果没有该属性, 则设为&quot;NULL&quot;
      phandle phandle;
      const char *full_name;  // 节点的名字, node-name[@unit-address]
      struct fwnode_handle fwnode;

      struct  property *properties;  // 节点的属性
      struct  property *deadprops;    /* removed properties */
      struct  device_node *parent;   // 节点的父亲
      struct  device_node *child;    // 节点的孩子(子节点)
      struct  device_node *sibling;  // 节点的兄弟(同级节点)
  #if defined(CONFIG_OF_KOBJ)
      struct  kobject kobj;
  #endif
      unsigned long _flags;
      void    *data;
  #if defined(CONFIG_SPARC)
      const char *path_component_name;
      unsigned int unique_id;
      struct of_irq_controller *irq_trans;
  #endif
  };</code></pre>
</li>
<li><p>c. device_node结构体中有properties, 用来表示该节点的属性，每一个属性对应一个property结构体:</p>
<pre><code class="c">  struct property {
      char    *name;    // 属性名字, 指向dtb文件中的字符串
      int length;       // 属性值的长度，按字节计算
      void    *value;   // 属性值, 指向dtb文件中value所在位置, 数据仍以big endian存储
      struct property *next;
  #if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)
      unsigned long _flags;
  #endif
  #if defined(CONFIG_OF_PROMTREE)
      unsigned int unique_id;
  #endif
  #if defined(CONFIG_OF_KOBJ)
      struct bin_attribute attr;
  #endif
  };</code></pre>
</li>
<li><p>d. 这些device_node构成一棵树, 根节点为: <code>of_root</code></p>
</li>
</ul>
<p>函数调用过程：</p>
<hr>
<ul>
<li><p>start_kernel // init/main.c</p>
<ul>
<li><p>setup_arch(&amp;command_line);  // arch/arm/kernel/setup.c</p>
<ul>
<li><p>arm_memblock_init(mdesc);   // arch/arm/kernel/setup.c</p>
<ul>
<li>early_init_fdt_reserve_self();//将DTB所占区域保留下来, 最后会调用: memblock_reserve</li>
<li>early_init_fdt_scan_reserved_mem();  // 根据dtb中的memreserve信息, 调用memblock_reserve保留其他区域</li>
</ul>
</li>
<li><p>unflatten_device_tree();    // arch/arm/kernel/setup.c//开始分配设置device_node结构体</p>
<ul>
<li><p>__unflatten_device_tree(initial_boot_params, NULL, &amp;of_root,early_init_dt_alloc_memory_arch, false);            // drivers/of/fdt.c</p>
<ul>
<li><pre><code class="c">  /* First pass, scan for size */
  size = unflatten_dt_nodes(blob, NULL, dad, NULL);

  /* Allocate memory for the expanded device tree */
  mem = dt_alloc(size + 4, __alignof__(struct device_node));

  /* Second pass, do actual unflattening */
  unflatten_dt_nodes(blob, mem, dad, mynodes);</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-device-node结构体转换为platform-device"><a href="#5-device-node结构体转换为platform-device" class="headerlink" title="5. device_node结构体转换为platform_device"></a>5. device_node结构体转换为platform_device</h3><p>基本流程：dts -&gt; dtb -&gt; device_node -&gt; platform_device</p>
<ul>
<li><p>转化为platform_device的只有一部分device_node </p>
<blockquote>
<p>条件：</p>
<ol>
<li>一般来说<u>根节点下</u>包含compatile属性的<u>子节点</u>都会转化为platform_device。而其他子节点不应该转化为platform_device。如：i2c, spi等总线节点下的子节点, 应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device</li>
<li>特殊情况：如果一个节点的compatile属性含有这些特殊的值（<code>simple-bus</code>、<code>simple-mfd</code>、<code>isa</code>、<code>arm,amba-bus</code>）（由drivers\of\platform.c中的of_default_bus_match_table表定义）之一, 那么它的子节点（也需含compatile属性。详见下面of_platform_bus_create的实现）也可以转换为platform_device</li>
</ol>
<p>附：</p>
<p>根节点下的iic、spi总线节点一般都会转化为platform_device结构体，这些总线节点下的子节点一般不再会转换为platform_device，而是交给bus的probe函数去注册为i2c_client、spi_device等设备结构体</p>
</blockquote>
</li>
</ul>
<p>转化过程：</p>
<ul>
<li>利用device_node中的reg, interrupts属性设置platform_device中的<code>resource</code>数组</li>
<li>将device_node结构体挂载在<code>platform_device.dev.of_node</code>上</li>
</ul>
<p>函数调用过程：</p>
<hr>
<p>核心函数：of_platform_default_populate_init</p>
<blockquote>
<p>注：</p>
<p>该函数不会直接调用，会通过do_initcall_level(level);函数间接调用，of_platform_default_populate_init函数通过一个宏将其放到了.initcall3s.init段处。do_initcall_level(3)会调用.initcall3s.init段的所有函数。</p>
</blockquote>
<p>调用of_platform_default_populate_init：</p>
<ul>
<li><p>start_kernel     // init/main.c</p>
<ul>
<li><p>rest_init();</p>
<ul>
<li><p>pid = kernel_thread(kernel_init, NULL, CLONE_FS);//启动线程kernel_init</p>
<ul>
<li><p>kernel_init线程中：</p>
</li>
<li><p>kernel_init_freeable();</p>
<ul>
<li><p>do_basic_setup();</p>
<ul>
<li><p>do_initcalls();</p>
<ul>
<li><pre><code class="c">  for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++)
      do_initcall_level(level);  // 比如 do_initcall_level(3)</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>生成platform_device:</p>
<ul>
<li><p>of_platform_default_populate_init//遍历所有节点并生成platform_device结构体</p>
<ul>
<li><p>of_platform_default_populate(NULL, NULL, NULL);</p>
<ul>
<li><p>of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL)</p>
<ul>
<li><pre><code class="c">  for_each_child_of_node(root, child) {
      rc = of_platform_bus_create(child, matches, lookup, parent, true);  // 调用过程看下面
      dev = of_device_alloc(np, bus_id, parent);   // 根据device_node节点的属性设置platform_device的resource
      if (rc) {
          of_node_put(child);
          break;
      }
  }</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>of_platform_bus_create创建总线节点（处理bus节点生成platform_devie, 并决定是否处理它的子节点）</p>
<ul>
<li><p>of_platform_bus_create</p>
<ul>
<li><pre><code class="c">  dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);  // 生成bus节点的platform_device结构体
  if (!dev || !of_match_node(matches, bus))  // 如果bus节点的compatile属性不吻合matches成表, 就不处理它的子节点
      return 0;

  for_each_child_of_node(bus, child) {    // 取出每一个子节点
      pr_debug(&quot;   create child: %pOF\n&quot;, child);
      rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);   // 处理它的子节点, of_platform_bus_create是一个递归调用
      if (rc) {
          of_node_put(child);
          break;
      }
  }</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-platform-device跟platform-driver的匹配"><a href="#6-platform-device跟platform-driver的匹配" class="headerlink" title="6. platform_device跟platform_driver的匹配"></a>6. platform_device跟platform_driver的匹配</h3><p>匹配时通过platform_bus_type的match成员函数实现的，即platform_match</p>
<p>匹配的优先级如下：</p>
<ul>
<li>比较 platform_dev.driver_override 和 platform_driver.drv-&gt;name</li>
<li>比较 platform_dev.dev.of_node的compatible属性 和 platform_driver.drv-&gt;of_match_table</li>
<li>比较 platform_dev.name 和 platform_driver.id_table</li>
<li>比较 platform_dev.name 和 platform_driver.drv-&gt;name</li>
</ul>
<h3 id="7-内核中设备树的操作函数"><a href="#7-内核中设备树的操作函数" class="headerlink" title="7. 内核中设备树的操作函数"></a>7. 内核中设备树的操作函数</h3><ul>
<li><p>a. 处理DTB<br>  of_fdt.h           // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)</p>
</li>
<li><p>b. 处理device_node<br>  of.h               // 提供设备树的一般处理函数, 比如 of_property_read_u32(读取某个属性的u32值), of_get_child_count(获取某个device_node的子节点数)<br>  of_address.h       // 地址相关的函数, 比如 of_get_address(获得reg属性中的addr, size值)<br>  of_match_device(从matches数组中取出与当前设备最匹配的一项)<br>  of_dma.h           // 设备树中DMA相关属性的函数<br>  of_gpio.h          // GPIO相关的函数<br>  of_graph.h         // GPU相关驱动中用到的函数, 从设备树中获得GPU信息<br>  of_iommu.h         // 很少用到<br>  of_irq.h           // 中断相关的函数<br>  of_mdio.h          // MDIO (Ethernet PHY) API<br>  of_net.h           // OF helpers for network devices.<br>  of_pci.h           // PCI相关函数<br>  of_pdt.h           // 很少用到<br>  of_reserved_mem.h  // reserved_mem的相关函数</p>
</li>
<li><p>c. 处理设备相关的信息 platform_device<br>  of_platform.h      // 把device_node转换为platform_device时用到的函数, </p>
<pre><code>                 // 比如of_device_alloc(根据device_node分配设置platform_device), 
                 //     of_find_device_by_node (根据device_node查找到platform_device),
                 //     of_platform_bus_probe (处理device_node及它的子节点)</code></pre><p>  of_device.h        // 设备相关的函数, 比如 of_match_device</p>
</li>
</ul>
<h3 id="8-在根文件系统中查看设备树-有助于调试"><a href="#8-在根文件系统中查看设备树-有助于调试" class="headerlink" title="8. 在根文件系统中查看设备树(有助于调试)"></a>8. 在根文件系统中查看设备树(有助于调试)</h3><ul>
<li><p>a. <code>/sys/firmware/fdt</code>        // 原始dtb文件</p>
<pre><code class="bash">  #打印设备数文件（dtb文件）
  hexdump -C /sys/firmware/fdt</code></pre>
</li>
<li><p>b. <code>/sys/firmware/devicetree</code> // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件</p>
</li>
<li><p>c. <code>/sys/devices/platform</code>    // 系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的</p>
<pre><code> 对于来自设备树的platform_device,可以进入 `/sys/devices/platform/&lt;设备名&gt;/of_node` 查看它的设备树属性</code></pre></li>
<li><p>d.  <code>/proc/device-tree</code> 是链接文件, 指向 /sys/firmware/devicetree/base</p>
</li>
</ul>
<h2 id="三、u-boot对设备树的支持"><a href="#三、u-boot对设备树的支持" class="headerlink" title="三、u-boot对设备树的支持"></a>三、u-boot对设备树的支持</h2><h3 id="1-传递dtb给内核（r2）"><a href="#1-传递dtb给内核（r2）" class="headerlink" title="1. 传递dtb给内核（r2）"></a>1. 传递dtb给内核（r2）</h3><ul>
<li><p>u-boot中内核启动命令</p>
<pre><code class="bash">  bootm &lt;uImage_addr&gt;                            // 无设备树,bootm 0x30007FC0
  bootm &lt;uImage_addr&gt; &lt;initrd_addr&gt; &lt;dtb_addr&gt;   // 有设备树</code></pre>
<p>  eg：</p>
<pre><code class="bash">  nand read.jffs2 0x30007FC0 kernel;     // 读内核uImage到内存0x30007FC0
  nand read.jffs2 32000000 device_tree;  // 读dtb到内存32000000
  bootm 0x30007FC0 - 0x32000000          // 启动, 没有initrd时对应参数写为&quot;-&quot;</code></pre>
</li>
<li><p>设备数的存放地址 <code>dtb_addr</code> 的选取原则</p>
<ul>
<li>不要破坏u-boot本身</li>
<li>不要挡内核的路: 内核本身的空间不能占用, 内核要用到的内存区域也不能占用内核启动时一般会在它所处位置的下边放置页表, 这块空间(一般是0x4000即16K字节)不能被占用</li>
</ul>
</li>
</ul>
<blockquote>
<p>JZ2440内存使用情况:</p>
<pre><code>                     ------------------------------
  0x33f80000       -&gt;|    u-boot                  |
                     ------------------------------
                     |    u-boot所使用的内存(栈等)|
                     ------------------------------
                     |                            |
                     |                            |
                     |        空闲区域            |
                     |                            |
                     |                            |
                     |                            |
                     |                            |
                     ------------------------------
  0x30008000       -&gt;|      zImage                |
                     ------------------------------  uImage = 64字节的头部+zImage
  0x30007FC0       -&gt;|      uImage头部            |
                     ------------------------------
  0x30004000       -&gt;|      内核创建的页表        |  head.S
                     ------------------------------
                     |                            |
                     |                            |
              -----&gt; ------------------------------
              |
              |
              --- (内存基址 0x30000000)</code></pre><ul>
<li><p>正常启动linux：</p>
<pre><code class="bash">  nand read.jffs2 30000000 device_tree
  nand read.jffs2 0x30007FC0 kernel
  bootm 0x30007FC0 - 30000000</code></pre>
</li>
<li><p>启动错误：</p>
<pre><code class="bash">  #设备数放到内核创建的页表处，会导致linux启动后设备树文件缺失
  nand read.jffs2 30004000 device_tree
  nand read.jffs2 0x30007FC0 kernel
  bootm 0x30007FC0 - 30004000</code></pre>
</li>
</ul>
</blockquote>
<h3 id="2-uboot中对dtb文件修改的原理"><a href="#2-uboot中对dtb文件修改的原理" class="headerlink" title="2. uboot中对dtb文件修改的原理"></a>2. uboot中对dtb文件修改的原理</h3><ul>
<li><p>修改属性的值</p>
<ul>
<li>a. 把原属性val所占空间从len字节扩展为newlen字节，把老值之后的所有内容向后移动(newlen - len)字节</li>
<li>b. 把新值写入val所占的newlen字节空间</li>
<li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li>
<li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li>
<li>e. 修改dtb头部信息中的总长度: totalsize</li>
</ul>
</li>
<li><p>添加一个全新的属性</p>
<ul>
<li>a. 如果在string block中没有这个属性的名字，就在string block尾部添加一个新字符串: 属性的名。并且修改dtb头部信息中string block的长度: size_dt_strings，修改dtb头部信息中的总长度: totalsize</li>
<li>b. 找到属性所在节点, 在节点尾部扩展一块空间, 内容及长度为: <pre><code> TAG      // 4字节, 对应0x00000003
 len      // 4字节, 表示属性的val的长度
 nameoff  // 4字节, 表示属性名的offset
 val      // len字节, 用来存放val</code></pre></li>
<li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li>
<li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li>
<li>e. 修改dtb头部信息中的总长度: totalsize</li>
</ul>
</li>
</ul>
<h3 id="3-uboot中dtb修改命令fdt的移植"><a href="#3-uboot中dtb修改命令fdt的移植" class="headerlink" title="3.uboot中dtb修改命令fdt的移植"></a>3.uboot中dtb修改命令fdt的移植</h3><p><strong>使用：</strong></p>
<ol>
<li><p>配置交叉编译工具链 <code>gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabi</code></p>
</li>
<li><p>解压</p>
<pre><code class="bash"> tar xjf u-boot-1.1.6.tar.bz2</code></pre>
</li>
<li><p>打补丁</p>
<pre><code class="bash"> patch -p1 &lt; ../u-boot-1.1.6_device_tree_for_jz2440_add_fdt_20181022.patch   // 打补丁
 make 100ask24x0_config                                                      // 配置
 make                                                                        // 编译, 可以得到u-boot.bin</code></pre>
</li>
</ol>
<p><strong>移植：</strong></p>
<p>高版本中已经存在，无需移植</p>
<h4 id="创建补丁文件"><a href="#创建补丁文件" class="headerlink" title="创建补丁文件"></a>创建补丁文件</h4><pre><code class="bash">diff -urN 原始未修改文件夹 修改后文件夹 &gt; 补丁文件.patch</code></pre>
<h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><pre><code class="bash">patch -p1 &lt; ../补丁文件.patch</code></pre>
<h2 id="四、中断系统中的设备树"><a href="#四、中断系统中的设备树" class="headerlink" title="四、中断系统中的设备树"></a>四、中断系统中的设备树</h2><h3 id="1-Linux对中断处理的框架及代码流程简述"><a href="#1-Linux对中断处理的框架及代码流程简述" class="headerlink" title="1. Linux对中断处理的框架及代码流程简述"></a>1. Linux对中断处理的框架及代码流程简述</h3><p>如图：</p>
<p><img src="//NU-LL.github.io/2019/10/13/设备树/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%A1%86%E6%9E%B6.jpg" alt="Linux中断处理的框架"></p>
<h3 id="2-中断号的演变与irq-domain"><a href="#2-中断号的演变与irq-domain" class="headerlink" title="2. 中断号的演变与irq_domain"></a>2. 中断号的演变与irq_domain</h3><h4 id="之前的irq"><a href="#之前的irq" class="headerlink" title="之前的irq"></a>之前的irq</h4><ul>
<li>以前中断号(virq)跟硬件密切相关，现在的趋势是中断号跟硬件无关, 仅仅是一个标号而已</li>
<li>以前, 对于每一个硬件中断(hwirq)都预先确定它的中断号(virq),这些中断号一般都写在一个头文件里, 比如arch\arm\mach-s3c24xx\include\mach\irqs.h使用时：<ul>
<li>执行 request_irq(virq, my_handler) :内核根据virq可以知道对应的硬件中断, 然后去设置、使能中断等</li>
<li>发生硬件中断时,内核读取硬件信息, 确定hwirq, 反算出virq,然后调用 irq_desc[virq].handle_irq, 最终会用到用户注册的my_handler函数</li>
</ul>
</li>
</ul>
<h4 id="现在的irq"><a href="#现在的irq" class="headerlink" title="现在的irq"></a>现在的irq</h4><ul>
<li><p>hwirq跟virq之间不再通过代码绑定，而是进行动态绑定：</p>
<ul>
<li><p>每一个hwirq会去irq_desc全局表中从hwirq项开始向后查找，直到找到空闲项就进行绑定：</p>
<ul>
<li>每一个中断控制器都有一个对应的<code>irq_domain</code>（域）</li>
</ul>
</li>
<li><p>绑定信息保存在<code>irq_domain</code>（域）中</p>
</li>
<li><p><code>irq_domain</code>中有个<code>linear_revmap</code>数组成员用于保存hwirq到virq的关系：</p>
<pre><code class="c">  irq_domain.linear_revmap[hwirq] = virq;</code></pre>
</li>
<li><p>不难看出<code>linear_revmap</code>数组成员中用到的项比较少，大部分为空闲项</p>
</li>
<li><p><code>irq_domain</code>对之前的irq的兼容：</p>
<ul>
<li><code>irq_domain</code>中有<code>linear_revmap</code>成员用于保存之前irq架构中的hwirq到预先设置好的virq之间的对应关系</li>
<li><code>linear_revmap</code>成员中基本上都使用了，很少的空闲项</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>例子：子中断控制器中的中断发生：</p>
<ol>
<li>进入中断入口，再跳转到C语言入口，执行相应的保存现场等动作</li>
<li>总中断控制器通过hwirq和irq_domain.linear_revmap查到具体的virq</li>
<li>通过virq查到全局表中具体的中断函数irq_desc[virq].handle_irq，发现是分发函数（s3c_irq_demux）</li>
<li>接着查询子中断控制器的hwirq，并找到对应的virq：irq_domain.linear_revmap[hwirq]</li>
<li>找到新的全局表中的中断函数irq_desc[virq].handle_irq并执行</li>
<li>该函数是用户通过request_irq(virq, my_handler)向系统注册的用户函数my_handler，真正交给用户<ol>
<li>此时request_irq中的virq不再通过固定文件获得，而是通过设备树中相互约定得来的。</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="设备树中irq的设置"><a href="#设备树中irq的设置" class="headerlink" title="设备树中irq的设置"></a>设备树中irq的设置</h4><p>设备树中应该对中断节点设置对应的中断控制器（决定使用哪个<code>irq_domain</code>）和hwirq（硬件中断号）</p>
<p>设备树中的设置会被irq_domain中的xlate成员函数解析，得到相应的virq和irq_type</p>
<p>irq_domain中的map成员函数会建立hwirq和virq之间的联系（详细分析见后文）</p>
<h3 id="3-设备树中对中断的描述"><a href="#3-设备树中对中断的描述" class="headerlink" title="3. 设备树中对中断的描述"></a>3. 设备树中对中断的描述</h3><p>ARM中顶层的中断控制器一般为<code>intc: interrupt-controller@xxxxxxxx</code>，其余节点均为其子节点</p>
<h4 id="中断节点"><a href="#中断节点" class="headerlink" title="中断节点"></a>中断节点</h4><ul>
<li><p><code>interrupts</code>属性：指定要使用的硬件中断号, 中断的触发类型等等，具体格式由对应的中断控制器决定</p>
</li>
<li><p><code>interrupt-parent</code>属性：指定该节点所在的中断控制器节点（若该节点中没有，在该节点的父节点中肯定已经包含）</p>
<ul>
<li>phandle属性指定</li>
<li>label属性指定</li>
</ul>
</li>
<li><p><code>interrupt-extended</code>属性（可选）：通过该属性可以解决一个节点产生多个中断的问题，其具体格式为：</p>
<p>  &lt;phandle&gt; &lt;prop-encoded-array&gt;</p>
<p>  其中：</p>
<ul>
<li><p>&lt;phandle&gt;：具体的发给那个中断控制器</p>
</li>
<li><p>&lt;prop-encoded-array&gt;：相关的中断描述，取决于中断控制器中的<code>#interrupt-cells</code>属性</p>
</li>
</ul>
</li>
</ul>
<h4 id="中断控制器节点"><a href="#中断控制器节点" class="headerlink" title="中断控制器节点"></a>中断控制器节点</h4><p>官方文档：<code>Documentation/devicetree/bindings/arm/gic.txt</code></p>
<ul>
<li><code>interrupt-controller</code>属性：表明自己是中断控制器</li>
<li><code>#interrupt-cells</code>属性：表明对应的子设备里interrupts属性应该用几个u32的数据来描述</li>
</ul>
<blockquote>
<p>对于 ARM 处理的 GIC（通用中断控制器）来说，一般<code>#interrupt-cells</code>为 3，其子节点<code>interrupts</code>属性中cells一般为：</p>
<ul>
<li>第一个 cells：中断类型， 0 表示 SPI 中断， 1 表示 PPI 中断</li>
<li>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0<del>987，对于 PPI 中断来说中断号的范围为 0</del>15</li>
<li>第三个 cells：标志， bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。 bit[15:8]为 PPI 中断的 CPU 掩码。  </li>
</ul>
</blockquote>
<ul>
<li><code>interrupt-parent</code>属性（可选）：指定该节点所在的中断控制器节点（除去最顶层的<code>intc</code>节点之外，其他所有中断节点中若没有，则在该节点的父节点中肯定已经包含）</li>
</ul>
<h3 id="4-使用设备树描述按键中断"><a href="#4-使用设备树描述按键中断" class="headerlink" title="4.使用设备树描述按键中断"></a>4.使用设备树描述按键中断</h3><ul>
<li>一般来说，一个节点会生成一个platform_device结构体，通过设备树中的compatible属性与platform_driver驱动结构体中的of_math_table结构体成员进行匹配，匹配上后会调用其下的probe函数，在该函数中会通过platform_get_resource函数来获取到platform_device对应的设备树中定义的相关资源（自定义属性的话需要利用of_XXXX系列函数自己转换），此时需要在这里保存下节点中的中断相关信息，以便于之后使用request_irq函数注册中断</li>
</ul>
<h3 id="5-内核对设备树中断信息的处理过程"><a href="#5-内核对设备树中断信息的处理过程" class="headerlink" title="5.内核对设备树中断信息的处理过程"></a>5.内核对设备树中断信息的处理过程</h3><ul>
<li>在Linux内核初始化时，会首先创建并初始化总中断控制器中的irq_domain结构体</li>
<li>各个子中断控制器会在各个设备节点所对应的platform_driver驱动结构体中的probe函数中对irq_domain结构体初始化</li>
<li>中断节点中，各个和中断相关的资源均会在内核初始化阶段（具体为of_device_alloc函数中，详见第二章第五节），将其初始化为platform_driver的resource结构体</li>
<li>各种中断数据的解析和处理均利用到了irq_domain-&gt;ops-&gt;xlate或者irq_domain-&gt;ops-&gt;map函数，此处不做详解，了解即可</li>
</ul>
<h2 id="五、实践操作"><a href="#五、实践操作" class="headerlink" title="五、实践操作"></a>五、实践操作</h2><h3 id="1-使用设备树给DM9000网卡-触摸屏指定中断"><a href="#1-使用设备树给DM9000网卡-触摸屏指定中断" class="headerlink" title="1. 使用设备树给DM9000网卡_触摸屏指定中断"></a>1. 使用设备树给DM9000网卡_触摸屏指定中断</h3><h3 id="2-在设备树中时钟的简单使用"><a href="#2-在设备树中时钟的简单使用" class="headerlink" title="2. 在设备树中时钟的简单使用"></a>2. 在设备树中时钟的简单使用</h3><p>参考文档：</p>
<ol>
<li>内核 Documentation/devicetree/bindings/clock/clock-bindings.txt</li>
<li>内核 Documentation/devicetree/bindings/clock/samsung,s3c2410-clock.txt</li>
</ol>
<h4 id="Clock-providers节点"><a href="#Clock-providers节点" class="headerlink" title="Clock providers节点"></a>Clock providers节点</h4><ul>
<li>这种节点属于内核中时钟树的提供者，用于提供时钟给别的模块</li>
<li><code>#clock-cells</code>属性：指定引用该节点的子节点中时钟的参数结构是由几个u32位数据描述的</li>
<li></li>
</ul>
<h4 id="Clock-consumers节点"><a href="#Clock-consumers节点" class="headerlink" title="Clock consumers节点"></a>Clock consumers节点</h4><ul>
<li><p><code>clocks</code>属性：通过该属性指定具体的Clock providers节点和需要用到的时钟信号，其具体格式为：</p>
<p>  &lt;Clock providers节点id&gt; &lt;相关时钟参数&gt;</p>
<p>  其中：</p>
<ul>
<li><p>&lt;Clock providers节点id&gt;：具体的Clock providers节点，通过lable或phandle属性引用均可</p>
</li>
<li><p>&lt;相关时钟参数&gt;：相关的中断描述，取决于Clock providers节点中的<code>#clock-cells</code>属性</p>
</li>
</ul>
</li>
</ul>
<h4 id="以前时钟驱动写法"><a href="#以前时钟驱动写法" class="headerlink" title="以前时钟驱动写法"></a>以前时钟驱动写法</h4><ol>
<li>clk=clk_get(NULL,”时钟名”)：通过时钟名字获得相应时钟</li>
<li>clk_prepare_enable(clk)：使能相关时钟</li>
</ol>
<h4 id="用上设备树后"><a href="#用上设备树后" class="headerlink" title="用上设备树后"></a>用上设备树后</h4><ol>
<li>of_count_phandle_with_args函数获取设备树中时钟的个数</li>
<li>of_clk_get函数获取具体的时钟</li>
<li>clk_prepare_enable使能时钟</li>
<li>clk_disable_unprepare禁止时钟</li>
</ol>
<p>eg:</p>
<pre><code class="c">// 确定时钟个数
int nr_pclks = of_count_phandle_with_args(dev-&gt;of_node, &quot;clocks&quot;,
                                          &quot;#clock-cells&quot;);
// 获得时钟
for (i = 0; i &lt; nr_pclks; i++) {
    struct clk *clk = of_clk_get(dev-&gt;of_node, i);
}

// 使能时钟
clk_prepare_enable(clk);

// 禁止时钟
clk_disable_unprepare(clk);</code></pre>
<h3 id="3-在设备树中pinctrl的简单使用"><a href="#3-在设备树中pinctrl的简单使用" class="headerlink" title="3. 在设备树中pinctrl的简单使用"></a>3. 在设备树中pinctrl的简单使用</h3><p>参考文档：内核 Documentation/devicetree/bindings/pinctrl/samsung-pinctrl.txt</p>
<p><code>Bank</code>：以引脚名为依据, 这些引脚分为若干组, 每组称为一个Bank。比如s3c2440里有GPA、GPB、GPC等Bank，每个Bank中有若干个引脚, 比如GPA0,GPA1, …, GPC0, GPC1,…等引脚</p>
<p><code>Group</code>：以功能为依据, 具有相同功能的引脚称为一个Group。比如s3c2440中串口0的TxD、RxD引脚使用 GPH2,GPH3, 那这2个引脚可以列为一组。比如s3c2440中串口0的流量控制引脚使用 GPH0,GPH1, 那这2个引脚也可以列为一组</p>
<p><code>State</code>：设备的某种状态, 比如内核自己定义的”default”,”init”,”idel”,”sleep”状态。也可以是其他自己定义的状态, 比如串口的”flow_ctrl”状态(使用流量控制)</p>
<h4 id="pinctrl节点"><a href="#pinctrl节点" class="headerlink" title="pinctrl节点"></a>pinctrl节点</h4><ul>
<li><p>节点中会定义各种pin bank节点，比如s3c2440有GPA,GPB,GPC,…,GPB各种BANK, 每个BANK中有若干引脚</p>
<ul>
<li><p>bank节点</p>
<ul>
<li><p><code>gpio-controller</code>属性：表明是gpio的控制器</p>
</li>
<li><p><code>#gpio-cells</code>属性：以后想使用bank中的引脚时, 需要用该属性来表明用多少个u32数据指定引脚</p>
</li>
<li><p>eg：</p>
<pre><code>  pinctrl_0: pinctrl@56000000 {
      reg = &lt;0x56000000 0x1000&gt;;

      gpa: gpa {
          gpio-controller;
          #gpio-cells = &lt;2&gt;;  /* 以后想使用gpa bank中的引脚时, 需要2个u32来指定引脚 */
      };
  };</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>pinctrl节点中也会有各种group(组合)子节点</p>
<ul>
<li><p>group节点（这里以samsung为例，具体属性由每家平台的驱动决定）</p>
<ul>
<li><p>属性依平台不一致而有所变化</p>
</li>
<li><p><code>samsung,pins</code>属性：该组内要使用到的gpio</p>
</li>
<li><p><code>samsung,pin-function</code>属性：在对应的gpio控制寄存器中，每个组中引脚对应的复用功能。</p>
</li>
<li><p><code>samsung,pin-val</code>属性：初始电平</p>
</li>
<li><p>eg：</p>
<pre><code>  uart0_data: uart0-data {
      samsung,pins = &quot;gph-0&quot;, &quot;gph-0&quot;;
      samsung,pin-function = &lt;2&gt;;   /* 在GPHCON寄存器中gph0,gph1可以设置以下值:
                                      0 --- 输入功能
                                      1 --- 输出功能
                                      2 --- 串口功能
                                      我们要使用串口功能,  
                                      samsung,pin-function 设置为2
                                      */
  };</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>一般来说一个设备节点引用pin group时才有可能涉及到<code>State</code>：</p>
<ul>
<li><code>pinctrl-names</code>属性：定义各种<code>State</code>，可以多个一起使用</li>
</ul>
</li>
<li><p><code>pinctrl-x</code>属性：每个<code>State</code>都需要一个对应的<code>pinctrl-x</code>属性指定使用哪一个或多个group节点</p>
</li>
<li><p>设备树中若指定了pinctrl节点，在对应的probe函数被调用之前，内核会先”bind pins”, 即先绑定、设置引脚</p>
<ul>
<li><p>会优先设置”init”状态的引脚</p>
<ul>
<li>如果没有”init”状态, 则设置”default”状态的引脚</li>
</ul>
<p>eg：</p>
<pre><code>serial@50000000 {
......
  pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;  /* 既是名字, 也称为state(状态) */
  pinctrl-0 = &lt;&amp;uart0_data&gt;;
pinctrl-1 = &lt;&amp;uart0_sleep&gt;;
};</code></pre></li>
<li><p>pinctrl-names中定义了2种state: default 和 sleep</p>
<ul>
<li>default 对应的引脚是: pinctrl-0, 它指定了使用哪些pin group: uart0_data</li>
<li>sleep   对应的引脚是: pinctrl-1, 它指定了使用哪些pin group: uart0_sleep</li>
</ul>
</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达。邮件：1125934312@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>设备树</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">8.7k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="NU-LL">NU-LL</a></p>
    <p><span class="copy-title">发布时间:</span>2019-10-13, 15:53:24</p>
    <p><span class="copy-title">最后更新:</span>2020-04-07, 22:47:18</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/10/13/设备树/" title="设备树">http://NU-LL.github.io/2019/10/13/设备树/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 NU-LL</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="/js/script.js?v=1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#DM9000C','#网卡移植','#GO','#Docker','#ESP32','#ESP8266','#Kconfig语法','#IIC驱动','#Latex','#Ctex','#LiCheePi Zero','#Linux服务','#Linux内核','#文件描述符','#Markdown','#Mininet','#数据分析','#NanoPi Neo Core','#字符驱动','#TensorFlow2','#SVM','#Xmanager','#远程链接','#git','#network namespace','#Kubernetes','#等待队列','#wait_queue_head_t','#wait_queue_t','#markdownlint','#python实战','#u-boot','#python','#爬虫','#二维数组','#指针','#存储器','#IAP','#BootLoader','#dual bank','#快速排序','#按键驱动','#poll机制','#异步通知机制','#根文件系统','#网卡驱动框架','#虚拟网卡','#设备树','#输入子系统','#Go语言入门经典','#驱动API','#深度学习','#廖雪峰python教程',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    

    
</style>







</html>
