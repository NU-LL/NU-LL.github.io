<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go语言 | spaceman</title><meta name="description" content="GO语言 该笔记是本人学习《Go语言入门经典》和所记录的，便于以后查阅  零、前言 go中的编码统一为utf-8，其中ascii的字符占一字节，汉字占三字节 GO语言中导入的包或声明的变量 若没有使用则会报错 12&#x2F;&#x2F;格式化源码gofmt -w main.go 格式： 123456789&#x2F;&#x2F;正确：main&amp;#123;&amp;#125;&#x2F;&#x2F;错误：main&amp;#123;&amp;#125; 标识符相关：  下划线“"><meta name="keywords" content="Go语言入门经典"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2019/10/23/Go%E8%AF%AD%E8%A8%80/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go语言"><meta property="og:url" content="http://nu-ll.github.io/2019/10/23/Go%E8%AF%AD%E8%A8%80/"><meta property="og:site_name" content="spaceman"><meta property="og:description" content="GO语言 该笔记是本人学习《Go语言入门经典》和所记录的，便于以后查阅  零、前言 go中的编码统一为utf-8，其中ascii的字符占一字节，汉字占三字节 GO语言中导入的包或声明的变量 若没有使用则会报错 12&#x2F;&#x2F;格式化源码gofmt -w main.go 格式： 123456789&#x2F;&#x2F;正确：main&amp;#123;&amp;#125;&#x2F;&#x2F;错误：main&amp;#123;&amp;#125; 标识符相关：  下划线“"><meta property="og:image" content="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg"><meta property="article:published_time" content="2019-10-23T13:07:25.000Z"><meta property="article:modified_time" content="2020-07-17T14:46:00.653Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '2'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.1',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-07-17 22:46:00'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">53</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">62</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go语言"><span class="toc-text"> GO语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#零-前言"><span class="toc-text"> 零、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一-类型1-4基本-5-end派生"><span class="toc-text"> 一、类型（1-4基本 5-end派生）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1布尔"><span class="toc-text"> 1.布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2整数"><span class="toc-text"> 2.整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3浮点数"><span class="toc-text"> 3.浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4字符串"><span class="toc-text"> 4.字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45基本数据类型的转换"><span class="toc-text"> 4.5基本数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5数组"><span class="toc-text"> 5.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51切片slice"><span class="toc-text"> 5.1切片slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52string和slice"><span class="toc-text"> 5.2string和slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53多维数组二维数组"><span class="toc-text"> 5.3多维数组（二维数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54映射map"><span class="toc-text"> 5.4映射map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55map切片及排序"><span class="toc-text"> 5.5map切片及排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6检测变量类型"><span class="toc-text"> 6.检测变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7类型转换"><span class="toc-text"> 7.类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-变量"><span class="toc-text"> 二、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1快捷声明"><span class="toc-text"> 1.快捷声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2简短声明"><span class="toc-text"> 2.简短声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3省略变量名声明"><span class="toc-text"> 3.省略变量名声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4指针"><span class="toc-text"> 4.指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5常量"><span class="toc-text"> 5.常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-函数和包"><span class="toc-text"> 三、函数和包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1基本格式"><span class="toc-text"> 1.基本格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2不定参数函数"><span class="toc-text"> 2.不定参数函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3具名返回值"><span class="toc-text"> 3.具名返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4init函数"><span class="toc-text"> 4.init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5匿名函数"><span class="toc-text"> 5.匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6内置函数"><span class="toc-text"> 6.内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7包"><span class="toc-text"> 7.包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7闭包"><span class="toc-text"> 7.闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-控制流程"><span class="toc-text"> 四、控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1if"><span class="toc-text"> 1.if</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11运算符"><span class="toc-text"> 1.1运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#111比较"><span class="toc-text"> 1.1.1比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#112算术"><span class="toc-text"> 1.1.2算术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#113逻辑"><span class="toc-text"> 1.1.3逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2switch"><span class="toc-text"> 2.switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3for"><span class="toc-text"> 3.for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4defer"><span class="toc-text"> 4.defer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-结构体和指针"><span class="toc-text"> 五、结构体和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1结构体"><span class="toc-text"> 1.结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11声明"><span class="toc-text"> 1.1声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12自定义结构体字段的默认值"><span class="toc-text"> 1.2自定义结构体字段的默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13结构体比较"><span class="toc-text"> 1.3结构体比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14结构体注意事项"><span class="toc-text"> 1.4结构体注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2指针"><span class="toc-text"> 2.指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-方法和接口"><span class="toc-text"> 六、方法和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1方法"><span class="toc-text"> 1.方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2接口详见十一章"><span class="toc-text"> 2.接口（详见十一章）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-字符串"><span class="toc-text"> 七、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1字面量"><span class="toc-text"> 1.字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2rune字面量"><span class="toc-text"> 2.rune字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3拼接字符串"><span class="toc-text"> 3.拼接字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4strings包处理字符串"><span class="toc-text"> 4.strings包处理字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5常用系统函数"><span class="toc-text"> 5.常用系统函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-处理错误"><span class="toc-text"> 八、处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1错误的处理机制"><span class="toc-text"> 1.错误的处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2自定义错误"><span class="toc-text"> 2.自定义错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11创建错误"><span class="toc-text"> 1.1创建错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-panic内置函数"><span class="toc-text"> 1.2 panic内置函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-goroutine协程"><span class="toc-text"> 九、Goroutine协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1多个协程之间的通信"><span class="toc-text"> 1.多个协程之间的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-channel通道"><span class="toc-text"> 十、channel通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine协程channel管道"><span class="toc-text"> Goroutine协程＋channel管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一-面向对象编程"><span class="toc-text"> 十一、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1构造函数工厂模式间接实现"><span class="toc-text"> 1.构造函数（工厂模式间接实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2封装"><span class="toc-text"> 2.封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3继承"><span class="toc-text"> 3.继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4接口"><span class="toc-text"> 4.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口和继承的关系"><span class="toc-text"> 接口和继承的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5多态"><span class="toc-text"> 5.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型断言"><span class="toc-text"> 类型断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二-文件操作"><span class="toc-text"> 十二、文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打开文件"><span class="toc-text"> 打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭文件"><span class="toc-text"> 关闭文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取文件"><span class="toc-text"> 读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写文件"><span class="toc-text"> 写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断文件是否存在"><span class="toc-text"> 判断文件是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件拷贝"><span class="toc-text"> 文件拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行参数"><span class="toc-text"> 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-text"> JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化"><span class="toc-text"> 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反序列化"><span class="toc-text"> 反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三-单元测试"><span class="toc-text"> 十三、单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-反射"><span class="toc-text"> 十四、反射</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">spaceman</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go语言</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-23T13:07:25.000Z" title="发表于 2019-10-23 21:07:25">2019-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-17T14:46:00.653Z" title="更新于 2020-07-17 22:46:00">2020-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="go语言"><a class="markdownIt-Anchor" href="#go语言"></a> GO语言</h1>
<p>该笔记是本人学习《Go语言入门经典》和所记录的，便于以后查阅</p>
<h2 id="零-前言"><a class="markdownIt-Anchor" href="#零-前言"></a> 零、前言</h2>
<p>go中的编码统一为utf-8，其中ascii的字符占一字节，汉字占三字节</p>
<p>GO语言中导入的包或声明的变量 若没有使用则会报错</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式化源码</span></span><br><span class="line">gofmt -w main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：</span></span><br><span class="line">main&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误：</span></span><br><span class="line">main</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标识符相关：</p>
<ul>
<li>下划线“_”本身在Go中是一个特殊的标识符,称为空标识符。可以代表任何其它的标识符,但是它对应的值会被忽略(比如:忽略某个返回值)。所以<strong>仅能被作为占位符使用</strong>,不能作为标识符使用</li>
<li>保留关键字（注意int、float32等均没有在这里边，不能使用这些作为命名）：<img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200102110401101.png" alt="保留关键字"></li>
<li>预定义标识符：<img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200102111410250.png" alt="预定义标识符"></li>
<li>尽量保持：包名和该文件所在目录的名字保持一致</li>
<li>首字母大写共有的，首字母小写是私有的（没有public、private等关键字）</li>
</ul>
<p>运算符相关：</p>
<ul>
<li>%运算的本质：$ a%b=a-a/b*b $</li>
<li>自增自减只能独立使用，不能和别的语句组合使用，有且仅有<code>i++</code>和<code>i--</code></li>
<li>没有三目运算符</li>
<li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>！</code></li>
<li>位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code></li>
<li>优先级：<img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200102123004830.png" alt="优先级">
<ul>
<li>只有单目运算符、赋值运算符是从右往左运算</li>
</ul>
</li>
</ul>
<p>Printf相关：</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式化字符串</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">整形</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点型</td>
</tr>
<tr>
<td style="text-align:center">%T</td>
<td style="text-align:center">输出对应类型</td>
</tr>
<tr>
<td style="text-align:center">%v</td>
<td style="text-align:center">自动匹配输出</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">输出字符型（按asc码输出）</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:center">布尔类型</td>
</tr>
</tbody>
</table>
<h2 id="一-类型1-4基本-5-end派生"><a class="markdownIt-Anchor" href="#一-类型1-4基本-5-end派生"></a> 一、类型（1-4基本 5-end派生）</h2>
<ul>
<li><strong>值类型</strong>：基本数据类型，int、float、bool、数组、结构体struct</li>
<li>变量直接存储，通常在<strong>栈</strong>中分配</li>
<li><strong>引用类型</strong>：指针、slice切片、map、管道chan、interface
<ul>
<li>变量存储的是一个地址，这个地址对应的空间才是真正的存储数据（值），内存通常在堆上分配</li>
<li>当没有任何变量应引用这个地址时，改地址对应的数据空间就成为一个垃圾，由GC来回收</li>
</ul>
</li>
</ul>
<h3 id="1布尔"><a class="markdownIt-Anchor" href="#1布尔"></a> 1.布尔</h3>
<ul>
<li>true</li>
<li>false（默认值）</li>
<li>占用一个字节</li>
</ul>
<p>注：Go不能用 1 和 0 代表 true 和 false，未赋值变量默认为false</p>
<p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h3 id="2整数"><a class="markdownIt-Anchor" href="#2整数"></a> 2.整数</h3>
<ul>
<li>默认值为0</li>
</ul>
<p>声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="3浮点数"><a class="markdownIt-Anchor" href="#3浮点数"></a> 3.浮点数</h3>
<ul>
<li>float32：32位</li>
<li>float64：64位</li>
<li>默认值为0（float64）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num1 := <span class="number">.123</span></span><br><span class="line">num2 := <span class="number">5.12e2</span><span class="comment">//512</span></span><br></pre></td></tr></table></figure>
<h3 id="4字符串"><a class="markdownIt-Anchor" href="#4字符串"></a> 4.字符串</h3>
<ul>
<li>默认值为&quot;&quot;</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> =<span class="string">""</span><span class="comment">//双引号</span></span><br><span class="line">s += <span class="string">"foo"</span></span><br><span class="line"><span class="comment">//反引号</span></span><br><span class="line">s := <span class="string">`</span></span><br><span class="line"><span class="string">asdfaf</span></span><br><span class="line"><span class="string">asdf</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不能对字符串执行数学运算</li>
<li>字符串是不可变的（不能修改）</li>
<li>可以通过‘+’拼接字符串，过长时能够换行（必须以‘+’号结尾）</li>
<li>println直接输出byte时输出的是ASCII<strong>码值</strong></li>
</ul>
<h3 id="45基本数据类型的转换"><a class="markdownIt-Anchor" href="#45基本数据类型的转换"></a> 4.5基本数据类型的转换</h3>
<ul>
<li>不能自动转换，必须显式转换</li>
<li>表达式：<code>T(V)</code>，表示将值V转化为类型T</li>
<li>基本数据类型转成string
<ul>
<li>fmt.Sprintf</li>
<li>strconv包函数
<ul>
<li>func FormatBool(b bool) string</li>
<li>func Itoa(i int) string</li>
<li>func FormatInt(i int64, base int) string</li>
<li>func FormatUint(i uint64, base int) string</li>
<li>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</li>
</ul>
</li>
</ul>
</li>
<li>string转成基本数据类型
<ul>
<li>strconv包函数
<ul>
<li>func ParseBool(str string)(value bool, err error)</li>
<li>func ParseFloat(s string. bitSize int)(f float64, err error)</li>
<li>func ParseInt(s string, base int, bitSize int)(i int64, err error)</li>
<li>func ParseUint(s string, b int, bitSize int)(n uint64, err error)</li>
</ul>
</li>
<li>失败时，转换的结果为对应类型的默认值</li>
</ul>
</li>
</ul>
<h3 id="5数组"><a class="markdownIt-Anchor" href="#5数组"></a> 5.数组</h3>
<ul>
<li>声明后元素固定，不能增加删除</li>
<li>值类型</li>
<li>数组的地址为<code>&amp;数组名</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var 数组名 [数组大小]数组类型</span></span><br><span class="line"><span class="keyword">var</span> beatles [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line">beatles[<span class="number">0</span>] = <span class="string">"John"</span></span><br><span class="line">beatles[<span class="number">1</span>] = <span class="string">"Paul"</span></span><br><span class="line">beatles[<span class="number">2</span>] = <span class="string">"Ringo"</span></span><br><span class="line">beatles[<span class="number">3</span>] = <span class="string">"George"</span></span><br><span class="line">fmt.Println(beatles)<span class="comment">//按顺序打印数组所有元素</span></span><br><span class="line"><span class="comment">//其他初始化方式：</span></span><br><span class="line"><span class="keyword">var</span> beatles [<span class="number">4</span>]<span class="keyword">string</span> = [<span class="number">4</span>]<span class="keyword">string</span>&#123;<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"Ringo"</span>,<span class="string">"George"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beatles = [<span class="number">4</span>]<span class="keyword">string</span>&#123;<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"Ringo"</span>,<span class="string">"George"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beatles = [...]<span class="keyword">string</span>&#123;<span class="string">"John"</span>,<span class="string">"Paul"</span>,<span class="string">"Ringo"</span>,<span class="string">"George"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beatles = [...]<span class="keyword">string</span>&#123;<span class="number">0</span>:<span class="string">"John"</span>,<span class="number">1</span>:<span class="string">"Paul"</span>,<span class="number">3</span>:<span class="string">"George"</span>,<span class="number">2</span>:<span class="string">"Ringo"</span>&#125;</span><br><span class="line">beatles = [...]<span class="keyword">string</span>&#123;<span class="number">0</span>:<span class="string">"John"</span>,<span class="number">1</span>:<span class="string">"Paul"</span>,<span class="number">3</span>:<span class="string">"George"</span>,<span class="number">2</span>:<span class="string">"Ringo"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<ul>
<li>
<p>常规遍历</p>
</li>
<li>
<p>for-range结构遍历</p>
<p>基本语法：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> array01 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>index：数组下标</li>
<li>value：该下标对应的值</li>
<li>他们都是仅在for循环内部可见的局部变量</li>
<li>遍历数组元素的时候,如果不想使用下标 index,可以直接把下标 index标为下划线 _</li>
<li>index,value不是固定的</li>
</ul>
</li>
</ul>
<p>注意事项：</p>
<ul>
<li>数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化</li>
<li>var arr []int这时arr就是一个slice切片</li>
<li>数组中的元素可以是任何数据类型,包括值类型和引用类型,但是<strong>不能混用</strong></li>
<li>数组创建后,如果没有赋值,有默认值
<ul>
<li>数值类型数组：默认值为0</li>
<li>字符串数组：默认值为&quot;&quot;</li>
<li>bool数组：默认值为 false</li>
</ul>
</li>
<li>使用数组的步骤
<ul>
<li>1.声明数组并开辟空间</li>
<li>2给数组各个元素赋值</li>
<li>3使用数组</li>
</ul>
</li>
<li>数组的下标是从0开始的</li>
<li>数组下标必须在指定范围内使用,否则报 panic:数组越界</li>
<li>Go的数组属值类型,在默认情况下是值传递,因此会进行值拷贝。数组间不会相互影响</li>
<li>如想在其它函数中,去修改原来的数组,可以使用引用传递（指针方式）</li>
<li>长度是数组类型的一部分,在传递函数参数时需要考虑数组的长度</li>
</ul>
<h4 id="51切片slice"><a class="markdownIt-Anchor" href="#51切片slice"></a> 5.1切片slice</h4>
<p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 切片名 [] 类型</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>切片是数组的一个引用,因此切片是<strong>引用类型</strong>,在进行传递时,遵守引用传递机制。</p>
<ul>
<li>
<p>通过slice改变值后原始数据也会改变</p>
</li>
<li>
<p>slice作为形参时，在函数内部改变slice中的值也会改变元素数据中的值</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    slice[<span class="number">0</span>] = <span class="number">100</span>  <span class="comment">//这里修改slice[0],会改变实参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slice = []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"slice="</span>, slice) <span class="comment">// [1,2,3,4]</span></span><br><span class="line">    test(slice)</span><br><span class="line">    fmt.Println(<span class="string">"slice="</span>, slice) <span class="comment">// [100, 2, 3, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>切片的使用和数组类似,遍历切片、访问切片的元素和求切片长度len(slice)都一样</p>
</li>
<li>
<p>切片的长度是可以变化的,因此切片是一个可以动态变化的数组</p>
</li>
</ul>
<hr>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">99</span>&#125;</span><br><span class="line"><span class="comment">//声明/定义一个切片</span></span><br><span class="line"><span class="comment">//slice := intArr[1:3]</span></span><br><span class="line"><span class="comment">//1. slice 就是切片名</span></span><br><span class="line"><span class="comment">//2. intArr[1:3] 表示 slice 引用到intArr这个数组</span></span><br><span class="line"><span class="comment">//3. 引用intArr数组的起始下标为 1 , 最后的下标为3(但是不包含3)</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"intArr="</span>, intArr)</span><br><span class="line">fmt.Println(<span class="string">"slice 的元素是 ="</span>, slice) <span class="comment">//  22, 33</span></span><br><span class="line">fmt.Println(<span class="string">"slice 的元素个数 ="</span>, <span class="built_in">len</span>(slice)) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(<span class="string">"slice 的容量 ="</span>, <span class="built_in">cap</span>(slice)) <span class="comment">// 切片的容量是可以动态变化</span></span><br></pre></td></tr></table></figure>
<p>slice从底层来说,其实就是一个数据结构(struct结构体)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述例子中的slice的结构可以视为：</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr *[<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以可以通过slice来更改原始数据。</p>
<p>上述例子的具体内存模型：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200103220708761.png" alt="slice的内存模型"></p>
<hr>
<p>切片的<strong>使用</strong>：</p>
<ul>
<li>
<p>定义一个切片,然后让切片去引用一个已经创建好的数组,如上述例子</p>
<ul>
<li>初始化：var slice = arr[startIndex:endIndex]
<ul>
<li>从arr中的startIndex取到endIndex（不包含endIndex）：[startIndex,endIndex)</li>
<li>切片初始化时,仍然不能越界。范围在[0-len(arr)]之间,但是可以动态增长</li>
<li>var slice = arr[0:end] ==&gt; var slice = arr[:end]</li>
<li>var slice = arr[start:len(arr)] ==&gt; var slice = arr[start:]</li>
<li>var slice = arr[0:len(arr)] ==&gt; var slice = arr[:]</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过内置函数make创建切片</p>
<ul>
<li>语法：<code>var 切片名 []type = make([],len,[cap])</code>
<ul>
<li>type：数据类型</li>
<li>len：大小</li>
<li>cap：指定切片容量，可选</li>
</ul>
</li>
<li>如果没有给切片的各个元素赋值,那么就会使用默认值</li>
<li>通过make方式创建的切片对应的数组是由make底层维护,对外不可见,即只能通过slice去访问各个元素</li>
</ul>
</li>
<li>
<p>定义一个切片,直接就指定具体数组,使用原理类似make的方式</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;<span class="string">"tom"</span>, <span class="string">"jack"</span>, <span class="string">"mary"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"strSlice="</span>, strSlice)</span><br><span class="line">fmt.Println(<span class="string">"strSlice size="</span>, <span class="built_in">len</span>(strSlice)) <span class="comment">//3</span></span><br><span class="line">fmt.Println(<span class="string">"strSlice cap="</span>, <span class="built_in">cap</span>(strSlice)) <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述方式1和2的区别：</p>
<ul>
<li>方式1是直接引用数组,这个数组是事先存在的,程序员是可见的</li>
<li>方式2是通过mak来创建切片,make会创建一个数组,是由切片在底层进行维护,程序员是看不见的。</li>
</ul>
<p>切片的<strong>遍历</strong>：</p>
<ul>
<li>for循环常规遍历</li>
<li>for-range结构遍历</li>
</ul>
<p>注意事项：</p>
<ul>
<li>
<p><code>cap</code>是一个内置函数,用于统计切片的容量,即最大可以存放多少个元素</p>
</li>
<li>
<p>切片定义完后,还不能使用,因为本身是一个空的,需要让其引用到一个数组或者make一个空间供切片来使用</p>
</li>
<li>
<p>切片可以继续切片(此时可以不用考虑切片底层的数据结构，即是在切完之后的切片上继续再切，但是所有的这些都是操作的同一片内存空间)</p>
</li>
<li>
<p>使用内置不定参函数<code>append</code>，可以对切片进行动态追加，append会调整切片的长度</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice3 []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;</span><br><span class="line"><span class="comment">//通过append直接给slice3追加具体的元素</span></span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>)</span><br><span class="line">fmt.Println(<span class="string">"slice3"</span>, slice3) <span class="comment">//100, 200, 300,400, 500, 600</span></span><br><span class="line"><span class="comment">//通过append将切片slice3追加给slice3</span></span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, slice3...) <span class="comment">// 100, 200, 300,400, 500, 600 100, 200, 300,400, 500, 600</span></span><br><span class="line">fmt.Println(<span class="string">"slice3"</span>, slice3)</span><br></pre></td></tr></table></figure>
<ul>
<li>切片 append操作的本质就是对数组扩容</li>
<li>go底层会创建一下新的数组 newArr(安装扩容后大小)</li>
<li>将slice原来包含的元素拷贝到新的数组 newArr</li>
<li>slice重新引用到 newArr</li>
<li>注意 newArr是在底层来维护的,程序员不可见</li>
</ul>
</li>
<li>
<p>使用内置函数<code>copy</code>复制切片中的元素，复制前需声明一个和目标切片类型一致的切片（切片长度没要求，按照小的算）</p>
<ul>
<li>
<p>copy(para1,para2)：para1和para2均为切片类型，从para2拷贝至para1</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice4 []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice5 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice5, slice4)</span><br><span class="line">fmt.Println(<span class="string">"slice4="</span>, slice4)<span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">fmt.Println(<span class="string">"slice5="</span>, slice5) <span class="comment">// 1, 2, 3, 4, 5, 0 , 0 ,0,0,0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>copy会创建一个新的副本</p>
</li>
</ul>
</li>
<li>
<p>使用内置不定参函数<code>append</code>删除元素，append会调整切片的长度，元素的排列顺序不会发生变化</p>
<ul>
<li>注意append删除最后的<code>...</code></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//make(数据类型,长度)</span></span><br><span class="line"><span class="keyword">var</span> cheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line">cheeses[<span class="number">0</span>] = <span class="string">"hello"</span></span><br><span class="line">cheeses[<span class="number">1</span>] = <span class="string">"world"</span></span><br><span class="line">cheeses := <span class="built_in">append</span>(cheeses,<span class="string">"hi"</span>)<span class="comment">//创建新的元素，索引为2</span></span><br><span class="line">cheeses := <span class="built_in">append</span>(cheeses,<span class="string">"hi1"</span>,<span class="string">"hi2"</span>,<span class="string">"hi3"</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(cheeses))<span class="comment">//打印长度</span></span><br><span class="line">cheeses := <span class="built_in">append</span>(cheeses[:<span class="number">2</span>],cheeses[<span class="number">2</span>+<span class="number">1</span>:]...)<span class="comment">//删除索引为2的元素</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(cheeses))<span class="comment">//打印长度</span></span><br><span class="line"><span class="comment">//开始复制</span></span><br><span class="line"><span class="keyword">var</span> smellyCheeses = <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">copy</span>(smellyCheeses,cheeses)</span><br></pre></td></tr></table></figure>
<h4 id="52string和slice"><a class="markdownIt-Anchor" href="#52string和slice"></a> 5.2string和slice</h4>
<ul>
<li>
<p>string底层是一个byte数组,因此 string也可以进行切片处理</p>
</li>
<li>
<p>string和切片在内存的形式,以&quot;abcd&quot;画出内存示意图<img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200104225130095.png" alt="内存示意图"></p>
</li>
<li>
<p>string是不可变的,也就说<strong>不能</strong>通过str[0]=‘z’方式来修改字符串</p>
</li>
<li>
<p>如果需要修改出字符串,可以先将 string -&gt; []byte或者[]rune-&gt;修改-&gt;重写转成string.</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello@atguigu"</span></span><br><span class="line"><span class="comment">//"hello@atguigu" =&gt;改成 "zello@atguigu"</span></span><br><span class="line">arr1 := []<span class="keyword">byte</span>(str)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">'z'</span></span><br><span class="line">str = <span class="keyword">string</span>(arr1)</span><br><span class="line">fmt.Println(<span class="string">"str="</span>, str)</span><br><span class="line"><span class="comment">// 细节，我们转成[]byte后，可以处理英文和数字，但是不能处理中文</span></span><br><span class="line"><span class="comment">// 原因是 []byte 字节来处理 ，而一个汉字，是3个字节，因此就会出现乱码</span></span><br><span class="line"><span class="comment">// 解决方法是 将  string 转成 []rune 即可， 因为 []rune是按字符处理，兼容汉字</span></span><br><span class="line">arr1 := []<span class="keyword">rune</span>(str)</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="string">'北'</span></span><br><span class="line">str = <span class="keyword">string</span>(arr1)</span><br><span class="line">fmt.Println(<span class="string">"str="</span>, str)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="53多维数组二维数组"><a class="markdownIt-Anchor" href="#53多维数组二维数组"></a> 5.3多维数组（二维数组）</h4>
<p>使用：</p>
<ul>
<li>
<p>先声明在赋值</p>
<ul>
<li>
<p>语法：var 数组名 [大小][大小]类型</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">0 2 0 3 0 0</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义/声明二维数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>][<span class="number">6</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//赋初值</span></span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(arr)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>直接初始化</p>
<ul>
<li>
<p>语法：var 数组名 [大小][大小]类型 = [大小][大小]类型{ {初值},{初值…} }</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr3 [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;</span></span><br><span class="line">arr3  := [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="string">"arr3="</span>, arr3)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>其他几种写法（类似一维数组）</p>
<ul>
<li>var 数组名 [大小][大小]类型 = [大小][大小]类型{ {初值},{初值…} }</li>
<li>var 数组名 [大小][大小]类型 = […][大小]类型{ {初值},{初值…} }</li>
<li>var 数组名 = [大小][大小]类型{ {初值},{初值…} }</li>
<li>var 数组名 = […][大小]类型{ {初值},{初值…} }</li>
</ul>
</li>
</ul>
<p>内存布局：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span> <span class="comment">//以这个为例来分析arr2在内存的布局!!</span></span><br><span class="line">arr2[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">fmt.Println(arr2)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"arr2[0]的地址%p\n"</span>, &amp;arr2[<span class="number">0</span>])<span class="comment">//第一行首地址</span></span><br><span class="line">fmt.Printf(<span class="string">"arr2[1]的地址%p\n"</span>, &amp;arr2[<span class="number">1</span>])<span class="comment">//第二行首地址</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"arr2[0][0]的地址%p\n"</span>, &amp;arr2[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"arr2[1][0]的地址%p\n"</span>, &amp;arr2[<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200105113017051.png" alt="二维数组内存布局示意图"></p>
<p>遍历：</p>
<ul>
<li>
<p>双层for循环</p>
</li>
<li>
<p>for-range方式遍历</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3  = [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr3 &#123;<span class="comment">//遍历行</span></span><br><span class="line">    <span class="keyword">for</span> j, v2 := <span class="keyword">range</span> v &#123;<span class="comment">//遍历行中的元素</span></span><br><span class="line">        fmt.Printf(<span class="string">"arr3[%v][%v]=%v \t"</span>,i, j, v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="54映射map"><a class="markdownIt-Anchor" href="#54映射map"></a> 5.4映射map</h4>
<p>map是 key-value数据结构,又称为字段或者关联数组。类似其它编程语言的集合,在编程中是经常使用到。</p>
<p>map是一个无序的结构，不会按照keytype或者valuetype进行排序</p>
<p>可以通过内置函数<code>len</code>获取map的长度</p>
<p>语法：<code>var 变量名 map[keytype]valuetype</code></p>
<ul>
<li>keytype：可以是很多种类型,比如bool,数字, string,指针, channel,还可以是只包含前面几个类型的接口,结构体,数组（keytype通常为int、 string）
<ul>
<li>注意:slice,map还有 function不可以,因为这几个没法用==来判断</li>
</ul>
</li>
<li>valuetype：类型和keytype基本一致（valuetype通常为数字（整数、浮点）、string、map、struct）</li>
</ul>
<p>声明：</p>
<ul>
<li>var a map[string]string</li>
<li>var a map[string]int</li>
<li>var a map[int]string</li>
<li>var a map[string]map[string]string</li>
<li>声明<strong>不会分配内存</strong>，初始化需要<strong>make</strong>，分配内存后才能赋值和使用
<ul>
<li>make(数据类型，大小)</li>
<li>a = make(map[string]string, 10)</li>
</ul>
</li>
</ul>
<p>使用方式：</p>
<ul>
<li>
<p>先声明再make</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//在使用map前，需要先make , make的作用就是给map分配数据空间</span></span><br><span class="line">a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明的同时make</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cities := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">cities[<span class="string">"no1"</span>] = <span class="string">"北京"</span></span><br><span class="line">cities[<span class="string">"no2"</span>] = <span class="string">"天津"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明时直接赋值</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heroes := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"hero1"</span> : <span class="string">"宋江"</span>,</span><br><span class="line">    <span class="string">"hero2"</span> : <span class="string">"卢俊义"</span>,</span><br><span class="line">    <span class="string">"hero3"</span> : <span class="string">"吴用"</span>,</span><br><span class="line">&#125;</span><br><span class="line">heroes[<span class="string">"hero4"</span>] = <span class="string">"林冲"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>增删改查：</p>
<ul>
<li>
<p>增加和更新</p>
<ul>
<li>map[key] = value //如果key还没有,就是增加,如果key存在就是修改</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>内置函数<code>delete</code>：<code>delete(map,&quot;key&quot;)</code>, 如果key存在,就删除该 key-value，如果key不存在，不操作，但是也不会报错</li>
<li>如果要删除所有元素：
<ul>
<li>遍历后一一delete</li>
<li>map = make()，make一个新的，让原来的成为垃圾，被gc回收</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查找</p>
<ul>
<li>
<p>直接找</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val, ok := cities[<span class="string">"no2"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"有no1 key 值为%v\n"</span>, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"没有no1 key\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>遍历（只能for-range）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">studentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">studentMap[<span class="string">"stu01"</span>] =  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">studentMap[<span class="string">"stu01"</span>][<span class="string">"name"</span>] = <span class="string">"tom"</span></span><br><span class="line">studentMap[<span class="string">"stu01"</span>][<span class="string">"sex"</span>] = <span class="string">"男"</span></span><br><span class="line">studentMap[<span class="string">"stu01"</span>][<span class="string">"address"</span>] = <span class="string">"北京长安街~"</span></span><br><span class="line"></span><br><span class="line">studentMap[<span class="string">"stu02"</span>] =  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>) <span class="comment">//这句话不能少!!</span></span><br><span class="line">studentMap[<span class="string">"stu02"</span>][<span class="string">"name"</span>] = <span class="string">"mary"</span></span><br><span class="line">studentMap[<span class="string">"stu02"</span>][<span class="string">"sex"</span>] = <span class="string">"女"</span></span><br><span class="line">studentMap[<span class="string">"stu02"</span>][<span class="string">"address"</span>] = <span class="string">"上海黄浦江~"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k1, v1 := <span class="keyword">range</span> studentMap &#123;</span><br><span class="line">    fmt.Println(<span class="string">"k1="</span>, k1)<span class="comment">//k1= stu01</span></span><br><span class="line">    <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"\t k2=%v v2=%v\n"</span>, k2, v2)<span class="comment">//k2=address v2=北京长安街~</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>map是<strong>引用</strong>类型,遵守引用类型传递的机制,在一个函数接收map,修改后,会直接修改原来的map</li>
<li>map的容量达到后,再想map增加元素,会自动扩容（无需借助其他函数，也不用管make中指定的大小）,并不会发生 panic,也就是说map能<strong>动态</strong>的增长键值对( key-value）</li>
<li>map的value也经常使用 <strong>struct类型</strong>,更适合管理复杂的数据(比前面value是一个map更好),比如value为 Student结构体</li>
</ul>
<h4 id="55map切片及排序"><a class="markdownIt-Anchor" href="#55map切片及排序"></a> 5.5map切片及排序</h4>
<p>map切片：</p>
<p>切片的数据类型如果是map,则我们称为 slice of map,map切片,这样使用则map的个数就可以动态变化（利用append）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">2</span>) <span class="comment">//准备放入两个妖怪</span></span><br><span class="line"><span class="comment">//2. 增加第一个妖怪的信息</span></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">    monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"牛魔王"</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"age"</span>] = <span class="string">"500"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">    monsters[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"name"</span>] = <span class="string">"玉兔精"</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"age"</span>] = <span class="string">"400"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个写法越界。</span></span><br><span class="line"><span class="comment">// if monsters[2] == nil &#123;</span></span><br><span class="line"><span class="comment">// 	monsters[2] = make(map[string]string, 2)</span></span><br><span class="line"><span class="comment">// 	monsters[2]["name"] = "狐狸精"</span></span><br><span class="line"><span class="comment">// 	monsters[2]["age"] = "300"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里我们需要使用到切片的append函数，可以动态的增加monster</span></span><br><span class="line"><span class="comment">//1. 先定义个monster信息</span></span><br><span class="line">newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"新的妖怪~火云邪神"</span>,</span><br><span class="line">    <span class="string">"age"</span> : <span class="string">"200"</span>,</span><br><span class="line">&#125;</span><br><span class="line">monsters = <span class="built_in">append</span>(monsters, newMonster)</span><br><span class="line"></span><br><span class="line">fmt.Println(monsters)</span><br></pre></td></tr></table></figure>
<p>map排序：</p>
<ul>
<li>先将map的key 放入到 切片中</li>
<li>对切片排序</li>
<li>遍历切片，然后按照key来输出map的值</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">map1[<span class="number">10</span>] = <span class="number">100</span></span><br><span class="line">map1[<span class="number">1</span>] = <span class="number">13</span></span><br><span class="line">map1[<span class="number">4</span>] = <span class="number">56</span></span><br><span class="line">map1[<span class="number">8</span>] = <span class="number">90</span></span><br><span class="line">fmt.Println(map1)</span><br><span class="line"><span class="comment">//如果按照map的key的顺序进行排序输出</span></span><br><span class="line"><span class="comment">//1. 先将map的key 放入到 切片中</span></span><br><span class="line"><span class="comment">//2. 对切片排序</span></span><br><span class="line"><span class="comment">//3. 遍历切片，然后按照key来输出map的值</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort.Ints(keys)<span class="comment">//需要引入sort包</span></span><br><span class="line">fmt.Println(keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"map1[%v]=%v \n"</span>, k, map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6检测变量类型"><a class="markdownIt-Anchor" href="#6检测变量类型"></a> 6.检测变量类型</h3>
<ul>
<li>依赖<code>reflect</code>包</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"string"</span></span><br><span class="line">reflect.TypeOf(s)</span><br></pre></td></tr></table></figure>
<h3 id="7类型转换"><a class="markdownIt-Anchor" href="#7类型转换"></a> 7.类型转换</h3>
<p>字符串和其他类型互换：</p>
<ul>
<li>依赖<code>strconv</code>包</li>
</ul>
<h2 id="二-变量"><a class="markdownIt-Anchor" href="#二-变量"></a> 二、变量</h2>
<ul>
<li>
<p>使用关键字<code>var</code>声明</p>
</li>
<li>
<p>声明后不能再次声明，但是可以重新赋值</p>
</li>
<li>
<p>变量声明后若未给与指定值将会设为默认值，不同变量类型默认值不一样，这种默认值称为<strong>零值</strong></p>
</li>
</ul>
<h3 id="1快捷声明"><a class="markdownIt-Anchor" href="#1快捷声明"></a> 1.快捷声明</h3>
<p>多个同类型变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s,t <span class="keyword">string</span> = <span class="string">"foo"</span>,<span class="string">"bar"</span></span><br></pre></td></tr></table></figure>
<p>多个<strong>不</strong>同类型变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局</span></span><br><span class="line"><span class="keyword">var</span>&#123;</span><br><span class="line">    s <span class="keyword">string</span> = <span class="string">"foo"</span></span><br><span class="line">    i <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或(函数内部)</span></span><br><span class="line">n1,name,n3 := <span class="number">100</span>,<span class="string">"tom"</span>,<span class="number">80</span></span><br><span class="line"><span class="keyword">var</span> n1,name,n3 := <span class="number">100</span>,<span class="string">"tom"</span>,<span class="number">80</span></span><br></pre></td></tr></table></figure>
<h3 id="2简短声明"><a class="markdownIt-Anchor" href="#2简短声明"></a> 2.简短声明</h3>
<ul>
<li>编译器会自动推断变量类型</li>
<li>只能在<strong>函数</strong>中使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello World"</span></span><br></pre></td></tr></table></figure>
<h3 id="3省略变量名声明"><a class="markdownIt-Anchor" href="#3省略变量名声明"></a> 3.省略变量名声明</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"hello World"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一般来说在函数内使用简短声明，在函数外省略变量名声明</li>
</ul>
<h3 id="4指针"><a class="markdownIt-Anchor" href="#4指针"></a> 4.指针</h3>
<ul>
<li>&amp;：取地址</li>
<li>*变量名：指针，eg：*int：int类型指针</li>
<li>*指针：取指针中的值</li>
<li>详见第五章</li>
</ul>
<h3 id="5常量"><a class="markdownIt-Anchor" href="#5常量"></a> 5.常量</h3>
<ul>
<li>可以引用，但是不能修改</li>
<li>关键字<code>const</code>修饰</li>
<li>定义时就必须初始化</li>
<li>常量只能修饰bool、数字类型（int、float）、string类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str <span class="keyword">string</span> = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简洁的写法：</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//专业的写法：</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="literal">iota</span><span class="comment">//a = 0</span></span><br><span class="line">    b<span class="comment">//在上述基础上+1 b=1</span></span><br><span class="line">    c<span class="comment">//在上述基础上+1 c=2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>golang中没有常量名必须字母大写的规定</li>
<li>仍然通过首字母的大小写来控制常量的访问范围</li>
</ul>
<h2 id="三-函数和包"><a class="markdownIt-Anchor" href="#三-函数和包"></a> 三、函数和包</h2>
<h3 id="1基本格式"><a class="markdownIt-Anchor" href="#1基本格式"></a> 1.基本格式</h3>
<ul>
<li>关键字<code>func</code>修饰</li>
<li>函数签名：函数的第一行，即<code>func 函数名(变量类型1 参数1,变量类型2 参数2,...) 返回值类型</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数1 变量类型1,参数2 变量类型2,...)</span> <span class="params">(返回值类型)</span></span> &#123;</span><br><span class="line">	函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg：</p>
<p>多个返回值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//输入为空，返回一个int一个string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPrice</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    i := <span class="number">2</span></span><br><span class="line">    s := <span class="string">"goldfish"</span></span><br><span class="line">    <span class="keyword">return</span> i,s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    quantity,prize := getPrice()</span><br><span class="line">	fmt.Println(<span class="string">"You won %v %v\n"</span>,quantity,prize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>基本数据类型和<strong>数组</strong>都是<strong>值传递</strong>，在函数内修改不会影响到原来的值</li>
<li>如果希望函数内的变量能修改函数外的变量,可以传入变量的地址&amp;,函数内以指针的方式操作变量。从效果上看类似引用</li>
<li>不支持传统的函数重载</li>
<li>函数本身也是一种数据类型，可以作为形参并且调用</li>
<li>go支持自定义数据类型
<ul>
<li>语法：<code>type 自定义数据类型名 数据类型</code></li>
</ul>
</li>
<li>支持函数返回值命名</li>
<li>使用<code>_</code><strong>标识符</strong>，忽略返回值</li>
<li>支持可变参数
<ul>
<li>args是slice切片,通过args[index]可以访间到各个值。</li>
<li>可变参数需要放在形参列表的最后一个</li>
</ul>
</li>
</ul>
<h3 id="2不定参数函数"><a class="markdownIt-Anchor" href="#2不定参数函数"></a> 2.不定参数函数</h3>
<ul>
<li>使用<code>...</code>指定不定参</li>
</ul>
<p>eg：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//numbers为一个包含所有参数的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(numbers... <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> _,number := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := sumNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3具名返回值"><a class="markdownIt-Anchor" href="#3具名返回值"></a> 3.具名返回值</h3>
<ul>
<li>函数返回前将赋值给具名变量</li>
<li>无需显示的返回相应的变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span> <span class="params">(x,y <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    x := <span class="string">"hello"</span></span><br><span class="line">    y := <span class="string">"world"</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4init函数"><a class="markdownIt-Anchor" href="#4init函数"></a> 4.init函数</h3>
<p>每一个源文件都可以包含一个init函数,该函数会在main函数执行前,被Go运行框架调用,也就是说init会在main函数前被调用。</p>
<p>注意事项：</p>
<ul>
<li>如果一个文件同时包含全局变量定义,init函数和main函数,则执行的流程是：<strong>全局变量定义-&gt;init函数-&gt;main函数</strong></li>
<li>init函数最主要的作用,就是完成一些初始化的工作</li>
<li>如果main.go和main包含的其他包中都有init函数，首先应优先执行包含包中的变量定义-&gt;init函数-&gt;main中变量定义-&gt;init函数-&gt;main函数</li>
</ul>
<h3 id="5匿名函数"><a class="markdownIt-Anchor" href="#5匿名函数"></a> 5.匿名函数</h3>
<p>Go支持匿名函数,如果我们某个函数只是希望使用一次,可以考虑使用匿名函数,匿名函数也可以实现多次调用</p>
<p>全局匿名函数：如果将匿名函数赋给一个全局变量,那么这个匿名函数,就成为一个全局匿名函数,可以在程序有效。</p>
<p>使用方式：</p>
<ul>
<li>
<p>在定义匿名函数时就直接调用</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将匿名函数赋给一个变量(函数变量),再通过该变量来调用匿名函数</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;<span class="comment">//a的数据类型就是函数类型</span></span><br><span class="line">res := a(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6内置函数"><a class="markdownIt-Anchor" href="#6内置函数"></a> 6.内置函数</h3>
<ul>
<li>len</li>
<li>new：用来分配内存,主要用来分配值类型,比如int、foat32、struct。返回的是指针</li>
<li>make：用来分配内存,主要用来分配引用类型,比如chan、map、 slice。</li>
</ul>
<h3 id="7包"><a class="markdownIt-Anchor" href="#7包"></a> 7.包</h3>
<ul>
<li>包的本质实际上就是创建不同的文件夹,来存放程序文件。</li>
<li>基本概念：go的每一个文件都是属于一个包的,也就是说go是以包的形式来管理文件和项目目录结构的</li>
<li>作用：
<ul>
<li>区分相同名字的函数、变量等标识符</li>
<li>当程序文件很多时,可以很好的管理项目</li>
<li>控制函数、变量等访问范围,即作用域（首字母大写共有，小写私有）</li>
</ul>
</li>
</ul>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打包：</span></span><br><span class="line"><span class="keyword">package</span> 包名</span><br><span class="line"><span class="comment">//引入包：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包的路径"</span></span><br><span class="line"><span class="comment">//调用包中的函数</span></span><br><span class="line">包名.函数名()</span><br></pre></td></tr></table></figure>
<p>细节说明：</p>
<ul>
<li>
<p>在给一个文件打包时,该包对应一个文件夹,比如这里的utis文件夹对应的包名就是 utils,文件的包名通常和文件所在的文件夹名一致,般为小写字母。</p>
<ul>
<li>不一致的话，调用包中的函数时，包名就得变更为具体的包名</li>
<li>import导入的在某种意义上相当于导入包所在的路径</li>
</ul>
</li>
<li>
<p>使用前需要先引用对应的包</p>
</li>
<li>
<p>打包指令应该在第一行然后才能是import指令</p>
</li>
<li>
<p>在import包时,路径从<code>$GOPATH</code>的src下开始,不用带src,编译器会自动从src下开始引入</p>
</li>
<li>
<p>首字母大写共有，小写私有</p>
</li>
<li>
<p>在访问其它包函数时,其语法是<code>包名.函数名</code></p>
</li>
<li>
<p>go支持给包取别名</p>
<ul>
<li>别名后只能通过<code>别名.函数名</code>访问</li>
</ul>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">    util <span class="string">"go_code/chapter06/fundemo01/utils"</span><span class="comment">//取别名为util</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    util.Cal()<span class="comment">//只能通过别名.函数名调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<strong>同一包下</strong>（可以是不同文件）,不能有相同的函数名和全局变量名,否则报重复定义</p>
</li>
<li>
<p>如果你要编译成一个可执行程序文件,就需要将这个包声明为man,即 package main，这就是一个语法规范。如果你是写一个库,包名可以自定</p>
<ul>
<li>main包只有一个</li>
<li>编译后生成一个有默认名的可执行文件,在<code>$GOPATH</code>目录下,可以指定名字和目录,比如:放在bin目录下:<code>D: goproject&gt; gobuild -o bin/my.exe go_code/chapter06/fundemo01/main</code></li>
</ul>
</li>
</ul>
<h3 id="7闭包"><a class="markdownIt-Anchor" href="#7闭包"></a> 7.闭包</h3>
<p>闭包就是<strong>一个函数</strong>和与其<strong>相关的引用环境</strong>组合的一个整体(实体)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := AddUpper()<span class="comment">//这里可以理解为初始化闭包中的一些变量 这里的传参是给闭包的</span></span><br><span class="line">    fmt.Println(f(<span class="number">1</span>))<span class="comment">//11 这里的传参是给闭包中的函数的</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))<span class="comment">//13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>))<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回的是一个匿名函数,但是这个匿名函数引用到函数外的n因此这个匿名函数就和n形成个整体,构成闭包</li>
<li>可以这样理解：闭包是类，函数是操作，n是字段。函数和它使用到的n构成闭包</li>
<li>当我们反复的调用f函数时,因为n<strong>只初始化一次</strong>,因此每调一次就进行累计
<ul>
<li>闭包中的变量只会初始化一次且会一直保存</li>
</ul>
</li>
<li>我们要搞清楚闭包的关键,就是要分析出返回的函数它使用(引用)到哪些变量,因为函数和它引用到的变量共同构成闭包。</li>
</ul>
<h2 id="四-控制流程"><a class="markdownIt-Anchor" href="#四-控制流程"></a> 四、控制流程</h2>
<h3 id="1if"><a class="markdownIt-Anchor" href="#1if"></a> 1.if</h3>
<ul>
<li>支持在if条件中直接定义一个变量</li>
<li>大括号不能省</li>
<li>条件可以用小括号，但是不推荐</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 套件表达式 &#123;</span><br><span class="line">    执行语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================</span></span><br><span class="line"><span class="keyword">if</span> 套件表达式 &#123;</span><br><span class="line">    执行语句a</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    执行语句b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================</span></span><br><span class="line"><span class="keyword">if</span> 套件表达式<span class="number">1</span> &#123;</span><br><span class="line">    执行语句a</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 条件表达式<span class="number">2</span> &#123;</span><br><span class="line">    执行语句b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11运算符"><a class="markdownIt-Anchor" href="#11运算符"></a> 1.1运算符</h4>
<h5 id="111比较"><a class="markdownIt-Anchor" href="#111比较"></a> 1.1.1比较</h5>
<ul>
<li>双方需要类型一致</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td></td>
</tr>
<tr>
<td>!=</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>&lt;=</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>&gt;=</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="112算术"><a class="markdownIt-Anchor" href="#112算术"></a> 1.1.2算术</h5>
<ul>
<li>双方需要类型一致</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td></td>
</tr>
<tr>
<td>/</td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>余（模）</td>
</tr>
</tbody>
</table>
<h5 id="113逻辑"><a class="markdownIt-Anchor" href="#113逻辑"></a> 1.1.3逻辑</h5>
<table>
<thead>
<tr>
<th>字符</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
</tbody>
</table>
<h3 id="2switch"><a class="markdownIt-Anchor" href="#2switch"></a> 2.switch</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 变量值 &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>,值<span class="number">2</span>:</span><br><span class="line">    	相关操作</span><br><span class="line">    <span class="keyword">case</span> 值:</span><br><span class="line">         相关操作</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fallthrough</code>：switch穿透，如果在case语句块后增加fallthrough,则会继续执行下一个case</li>
<li>Type Switch: switch语句还可以被用于 type-switch来判断某个 interface变量中实际指向的变量类型</li>
</ul>
<h3 id="3for"><a class="markdownIt-Anchor" href="#3for"></a> 3.for</h3>
<p>语法格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量初始化;循环条件;循环变量迭代 &#123;</span><br><span class="line">	循环操作(语句)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以配合<strong>break</strong>退出循环</li>
<li>beak语句出现在多层嵌套的语句块中时,可以<strong>通过标签</strong>指明要终止的是哪层语句块</li>
<li>可以配合<strong>continue</strong>退出<strong>本次</strong>循环</li>
<li>continue语句出现在多层嵌套的语句块中时,可以<strong>通过标签</strong>指明要跳过的是哪层语句块</li>
<li>可以通过<strong>goto</strong>语句可以无条件地转移到程序中指定的行
<ul>
<li>在Go程序设计中般不主张使用goto语句,以免造成程序流程的混乱,使理解和调试程序都产生困难</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">	i++</span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,n := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>,n := <span class="built_in">len</span>(str);i++ &#123;<span class="comment">//按照字节处理，如有中文会乱码</span></span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line">str1 = []<span class="keyword">rune</span>(str)<span class="comment">//解决中文乱码，将str转成切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>,n := <span class="built_in">len</span>(str1);i++ &#123;</span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> index,val := <span class="keyword">range</span> str &#123;<span class="comment">//按照编码方式处理，中文不会有问题</span></span><br><span class="line">	相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4defer"><a class="markdownIt-Anchor" href="#4defer"></a> 4.defer</h3>
<p>在函数中,程序员经常需要创建资源比如:数据库连接、文件句柄、锁等),为了在函数执行完后及时的释放资源,Go的设计者提供 defer（延时机制）</p>
<ul>
<li>用于执行清理操作或者确保操作完成后<strong>再执行</strong>另一个函数
<ul>
<li>即，在defer所在的函数执行完毕后<strong>执行另一个函数</strong></li>
</ul>
</li>
<li>多条defer语句的输出将按照与defer出现的顺序<strong>相反的顺序</strong>执行</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈(假设为defer栈)</span></span><br><span class="line">	<span class="comment">//当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"ok1 n1="</span>, n1) <span class="comment">//defer 3. ok1 n1 = 10</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"ok2 n2="</span>, n2) <span class="comment">//defer 2. ok2 n2= 20</span></span><br><span class="line">	<span class="comment">//增加一句话</span></span><br><span class="line">	n1++ <span class="comment">// n1 = 11</span></span><br><span class="line">	n2++ <span class="comment">// n2 = 21</span></span><br><span class="line">	res := n1 + n2 <span class="comment">// res = 32</span></span><br><span class="line">	fmt.Println(<span class="string">"ok3 res="</span>, res) <span class="comment">// 1. ok3 res= 32</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"res="</span>, res)  <span class="comment">// 4. res= 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>当go执行到一个 defer时,不会立即执行 defer后的语句,而是将defer后的语句压入到一个栈中[暂时称该栈为 defer栈]然后继续执行函数下一个语句</li>
<li>当函数执行完毕后,在从 defer栈中,依次从栈顶取出语句执行(注:遵守栈先入后出的机制)。</li>
<li>在 defer将语句放入到栈时,也会将相关的值拷贝同时入栈。</li>
</ul>
<h2 id="五-结构体和指针"><a class="markdownIt-Anchor" href="#五-结构体和指针"></a> 五、结构体和指针</h2>
<h3 id="1结构体"><a class="markdownIt-Anchor" href="#1结构体"></a> 1.结构体</h3>
<p>面向对象编程说明：</p>
<ul>
<li>Galang也支持面向对象编程(OOP),但是和传统的面向对象编程有区别,并不是纯粹的面向对象语言。所以我们说 Galang支持<strong>面向对象编程特性</strong>是比较准确的。</li>
<li>Galang没有类（class）,Go语言的结构体( struct)和其它编程语言的类（class）有同等的地位,你可以理解 Galang是基于 struct来实现OOP特性的</li>
<li>Galang面向对象编程非常简洁,<strong>去掉</strong>了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等等</li>
<li>Galang仍然有面向对象编程的继承,封装和多态的特性,只是实现的方式和其它OOP语言不一样,比如<strong>继承</strong>: Galang没有 extends关键字,继承是通过匿名字段来实现</li>
<li>Galang面向对象(OOP)很优雅,OOP本身就是语言类型系统( type system)的一部分,通过接口 (interface)关联,<strong>耦合性低</strong>,也非常灵活。也就是说在 Galang中<strong>面向接口编程</strong>是非常重要的特性</li>
</ul>
<p>结构体是<strong>值类型</strong>，其在内存中的布局如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200105163550051.png" alt="内存中的布局"></p>
<h4 id="11声明"><a class="markdownIt-Anchor" href="#11声明"></a> 1.1声明</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span>&#123;</span><br><span class="line">	字段名称 字段类型</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体名称首字母大小：结构体能够在其他包中被使用</span></span><br><span class="line"><span class="comment">//结构体中字段名称首字母大小：字段能够在其他包中被使用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字段/属性：结构体字段=属性= field，字段是结构体的一个组成部分,一般是基本数据类型、数组,也可是引用类型。
<ul>
<li>字段声明同变量</li>
<li>在创建一个结构体变量后,如果没有给字段赋值,都对应一个零值(默认值),规则同前面讲的一样</li>
<li>同结构体变量的字段是独立,互不影响,一个结构体变量字段的更改,不影响另外一个。</li>
</ul>
</li>
<li>关键字<code>type</code>指定一种新类型</li>
<li>关键字<code>struct</code>指定为结构体</li>
<li>可以使用关键字<code>new</code>创建结构体实例</li>
<li>使用<code>.</code>访问结构体中的成员</li>
<li>声明或创建后不能再修改其成员的数据类型</li>
<li>每个字段独占一行时，最后一个字段结尾必须加逗号</li>
<li>结构体可以嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Rating <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">var</span> m Movie</span><br><span class="line">m.Name = <span class="string">"Metropoils"</span></span><br><span class="line">m.Rating = <span class="number">0.9918</span></span><br><span class="line"><span class="comment">//new创建</span></span><br><span class="line">x := <span class="built_in">new</span>(Movie)<span class="comment">//返回的其实是个指针</span></span><br><span class="line"><span class="comment">//(*x).Name = "Metropoils"//标准写法</span></span><br><span class="line"><span class="comment">//(*x).Rating = 0.99</span></span><br><span class="line">x.Name = <span class="string">"Metropoils"</span><span class="comment">//go的设计者 为了程序员使用方便，底层会对 x.Name = "Metropoils" 进行处理,会给 x 加上 取值运算 (*x).Name = "Metropoils"</span></span><br><span class="line">x.Rating = <span class="number">0.99</span></span><br><span class="line"><span class="comment">//使用简短变量赋值，可以省略new</span></span><br><span class="line">n := Movie&#123;</span><br><span class="line">    Name:<span class="string">"Citizen Kane"</span>,</span><br><span class="line">    Rating:<span class="number">10</span>,<span class="comment">//每个字段独占一行时，最后一个字段结尾必须加逗号</span></span><br><span class="line">&#125;</span><br><span class="line">n := Movie&#123;Name:<span class="string">"Citizen Kane"</span>,Rating:<span class="number">10</span>&#125;<span class="comment">//注意逗号</span></span><br><span class="line">n := Movie&#123;<span class="string">"Citizen Kane"</span>,<span class="number">10</span>&#125;<span class="comment">//可以省略字段名，不推荐</span></span><br><span class="line"><span class="comment">//另一种创建方式</span></span><br><span class="line"><span class="comment">//var movie *Movie = &amp;Movie&#123;"Metropoils",0.45&#125;//创建时直接赋值也是可以的</span></span><br><span class="line"><span class="keyword">var</span> movie *Movie = &amp;Movie&#123;&#125;<span class="comment">//返回结构体指针</span></span><br><span class="line"><span class="comment">//(*movie).Name = "Metropoils"//标准写法</span></span><br><span class="line">movie.Name = <span class="string">"Metropoils"</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">fmt.Println(<span class="string">"%+v\n"</span>,m)</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体指针访问字段的标准方式应该是:<code>(*结构体指针).字段名</code></li>
<li>go做了一个简化,也支持<code>结构体指针.字段名</code>,更加符合程序员使用的习惯,go编译器底层对<code>结构体指针.字段名</code>做了<strong>转化</strong><code>(*结构体指针).字段名</code></li>
<li><code>(*结构体指针).字段名</code><strong>不能写成</strong><code>*结构体指针.字段名</code>：<code>.</code>的优先级高于<code>*</code></li>
</ul>
<h4 id="12自定义结构体字段的默认值"><a class="markdownIt-Anchor" href="#12自定义结构体字段的默认值"></a> 1.2自定义结构体字段的默认值</h4>
<ul>
<li>可以利用自定义函数（构造函数）专门来给自定义的结构体赋自定义的默认值</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>零值（默认值）</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>flase</td>
</tr>
<tr>
<td>整形</td>
<td>0</td>
</tr>
<tr>
<td>浮点型</td>
<td>0.0</td>
</tr>
<tr>
<td>字符串</td>
<td>“”</td>
</tr>
<tr>
<td>指针</td>
<td>nil</td>
</tr>
<tr>
<td>函数</td>
<td>nil</td>
</tr>
<tr>
<td>接口</td>
<td>nil</td>
</tr>
<tr>
<td>切片slice</td>
<td>nil</td>
</tr>
<tr>
<td>通道</td>
<td>nil</td>
</tr>
<tr>
<td>映射map</td>
<td>nil</td>
</tr>
</tbody>
</table>
<h4 id="13结构体比较"><a class="markdownIt-Anchor" href="#13结构体比较"></a> 1.3结构体比较</h4>
<ul>
<li>只能比较字段均一致的结构体
<ul>
<li>可以使用<code>reflect</code>包检查结构体类型</li>
</ul>
</li>
<li>只有==和!=</li>
<li>结构体或字段的首字母大写才能导出（公有值）</li>
</ul>
<h4 id="14结构体注意事项"><a class="markdownIt-Anchor" href="#14结构体注意事项"></a> 1.4结构体注意事项</h4>
<ul>
<li>
<p>结构体的所有字段在内存中是连续的</p>
</li>
<li>
<p>结构体是用户单独定义的类型,和其它类型进行转换时（利用强制类型转化）需要有<strong>完全</strong>相同的字段（名字、个数和类型）</p>
</li>
<li>
<p>结构体进行type重新定义(相当于取别名), Golang认为是新的数据类型,但是相互间可以<strong>强制类型转化</strong></p>
</li>
<li>
<p>struct的每个字段上,可以写上一个tag,该tag可以通过<strong>反射机制</strong>获取,常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong></p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// `json:"name"` 就是 struct tag</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Skill <span class="keyword">string</span> <span class="string">`json:"skill"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a A</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    a = A(b) <span class="comment">// ? 可以转换，但是有要求，就是结构体的的字段要完全一样(包括:名字、个数和类型！)</span></span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建一个Monster变量</span></span><br><span class="line">    monster := Monster&#123;<span class="string">"牛魔王"</span>, <span class="number">500</span>, <span class="string">"芭蕉扇~"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 将monster变量序列化为 json格式字串</span></span><br><span class="line">    <span class="comment">//   json.Marshal 函数中使用反射，这个讲解反射时，会详细介绍</span></span><br><span class="line">    jsonStr, err := json.Marshal(monster)<span class="comment">//若将Monster中的字段改成小写，就不能够调用（作用域限制），这里只能够用tag</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"json 处理错误 "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"jsonStr"</span>, <span class="keyword">string</span>(jsonStr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2指针"><a class="markdownIt-Anchor" href="#2指针"></a> 2.指针</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Rating <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line">a := Movie&#123;</span><br><span class="line">    Name:<span class="string">"Citizen Kane"</span>,</span><br><span class="line">    Rating:<span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">b := a<span class="comment">//值引用，拷贝副本到b中</span></span><br><span class="line">c := &amp;a<span class="comment">//指针引用，c和a是一块内存区域，改变c，a也会变</span></span><br></pre></td></tr></table></figure>
<h2 id="六-方法和接口"><a class="markdownIt-Anchor" href="#六-方法和接口"></a> 六、方法和接口</h2>
<h3 id="1方法"><a class="markdownIt-Anchor" href="#1方法"></a> 1.方法</h3>
<ul>
<li>Galang中的<strong>方法</strong>是作用在<strong>指定的数据类型上</strong>的(即:和指定的数据类型绑定),因此<strong>自定义类型</strong>,都可以有方法,而不仅仅是 struct</li>
<li>与函数类似，有关键字<code>func</code>指定，会在func后添加另一个参数表</li>
<li>可以建立多个方法，构成方法集</li>
<li>方法和某个结构体紧密绑定，可以通过<code>结构体.方法名</code>的形式调用属于该结构体的方法</li>
<li>方法中的接受者类型类似<strong>一般用指针</strong>，以便直接修改结构体内部成员。如果不使用指针，修改后的值将不会保存，相当于拷贝了一份原结构体的副本来进行操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接受者参数 接受者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;<span class="comment">//就相当于 该方法 和 接受者 进行了绑定</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接受者类型type：表示这个方法和type这个类型进行绑定,或者说该方法作用于type类型</li>
<li>type可以是结构体,也可以其它的自定义类型</li>
<li>接受者参数：就是type的一个实例（变量）</li>
</ul>
<p>eg：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Sphere <span class="keyword">struct</span>&#123;</span><br><span class="line">    Radius <span class="keyword">float64</span></span><br><span class="line">    base <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SurfaceArea方法和*Sphere类型绑定</span></span><br><span class="line"><span class="comment">//Sphere结构体的方法，指针类型，可以修改结构体中的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sphere)</span> <span class="title">SurfaceArea</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    Sphere.base = f</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(<span class="number">4</span>) * math.PI * (s.Radius * s.Radius)<span class="comment">//s.Radius其实是(*s).Radius的简写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Volume方法和Sphere类型绑定</span></span><br><span class="line"><span class="comment">//Sphere结构体的方法，非指针类型，修改的是副本结构体中的值（结构体是值传递，会拷贝一份副本）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sphere)</span> <span class="title">Volume</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    Sphere.base = f</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Sphere&#123;</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">        base:<span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s.SurfaceArea(<span class="number">4</span>))<span class="comment">//会修改s.base的值</span></span><br><span class="line">    <span class="comment">//实际上是(&amp;s).SurfaceArea(4) 只不过编译器底层会将s.SurfaceArea(4)优化成(&amp;s).SurfaceArea(4)</span></span><br><span class="line">    s.Volume(<span class="number">4</span>)<span class="comment">//不会修改s.base的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法的调用和传参机制和函数基本一样,不一样的地方是方法调用时会将<strong>调用方法的变量</strong>,当做实参也传递给方法。</li>
</ul>
<p>结构体创建及赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//在创建结构体变量时，就直接指定字段的值</span></span><br><span class="line"><span class="keyword">var</span> stu1 = Stu&#123;<span class="string">"小明"</span>, <span class="number">19</span>&#125; <span class="comment">// stu1---&gt; 结构体数据空间</span></span><br><span class="line">stu2 := Stu&#123;<span class="string">"小明~"</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">//在创建结构体变量时，把字段名和字段值写在一起, 这种写法，就不依赖字段的定义顺序.</span></span><br><span class="line"><span class="keyword">var</span> stu3 = Stu&#123;</span><br><span class="line">    Name :<span class="string">"jack"</span>,</span><br><span class="line">    Age : <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu4 := Stu&#123;</span><br><span class="line">    Age : <span class="number">30</span>,</span><br><span class="line">    Name : <span class="string">"mary"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(stu1, stu2, stu3, stu4)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2， 返回结构体的指针类型(!!!)</span></span><br><span class="line"><span class="keyword">var</span> stu5 *Stu = &amp;Stu&#123;<span class="string">"小王"</span>, <span class="number">29</span>&#125;  <span class="comment">// stu5--&gt; 地址 ---》 结构体数据[xxxx,xxx]</span></span><br><span class="line">stu6 := &amp;Stu&#123;<span class="string">"小王~"</span>, <span class="number">39</span>&#125;</span><br><span class="line"><span class="comment">//在创建结构体指针变量时，把字段名和字段值写在一起, 这种写法，就不依赖字段的定义顺序.</span></span><br><span class="line"><span class="keyword">var</span> stu7 = &amp;Stu&#123;</span><br><span class="line">    Name : <span class="string">"小李"</span>,</span><br><span class="line">    Age :<span class="number">49</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu8 := &amp;Stu&#123;</span><br><span class="line">    Age :<span class="number">59</span>,</span><br><span class="line">    Name : <span class="string">"小李~"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*stu5, *stu6, *stu7, *stu8)</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>结构体类型是值类型,在方法调用中,遵守<strong>值类型</strong>的传递机制,是值拷贝传递方式</li>
<li>如程序员希望在方法中,修改结构体变量的值,可以通过<strong>结构体指针</strong>的方式来处理</li>
<li>Golang中的方法作用在<strong>指定的数据类型</strong>上的(即:和指定的数据类型绑定)因此<strong>自定义类型</strong>,都可以有方法,而不仅仅是 struct,比如int,foat32等都可以有方法</li>
<li>方法的访问范围控制的规则,和函数一样。方法名首字母小写,只能在本包访问,方法首字母大写,可以在本包和其它包访问。</li>
<li>如果一个变量实现了**String()**这个方法,那么 fmt.Println默认会调用这个变量的String()进行输出（这里的类型必须一样，若绑定的方法接受者类型为指针，则输入参数一定要加&amp;）</li>
</ul>
<p>方法和函数的区别：</p>
<ul>
<li>
<p>调用方式不一样</p>
<ul>
<li>函数：函数名(实参列表)</li>
<li>方法：变量.方法名(实参列表)</li>
</ul>
</li>
<li>
<p>对于普通函数,接收者为值类型时,不能将指针类型的数据直接传递,反之亦然</p>
</li>
<li>
<p>对于方法(如 struct的方法),接收者为值类型时,可以直接用指针类型的变量调用方法,反过来同样也可以。最终的决定权在方法的<strong>接受者类型</strong>上</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于方法（如struct的方法），</span></span><br><span class="line"><span class="comment">//接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.Name = <span class="string">"jack"</span></span><br><span class="line">    fmt.Println(<span class="string">"test03() ="</span>, p.Name) <span class="comment">// jack</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">test04</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.Name = <span class="string">"mary"</span></span><br><span class="line">    fmt.Println(<span class="string">"test03() ="</span>, p.Name) <span class="comment">// mary</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">"tom"</span>&#125;</span><br><span class="line">    p.test03()</span><br><span class="line">    fmt.Println(<span class="string">"main() p.name="</span>, p.Name) <span class="comment">// tom</span></span><br><span class="line">    (&amp;p).test03() <span class="comment">// 从形式上是传入地址，但是本质仍然是值拷贝</span></span><br><span class="line">    fmt.Println(<span class="string">"main() p.name="</span>, p.Name) <span class="comment">// tom</span></span><br><span class="line"></span><br><span class="line">    (&amp;p).test04()</span><br><span class="line">    fmt.Println(<span class="string">"main() p.name="</span>, p.Name) <span class="comment">// mary</span></span><br><span class="line">    p.test04() <span class="comment">// 等价 (&amp;p).test04 , 从形式上是传入值类型，但是本质仍然是地址拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2接口详见十一章"><a class="markdownIt-Anchor" href="#2接口详见十一章"></a> 2.接口（详见十一章）</h3>
<ul>
<li>使用关键字<code>interface</code>指定接口</li>
<li>可以理解为方法集的一个蓝本（充当了方法集的规范），描述了方法集中的所有方法，但并没有实现它</li>
<li>描述了方法集中的所有方法，并指定了每个方法的函数签名</li>
<li>使用接口前需要实现接口，即满足接口要求：
<ul>
<li>实现接口指定方法集</li>
<li>函数签名正确无误</li>
</ul>
</li>
<li>接口是一种<strong>类型</strong>，可以<strong>作为参数</strong>传递给函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名称 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法<span class="number">1</span>名称(参数<span class="number">1</span> 变量类型<span class="number">1</span>,参数<span class="number">2</span> 变量类型<span class="number">2</span>,...) 返回值类型</span><br><span class="line">    方法<span class="number">2</span>名称(参数<span class="number">1</span> 变量类型<span class="number">1</span>,参数<span class="number">2</span> 变量类型<span class="number">2</span>,...) 返回值类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-字符串"><a class="markdownIt-Anchor" href="#七-字符串"></a> 七、字符串</h2>
<ul>
<li>字符串实际上是只读的字节切片</li>
</ul>
<h3 id="1字面量"><a class="markdownIt-Anchor" href="#1字面量"></a> 1.字面量</h3>
<ul>
<li>与C语言类型，利用<strong>双引号</strong>括起来</li>
<li>可以使用基于反斜杠的各种转义字符</li>
</ul>
<h3 id="2rune字面量"><a class="markdownIt-Anchor" href="#2rune字面量"></a> 2.rune字面量</h3>
<ul>
<li>使用<strong>反引号</strong><code>·</code>括起来（Esc键下的那个）</li>
<li>不能使用转义字符，是什么格式写在代码里就怎么输出</li>
</ul>
<h3 id="3拼接字符串"><a class="markdownIt-Anchor" href="#3拼接字符串"></a> 3.拼接字符串</h3>
<ul>
<li>使用运算符<code>+</code>或<code>+=</code>拼接</li>
<li>只能拼接字符串型变量
<ul>
<li>可以使用strconv包中的Itoa方法将整数转化为字符串</li>
</ul>
</li>
<li>拼接次数增多会导致效率边低
<ul>
<li>可使用缓存区解决</li>
</ul>
</li>
</ul>
<h3 id="4strings包处理字符串"><a class="markdownIt-Anchor" href="#4strings包处理字符串"></a> 4.strings包处理字符串</h3>
<ul>
<li>strings.ToLower：将字符串转化为小写</li>
<li>strings.Index：在字符串中查找子串并返回索引</li>
<li>strings.TrimSpace：去除开头和结尾的空格</li>
</ul>
<h3 id="5常用系统函数"><a class="markdownIt-Anchor" href="#5常用系统函数"></a> 5.常用系统函数</h3>
<ul>
<li>统计字符串长度，按照字节：len(str)，内嵌函数，无需包</li>
<li>字符串遍历,同时处理有中文的间题 r := []rune(str)</li>
<li>字符串 转 整数:n,err := strconv.Atoi(“12”)</li>
<li>整数 转 字符串str = strconv.Itoa(12345)</li>
<li>字符串 转 []byte: var bytes = []byte(“hello go”)</li>
<li>[]byte 转 字符串:str = string([]byte{97,98,99})</li>
<li>10进制 转 2,8,16进制:str = strconv.FormatInt(123,2)</li>
<li>查找子串是否在指定的字符串中: strings.Contains(“seafood”,“foo”)//true</li>
<li>统计一个字符串有几个指定的子串: strings.Count(“cheese”,“e”)//4</li>
<li>不区大小写的字符串比较(==比较是区分字母大小写的): fmt.PrintIn( strings.EqualFold(“abc”,“Abc”)//true</li>
<li>返回子串在字符串第一次出现的index值,如果没有返回-1: strings.Index(“NTL_abc”,“abc”)//4</li>
<li>返回子串在字符串最后一次出现的index,如没有返回-1: strings.Lastlndex(“go golang”,“go”)//3</li>
<li>将指定的子串替换成另外一个子串: strings.Replace(“go go hello”,“go”,“go语言”,n)n可以指定你希望替换几个,如果n=-1表示全部替换</li>
<li>按照指定的某个字符,为分割标识,将一个字符串拆分成字符串数组：strings.Split(“hello,wrold,ok”,&quot;,&quot;)</li>
<li>将字符串的字母进行大小写的转换: strings.ToLower(“Go”)//go strings.ToUpper(“Go”)//Go</li>
<li>将字符串左右两边的空格去掉: strings.TrimSpacel(&quot; tn a lone gopher ntrn &quot;)</li>
<li>将字符串左右两边指定的字符去掉: strings.Trim(&quot;! hello!&quot;,&quot; !&quot;)//[“hello”]//将左右两边!和&quot; &quot;去掉</li>
<li>将字符串左边指定的字符去掉: strings.TrimLeft(&quot;! hello!&quot;,&quot; !&quot;)//[“hello”]//将左边!和&quot; &quot;去掉</li>
<li>将字符串右边指定的字符去掉: strings.TrimRight(&quot;! hello!&quot;,&quot; !&quot;)//[“hello”]//将右边!和&quot; &quot;去掉</li>
<li>判断字符串是否以指定的字符串开头: strings.HasPrefix(“<a href="ftp://192.168.10.1">ftp://192.168.10.1</a>&quot;,“ftp”)//true</li>
<li>判断字符串是否以指定的字符串结束: strings.HasSuffix(“NLT_abc. jpg”,“abc”)//false</li>
</ul>
<h2 id="八-处理错误"><a class="markdownIt-Anchor" href="#八-处理错误"></a> 八、处理错误</h2>
<h3 id="1错误的处理机制"><a class="markdownIt-Anchor" href="#1错误的处理机制"></a> 1.错误的处理机制</h3>
<p>基本说明：</p>
<ul>
<li>Go语言追求简洁优雅,所以,Go语言不支持传统的try…catch…finally这种处理</li>
<li>Go中引入的处理方式为: <code>defer</code>, <code>panic</code>, <code>recover</code></li>
<li>这几个异常的使用场景可以这么简单描述：Go中可以抛出一个 panic的异常,然后在 defer中通过 <strong>recover捕获</strong>这个异常,然后正常处理</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数调用后不会终止（会运行匿名函数），任然会正常运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用defer + recover 来捕获和处理异常</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>()  <span class="comment">// recover()内置函数，可以捕获到异常</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  <span class="comment">// 说明捕获到错误</span></span><br><span class="line">			fmt.Println(<span class="string">"err="</span>, err)</span><br><span class="line">			<span class="comment">//这里就可以将错误信息发送给管理员....</span></span><br><span class="line">			fmt.Println(<span class="string">"发送邮件给admin@sohu.com~"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	num1 := <span class="number">10</span></span><br><span class="line">	num2 := <span class="number">0</span></span><br><span class="line">	res := num1 / num2<span class="comment">//这里会有异常</span></span><br><span class="line">	fmt.Println(<span class="string">"res="</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2自定义错误"><a class="markdownIt-Anchor" href="#2自定义错误"></a> 2.自定义错误</h3>
<ul>
<li>
<p>没有错误，返回的错误值为nil</p>
</li>
<li>
<p>一般错误是通过返回给他的调用者处理的</p>
</li>
<li>
<p>错误是一个值，在标准库中声明了接口error</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11创建错误"><a class="markdownIt-Anchor" href="#11创建错误"></a> 1.1创建错误</h4>
<ul>
<li>
<p>使用标准库中的<code>errors</code>包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"错误内容"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用标准库中的<code>fmt</code>包中的<code>Errorf</code>方法灵活的创建</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">role,name := <span class="string">"Richard Jupp"</span>,<span class="string">"Drummer"</span></span><br><span class="line">err := fmt.Errorf(<span class="string">"The %v %v quit"</span>,role,name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="12-panic内置函数"><a class="markdownIt-Anchor" href="#12-panic内置函数"></a> 1.2 panic内置函数</h4>
<ul>
<li>慎用</li>
<li>内置函数,接收一个interface{}类型的值(也就是任何值了)作为参数。可以接收error类型的变量,输出错误信息,并退出程序</li>
<li>是go语言中的内置函数，能够终止正常的控制流程并引起恐慌，导致程序停止执行</li>
</ul>
<h2 id="九-goroutine协程"><a class="markdownIt-Anchor" href="#九-goroutine协程"></a> 九、Goroutine协程</h2>
<ul>
<li>关键字<code>go</code>修饰</li>
<li>是一种支持并发编程的方式</li>
<li>用于处理需要并发的任务</li>
<li>占用内存极小，且创建和销毁效率也很高</li>
</ul>
<p>进程和线程：</p>
<ul>
<li>进程就是程序程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位</li>
<li>线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</li>
<li>一个进程可以创建核销毁多个线程，同一个进程中的多个线程可以并发执行</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
</ul>
<p>并发和并行：</p>
<ul>
<li>多线程程序在单核上运行，就是并发</li>
<li>多线程程序在多核上运行，就是并行</li>
</ul>
<p>go协程和go主线程</p>
<ul>
<li>Go主线程（有程序员直接称为线程/也可以理解成进程一个Go线程上，可以起多个协程，你可以这样理解，协程是轻量级的线程</li>
<li>Go协程的特点
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
</li>
</ul>
<blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> test() <span class="comment">// 开启了一个协程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">" main() hello,golang"</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果主线程退出了，则协程即使还没有执行完毕，也会退出</li>
<li>当然协程也可以在主线程没有退出前，就自己结束了，比如完成了自己的任务</li>
</ul>
</blockquote>
<p>协程的调度模型（MPG模式）：</p>
<ul>
<li>M：操作系统的主线程（是物理线程）</li>
<li>P：协程执行需要的上下文</li>
<li>G：协程</li>
</ul>
<p>设置Golang运行的cpu数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line">runtime.NumCPU()<span class="comment">//获取本地机器的逻辑cpu</span></span><br><span class="line">runtime.GOMAXPROCS(num)<span class="comment">//设置Go可同时执行的最大cpu个数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>go1.8后，默认让程序运行在多个核上可以不用设置了</li>
<li>go1.8前，还是要设置一下，可以更高效的利益cpu</li>
</ul>
<h3 id="1多个协程之间的通信"><a class="markdownIt-Anchor" href="#1多个协程之间的通信"></a> 1.多个协程之间的通信</h3>
<p>在<strong>编译</strong>程序时，可以通过增加<code>-race</code>参数，即可查看是否存在资源竞争，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">go</span> build -race test.<span class="keyword">go</span></span><br><span class="line">&gt; test.exe</span><br></pre></td></tr></table></figure>
<p><code>sync</code>包提供了一些基本的同步元素，如互斥锁。大部分都是适用于低水平程序线程，高水平的同步使用channel通信更好一些。</p>
<blockquote>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    _ <span class="string">"time"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 需求：现在要计算 1-200 的各个数的阶乘，并且把各个数的阶乘放入到map中。</span></span><br><span class="line"><span class="comment">// 最后显示出来。要求使用goroutine完成 </span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)  </span><br><span class="line">    <span class="comment">//声明一个全局的互斥锁lock</span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="comment">// test 函数就是计算 n!, 让将这个结果放入到 myMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        res *= i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们将 res 放入到myMap </span></span><br><span class="line">    lock.Lock()<span class="comment">//加锁</span></span><br><span class="line">    myMap[n] = res <span class="comment">//concurrent map writes?</span></span><br><span class="line">    lock.Unlock()<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们这里开启多个协程完成这个任务[200个]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> test(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠10秒钟【第二个问题 】</span></span><br><span class="line">    <span class="comment">//time.Sleep(time.Second * 5)</span></span><br><span class="line"></span><br><span class="line">    lock.Lock()<span class="comment">//这里加锁是为了让go底层知道（go底层可能仍会访问改资源）</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>更好的通信机制应该是用到下一章的<strong>管道</strong></p>
<h2 id="十-channel通道"><a class="markdownIt-Anchor" href="#十-channel通道"></a> 十、channel通道</h2>
<ul>
<li>一种与Goroutine通信的方式</li>
<li>能够让数据进入和离开Goroutine，方便Goroutine之间进行通信</li>
<li>使用关键字<code>make</code>创建，使用关键字<code>chan</code>指定创建的是通道</li>
<li>channel的本质就是一个数据结构——队列
<ul>
<li>先进先出</li>
</ul>
</li>
<li><strong>线程安全</strong>，多 goroutine访问时，不需要加锁，就是说 channel本身就是线程安全</li>
<li>channel是有类型的，一个 string的channel只能存放 string类型数据</li>
</ul>
<p>声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br></pre></td></tr></table></figure>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li>channel必须初始化才能写入数据（即make后）</li>
<li>管道是有类型的</li>
</ul>
<p>初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管道变量名字 = <span class="built_in">make</span>(<span class="keyword">chan</span> 通道存储的数据类型,管道中的容量)</span><br></pre></td></tr></table></figure>
<p>数据传输：</p>
<p>向通道发送消息（注意通道只能接受创建时指定的通道类型）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">intChan&lt;- <span class="number">10</span></span><br><span class="line">num := <span class="number">211</span></span><br><span class="line">intChan&lt;- num</span><br><span class="line">intChan&lt;- <span class="number">50</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>len(intChan)</code>：获取到通道的长度，具体为传入通道中的数据</li>
<li><code>cap(intChan)</code>：获取通道的容量，具体为make创建时的大小</li>
<li>给管写入数据时，不能超过其容量</li>
</ul>
<p>从通道接收消息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num2 <span class="keyword">int</span></span><br><span class="line">num2 = &lt;-intChan<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报deadlock</li>
</ul>
<blockquote>
<p>注意：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个存放任意数据类型的管道 3个数据</span></span><br><span class="line">    <span class="comment">//var allChan chan interface&#123;&#125;</span></span><br><span class="line">    allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    allChan&lt;- <span class="number">10</span></span><br><span class="line">    allChan&lt;- <span class="string">"tom jack"</span></span><br><span class="line">    cat := Cat&#123;<span class="string">"小花猫"</span>, <span class="number">4</span>&#125;</span><br><span class="line">    allChan&lt;- cat</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们希望获得到管道中的第三个元素，则先将前2个推出</span></span><br><span class="line">    &lt;-allChan</span><br><span class="line">    &lt;-allChan</span><br><span class="line"></span><br><span class="line">    newCat := &lt;-allChan <span class="comment">//此时从管道中取出的Cat是一个空接口</span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat=%T , newCat=%v\n"</span>, newCat, newCat)<span class="comment">//newCat=main.Cat , newCat=&lt;小花苗 4&gt;  此处能够打印出来是在运行的层面上</span></span><br><span class="line">    <span class="comment">//下面的写法是错误的!编译不通过</span></span><br><span class="line">    <span class="comment">//fmt.Printf("newCat.Name=%v", newCat.Name)//此处不能编译通过是在编译的层面上发现类型不匹配（接口中不能有字段）</span></span><br><span class="line">    <span class="comment">//使用类型断言 强制转换</span></span><br><span class="line">    a := newCat.(Cat) </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>, a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>管道关闭：</p>
<p>使用内置函数<code>close</code>可以关闭 channel，当 channel关闭后，就不能再向 channel写数据，但是仍然可以从该 channel读取数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">intChan&lt;- <span class="number">100</span></span><br><span class="line">intChan&lt;- <span class="number">200</span></span><br><span class="line"><span class="built_in">close</span>(intChan) <span class="comment">// close</span></span><br><span class="line"><span class="comment">//这是不能够再写入数到channel</span></span><br><span class="line"><span class="comment">//intChan&lt;- 300</span></span><br><span class="line"><span class="comment">//当管道关闭后，读取数据是可以的</span></span><br><span class="line">n1 := &lt;-intChan</span><br><span class="line">fmt.Println(<span class="string">"n1="</span>, n1)</span><br></pre></td></tr></table></figure>
<p>管道关闭后，数据全部读取完毕后假设再次读取，此时会返回一个错误值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1,ok := &lt;-intChan<span class="comment">//ok用于保存错误值</span></span><br></pre></td></tr></table></figure>
<p>但是假设没有关闭就再次读，会发生<code>deadlock</code>，与下面的<code>for- range</code>遍历类似</p>
<ul>
<li>未关闭管道一直读会发生<code>deadlock</code>，但是关闭后读就只会返回正确与否，不会产生<code>deadlock</code>。可以理解为留下一个标志位，读到这个标志位就停止</li>
<li>在没有关闭管道前也可以读取管道中的内容</li>
</ul>
<p>管道遍历：</p>
<p>channel支持<code>for- range</code>的方式进行遍历，请注意两个细节</p>
<ul>
<li>1）在遍历时，如果 channel没有关闭，则会出现 <code>deadlock</code>的错误
<ul>
<li>因为所有数据全部取出后，仍会再次取数据，此时会产生<code>deadlock</code>的错误</li>
<li>如果写的快，读得慢，写满后写入方会阻塞，但是只要有读取就不会发生<code>deadlock</code>。反之，编译器底层发现一直在写而没有读取就会发生<code>deadlock</code></li>
<li>总之，只要管道有流动就不会发生<code>deadlock</code></li>
</ul>
</li>
<li>2）在遍历时，如果 channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    intChan2&lt;- i * <span class="number">2</span>  <span class="comment">//放入100个数据到管道</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(intChan2)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">"v="</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="goroutine协程channel管道"><a class="markdownIt-Anchor" href="#goroutine协程channel管道"></a> Goroutine协程＋channel管道</h3>
<blockquote>
<p>协程＋管道例子：</p>
<p>同时读写协作问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write Data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">        <span class="comment">//放入数据</span></span><br><span class="line">        intChan&lt;- i <span class="comment">//</span></span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>, i)</span><br><span class="line">        <span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(intChan) <span class="comment">//关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>, exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, ok := &lt;-intChan</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>, v) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//readData 读取完数据后，即任务完成</span></span><br><span class="line">    exitChan&lt;- <span class="literal">true</span></span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建两个管道</span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> writeData(intChan)</span><br><span class="line">    <span class="keyword">go</span> readData(intChan, exitChan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//time.Sleep(time.Second * 10)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, ok := &lt;-exitChan</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞问题</p>
<p>上述例子，如果只有写入数据而没有读取，就会出现阻塞而deadlock，原因是 intChan容量是10，而代码 writeData会写入50个数据阻塞在 writeData的ch&lt;-i</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建两个管道</span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> writeData(intChan)</span><br><span class="line">    <span class="comment">//go readData(intChan, exitChan)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待readData协程完成</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, ok := &lt;-exitChan</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>写管道和读管道的<strong>频率不一致</strong>，<strong>无所谓</strong></p>
<p>注意细节：</p>
<ul>
<li>
<p>channel可以声明为只读或只写（默认为双向，可读可写）</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span><span class="comment">//chan&lt;-可以理解为属性，稍微修饰下，并不能通过make(chan&lt;- int)创建，下面同理</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">chan2&lt;- <span class="number">20</span></span><br><span class="line"><span class="comment">//num := &lt;-chan2 //error</span></span><br><span class="line">fmt.Println(<span class="string">"chan2="</span>, chan2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan3 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">num2 := &lt;-chan3</span><br><span class="line"><span class="comment">//chan3&lt;- 30 //err</span></span><br><span class="line">fmt.Println(<span class="string">"num2"</span>, num2)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用select可以解决从管道取数据的阻塞问题</p>
<ul>
<li>
<p>传统方法在遍历时，如果不关闭会因为阻塞而导致deadlock</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    intChan&lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个管道 5个数据string</span></span><br><span class="line">stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    stringChan &lt;- <span class="string">"hello"</span> + fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在实际开发中，可能我们不好确定什么关闭该管道.</span></span><br><span class="line"><span class="comment">//可以使用select 方式可以解决</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">//注意: 这里，如果intChan一直没有关闭，不会一直阻塞而deadlock</span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配</span></span><br><span class="line">        <span class="keyword">case</span> v := &lt;-intChan : </span><br><span class="line">        fmt.Printf(<span class="string">"从intChan读取的数据%d\n"</span>, v)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-stringChan :</span><br><span class="line">        fmt.Printf(<span class="string">"从stringChan读取的数据%s\n"</span>, v)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">        fmt.Printf(<span class="string">"都取不到了，不玩了, 程序员可以加入逻辑\n"</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>协程中使用recover，可以解决因协程中出现panic而导致整个程序崩溃的问题</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">"hello,world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里我们可以使用defer + recover</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//捕获test抛出的panic</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"test() 发生错误"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//定义了一个map</span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">    myMap[<span class="number">0</span>] = <span class="string">"golang"</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> sayHello()</span><br><span class="line">    <span class="keyword">go</span> test()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>, i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="十一-面向对象编程"><a class="markdownIt-Anchor" href="#十一-面向对象编程"></a> 十一、面向对象编程</h2>
<h3 id="1构造函数工厂模式间接实现"><a class="markdownIt-Anchor" href="#1构造函数工厂模式间接实现"></a> 1.构造函数（工厂模式间接实现）</h3>
<p>Golang的结构体没有构造函数,通常可以使用<strong>工厂模式</strong>来解决这个问题</p>
<p>使用工厂模式实现跨包创建结构体实例(变量):</p>
<ul>
<li>
<p>如果 modle包的结构体变量首字母大写,引入后,直接使用,没有问题</p>
</li>
<li>
<p>如果mode包的结构体变量首字母小写,引入后,不能直接使用,可以工厂模式解决</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建要给Student实例</span></span><br><span class="line">	<span class="comment">// var stu = model.Student&#123;</span></span><br><span class="line">	<span class="comment">// 	Name :"tom",</span></span><br><span class="line">	<span class="comment">// 	Score : 78.9,</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">//定student结构体是首字母小写，我们可以通过工厂模式来解决</span></span><br><span class="line">	<span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom~"</span>, <span class="number">98.8</span>)</span><br><span class="line">	fmt.Println(*stu) <span class="comment">//&amp;&#123;....&#125;</span></span><br><span class="line">	fmt.Println(<span class="string">"name="</span>, stu.Name, <span class="string">" score="</span>, stu.GetScore())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//student.go</span></span><br><span class="line"><span class="keyword">package</span> model</span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为student结构体首字母是小写，因此是只能在model使用</span></span><br><span class="line"><span class="comment">//我们通过工厂模式来解决</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(n <span class="keyword">string</span>, s <span class="keyword">float64</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">		Name : n,</span><br><span class="line">		score : s,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果score字段首字母小写，则，在其它包不可以直接方法，我们可以提供一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetScore</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.score <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2封装"><a class="markdownIt-Anchor" href="#2封装"></a> 2.封装</h3>
<p>封装( encapsulation)就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只有通过被授权的操作(方法)，才能对字段进行操作</p>
<p>如何体现封装：</p>
<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法,包 实现封装</li>
</ul>
<p>步骤：</p>
<ul>
<li>
<p>将结构体、字段(属性)的<strong>首字母小写</strong>(不能导出了,其它包不能使用,类似 private)</p>
</li>
<li>
<p>结构体所在包提供一个工厂模式的函数,首字母大写。类似一个构造函数</p>
</li>
<li>
<p>提供一个首字母大写的Set方法(类似其它语言的 public),用于对属性判断并赋值</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">SetXxx</span><span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    <span class="comment">//加入数据验证的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提供一个首字母大写的Get方法(类似其它语言的public,用于获取属性的值</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">var</span> 结构体类型名)</span> <span class="title">GetXxx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">var</span>.字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>特别说明:在 Golang开发中并没有特别强调封装,Galang本身对面向对象的特性做了简化</p>
</li>
</ul>
<h3 id="3继承"><a class="markdownIt-Anchor" href="#3继承"></a> 3.继承</h3>
<p>继承可以解决<strong>代码复用</strong>，让我们的编程更加靠近人类思维。</p>
<p>当多个结构体存在相同的属性(字段)和方法时,可以从这些结构体中抽象出结构体，在该结构体中定义这些相同的属性和方法</p>
<p>其它的结构体不需要重新定义这些属性和方法,只需嵌套一个<strong>匿名结构体</strong>即可。</p>
<p>在 Golang中,如果一个 struct<strong>嵌套</strong>了另一个匿名结构体,那么这个结构体可以<strong>直接访问</strong>匿名结构体的<strong>字段和方法</strong>,从而实现了继承特性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Pupil 和 Graduate 共有的方法也绑定到 *Student</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">ShowInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"学生名=%v 年龄=%v 成绩=%v\n"</span>, stu.Name, stu.Age, stu.Score)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">SetScore</span><span class="params">(score <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//业务判断</span></span><br><span class="line">    stu.Score = score</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 *Student 增加一个方法，那么 Pupil 和 Graduate都可以使用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">GetSum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小学生</span></span><br><span class="line"><span class="keyword">type</span> Pupil <span class="keyword">struct</span> &#123;</span><br><span class="line">    Student <span class="comment">//嵌入了Student匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示他的成绩</span></span><br><span class="line"><span class="comment">//这时Pupil结构体特有的方法，保留</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pupil)</span> <span class="title">testing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"小学生正在考试中....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大学生</span></span><br><span class="line"><span class="keyword">type</span> Graduate <span class="keyword">struct</span> &#123;</span><br><span class="line">    Student <span class="comment">//嵌入了Student匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示他的成绩</span></span><br><span class="line"><span class="comment">//这时Graduate结构体特有的方法，保留</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Graduate)</span> <span class="title">testing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"大学生正在考试中....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//当我们对结构体嵌入了匿名结构体使用方法会发生变化</span></span><br><span class="line">    pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">    pupil.Student.Name = <span class="string">"tom~"</span></span><br><span class="line">    pupil.Student.Age = <span class="number">8</span></span><br><span class="line">    pupil.testing()</span><br><span class="line">    pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">    pupil.Student.ShowInfo()</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>, pupil.Student.GetSum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    graduate := &amp;Graduate&#123;&#125;</span><br><span class="line">    graduate.Student.Name = <span class="string">"mary~"</span><span class="comment">//可以简化为graduate.Name = "mary~"</span></span><br><span class="line">    graduate.Student.Age = <span class="number">28</span></span><br><span class="line">    graduate.testing()</span><br><span class="line">    graduate.Student.SetScore(<span class="number">90</span>)</span><br><span class="line">    graduate.Student.ShowInfo()</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>, graduate.Student.GetSum(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>结构体可以使用嵌套匿名结构体<strong>所有的字段和方法</strong>,即:首字母大写或者小写的字段、方法,都可以使用。</p>
</li>
<li>
<p>匿名结构休字段访问可以简化：<code>变量名.匿名结构体名.成员</code>–&gt;<code>变量名.成员</code></p>
</li>
<li>
<p>当结构体和匿名结构体有<strong>相同</strong>的字段或者方法时,编译器采用<strong>就近访问原则</strong>访问,如希望访问匿名结构体的字段和方法,可以通过匿名结构体名来区分</p>
</li>
<li>
<p>结枃体嵌入两个(或多个)匿名结构体,如两个匿名结构体有相同的字段和方法(同时<strong>结构体本身没有同名的字段和方法</strong>),在访问时,就<strong>必须明确指定</strong>匿名结构体名字,否则编译报错。</p>
</li>
<li>
<p>如果一个 struct嵌套了一个有名结构体,这种模式就是<strong>组合</strong>,如果是组合关系,那么在访问组合的结构体的字段或方式时,<strong>必须带上</strong>结构体的名字</p>
</li>
<li>
<p>嵌套匿名结构体后,也可以在创建结构体变量(实例)时,直接指定各个匿名结构体字段的值</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TV <span class="keyword">struct</span> &#123;</span><br><span class="line">    Goods</span><br><span class="line">    Brand</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">    tv := TV&#123; Goods&#123;<span class="string">"电视机001"</span>, <span class="number">5000.99</span>&#125;,  Brand&#123;<span class="string">"海尔"</span>, <span class="string">"山东"</span>&#125;, &#125;</span><br><span class="line">    tv2 := TV&#123;</span><br><span class="line">        Goods&#123;</span><br><span class="line">            Price : <span class="number">5000.99</span>,</span><br><span class="line">            Name : <span class="string">"电视机002"</span>,</span><br><span class="line">        &#125;,  </span><br><span class="line">        Brand&#123;</span><br><span class="line">            Name : <span class="string">"夏普"</span>,</span><br><span class="line">            Address :<span class="string">"北京"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体的匿名字段可以是基本数据类型</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>  &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> E <span class="keyword">struct</span> &#123;</span><br><span class="line">    Monster</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    n <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> e E</span><br><span class="line">    e.Name = <span class="string">"狐狸精"</span></span><br><span class="line">    e.Age = <span class="number">300</span></span><br><span class="line">    e.<span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">    e.n = <span class="number">40</span></span><br><span class="line">    fmt.Println(<span class="string">"e="</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>多重继承：</p>
<ul>
<li>如一个struct嵌套了多个匿名结构体,那么该结构体可以直接访问嵌套的匿名结构体的字段和方法,从而实现了多重继承
<ul>
<li>上上个例子中的TV，嵌套了Goods和Brand结构体</li>
</ul>
</li>
<li>如嵌入的匿名结构体有<strong>相同的字段名或者方法名</strong>,则在访问时,需要通过<strong>匿名结构体类型名</strong>来区分</li>
<li>为了保证代码的简洁性,建议大家<strong>尽量不使用</strong>多重继承</li>
</ul>
<h3 id="4接口"><a class="markdownIt-Anchor" href="#4接口"></a> 4.接口</h3>
<p>interface类型可以定义一组方法,但是这些不需要实现。并且 <strong>interface不能包含任何变量</strong>。到自定义类型(比如结构体 Phone)要使用的时候,在根据具体情况把这些方法写出来</p>
<p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    method1(参数列表) 返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口里的所有方法都没有方法体,即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想</li>
<li>Golang中的接口,不需要显式的实现。只要变量,含有接口类型中的<strong>所有方法</strong>,那变量就实现这个接口。因此, Galang中<strong>没有 implement</strong>这样的关键字</li>
</ul>
<p>注意事项：</p>
<ul>
<li>
<p>接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例)</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Say</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Stu Say()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu Stu <span class="comment">//结构体变量，实现了 Say() 实现了 AInterface</span></span><br><span class="line">    <span class="keyword">var</span> a AInterface = stu</span><br><span class="line">    a.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口中所有的方法都没有方法体,即都是没有实现的方法。</p>
</li>
<li>
<p>在 Golang中,一个自定义类型需要将某个接口的<strong>所有方法</strong>都实现,我们才说这个自定义类型实现了该接口。</p>
</li>
<li>
<p>一个自定义类型只有实现了某个接口,才能将该自定义类型的实例(变量)赋给接囗类型</p>
</li>
<li>
<p>只要是自定义数据类型,就可以实现接口,不仅仅是结构体类型</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> integer <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i integer)</span> <span class="title">Say</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"integer Say i ="</span> ,i )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i integer = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> b AInterface = i</span><br><span class="line">    b.Say() <span class="comment">// integer Say i = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一个自定义类型可以实现多个接口</p>
</li>
<li>
<p>Golang接口中不能有任何变量</p>
</li>
<li>
<p>一个接口(比如A接口)可以<strong>继承</strong>多个别的接口(比如B,C接口),这时如果要实现A接口,也必须将B、C接口的方法也全部实现，但是<strong>不能够有相同的接口</strong></p>
</li>
<li>
<p>interface类型默认是一个指针（<strong>引用类型</strong>）,如果没有对 interface初始化就使用,那么会输出nil</p>
</li>
<li>
<p>空接囗 <code>interface{}</code>没有任何方法,所以所有类型都实现了空接口，即可以将<strong>任何一个变量赋值给空接口</strong></p>
</li>
</ul>
<h4 id="接口和继承的关系"><a class="markdownIt-Anchor" href="#接口和继承的关系"></a> 接口和继承的关系</h4>
<ul>
<li>
<p>接口是继承的补充</p>
</li>
<li>
<p>当A结构体继承了B结构体,那么A结构就自动的继承了B结构体的字段和方法,并且可以直接使用</p>
</li>
<li>
<p>当A结构体需要扩展功能,同时不希望去破坏继承关系,则可以去实现某个接口即可</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200109151443437.png" alt="接口和继承的关系"></p>
</li>
<li>
<p>接口和继承解决的问题不同</p>
<ul>
<li>继承的价值主要在于:解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li>
<li>接口的价值主要在于:<strong>设计</strong>,设计好各种规范(方法),让其它自定义类型去实现这些方法</li>
</ul>
</li>
<li>
<p>接口比继承更加灵活</p>
<ul>
<li>继承是满足<code>is-a</code>的关系,而接口只需满足<code>like-a</code>的关系。</li>
</ul>
</li>
<li>
<p>接口在一定程度上实现代码解耦</p>
</li>
</ul>
<h3 id="5多态"><a class="markdownIt-Anchor" href="#5多态"></a> 5.多态</h3>
<p>变量(实例)具有多种形态。面向对象的第三大特征,在Go语言,多态特征是<strong>通过接口实现</strong>的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。</p>
<p>接口体现多态特性：</p>
<ul>
<li>
<p><strong>多态参数</strong>：在下面的Usb接口案例, Usb usb,即可以接收手机变量,又可以接收相机变量,就体现了Usb接口多态</p>
<ul>
<li>
<p>例子：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明/定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">//声明了两个没有实现的方法</span></span><br><span class="line">    Start()</span><br><span class="line">    Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//让Phone 实现 Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让Camera 实现   Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"相机开始工作~~~。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算机</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个方法Working 方法，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="comment">//只要是实现了 Usb接口 （所谓实现Usb接口，就是指实现了 Usb接口声明所有方法）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span> &#123;</span><br><span class="line">    <span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">    usb.Start()</span><br><span class="line">    usb.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//先创建结构体变量</span></span><br><span class="line">    computer := Computer&#123;&#125;</span><br><span class="line">    phone := Phone&#123;&#125;</span><br><span class="line">    camera := Camera&#123;&#125;</span><br><span class="line">    <span class="comment">//关键点</span></span><br><span class="line">    computer.Working(phone)</span><br><span class="line">    computer.Working(camera) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>多态数组</strong>：下面例子Usb数组中,存放 Phone结构体和 Camera结构体变量。Phone还有一个特有的方法call(),请遍历Usb数组,如果是 Phone变量,除了调用Usb接口声明的方法外,还需要调用 Phone特有方法call</p>
<ul>
<li>
<p>例子：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明/定义一个接口</span></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//声明了两个没有实现的方法</span></span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让Phone 实现 Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让Camera 实现   Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"相机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义一个Usb接口数组，可以存放Phone和Camera的结构体变量</span></span><br><span class="line">	<span class="comment">//这里就体现出多态数组</span></span><br><span class="line">	<span class="keyword">var</span> usbArr [<span class="number">3</span>]Usb</span><br><span class="line">	usbArr[<span class="number">0</span>] = Phone&#123;<span class="string">"vivo"</span>&#125;</span><br><span class="line">	usbArr[<span class="number">1</span>] = Phone&#123;<span class="string">"小米"</span>&#125;</span><br><span class="line">	usbArr[<span class="number">2</span>] = Camera&#123;<span class="string">"尼康"</span>&#125;</span><br><span class="line">	fmt.Println(usbArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h4>
<p>类型断言,由于接口是一般类型,不知道具体类型,如果要<strong>转成具体类型</strong>,就需要使用类型断言，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = t<span class="comment">//空接口，可以接收任意类型</span></span><br><span class="line">y := x.(<span class="keyword">float32</span>)<span class="comment">//类型断言</span></span><br></pre></td></tr></table></figure>
<p>在进行类型断言时,如果类型不匹配,就会报 panic因此进行类型断言时,要确保原来的空接口指向的就是断言的类型</p>
<p>带检测的类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">float32</span> = <span class="number">2.1</span></span><br><span class="line">x = b2  <span class="comment">//空接口，可以接收任意类型</span></span><br><span class="line"><span class="comment">// x=&gt;float32 [使用类型断言]</span></span><br><span class="line"><span class="comment">//类型断言(带检测的)</span></span><br><span class="line"><span class="keyword">if</span> y, ok := x.(<span class="keyword">float32</span>); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert success"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"y 的类型是 %T 值是=%v"</span>, y, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"convert fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"继续执行..."</span>)</span><br></pre></td></tr></table></figure>
<p>可以通过这种方法判断输入参数的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个函数，可以判断输入的参数是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeJudge</span><span class="params">(items... <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">bool</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 bool 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">float32</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 float32 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">float64</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 float64 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 整数 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">string</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 string 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> Student :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 Student 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">case</span> *Student :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是 *Student 类型，值是%v\n"</span>, index, x)</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">            fmt.Printf(<span class="string">"第%v个参数是  类型 不确定，值是%v\n"</span>, index, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十二-文件操作"><a class="markdownIt-Anchor" href="#十二-文件操作"></a> 十二、文件操作</h2>
<p>文件在程序中是以流的形式来操作的</p>
<ul>
<li>流:数据在数据源(文件)和程序(内存)之间经历的路径</li>
<li>输入流:数据从数据源(文件)到程序(内存)的路径</li>
<li>输出流:数据从程序(内存)到数据源(文件)的路径</li>
</ul>
<p><code>os.File</code>封装所有文件相关操作,<code>File</code>是一个结构体。</p>
<h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>另外一种打开文件的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(file *File, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。（一般用于文件写入时的打开函数）</p>
<h3 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<h3 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h3>
<ul>
<li>
<p>带缓冲的读取：</p>
<ul>
<li>采取<code>bufio.NewReader(file)</code>新建缓存，缓存大小默认为4096</li>
</ul>
	<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NewReader创建一个具有默认大小缓冲、从r读取的*Reader。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="comment">//ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
	<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"open file err="</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数退出时，要及时的关闭file</span></span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">//要及时关闭file句柄，否则会有内存泄漏.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 *Reader  ，是带缓冲的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const (</span></span><br><span class="line"><span class="comment">defaultBufSize = 4096 //默认的缓冲区为4096</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="comment">//循环的读取文件的内容</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    str, err := reader.ReadString(<span class="string">'\n'</span>) <span class="comment">// 读到一个换行就结束</span></span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123; <span class="comment">// io.EOF表示文件的末尾</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    fmt.Printf(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"文件读取结束..."</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一次性读取（适合文件不大的情况下，效率低）</p>
<ul>
<li>
<p>利用函数<code>ioutil.ReadFile</code>一次性读取（无需打开文件，直接读取）</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ioutil.ReadFile一次性将文件读取到位</span></span><br><span class="line">file := <span class="string">"d:/test.txt"</span></span><br><span class="line">content, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"read file err=%v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把读取到的内容显示到终端</span></span><br><span class="line"><span class="comment">//fmt.Printf("%v", content) // []byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, <span class="keyword">string</span>(content)) <span class="comment">// []byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们没有显式的Open文件，因此也不需要显式的Close文件</span></span><br><span class="line"><span class="comment">//因为，文件的Open和Close被封装到 ReadFile 函数内部</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3>
<p>通过缓存，即<code>bufio</code>中的<code>bufio.NewWriter</code>写文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新文件，写入内容 5句 "hello, Gardon"</span></span><br><span class="line"><span class="comment">//1 .打开文件 d:/abc.txt</span></span><br><span class="line">filePath := <span class="string">"d:/abc.txt"</span></span><br><span class="line">file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"open file err=%v\n"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//及时关闭file句柄</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">//准备写入5句 "hello, Gardon"</span></span><br><span class="line">str := <span class="string">"hello,Gardon\r\n"</span> <span class="comment">// \r\n 表示换行</span></span><br><span class="line"><span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    writer.WriteString(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为writer是带缓存，因此在调用WriterString方法时，其实</span></span><br><span class="line"><span class="comment">//内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据</span></span><br><span class="line"><span class="comment">//真正写入到文件中， 否则文件中会没有数据!!!</span></span><br><span class="line">writer.Flush()</span><br></pre></td></tr></table></figure>
<p>通过<code>ioutil.WriteFile</code>写文件（无需打开文件，直接写入）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p>
<h3 id="判断文件是否存在"><a class="markdownIt-Anchor" href="#判断文件是否存在"></a> 判断文件是否存在</h3>
<p>golang判断文件或文件夹是否存在的方法为使用 os.Stat()函数返回的错误值进行判断</p>
<ul>
<li>1）如果返回的错误为nil，说明文件或文件夹存在</li>
<li>2）如果返回的错误类型使用 os.IsNotExist()判断为true，说明文件或文件夹不存在</li>
<li>3）如果返回的错误为其它类型则不确定是否在存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Stat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为*PathError类型。</p>
<h3 id="文件拷贝"><a class="markdownIt-Anchor" href="#文件拷贝"></a> 文件拷贝</h3>
<p>io包中的Copy函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</p>
<p>对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</p>
<p>注意：dst为Writer类型，src为Reader类型，需要NewWriter和NewReader函数进行创建</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="keyword">string</span>, srcFileName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    srcFile, err := os.Open(srcFileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"open file err=%v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> srcFile.Close()</span><br><span class="line">    <span class="comment">//通过srcfile ,获取到 Reader</span></span><br><span class="line">    reader := bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开dstFileName</span></span><br><span class="line">    dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY | os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"open file err=%v\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过dstFile, 获取到 Writer</span></span><br><span class="line">    writer := bufio.NewWriter(dstFile)</span><br><span class="line">    <span class="keyword">defer</span> dstFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//将d:/flower.jpg 文件拷贝到 e:/abc.jpg</span></span><br><span class="line">    <span class="comment">//调用CopyFile 完成文件拷贝</span></span><br><span class="line">    srcFile := <span class="string">"d:/flower.jpg"</span></span><br><span class="line">    dstFile := <span class="string">"e:/abc.jpg"</span></span><br><span class="line">    _, err := CopyFile(dstFile, srcFile)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"拷贝完成\n"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"拷贝错误 err=%v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h3>
<p><code>os.Args</code>是一Ar个 string的切片，用来存储所有的命令行参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"命令行的参数有"</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line"><span class="comment">//遍历os.Args切片，就可以得到所有的命令行输入参数值</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"args[%v]=%v\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用及结果</span></span><br><span class="line">test.exe tom d:/bbb/init.log <span class="number">909</span></span><br><span class="line">命令行的参数有 <span class="number">4</span></span><br><span class="line">args[<span class="number">0</span>]=test.exe</span><br><span class="line">args[<span class="number">1</span>]=tom</span><br><span class="line">args[<span class="number">2</span>]=d:/bbb/init.log</span><br><span class="line">args[<span class="number">3</span>]=<span class="number">909</span></span><br></pre></td></tr></table></figure>
<p>用<strong>flag包</strong>解析命令行参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span> <span class="title">Int64</span><span class="params">(name <span class="keyword">string</span>, value <span class="keyword">int64</span>, usage <span class="keyword">string</span>)</span> *<span class="title">int64</span></span></span><br></pre></td></tr></table></figure>
<p>Int64用指定的名称、默认值、使用信息注册一个int64类型flag。返回一个保存了该flag的值的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FlagSet)</span> <span class="title">StringVar</span><span class="params">(p *<span class="keyword">string</span>, name <span class="keyword">string</span>, value <span class="keyword">string</span>, usage <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>StringVar用指定的名称、默认值、使用信息注册一个string类型flag，并将flag的值保存到p指向的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>从os.Args[1:]中解析注册的flag。必须在所有flag都注册好而未访问其值时执行。未注册却使用flag -help时，会返回ErrHelp。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义几个变量，用于接收命令行的参数值</span></span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> pwd <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> host <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> port <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;user 就是接收用户命令行中输入的 -u 后面的参数值</span></span><br><span class="line"><span class="comment">//"u" ,就是 -u 指定参数</span></span><br><span class="line"><span class="comment">//"" , 默认值</span></span><br><span class="line"><span class="comment">//"用户名,默认为空" 说明</span></span><br><span class="line">flag.StringVar(&amp;user, <span class="string">"u"</span>, <span class="string">""</span>, <span class="string">"用户名,默认为空"</span>)</span><br><span class="line">flag.StringVar(&amp;pwd, <span class="string">"pwd"</span>, <span class="string">""</span>, <span class="string">"密码,默认为空"</span>)</span><br><span class="line">flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">"localhost"</span>, <span class="string">"主机名,默认为localhost"</span>)</span><br><span class="line">flag.IntVar(&amp;port, <span class="string">"port"</span>, <span class="number">3306</span>, <span class="string">"端口号，默认为3306"</span>)</span><br><span class="line"><span class="comment">//这里有一个非常重要的操作,转换， 必须调用该方法</span></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">//go build -o main.exe main.go编译为exe可执行文件后：</span></span><br><span class="line"><span class="comment">//执行命令：main.exe -u root -pwd 123456 -h 127.0.0.5 -port 8080</span></span><br><span class="line"><span class="comment">//该处会输出对应的结果</span></span><br><span class="line">fmt.Printf(<span class="string">"user=%v pwd=%v host=%v port=%v"</span>,</span><br><span class="line">           user, pwd, host, port)</span><br></pre></td></tr></table></figure>
<h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3>
<p>JSON易于机器解析和生成，并有效地提升网络传输效率，通常程序在网络传输时会先将数据（结构体、map等）序列化成json字符串，到接收方得到json字符串时，在反序列化恢复成原来的数据类型（结构体、map等）。这种方式已然成为各个语言的标准。</p>
<p>JSON键值对是用来保存数据一种方式，键/值对组合中的键名写在前面并用双引号&quot;&quot;包裹，使用冒号:分隔，然后紧接着值</p>
<p>任何数据类型都可以转换成JSON格式（对基本数据类型（int、float64等）序列化一般意义不大）</p>
<p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a>网站可以验证一个json格式的数据是否正确</p>
<h4 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h4>
<p><code>encoding/json</code>包中<code>Marshal</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>返回v的json编码。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化Struct</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"monster_name"`</span> <span class="comment">//反射机制</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"monster_age"`</span></span><br><span class="line">    Birthday <span class="keyword">string</span> <span class="comment">//....</span></span><br><span class="line">    Sal <span class="keyword">float64</span></span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">monster := Monster&#123;</span><br><span class="line">    Name :<span class="string">"牛魔王"</span>,</span><br><span class="line">    Age : <span class="number">500</span> ,</span><br><span class="line">    Birthday : <span class="string">"2011-11-11"</span>,</span><br><span class="line">    Sal : <span class="number">8000.0</span>,</span><br><span class="line">    Skill : <span class="string">"牛魔拳"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将monster 序列化</span></span><br><span class="line">data, err := json.Marshal(&amp;monster) <span class="comment">//..</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"序列号错误 err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出序列化后的结果</span></span><br><span class="line">fmt.Printf(<span class="string">"monster序列化后=%v\n"</span>, <span class="keyword">string</span>(data))</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化Map</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//使用map,需要make</span></span><br><span class="line">a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">a[<span class="string">"name"</span>] = <span class="string">"红孩儿"</span></span><br><span class="line">a[<span class="string">"age"</span>] = <span class="number">30</span></span><br><span class="line">a[<span class="string">"address"</span>] = <span class="string">"洪崖洞"</span></span><br><span class="line"><span class="comment">//将a这个map进行序列化</span></span><br><span class="line"><span class="comment">//将monster 序列化</span></span><br><span class="line">data, err := json.Marshal(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"序列化错误 err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出序列化后的结果</span></span><br><span class="line">fmt.Printf(<span class="string">"a map 序列化后=%v\n"</span>, <span class="keyword">string</span>(data))</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化slice</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//使用map前，需要先make</span></span><br><span class="line">m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m1[<span class="string">"name"</span>] = <span class="string">"jack"</span></span><br><span class="line">m1[<span class="string">"age"</span>] = <span class="string">"7"</span></span><br><span class="line">m1[<span class="string">"address"</span>] = <span class="string">"北京"</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"><span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//使用map前，需要先make</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m2[<span class="string">"name"</span>] = <span class="string">"tom"</span></span><br><span class="line">m2[<span class="string">"age"</span>] = <span class="string">"20"</span></span><br><span class="line">m2[<span class="string">"address"</span>] = [<span class="number">2</span>]<span class="keyword">string</span>&#123;<span class="string">"墨西哥"</span>,<span class="string">"夏威夷"</span>&#125;</span><br><span class="line">slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"><span class="comment">//将切片进行序列化操作</span></span><br><span class="line">data, err := json.Marshal(slice)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"序列化错误 err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出序列化后的结果</span></span><br><span class="line">fmt.Printf(<span class="string">"slice 序列化后=%v\n"</span>, <span class="keyword">string</span>(data))</span><br></pre></td></tr></table></figure>
<ul>
<li>对于结构体的序列化，如果我们希望序列化后的key的名字，由我们自己重新制定，那么可以给 struct指定一个tag标签</li>
</ul>
<h4 id="反序列化"><a class="markdownIt-Anchor" href="#反序列化"></a> 反序列化</h4>
<p><code>encoding/json</code>包中<code>Unmarshal</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>解析json编码的数据并将结果存入v指向的值</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化struct</span></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>  </span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Birthday <span class="keyword">string</span> <span class="comment">//....</span></span><br><span class="line">    Sal <span class="keyword">float64</span></span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">str := <span class="string">"&#123;\"Name\":\"牛魔王~~~\",\"Age\":500,\"Birthday\":\"2011-11-11\",\"Sal\":8000,\"Skill\":\"牛魔拳\"&#125;"</span></span><br><span class="line"><span class="comment">//定义一个Monster实例</span></span><br><span class="line"><span class="keyword">var</span> monster Monster</span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;monster)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"unmarshal err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"反序列化后 monster=%v monster.Name=%v \n"</span>, monster, monster.Name)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化map</span></span><br><span class="line">str := <span class="string">"&#123;\"address\":\"洪崖洞\",\"age\":30,\"name\":\"红孩儿\"&#125;"</span></span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="comment">//注意：反序列化map,不需要make,因为make操作被封装到 Unmarshal函数</span></span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"unmarshal err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"反序列化后 a=%v\n"</span>, a)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化slice</span></span><br><span class="line">str := <span class="string">"[&#123;\"address\":\"北京\",\"age\":\"7\",\"name\":\"jack\"&#125;,"</span> +</span><br><span class="line"><span class="string">"&#123;\"address\":[\"墨西哥\",\"夏威夷\"],\"age\":\"20\",\"name\":\"tom\"&#125;]"</span></span><br><span class="line"><span class="comment">//定义一个slice</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//反序列化，不需要make,因为make操作被封装到 Unmarshal函数</span></span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;slice)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"unmarshal err=%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"反序列化后 slice=%v\n"</span>, slice)</span><br></pre></td></tr></table></figure>
<ul>
<li>在反序列化串时，要确保<strong>反序列化后的数据类型</strong>和原来<strong>序列化前的数据类型</strong>一致</li>
<li>如果json字符串是通过程序获取到的，则不需要再对json字符串转义处理</li>
</ul>
<h2 id="十三-单元测试"><a class="markdownIt-Anchor" href="#十三-单元测试"></a> 十三、单元测试</h2>
<p>Go语言中自带有一个轻量级的测试框架 testing和自带的 go test命令来实现单元测试和性能测试， testing框架和其他语言中的测试框架类似，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试可以解决如下问题</p>
<ul>
<li>1）确保每个函数是可运行，并且运行结果是正确的</li>
<li>2）确保写出来的代码性能是好的</li>
<li>3）单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定</li>
</ul>
<p>testing框架测试原理：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2019/10/23/Go%E8%AF%AD%E8%A8%80/image-20200114104332453.png" alt="testing框架测试原理"></p>
<p>注意：</p>
<ul>
<li>测试用例文件名_test.go结尾。比如 cal_test. go,cal不是固定的</li>
<li>测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAddUpper
<ul>
<li>其中 Xxx 可以是任何字母数字字符串（但第一个字母不能是 [a-z]），用于识别测试例程</li>
</ul>
</li>
<li>TestAddUpper(t* tesing.T)的形参类型必须是<code>* testing.T</code>【看一下手册】</li>
<li>测试用例文件中，可以有多个测试用例函数，如 TestAddUpper、 TestSub</li>
<li>运行测试用例指令
<ul>
<li>（1） <code>cmd&gt;go test</code>【如果运行正确，无日志，错误时，会输出日志】</li>
<li>（2） <code>cmd&gt;go test -v</code>【运行正确或是错误，都输出日志】</li>
</ul>
</li>
<li>当出现错误时，可以使用 <code>t.Fatalf</code>来格式化输出错误信息，并退出程序</li>
<li><code>t.Logf</code>方法可以输出相应的日志</li>
<li>测试用例函数，并没有放在main函数中，也执行了，这就是测试用例的方便之处</li>
<li>PASS表示测试用例运行成功，FAIL表示测试用例运行失败</li>
<li>测试单个文件，一定要带上被测试的原文件：<code>go test -v cal_test.go(测试文件名) cal.go(测试文件所需要的函数)</code>
<ul>
<li>默认扫描整个目录下的所有测试文件</li>
</ul>
</li>
<li>测试单个方法：<code>go test -v -test.run TestAddUpper(待测试的方法名)</code></li>
</ul>
<h2 id="十四-反射"><a class="markdownIt-Anchor" href="#十四-反射"></a> 十四、反射</h2>
<p>基本介绍：</p>
<ul>
<li>反射可以在<strong>运行时</strong>动态获取变量的各种信息，比如变量的类型（type），类别（kind），kind范围大于type</li>
<li>如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</li>
<li>通过反射，可以使修改变量的值，可以调用关联的方法</li>
<li>使用反射需要<code>import (&quot;reflect&quot;)</code></li>
</ul>
<p>反射重要函数和概念：</p>
<ul>
<li><code>reflect.Type(变量名)</code>，获取变量的类型，返回 <code>reflect.Type</code>类型</li>
<li><code>reflect.Valueof(变量名)</code>，获取变量的值，返回 <code>reflect.Value</code>类型， <code>reflect.Value</code>是一结构体类型。通过 <code>reflect.Value</code>，可以获取到关于该变量的很多信息</li>
<li>变量、空接口<code>interface{}</code>、<code>reflect.Value</code>是可以相互转换的</li>
</ul>
<p>例子：</p>
<p>对基本数据类型、<code>interface{}</code>、<code>reflect.Value</code>进行反射</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//通过反射获取的传入的变量的 type类型 , kind类别, 值</span></span><br><span class="line">    <span class="comment">//1. 先获取到 reflect.Type</span></span><br><span class="line">    rTyp := reflect.TypeOf(b)</span><br><span class="line">    fmt.Println(<span class="string">"rType="</span>, rTyp)<span class="comment">//rType=int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取到 reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line">	fmt.Println(<span class="string">"rVal="</span>, rTyp)<span class="comment">//rVal=100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处需要转成int才能用于计算，上面能够直接输出是因为运行时存在值，为100。</span></span><br><span class="line">    <span class="comment">//此处如果不转化，会因为interface&#123;&#125;类型和2相加 而在编译阶段报错</span></span><br><span class="line">    n2 := <span class="number">2</span> + rVal.Int()</span><br><span class="line">    <span class="comment">//n3 := rVal.Float()</span></span><br><span class="line">    fmt.Println(<span class="string">"n2="</span>, n2)<span class="comment">//n2=102</span></span><br><span class="line">    <span class="comment">//fmt.Println("n3=", n3)</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal type=%T\n"</span>, rVal, rVal)<span class="comment">//rVal=100 rVal type=reflect.Value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面我们将 rVal 转成 interface&#123;&#125;</span></span><br><span class="line">    iV := rVal.Interface()</span><br><span class="line">    <span class="comment">//将 interface&#123;&#125; 通过断言转成需要的类型</span></span><br><span class="line">    num2 := iV.(<span class="keyword">int</span>)</span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>, num2)<span class="comment">//num2=100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个int</span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对结构体、<code>interface{}</code>、<code>reflect.Value</code>进行反射</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//通过反射获取的传入的变量的 type , kind, 值</span></span><br><span class="line">    <span class="comment">//1. 先获取到 reflect.Type 类型</span></span><br><span class="line">    rTyp := reflect.TypeOf(b)</span><br><span class="line">    fmt.Println(<span class="string">"rType="</span>, rTyp)<span class="comment">//rType=main.Student</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取到 reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取 变量对应的Kind 类别</span></span><br><span class="line">    <span class="comment">//(1) rVal.Kind() ==&gt; 返回的就是一个常量</span></span><br><span class="line">    kind1 := rVal.Kind()</span><br><span class="line">    <span class="comment">//(2) rTyp.Kind() ==&gt; 返回的也是常量，和上述方法一致</span></span><br><span class="line">    kind2 := rTyp.Kind()</span><br><span class="line">    fmt.Printf(<span class="string">"kind =%v kind=%v\n"</span>, kind1, kind2)<span class="comment">//kind =struct kind=struct</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面我们将 rVal 转成 interface&#123;&#125;</span></span><br><span class="line">    iV := rVal.Interface()</span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv type=%T \n"</span>, iV, iV)<span class="comment">//iv=&lt;tom 20&gt; iv type=main.Student</span></span><br><span class="line">    <span class="comment">//和上述例子一样，这里能够通过%v在运行时取出值，但是在编译时会因为类型问题不能够通过iV.Name或iV.Age取出变量值</span></span><br><span class="line">    <span class="comment">//将 interface&#123;&#125; 通过断言转成需要的类型可以解决上述问题</span></span><br><span class="line">    <span class="comment">//可以使用 swtich 的断言形式来做的更加的灵活</span></span><br><span class="line">    stu, ok := iV.(Student)<span class="comment">//防止同字段的别的结构体干扰，如Monster</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v\n"</span>, stu.Name)<span class="comment">//stu.Name=tom</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Student的实例</span></span><br><span class="line">    stu := Student&#123;</span><br><span class="line">        Name : <span class="string">"tom"</span>,</span><br><span class="line">        Age : <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项和细节：</p>
<ul>
<li><code>reflect.Value.Kind</code>，获取变量的类别，返回的是一个常量</li>
<li>Type是类型，Kind是类别，Type和Kind<strong>可能是相同的</strong>，也可能是不同的
<ul>
<li>比如：var num int=10 num的Type是int,Kind也是int</li>
<li>比如：var stu Student stu的type是 包名.Student , Kind是 struct</li>
</ul>
</li>
<li></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2019/10/23/Go%E8%AF%AD%E8%A8%80/">http://nu-ll.github.io/2019/10/23/Go语言/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/">Go语言入门经典</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/08/Xmanager%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%83%8F%E5%8C%96%E7%95%8C%E9%9D%A2/"><img class="prev-cover" data-lazy-src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Xmanager远程Ubuntu系统图像化界面</div></div></a></div><div class="next-post pull-right"><a href="/2019/10/18/LiCheePi_Zero%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/"><img class="next-cover" data-lazy-src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LiCheePi_Zero底层开发</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By spaceman</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>