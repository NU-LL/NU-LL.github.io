<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>Python | 无名小卒</title>
  <meta name="keywords" content=" 廖雪峰python教程 ">
  <meta name="description" content="Python | 无名小卒">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://NU-LL.github.io/about/index.html">
<meta property="og:site_name" content="无名小卒">
<meta property="og:description" content="关于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-21T14:30:10.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="关于">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>NU-LL</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/NU-LL" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="csdn" href="https://blog.csdn.net/CSDN_JZ_" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="email" href="mailto:1125934312@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1125934312&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=323374922" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(40)</small></div></li>
    
        
            
            <li><div data-rel="MCU">MCU<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Linux">Linux<small>(25)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程语言">编程语言<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="感悟与总结">感悟与总结<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="人工智能">人工智能<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a style="border-right: 1px solid #fff; width: 49%"  class="about site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">
<input type="hidden" id="yelog_site_word_count" value="243.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://github.com/NU-LL">NU-LL</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">ESP8266</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">DM9000C</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">网卡移植</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Kconfig语法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Latex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Ctex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">IIC驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux服务</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">LiCheePi Zero</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">文件描述符</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux内核</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Markdown</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Mininet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">字符驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">数据分析</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Xmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">远程链接</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">NanoPi Neo Core</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Kubernetes</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">network namespace</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">markdownlint</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">python实战</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">爬虫</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">u-boot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">二维数组</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">指针</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">存储器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">IAP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">BootLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">dual bank</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">按键驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">异步通知机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">根文件系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">等待队列</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_head_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">poll机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">TensorFlow2</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">快速排序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">网卡驱动框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">虚拟网卡</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">设备树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">输入子系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Go语言入门经典</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">驱动API</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">廖雪峰python教程</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="MCU "
           href="/2020/04/28/ESP8266/"
           data-tag="ESP8266"
           data-author="" >
            <span class="post-title" title="ESP8266">ESP8266</span>
            <span class="post-date" title="2020-04-28 14:27:54">2020/04/28</span>
        </a>
        
        <a  class="Linux "
           href="/2020/01/16/Docker/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="Docker">Docker</span>
            <span class="post-date" title="2020-01-16 20:14:51">2020/01/16</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/04/DM9000C网卡移植/"
           data-tag="DM9000C,网卡移植"
           data-author="" >
            <span class="post-title" title="DM9000C网卡移植">DM9000C网卡移植</span>
            <span class="post-date" title="2019-08-04 23:07:22">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/15/Kconfig文件语法分析/"
           data-tag="Kconfig语法"
           data-author="" >
            <span class="post-title" title="Kconfig文件语法分析">Kconfig文件语法分析</span>
            <span class="post-date" title="2019-08-15 19:38:40">2019/08/15</span>
        </a>
        
        <a  class="工具 "
           href="/2019/08/19/Latex排版全解/"
           data-tag="Latex,Ctex"
           data-author="" >
            <span class="post-title" title="Latex排版全解">Latex排版全解</span>
            <span class="post-date" title="2019-08-19 16:02:27">2019/08/19</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/05/IIC驱动/"
           data-tag="IIC驱动"
           data-author="" >
            <span class="post-title" title="IIC驱动">IIC驱动</span>
            <span class="post-date" title="2019-08-05 14:39:10">2019/08/05</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/28/Linux上常见服务搭建/"
           data-tag="Linux服务"
           data-author="" >
            <span class="post-title" title="Linux上常见服务搭建">Linux上常见服务搭建</span>
            <span class="post-date" title="2020-03-28 01:27:58">2020/03/28</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/LiCheePi_Zero底层开发/"
           data-tag="LiCheePi Zero"
           data-author="" >
            <span class="post-title" title="LiCheePi_Zero底层开发">LiCheePi_Zero底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/Linux编程--文件描述符fd/"
           data-tag="文件描述符"
           data-author="" >
            <span class="post-title" title="Linux编程--文件描述符fd">Linux编程--文件描述符fd</span>
            <span class="post-date" title="2019-07-21 10:13:47">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/13/Linux内核启动流程/"
           data-tag="Linux内核"
           data-author="" >
            <span class="post-title" title="Linux内核启动流程">Linux内核启动流程</span>
            <span class="post-date" title="2019-08-13 16:13:46">2019/08/13</span>
        </a>
        
        <a  class="工具 "
           href="/2019/07/12/Markdown 语法整理/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 语法整理">Markdown 语法整理</span>
            <span class="post-date" title="2019-07-12 13:57:24">2019/07/12</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/13/Mininet/"
           data-tag="Mininet"
           data-author="" >
            <span class="post-title" title="Mininet">Mininet</span>
            <span class="post-date" title="2020-02-13 18:37:12">2020/02/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/RTC驱动分析/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="RTC驱动分析">RTC驱动分析</span>
            <span class="post-date" title="2019-08-07 13:37:33">2019/08/07</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/03/10/Python数据分析与展示/"
           data-tag="数据分析"
           data-author="" >
            <span class="post-title" title="Python数据分析与展示">Python数据分析与展示</span>
            <span class="post-date" title="2020-03-10 15:10:50">2020/03/10</span>
        </a>
        
        <a  class="Linux "
           href="/2019/11/08/Xmanager远程Ubuntu系统图像化界面/"
           data-tag="Xmanager,远程链接"
           data-author="" >
            <span class="post-title" title="Xmanager远程Ubuntu系统图像化界面">Xmanager远程Ubuntu系统图像化界面</span>
            <span class="post-date" title="2019-11-08 22:58:53">2019/11/08</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/NanoPi_Neo_Core底层开发/"
           data-tag="NanoPi Neo Core"
           data-author="" >
            <span class="post-title" title="NanoPi_Neo_Core底层开发">NanoPi_Neo_Core底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/15/kubernetes/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes">Kubernetes</span>
            <span class="post-date" title="2020-03-15 13:48:53">2020/03/15</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/git/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <span class="post-date" title="2019-09-17 09:59:56">2019/09/17</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/10/linux 网络虚拟化： network namespace 简介/"
           data-tag="network namespace"
           data-author="" >
            <span class="post-title" title="linux 网络虚拟化： network namespace 简介">linux 网络虚拟化： network namespace 简介</span>
            <span class="post-date" title="2020-02-10 14:24:09">2020/02/10</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/markdownlint规则详细介绍/"
           data-tag="markdownlint"
           data-author="" >
            <span class="post-title" title="VSC插件之markdownlint规则详细介绍">VSC插件之markdownlint规则详细介绍</span>
            <span class="post-date" title="2019-09-17 15:00:13">2019/09/17</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/29/python实战/"
           data-tag="python实战"
           data-author="" >
            <span class="post-title" title="python实战">python实战</span>
            <span class="post-date" title="2020-01-29 21:36:32">2020/01/29</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/02/18/python爬虫/"
           data-tag="python,爬虫"
           data-author="" >
            <span class="post-title" title="python爬虫">python爬虫</span>
            <span class="post-date" title="2020-02-18 23:40:18">2020/02/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/06/二维数组与指针的一些问题/"
           data-tag="二维数组,指针"
           data-author="" >
            <span class="post-title" title="二维数组与指针的一些问题">二维数组与指针的一些问题</span>
            <span class="post-date" title="2019-08-06 13:11:26">2019/08/06</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/字符驱动设备的另一种写法/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="字符驱动设备的另一种写法">字符驱动设备的另一种写法</span>
            <span class="post-date" title="2019-08-07 12:20:30">2019/08/07</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/11/各种存储器的区别/"
           data-tag="存储器"
           data-author="" >
            <span class="post-title" title="各种存储器的区别">各种存储器的区别</span>
            <span class="post-date" title="2019-08-11 10:57:19">2019/08/11</span>
        </a>
        
        <a  class="MCU "
           href="/2019/11/12/基于STM32L476的IAP升级/"
           data-tag="IAP,BootLoader,dual bank"
           data-author="" >
            <span class="post-title" title="基于STM32L476的IAP升级">基于STM32L476的IAP升级</span>
            <span class="post-date" title="2019-11-12 22:47:40">2019/11/12</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/22/按键驱动：异步通知机制/"
           data-tag="按键驱动,异步通知机制"
           data-author="" >
            <span class="post-title" title="按键驱动：异步通知机制">按键驱动：异步通知机制</span>
            <span class="post-date" title="2019-07-22 19:04:24">2019/07/22</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/14/构造根文件系统/"
           data-tag="根文件系统"
           data-author="" >
            <span class="post-title" title="构造根文件系统">构造根文件系统</span>
            <span class="post-date" title="2019-08-14 20:18:45">2019/08/14</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/linux等待队列wait_queue_head_t和wait_queue_t/"
           data-tag="等待队列,wait_queue_head_t,wait_queue_t"
           data-author="" >
            <span class="post-title" title="linux等待队列wait_queue_head_t和wait_queue_t">linux等待队列wait_queue_head_t和wait_queue_t</span>
            <span class="post-date" title="2019-07-21 18:18:54">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/按键驱动——poll机制/"
           data-tag="按键驱动,poll机制"
           data-author="" >
            <span class="post-title" title="按键驱动——poll机制">按键驱动——poll机制</span>
            <span class="post-date" title="2019-07-21 20:30:38">2019/07/21</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/01/03/深度学习与TensorFlow2/"
           data-tag="深度学习,TensorFlow2"
           data-author="" >
            <span class="post-title" title="深度学习与TensorFlow2">深度学习与TensorFlow2</span>
            <span class="post-date" title="2020-01-03 21:04:26">2020/01/03</span>
        </a>
        
        <a  class="算法 "
           href="/2019/07/29/快速排序/"
           data-tag="快速排序"
           data-author="" >
            <span class="post-title" title="快速排序">快速排序</span>
            <span class="post-date" title="2019-07-29 22:27:34">2019/07/29</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/04/网卡驱动程序/"
           data-tag="网卡驱动框架,虚拟网卡"
           data-author="" >
            <span class="post-title" title="网卡驱动程序">网卡驱动程序</span>
            <span class="post-date" title="2019-08-04 21:24:07">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/13/设备树/"
           data-tag="设备树"
           data-author="" >
            <span class="post-title" title="设备树">设备树</span>
            <span class="post-date" title="2019-10-13 15:53:24">2019/10/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/25/输入子系统/"
           data-tag="按键驱动,输入子系统"
           data-author="" >
            <span class="post-title" title="输入子系统">输入子系统</span>
            <span class="post-date" title="2019-07-25 00:05:15">2019/07/25</span>
        </a>
        
        <a  class="编程语言 "
           href="/2019/10/23/Go语言/"
           data-tag="Go语言入门经典"
           data-author="" >
            <span class="post-title" title="Go语言">Go语言</span>
            <span class="post-date" title="2019-10-23 21:07:25">2019/10/23</span>
        </a>
        
        <a  class="Linux "
           href="/2020/04/06/Linux驱动常用API整理/"
           data-tag="驱动API"
           data-author="" >
            <span class="post-title" title="Linux驱动常用API整理">Linux驱动常用API整理</span>
            <span class="post-date" title="2020-04-06 22:48:09">2020/04/06</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/u-boot分析与使用 - 老版本备份/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/10/python/"
           data-tag="廖雪峰python教程"
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2020-01-10 20:18:52">2020/01/10</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-python" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Python</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="编程语言">编程语言</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color2">廖雪峰python教程</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-02-24 19:15:08'>2020-01-10 20:18</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:55k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、基础"><span class="toc-text">一、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-前言"><span class="toc-text">0.前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数据类型和变量"><span class="toc-text">1.数据类型和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1数据类型"><span class="toc-text">1.1数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2变量"><span class="toc-text">1.2变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3常量"><span class="toc-text">1.3常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4除法相关"><span class="toc-text">1.4除法相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-字符串和编码"><span class="toc-text">2.字符串和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0前言-字符编码"><span class="toc-text">2.0前言 字符编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1Python的字符串"><span class="toc-text">2.1Python的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2格式化"><span class="toc-text">2.2格式化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用list和tuple"><span class="toc-text">3.使用list和tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1list列表"><span class="toc-text">3.1list列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2tuple元组"><span class="toc-text">3.2tuple元组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1tuple的本质"><span class="toc-text">3.2.1tuple的本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-条件判断"><span class="toc-text">4.条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1if语句"><span class="toc-text">4.1if语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2input"><span class="toc-text">4.2input</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-循环"><span class="toc-text">5.循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-使用dict和set"><span class="toc-text">6.使用dict和set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1dict字典"><span class="toc-text">6.1dict字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2set"><span class="toc-text">6.2set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3不可变对象"><span class="toc-text">6.3不可变对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、函数"><span class="toc-text">二、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-调用函数"><span class="toc-text">1.调用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1数据类型转换"><span class="toc-text">1.1数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-定义函数"><span class="toc-text">2.定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1空函数"><span class="toc-text">2.1空函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2返回多个值"><span class="toc-text">2.2返回多个值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3函数的参数"><span class="toc-text">3函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1位置参数"><span class="toc-text">3.1位置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2默认参数"><span class="toc-text">3.2默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3可变参数"><span class="toc-text">3.3可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4关键字参数"><span class="toc-text">3.4关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5命名关键字参数"><span class="toc-text">3.5命名关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6组合参数"><span class="toc-text">3.6组合参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4递归函数"><span class="toc-text">4递归函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、高级特性"><span class="toc-text">三、高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1切片"><span class="toc-text">3.1切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2迭代"><span class="toc-text">3.2迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3列表生成式"><span class="toc-text">3.3列表生成式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4生成器"><span class="toc-text">3.4生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5迭代器"><span class="toc-text">3.5迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、函数式编程"><span class="toc-text">四、函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1高阶函数"><span class="toc-text">4.1高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1map-reduce"><span class="toc-text">4.1.1map/reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2filter"><span class="toc-text">4.1.2filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3sorted"><span class="toc-text">4.1.3sorted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2返回函数"><span class="toc-text">4.2返回函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1闭包"><span class="toc-text">4.2.1闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2关键字global与nonlocal"><span class="toc-text">4.2.2关键字global与nonlocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3匿名函数"><span class="toc-text">4.3匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4装饰器"><span class="toc-text">4.4装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5偏函数"><span class="toc-text">4.5偏函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、模块"><span class="toc-text">五、模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0模块和包"><span class="toc-text">5.0模块和包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1使用模块"><span class="toc-text">5.1使用模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2安装第三方模块"><span class="toc-text">5.2安装第三方模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1模块搜索路径"><span class="toc-text">5.2.1模块搜索路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、面向对象编程"><span class="toc-text">六、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1类和实例"><span class="toc-text">6.1类和实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1数据封装"><span class="toc-text">6.1.1数据封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2访问限制"><span class="toc-text">6.2访问限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3继承和多态"><span class="toc-text">6.3继承和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1静态语言和动态语言在此处的区别"><span class="toc-text">6.3.1静态语言和动态语言在此处的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4获取对象信息"><span class="toc-text">6.4获取对象信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type"><span class="toc-text">type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isinstance"><span class="toc-text">isinstance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dir"><span class="toc-text">dir</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5实例属性和类属性"><span class="toc-text">6.5实例属性和类属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、面向对象高级编程"><span class="toc-text">七、面向对象高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1使用-slots"><span class="toc-text">7.1使用_slots_</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2使用-property"><span class="toc-text">7.2使用@property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3多重继承"><span class="toc-text">7.3多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1MinIn"><span class="toc-text">7.3.1MinIn</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4定制类"><span class="toc-text">7.4定制类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-str-、-repr"><span class="toc-text">7.4.1__str__、_repr_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-iter"><span class="toc-text">7.4.2_iter_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-getitem"><span class="toc-text">7.4.3_getitem_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-getattr"><span class="toc-text">7.4.4_getattr_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-5-call"><span class="toc-text">7.4.5_call_</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5使用枚举类"><span class="toc-text">7.5使用枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6使用元类"><span class="toc-text">7.6使用元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1type"><span class="toc-text">7.6.1type()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2metaclass"><span class="toc-text">7.6.2metaclass</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、错误、调试和测试"><span class="toc-text">八、错误、调试和测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1错误处理"><span class="toc-text">8.1错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1try"><span class="toc-text">8.1.1try</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2调用栈"><span class="toc-text">8.1.2调用栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3记录错误"><span class="toc-text">8.1.3记录错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4抛出错误"><span class="toc-text">8.1.4抛出错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2调试"><span class="toc-text">8.2调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1断言"><span class="toc-text">8.2.1断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2logging"><span class="toc-text">8.2.2logging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3pdb"><span class="toc-text">8.2.3pdb</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3单元测试"><span class="toc-text">8.3单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1运行单元测试"><span class="toc-text">8.3.1运行单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2setUp与tearDown"><span class="toc-text">8.3.2setUp与tearDown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3文档测试"><span class="toc-text">8.3.3文档测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、IO编程"><span class="toc-text">九、IO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1文件读写"><span class="toc-text">9.1文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1读文件"><span class="toc-text">9.1.1读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2file-like-object"><span class="toc-text">9.1.2file-like object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3写文件"><span class="toc-text">9.1.3写文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2StringIO和BytesIO"><span class="toc-text">9.2StringIO和BytesIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1StringIO"><span class="toc-text">9.2.1StringIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2BytesIO"><span class="toc-text">9.2.2BytesIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3操作文件和目录"><span class="toc-text">9.3操作文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1环境变量"><span class="toc-text">9.3.1环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2操作文件和目录"><span class="toc-text">9.3.2操作文件和目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4序列化"><span class="toc-text">9.4序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1pickle"><span class="toc-text">9.4.1pickle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2JSON"><span class="toc-text">9.4.2JSON</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、进程和线程"><span class="toc-text">十、进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1多进程"><span class="toc-text">10.1多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1multiprocessing"><span class="toc-text">10.1.1multiprocessing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2pool"><span class="toc-text">10.1.2pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3子进程"><span class="toc-text">10.1.3子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4进程间通信"><span class="toc-text">10.1.4进程间通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2多线程"><span class="toc-text">10.2多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1Lock"><span class="toc-text">10.2.1Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2多核CPU"><span class="toc-text">10.2.2多核CPU</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3ThreadLocal"><span class="toc-text">10.3ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4分布式进程"><span class="toc-text">10.4分布式进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、正则表达式"><span class="toc-text">十二、正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1基础"><span class="toc-text">12.1基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2进阶"><span class="toc-text">12.2进阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3re模块"><span class="toc-text">12.3re模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4切分字符串"><span class="toc-text">12.4切分字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5分组"><span class="toc-text">12.5分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6贪婪匹配"><span class="toc-text">12.6贪婪匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7编译"><span class="toc-text">12.7编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、常用内置模块"><span class="toc-text">十三、常用内置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1datetime"><span class="toc-text">13.1datetime</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1获取当前日期和时间"><span class="toc-text">13.1.1获取当前日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2获取指定日期和时间"><span class="toc-text">13.1.2获取指定日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3datetime转换为timestamp"><span class="toc-text">13.1.3datetime转换为timestamp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-4timestamp转换为datetime"><span class="toc-text">13.1.4timestamp转换为datetime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-5str转换为datetime"><span class="toc-text">13.1.5str转换为datetime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-6datetime转换为str"><span class="toc-text">13.1.6datetime转换为str</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-7datetime加减"><span class="toc-text">13.1.7datetime加减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-8本地时间转换为UTC时间"><span class="toc-text">13.1.8本地时间转换为UTC时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-9时区转换"><span class="toc-text">13.1.9时区转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2collections"><span class="toc-text">13.2collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1namedtuple"><span class="toc-text">13.2.1namedtuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2deque"><span class="toc-text">13.2.2deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3defaultdict"><span class="toc-text">13.2.3defaultdict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4OrderedDict"><span class="toc-text">13.2.4OrderedDict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-5ChainMap"><span class="toc-text">13.2.5ChainMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-6Counter"><span class="toc-text">13.2.6Counter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3base64"><span class="toc-text">13.3base64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4struct"><span class="toc-text">13.4struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5hashlib"><span class="toc-text">13.5hashlib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6hmac"><span class="toc-text">13.6hmac</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7itertools"><span class="toc-text">13.7itertools</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-1chain"><span class="toc-text">13.7.1chain()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-2groupby"><span class="toc-text">13.7.2groupby()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8contextlib"><span class="toc-text">13.8contextlib</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-1-contextmanager"><span class="toc-text">13.8.1@contextmanager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-2-closing"><span class="toc-text">13.8.2@closing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9urllib"><span class="toc-text">13.9urllib</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-9-1Get"><span class="toc-text">13.9.1Get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-9-2Post"><span class="toc-text">13.9.2Post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-9-3Handler"><span class="toc-text">13.9.3Handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四、常用第三方模块"><span class="toc-text">十四、常用第三方模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1Pillow"><span class="toc-text">14.1Pillow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-1操作图像"><span class="toc-text">14.1.1操作图像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2requests"><span class="toc-text">14.2requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3chardet"><span class="toc-text">14.3chardet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4psutil"><span class="toc-text">14.4psutil</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1获取CPU信息"><span class="toc-text">14.4.1获取CPU信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2获取内存信息"><span class="toc-text">14.4.2获取内存信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3获取磁盘信息"><span class="toc-text">14.4.3获取磁盘信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-4获取网络信息"><span class="toc-text">14.4.4获取网络信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-5获取进程信息"><span class="toc-text">14.4.5获取进程信息</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>感谢廖雪峰老师提供这么好的教程，此文档为本人学习中所做笔记</p>
<p>以<code>#</code>开头的语句是注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p>
<p>Python程序是大小写敏感的，如果写错了大小写，程序会报错。</p>
<p>按照约定俗成的惯例，应该始终坚持使用<strong><em>4个空格</em></strong>的缩进。</p>
<h3 id="1-数据类型和变量"><a href="#1-数据类型和变量" class="headerlink" title="1.数据类型和变量"></a>1.数据类型和变量</h3><h4 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h4><ul>
<li><p>整数</p>
<ul>
<li>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。</p>
</li>
<li><p>为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p>
<pre><code class="python">  &gt;&gt;&gt; print(&#39;\\\t\\&#39;)
  \       \
  &gt;&gt;&gt; print(r&#39;\\\t\\&#39;)
  \\\t\\</code></pre>
</li>
<li><p>为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p>
<pre><code class="python">  &gt;&gt;&gt; print(&#39;&#39;&#39;line1
  ... line2
  ... line3&#39;&#39;&#39;)
  line1
  line2
  line3</code></pre>
<p>  上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入，注意<code>...</code>是提示符，不是代码的一部分</p>
</li>
<li><p>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用</p>
<pre><code class="python">  print(r&#39;&#39;&#39;hello,\n
  world&#39;&#39;&#39;)
  #结果如下
  hello,\n
  world</code></pre>
</li>
</ul>
</li>
<li><p>布尔值</p>
<ul>
<li>布尔值只有<code>True</code>、<code>False</code>两种值</li>
<li>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</li>
</ul>
</li>
<li><p>空值</p>
<ul>
<li>空值是Python里一个特殊的值，用<code>None</code>表示</li>
<li><code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</li>
</ul>
</li>
</ul>
<h4 id="1-2变量"><a href="#1-2变量" class="headerlink" title="1.2变量"></a>1.2变量</h4><p>可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>
<p>这种 变量本身类型 不固定的语言称之为<em>动态语言<em>，与之对应的是</em>静态语言</em></p>
<p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p>
<h4 id="1-3常量"><a href="#1-3常量" class="headerlink" title="1.3常量"></a>1.3常量</h4><p>常量就是不能变的变量。在Python中，通常用全部大写的变量名表示常量：</p>
<pre><code class="python">PI = 3.14159265359</code></pre>
<p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变</p>
<h4 id="1-4除法相关"><a href="#1-4除法相关" class="headerlink" title="1.4除法相关"></a>1.4除法相关</h4><p>在Python中，有两种除法，一种除法是<code>/</code>：</p>
<pre><code class="python">&gt;&gt;&gt; 10 / 3
3.3333333333333335
&gt;&gt;&gt; 9 / 3
3.0</code></pre>
<p><code>/</code>除法计算结果是<strong>浮点数</strong>，即使是两个整数恰好整除，结果也是浮点数</p>
<p>还有一种除法是<code>//</code>，称为<strong>地板除</strong>，两个整数的除法仍然是整数：</p>
<pre><code class="python">&gt;&gt;&gt; 10 // 3
3</code></pre>
<p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个<strong>余数运算</strong>，可以得到两个整数相除的余数：</p>
<pre><code class="python">&gt;&gt;&gt; 10 % 3
1</code></pre>
<h3 id="2-字符串和编码"><a href="#2-字符串和编码" class="headerlink" title="2.字符串和编码"></a>2.字符串和编码</h3><h4 id="2-0前言-字符编码"><a href="#2-0前言-字符编码" class="headerlink" title="2.0前言 字符编码"></a>2.0前言 字符编码</h4><p><strong>历史关系</strong></p>
<p>捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>
<p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p>
<p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>&#39;0&#39;</code>和整数<code>0</code>是不同的；</p>
<p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p>
<p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td>x</td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody></table>
<p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<p><strong>计算机系统通用的字符编码工作方式</strong></p>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/0.png" alt="rw-file-utf-8"></p>
<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/0-1578660589334.png" alt="web-utf-8"></p>
<p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p>
<h4 id="2-1Python的字符串"><a href="#2-1Python的字符串" class="headerlink" title="2.1Python的字符串"></a>2.1Python的字符串</h4><p>在最新的Python 3版本中，字符串是以Unicode编码的</p>
<p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p>
<pre><code class="python">&gt;&gt;&gt; ord(&#39;A&#39;)
65
&gt;&gt;&gt; ord(&#39;中&#39;)
20013
&gt;&gt;&gt; chr(66)
&#39;B&#39;
&gt;&gt;&gt; chr(25991)
&#39;文&#39;</code></pre>
<p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;\u4e2d\u6587&#39;
&#39;中文&#39;</code></pre>
<p>两种写法完全是等价的。</p>
<p>由上文可知，Python的字符串在内存中以Unicode表示，如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p>
<p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p>
<pre><code class="python">x = b&#39;ABC&#39;</code></pre>
<p>要注意<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，虽然内容显示一样，但<code>bytes</code>的每个字符都只占用一个字节。</p>
<p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)
b&#39;ABC&#39;
&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;ascii&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)</code></pre>
<p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p>
<p>反过来，要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; b&#39;ABC&#39;.decode(&#39;ascii&#39;)
&#39;ABC&#39;
&gt;&gt;&gt; b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)
&#39;中文&#39;</code></pre>
<p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错</p>
<p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p>
<pre><code class="python">&gt;&gt;&gt; b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)
&#39;中&#39;</code></pre>
<p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数，如果将<code>str</code>换成<code>bytes</code>，<code>len()</code>函数就计算字节数</p>
<ul>
<li>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</li>
</ul>
<p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p>
<p>当你的源代码中包含中文的时候，就需要务必指定保存为UTF-8编码。我们通常在文件开头写上这两行：</p>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-</code></pre>
<ul>
<li><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
</li>
<li><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
</li>
</ul>
<h4 id="2-2格式化"><a href="#2-2格式化" class="headerlink" title="2.2格式化"></a>2.2格式化</h4><p>和C语言是一致的，用<code>%</code>实现：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;Hello, %s&#39; % &#39;world&#39;
&#39;Hello, world&#39;
&gt;&gt;&gt; &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)
&#39;Hi, Michael, you have $1000000.&#39;</code></pre>
<p>在字符串内部，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody></table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p>
<pre><code class="python">&gt;&gt;&gt; print(&#39;%2d-%02d&#39; % (3, 1))
 3-01
&gt;&gt;&gt; print(&#39;%.2f&#39; % 3.1415926)
3.14</code></pre>
<p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)
&#39;Age: 25. Gender: True&#39;</code></pre>
<p>当需要显示<code>%</code>时，用<code>%%</code>来转义成<code>%</code></p>
<p><strong>format()</strong></p>
<p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比%要麻烦得多：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)
&#39;Hello, 小明, 成绩提升了 17.1%&#39;</code></pre>
<h3 id="3-使用list和tuple"><a href="#3-使用list和tuple" class="headerlink" title="3.使用list和tuple"></a>3.使用list和tuple</h3><h4 id="3-1list列表"><a href="#3-1list列表" class="headerlink" title="3.1list列表"></a>3.1list列表</h4><p>list，列表，是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>用<code>len()</code>函数可以获得list元素的个数</p>
<p>基础操作类似于数组</p>
<pre><code class="python">#创建
&gt;&gt;&gt; classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
#获取长度
&gt;&gt;&gt; len(classmates)
3
#访问元素 0~3
&gt;&gt;&gt; classmates[0]
&#39;Michael&#39;
#反向 访问元素 -1~-3
&gt;&gt;&gt; classmates[-1]
&#39;Tracy&#39;</code></pre>
<p>增加，删除：</p>
<pre><code class="python">#追加元素到末尾
&gt;&gt;&gt; classmates.append(&#39;Adam&#39;)
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]
#插入到指定的位置
&gt;&gt;&gt; classmates.insert(1, &#39;Jack&#39;)
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]
#删除list末尾的元素
&gt;&gt;&gt; classmates.pop()
&#39;Adam&#39;
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
#删除指定位置的元素
&gt;&gt;&gt; classmates.pop(1)
&#39;Jack&#39;
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
#某个元素替换成别的元素
&gt;&gt;&gt; classmates[1] = &#39;Sarah&#39;
&gt;&gt;&gt; classmates
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]</code></pre>
<p>list里面的元素的<strong>数据类型可以不同</strong>：</p>
<pre><code class="python">&gt;&gt;&gt; L = [&#39;Apple&#39;, 123, True]
#list元素也可以是另一个list
&gt;&gt;&gt; s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;]
&gt;&gt;&gt; len(s)
4
#要拿到&#39;php&#39;可以写s[2][1]，类似二维数组</code></pre>
<p>空的list，长度为0</p>
<p>注意：</p>
<p>list实际上可以理解为一个指向数组的指针，也就是说list和tuple的底层实现有点类似（见后文中的 tuple的本质 章节），所以普通的list赋值是指针的赋值：</p>
<pre><code class="python">a = [1,2,3]
b = a#将a赋值给b之后，a和b指向同一块区域
b = [1,2]#修改后a、b均修改
#这里需要拷贝：
a = [1,2,3]
b = a[:]#将a中内容全部拷贝给b，a和b指向不同区域
b = [1,2]#修改后 a中内容不会修改</code></pre>
<h4 id="3-2tuple元组"><a href="#3-2tuple元组" class="headerlink" title="3.2tuple元组"></a>3.2tuple元组</h4><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦<strong>初始化就不能修改</strong>，所以没有append()，insert()这样的方法。其他获取元素的方法和list是一样。</p>
<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p>
<p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就<strong>必须被确定下来</strong>，比如：</p>
<pre><code class="python">&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t
(1, 2)
#定义一个空的tuple（注意这里是tuple，不是数学公式中的小括号）
&gt;&gt;&gt; t = ()
&gt;&gt;&gt; t
()</code></pre>
<p>注意：只有1个元素的tuple定义时为了和数学公式中的小括号区分，必须加一个<strong>逗号</strong><code>,</code>来消除歧义：</p>
<pre><code class="python">&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; t
(1,)</code></pre>
<h5 id="3-2-1tuple的本质"><a href="#3-2-1tuple的本质" class="headerlink" title="3.2.1tuple的本质"></a>3.2.1tuple的本质</h5><p>tuple的本质有点类似C语言中的<code>const *</code>，即tuple的每个元素，指向永远不变。</p>
<p>例子：</p>
<pre><code class="python">&gt;&gt;&gt; t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
&gt;&gt;&gt; t[2][0] = &#39;X&#39;
&gt;&gt;&gt; t[2][1] = &#39;Y&#39;
&gt;&gt;&gt; t
(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])</code></pre>
<p>这个tuple定义的时候有3个元素，分别是<code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个list。但是tuple最后却变了，为什么？</p>
<p>我们先看看定义的时候tuple包含的3个元素：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/0-1578666556949.png" alt="tuple-0"></p>
<p>当我们把list的元素<code>&#39;A&#39;</code>和<code>&#39;B&#39;</code>修改为<code>&#39;X&#39;</code>和<code>&#39;Y&#39;</code>后，tuple变为：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/0-1578666556950.png" alt="tuple-1"></p>
<p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<p>要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>
<h3 id="4-条件判断"><a href="#4-条件判断" class="headerlink" title="4.条件判断"></a>4.条件判断</h3><h4 id="4-1if语句"><a href="#4-1if语句" class="headerlink" title="4.1if语句"></a>4.1if语句</h4><p><code>elif</code>是<code>else if</code>的缩写，可以有多个<code>elif</code>，<code>if</code>语句的完整形式是：</p>
<pre><code class="python">if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;</code></pre>
<p><code>if</code>判断条件还可以简写，比如写：</p>
<pre><code class="python">if x:
    print(&#39;True&#39;)</code></pre>
<p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<h4 id="4-2input"><a href="#4-2input" class="headerlink" title="4.2input"></a>4.2input</h4><p>用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思。</p>
<p>注意：<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p>
<pre><code class="python">s = input(&#39;birth: &#39;)
birth = int(s)
if birth &lt; 2000:
    print(&#39;00前&#39;)
else:
    print(&#39;00后&#39;)</code></pre>
<h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h3><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，即<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p>
<p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。</p>
<pre><code class="python">&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
#循环
sum = 0
for x in range(101):
    sum = sum + x
print(sum)</code></pre>
<p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。</p>
<pre><code class="python">sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)</code></pre>
<p>在循环中，<code>break</code>语句可以提前退出循环。</p>
<p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p>
<h3 id="6-使用dict和set"><a href="#6-使用dict和set" class="headerlink" title="6.使用dict和set"></a>6.使用dict和set</h3><h4 id="6-1dict字典"><a href="#6-1dict字典" class="headerlink" title="6.1dict字典"></a>6.1dict字典</h4><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<pre><code class="python">#初始化
&gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
&gt;&gt;&gt; d[&#39;Michael&#39;]
95
#通过key将数据放入dict
&gt;&gt;&gt; d[&#39;Adam&#39;] = 67
&gt;&gt;&gt; d[&#39;Adam&#39;]
67
#替换
&gt;&gt;&gt; d[&#39;Jack&#39;] = 90
&gt;&gt;&gt; d[&#39;Jack&#39;]
90
&gt;&gt;&gt; d[&#39;Jack&#39;] = 88
&gt;&gt;&gt; d[&#39;Jack&#39;]
88
#删除，对应的value也会从dict中删除
&gt;&gt;&gt; d.pop(&#39;Bob&#39;)
75
&gt;&gt;&gt; d
{&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85}</code></pre>
<p>如果key不存在，dict就会报错</p>
<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;Thomas&#39; in d
False</code></pre>
<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<pre><code class="python">&gt;&gt;&gt; d.get(&#39;Thomas&#39;)
&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)
-1</code></pre>
<p>注意：</p>
<ul>
<li>返回<code>None</code>的时候Python的交互环境不显示结果。</li>
<li>dict内部存放的顺序和key放入的顺序是没有关系的。</li>
<li>dict的key必须是<strong>不可变对象</strong>。（哈希算法，利用key计算value的位置）<ul>
<li>字符串、整数等都是不可变的，而list是可变的，不能作为key</li>
</ul>
</li>
</ul>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<h4 id="6-2set"><a href="#6-2set" class="headerlink" title="6.2set"></a>6.2set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<pre><code class="python">&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s
{1, 2, 3}
#重复元素在set中自动被过滤
&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; s
{1, 2, 3}</code></pre>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
<p>基本操作：</p>
<pre><code class="python">#添加 可以重复添加，但不会有效果
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
#删除
&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; s
{1, 2, 3}</code></pre>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的<strong>交集</strong>、<strong>并集</strong>等操作：</p>
<pre><code class="python">&gt;&gt;&gt; s1 = set([1, 2, 3])
&gt;&gt;&gt; s2 = set([2, 3, 4])
&gt;&gt;&gt; s1 &amp; s2
{2, 3}
&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4}</code></pre>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样<strong>不可以放入可变对象</strong>，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</p>
<h4 id="6-3不可变对象"><a href="#6-3不可变对象" class="headerlink" title="6.3不可变对象"></a>6.3不可变对象</h4><p>上面我们讲了，str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<pre><code class="python">&gt;&gt;&gt; a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39;
&gt;&gt;&gt; a.replace(&#39;a&#39;, &#39;A&#39;)
&#39;Abc&#39;
&gt;&gt;&gt; a
&#39;abc&#39;</code></pre>
<p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>&#39;Abc&#39;</code>，但变量<code>a</code>最后仍是<code>&#39;abc&#39;</code>，应该怎么理解呢？</p>
<p>我们先把代码改成下面这样：</p>
<pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39;
&gt;&gt;&gt; b = a.replace(&#39;a&#39;, &#39;A&#39;)
&gt;&gt;&gt; b
&#39;Abc&#39;
&gt;&gt;&gt; a
&#39;abc&#39;</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p>
<pre><code class="ascii">┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ &#39;abc&#39; │
└───┘                  └───────┘</code></pre>
<p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p>
<pre><code class="ascii">┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ &#39;abc&#39; │
└───┘                  └───────┘
┌───┐                  ┌───────┐
│ b │─────────────────&gt;│ &#39;Abc&#39; │
└───┘                  └───────┘</code></pre>
<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1-调用函数"><a href="#1-调用函数" class="headerlink" title="1.调用函数"></a>1.调用函数</h3><p>Python的官方网站查看内置函数文档：<a href="https://docs.python.org/zh-cn/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/functions.html</a></p>
<h4 id="1-1数据类型转换"><a href="#1-1数据类型转换" class="headerlink" title="1.1数据类型转换"></a>1.1数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数，<code>hex()</code>函数把一个整数转换成十六进制表示的字符串</p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<pre><code class="python">&gt;&gt;&gt; a = abs # 变量a指向abs函数
&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
1</code></pre>
<h3 id="2-定义函数"><a href="#2-定义函数" class="headerlink" title="2.定义函数"></a>2.定义函数</h3><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>
<pre><code class="python">def my_abs(x):
    if x &gt;= 0:
        return x
    else:
        return -x
print(my_abs(-99))
#增加对参数类型的检查
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError(&#39;bad operand type&#39;)
    if x &gt;= 0:
        return x
    else:
        return -x</code></pre>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p>
<h4 id="2-1空函数"><a href="#2-1空函数" class="headerlink" title="2.1空函数"></a>2.1空函数</h4><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p>
<pre><code class="python">def nop():
    pass</code></pre>
<p><code>pass</code>语句可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>
<h4 id="2-2返回多个值"><a href="#2-2返回多个值" class="headerlink" title="2.2返回多个值"></a>2.2返回多个值</h4><p>例如：</p>
<pre><code class="python">import math
def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny</code></pre>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<pre><code class="python">#看起来是两个值
&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(x, y)
151.96152422706632 70.0
#实际上是一个tuple
&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print(r)
(151.96152422706632, 70.0)</code></pre>
<p>在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="3函数的参数"><a href="#3函数的参数" class="headerlink" title="3函数的参数"></a>3函数的参数</h3><h4 id="3-1位置参数"><a href="#3-1位置参数" class="headerlink" title="3.1位置参数"></a>3.1位置参数</h4><pre><code class="python">def power(x):
    return x * x</code></pre>
<p>对于<code>power(x)</code>函数，参数<code>x</code>就是一个位置参数。</p>
<p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code></p>
<p>修改原函数后的<code>power(x, n)</code>函数，可以计算任意n次方：</p>
<pre><code class="python">def power(x, n):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s</code></pre>
<p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p>
<h4 id="3-2默认参数"><a href="#3-2默认参数" class="headerlink" title="3.2默认参数"></a>3.2默认参数</h4><p>新的<code>power(x, n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用</p>
<p>由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p>
<pre><code class="python">def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s</code></pre>
<p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code></p>
<p>默认参数可以简化函数的调用，但是需要注意：</p>
<ul>
<li>必选参数在前，默认参数在后，否则Python的解释器会报错</li>
<li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li>
<li>默认参数在函数定义的时候就被计算出来了，且必须指向一个不变对象，见后文例子</li>
</ul>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。</p>
<hr>
<p>默认参数例子：</p>
<pre><code class="python">def add_end(L=[]):
    L.append(&#39;END&#39;)
    return L</code></pre>
<p>当你正常调用时，结果似乎不错：</p>
<pre><code class="python">&gt;&gt;&gt; add_end([1, 2, 3])
[1, 2, 3, &#39;END&#39;]
&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]
#使用默认参数调用时，再次调用add_end()，结果就不对了
&gt;&gt;&gt; add_end()
[&#39;END&#39;]
&gt;&gt;&gt; add_end()
[&#39;END&#39;, &#39;END&#39;]
&gt;&gt;&gt; add_end()
[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</code></pre>
<p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！</p>
<p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p>
<pre><code class="python">def add_end(L=None):
    if L is None:
        L = []
    L.append(&#39;END&#39;)
    return L</code></pre>
<p>现在，无论调用多少次，都不会有问题：</p>
<h4 id="3-3可变参数"><a href="#3-3可变参数" class="headerlink" title="3.3可变参数"></a>3.3可变参数</h4><pre><code class="python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum</code></pre>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数</p>
<p>如果已经有一个list或者tuple，Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p>
<pre><code class="python">&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14</code></pre>
<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h4 id="3-4关键字参数"><a href="#3-4关键字参数" class="headerlink" title="3.4关键字参数"></a>3.4关键字参数</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p>
<pre><code class="python">def person(name, age, **kw):
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</code></pre>
<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>
<pre><code class="python">#只传入必选参数
&gt;&gt;&gt; person(&#39;Michael&#39;, 30)
name: Michael age: 30 other: {}
#传入任意个数的关键字参数
&gt;&gt;&gt; person(&#39;Bob&#39;, 35, city=&#39;Beijing&#39;)
name: Bob age: 35 other: {&#39;city&#39;: &#39;Beijing&#39;}
&gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)
name: Adam age: 45 other: {&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;}</code></pre>
<p>和可变参数类似，已经有一个dict，Python允许你在dict前面加一个<code>**</code>号，把dict的元素变成可变参数传进去：</p>
<pre><code class="python">&gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra)
name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}</code></pre>
<h4 id="3-5命名关键字参数"><a href="#3-5命名关键字参数" class="headerlink" title="3.5命名关键字参数"></a>3.5命名关键字参数</h4><p>对于<em>关键字参数</em>，函数的调用者可以传入<em>任意不受限制</em>的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。</p>
<p>如果要限制关键字参数的名字，就可以用<strong>命名关键字参数</strong>，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p>
<pre><code class="python">def person(name, age, *, city, job):
    print(name, age, city, job)</code></pre>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>
<p>调用方式如下：</p>
<pre><code class="python">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)
Jack 24 Beijing Engineer</code></pre>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>
<pre><code class="python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)</code></pre>
<p>命名关键字参数<strong>必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错</p>
<p>命名关键字参数也可以有缺省值，从而简化调用</p>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就<strong>必须</strong>加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数：</p>
<pre><code class="python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass</code></pre>
<h4 id="3-6组合参数"><a href="#3-6组合参数" class="headerlink" title="3.6组合参数"></a>3.6组合参数</h4><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong>。</p>
<p>比如定义一个函数，包含上述若干种参数：</p>
<pre><code class="python">def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)</code></pre>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<pre><code class="python">&gt;&gt;&gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;)
a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {}
&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x=99)
a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {&#39;x&#39;: 99}
&gt;&gt;&gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {&#39;ext&#39;: None}</code></pre>
<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<pre><code class="python">#调用f1
&gt;&gt;&gt; args = (1, 2, 3, 4)
&gt;&gt;&gt; kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
&gt;&gt;&gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
#调用f2
&gt;&gt;&gt; args = (1, 2, 3)
&gt;&gt;&gt; kw = {&#39;d&#39;: 88, &#39;x&#39;: &#39;#&#39;}
&gt;&gt;&gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {&#39;x&#39;: &#39;#&#39;}</code></pre>
<p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h3 id="4递归函数"><a href="#4递归函数" class="headerlink" title="4递归函数"></a>4递归函数</h3><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，<strong>return语句不能包含表达式</strong>。这样，<strong>编译器</strong>或者<strong>解释器</strong>就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<pre><code class="python">#没有尾递归优化
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
#有尾递归优化
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)</code></pre>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code>fact(n)</code>函数改成尾递归方式，也会导致栈溢出。</p>
<h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="3-1切片"><a href="#3-1切片" class="headerlink" title="3.1切片"></a>3.1切片</h3><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p>
<p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p>
<pre><code class="python">&gt;&gt;&gt; L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]
&gt;&gt;&gt; L[0:3]
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]
#如果第一个索引是0，还可以省略
&gt;&gt;&gt; L[:3]
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]
#支持倒数切片
&gt;&gt;&gt; L[-2:]
[&#39;Bob&#39;, &#39;Jack&#39;]
&gt;&gt;&gt; L[-2:-1]
[&#39;Bob&#39;]</code></pre>
<p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p>
<pre><code class="python">#创建一个更大的数列
&gt;&gt;&gt; L = list(range(100))
&gt;&gt;&gt; L
[0, 1, 2, 3, ..., 99]
#前10个数，每两个取一个
&gt;&gt;&gt; L[:10:2]
[0, 2, 4, 6, 8]
#所有数，每5个取一个：
&gt;&gt;&gt; L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
#原样复制一个list
&gt;&gt;&gt; L[:]
[0, 1, 2, 3, ..., 99]</code></pre>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</p>
<p>同样，字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串</p>
<h3 id="3-2迭代"><a href="#3-2迭代" class="headerlink" title="3.2迭代"></a>3.2迭代</h3><p>如果给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>
<p>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C语言，迭代list是通过下标完成的</p>
<p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代</p>
<pre><code class="python">&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&gt;&gt;&gt; for key in d:
...     print(key)
...
a
c
b</code></pre>
<p>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</p>
<p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p>
<p>由于字符串也是可迭代对象，因此，也可以作用于<code>for</code>循环</p>
<p>通过collections模块的Iterable类型可以判断一个对象是否为可迭代对象：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
True
&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
False</code></pre>
<p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<pre><code class="python">&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
...     print(i, value)
...
0 A
1 B
2 C</code></pre>
<p>上面的<code>for</code>循环里，同时引用了两个变量，在Python里是很常见的</p>
<h3 id="3-3列表生成式"><a href="#3-3列表生成式" class="headerlink" title="3.3列表生成式"></a>3.3列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<pre><code class="python">#普通方法
&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

#运用列表生成式 生成复杂的list
&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
#for循环后＋if
&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
#两层循环
&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]
#for循环中同时使用两个甚至多个变量
&gt;&gt;&gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }
&gt;&gt;&gt; [k + &#39;=&#39; + v for k, v in d.items()]
[&#39;y=B&#39;, &#39;x=A&#39;, &#39;z=C&#39;]
#把一个list中所有的字符串变成小写
&gt;&gt;&gt; L = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]
&gt;&gt;&gt; [s.lower() for s in L]
[&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</code></pre>
<h3 id="3-4生成器"><a href="#3-4生成器" class="headerlink" title="3.4生成器"></a>3.4生成器</h3><p>如果列表元素可以按照某种算法推算出来，那我们可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<pre><code class="python">&gt;&gt;&gt; L = [x * x for x in range(10)]
&gt;&gt;&gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; g = (x * x for x in range(10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;
#通过next()函数获得generator的下一个返回值
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
16
&gt;&gt;&gt; next(g)
25
&gt;&gt;&gt; next(g)
36
&gt;&gt;&gt; next(g)
49
&gt;&gt;&gt; next(g)
64
&gt;&gt;&gt; next(g)
81
&gt;&gt;&gt; next(g)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration</code></pre>
<p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。</p>
<p>generator保存的是算法，每次调用<code>next(g)</code>，就计算出<code>g</code>的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p>
<p>generator是可迭代对象，所以能够使用<code>for</code>循环迭代</p>
<p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p>
<p>定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p>
<pre><code class="python">#普通函数 生成斐波拉契数列
def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;
#generator
def fib(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;
</code></pre>
<blockquote>
<p>其中赋值语句：</p>
<pre><code class="python">a, b = b, a + b</code></pre>
<p>相当于：</p>
<pre><code class="python">t = (b, a + b) # t是一个tuple
a = t[0]
b = t[1]</code></pre>
<p>但不必显式写出临时变量t就可以赋值。</p>
</blockquote>
<p>这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。可概括为以下三点：</p>
<ul>
<li>生成器是一个不断产生值的函数</li>
<li>包含yield语句的函数是一个生成器</li>
<li>生成器每次产生一个值(yield语句)，函数被冻结，被唤醒后再产生一个值</li>
</ul>
<blockquote>
<p>例子，定义一个generator，依次返回数字1，3，5：</p>
<pre><code class="python">def odd():
    print(&#39;step 1&#39;)
    yield 1
    print(&#39;step 2&#39;)
    yield(3)
    print(&#39;step 3&#39;)
    yield(5)</code></pre>
<p>调用该generator时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值：</p>
<pre><code class="python">&gt;&gt;&gt; o = odd()
&gt;&gt;&gt; next(o)
step 1
1
&gt;&gt;&gt; next(o)
step 2
3
&gt;&gt;&gt; next(o)
step 3
5
&gt;&gt;&gt; next(o)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration</code></pre>
<p>可以看到，<code>odd</code>不是普通函数，而是generator，在执行过程中，遇到<code>yield</code>就中断，下次又继续执行。执行3次<code>yield</code>后，已经没有<code>yield</code>可以执行了，所以，第4次调用<code>next(o)</code>就报错。</p>
</blockquote>
<p>用<code>for</code>循环调用generator时（如这种：<code>for n in fib(6)</code>），发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
<pre><code class="python">&gt;&gt;&gt; g = fib(6)
&gt;&gt;&gt; while True:
...     try:
...         x = next(g)
...         print(&#39;g:&#39;, x)
...     except StopIteration as e:
...         print(&#39;Generator return value:&#39;, e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done</code></pre>
<h3 id="3-5迭代器"><a href="#3-5迭代器" class="headerlink" title="3.5迭代器"></a>3.5迭代器</h3><p>可以直接作用于<code>for</code>循环的数据类型有以下几种：</p>
<p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p>
<p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import Iterable
&gt;&gt;&gt; isinstance([], Iterable)
True
&gt;&gt;&gt; isinstance({}, Iterable)
True
&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)
True
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
True</code></pre>
<p>而生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器</strong>：<code>Iterator</code>。</p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import Iterator
&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
True
&gt;&gt;&gt; isinstance([], Iterator)
False
&gt;&gt;&gt; isinstance({}, Iterator)
False
&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterator)
False</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="python">&gt;&gt;&gt; isinstance(iter([]), Iterator)
True
&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)
True</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p><strong>总之</strong>：</p>
<ul>
<li>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</li>
<li>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</li>
<li>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的<ul>
<li>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等会先通过<code>iter()</code>函数获得一个<code>Iterator</code>对象</li>
</ul>
</li>
</ul>
<h2 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h2><h3 id="4-1高阶函数"><a href="#4-1高阶函数" class="headerlink" title="4.1高阶函数"></a>4.1高阶函数</h3><p>函数本身也可以赋值给变量，即：变量可以指向函数。</p>
<p>如果一个变量指向了一个函数，那么，可以通过该变量来调用这个函数</p>
<pre><code class="python">&gt;&gt;&gt; f = abs
&gt;&gt;&gt; f
&lt;built-in function abs&gt;
&gt;&gt;&gt; f(-10)
10</code></pre>
<p>函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p>
<pre><code class="python">&gt;&gt;&gt; abs = 10#修改abs的指向
&gt;&gt;&gt; abs(-10)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;int&#39; object is not callable
#要恢复abs函数，需要重启Python交互环境。</code></pre>
<p>注意：由于<code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改<code>abs</code>变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</p>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数</strong>。</p>
<p>如：</p>
<pre><code class="python">def add(x, y, f):
    return f(x) + f(y)</code></pre>
<p>编写高阶函数，就是让函数的参数能够接收别的函数。函数式编程就是指这种高度抽象的编程范式。</p>
<h4 id="4-1-1map-reduce"><a href="#4-1-1map-reduce" class="headerlink" title="4.1.1map/reduce"></a>4.1.1map/reduce</h4><p>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p>
<p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<blockquote>
<p>比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p>
<pre><code class="ascii">            f(x) = x * x

                  │
                  │
  ┌───┬───┬───┬───┼───┬───┬───┬───┐
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   2   3   4   5   6   7   8   9 ]

  │   │   │   │   │   │   │   │   │
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   4   9  16  25  36  49  64  81 ]</code></pre>
<p>现在，我们用Python代码实现：</p>
<pre><code class="python">&gt;&gt;&gt; def f(x):
...     return x * x
...
&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>
<p><code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p>
</blockquote>
<p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x^2^，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
<pre><code class="python">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre>
<p>只需要一行代码。</p>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code class="python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre>
<blockquote>
<p>比如对一个序列求和，就可以用<code>reduce</code>实现：</p>
<pre><code class="python">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def add(x, y):
...     return x + y
...
&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25</code></pre>
<p>比如把<code>str</code>转换为<code>int</code>：</p>
<pre><code class="python">from functools import reduce

DIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))</code></pre>
<p>还可以用lambda函数进一步简化成：</p>
<pre><code class="python">from functools import reduce

DIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</code></pre>
<p>lambda函数的用法在后面介绍。</p>
</blockquote>
<h4 id="4-1-2filter"><a href="#4-1-2filter" class="headerlink" title="4.1.2filter"></a>4.1.2filter</h4><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<blockquote>
<p>把一个序列中的空字符串删掉：</p>
<pre><code class="python">def not_empty(s):
    return s and s.strip()

list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))
# 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre>
</blockquote>
<p>注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p>
<h4 id="4-1-3sorted"><a href="#4-1-3sorted" class="headerlink" title="4.1.3sorted"></a>4.1.3sorted</h4><p>Python内置的<code>sorted()</code>函数就可以对list从小到大进行排序：</p>
<pre><code class="python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]</code></pre>
<p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p>
<blockquote>
<p>如按绝对值大小排序：</p>
<pre><code class="python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]</code></pre>
<p>这个过程可以理解为：</p>
<pre><code class="python">list = [36, 5, -12, 9, -21]#原始的list
keys = [36, 5,  12, 9,  21]#经过key=abs处理过的list</code></pre>
<p>然后<code>sorted()</code>函数按照keys进行排序，并按照对应关系返回list相应的元素：</p>
<pre><code class="ascii">keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]</code></pre>
</blockquote>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的</p>
<p>要进行<strong>反向排序</strong>，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p>
<h3 id="4-2返回函数"><a href="#4-2返回函数" class="headerlink" title="4.2返回函数"></a>4.2返回函数</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<pre><code class="python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum</code></pre>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="python">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
#真正计算求和的结果
&gt;&gt;&gt; f()
25</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果</p>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“<strong>闭包</strong>（Closure）”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code class="python">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1==f2
False</code></pre>
<p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
<h4 id="4-2-1闭包"><a href="#4-2-1闭包" class="headerlink" title="4.2.1闭包"></a>4.2.1闭包</h4><p>注意到返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。</p>
<blockquote>
<p>例子：</p>
<pre><code class="python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p>
<pre><code class="python">&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9</code></pre>
<p>全部都是<code>9</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p>
</blockquote>
<p>返回闭包时牢记一点：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。</p>
<blockquote>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs</code></pre>
<p>再看看结果：</p>
<pre><code class="python">&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9</code></pre>
<p>缺点是代码较长，可利用lambda函数缩短代码。</p>
</blockquote>
<h4 id="4-2-2关键字global与nonlocal"><a href="#4-2-2关键字global与nonlocal" class="headerlink" title="4.2.2关键字global与nonlocal"></a>4.2.2关键字global与nonlocal</h4><p>第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。</p>
<p>第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误</p>
<h3 id="4-3匿名函数"><a href="#4-3匿名函数" class="headerlink" title="4.3匿名函数"></a>4.3匿名函数</h3><p>匿名函数<code>lambda x: x * x</code>实际上就是：</p>
<pre><code class="python">def f(x):
    return x * x</code></pre>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<pre><code class="python">&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
&gt;&gt;&gt; f(5)
25</code></pre>
<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<pre><code class="python">def build(x, y):
    return lambda: x * x + y * y</code></pre>
<h3 id="4-4装饰器"><a href="#4-4装饰器" class="headerlink" title="4.4装饰器"></a>4.4装饰器</h3><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字</p>
<pre><code class="python">&gt;&gt;&gt; def now():
...     print(&#39;2015-3-25&#39;)
...
&gt;&gt;&gt; now.__name__
&#39;now&#39;</code></pre>
<p>现在，假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间<strong>动态增加功能</strong>的方式，称之为“<strong>装饰器</strong>”（Decorator）。</p>
<p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<pre><code class="python">def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper</code></pre>
<p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的<strong>@</strong>语法，把decorator置于函数的定义处：</p>
<pre><code class="python">@log
def now():
    print(&#39;2015-3-25&#39;)</code></pre>
<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p>
<pre><code class="python">&gt;&gt;&gt; now()
call now():
2015-3-25</code></pre>
<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<pre><code class="python">now = log(now)</code></pre>
<p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p>
<p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<pre><code class="python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code class="python">@log(&#39;execute&#39;)
def now():
    print(&#39;2015-3-25&#39;)</code></pre>
<p>执行结果如下：</p>
<pre><code class="python">&gt;&gt;&gt; now()
execute now():
2015-3-25</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="python">&gt;&gt;&gt; now = log(&#39;execute&#39;)(now)</code></pre>
<p>我们来剖析上面的语句，首先执行<code>log(&#39;execute&#39;)</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>&#39;now&#39;</code>变成了<code>&#39;wrapper&#39;</code>：</p>
<pre><code class="python">&gt;&gt;&gt; now.__name__
&#39;wrapper&#39;</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>&#39;wrapper&#39;</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code class="python">import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper</code></pre>
<p>或者针对带参数的decorator：</p>
<pre><code class="python">import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator</code></pre>
<p><code>import functools</code>是导入<code>functools</code>模块。模块的概念稍候讲解。现在，只需记住在定义<code>wrapper()</code>的前面加上<code>@functools.wraps(func)</code>即可。</p>
<h3 id="4-5偏函数"><a href="#4-5偏函数" class="headerlink" title="4.5偏函数"></a>4.5偏函数</h3><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</p>
<p><code>functools.partial</code>就是帮助我们创建一个偏函数的，作用就是把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<pre><code class="python">&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
#重设默认值
&gt;&gt;&gt; int2(&#39;1000000&#39;, base=10)
1000000</code></pre>
<p>最后，创建偏函数时，实际上可以接收 函数对象、<code>*args</code>和<code>**kw</code>这3个参数</p>
<blockquote>
<p>例子：</p>
<pre><code class="python">int2 = functools.partial(int, base=2)
int2(&#39;10010&#39;)
#相当于
kw = { &#39;base&#39;: 2 }
int(&#39;10010&#39;, **kw)</code></pre>
<p>又：</p>
<pre><code class="python">max2 = functools.partial(max, 10)
max2(5, 6, 7)
#相当于
args = (10, 5, 6, 7)#实际上会把10作为*args的一部分自动加到左边
max(*args)</code></pre>
<p>注意上述例子中会把10作为<em>args的一部分自动加到*</em>左边**</p>
</blockquote>
<h2 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h2><h3 id="5-0模块和包"><a href="#5-0模块和包" class="headerlink" title="5.0模块和包"></a>5.0模块和包</h3><p>在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p>
<blockquote>
<p>例子：</p>
<p>一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块，一个<code>xyz.py</code>的文件就是一个名字叫<code>xyz</code>的模块。</p>
<p>现在，假设我们的<code>abc</code>和<code>xyz</code>这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p>
<pre><code class="ascii">mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py</code></pre>
<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p>
<p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p>
</blockquote>
<p>可以有多级目录，组成多级层次的包结构</p>
<blockquote>
<p>例子：</p>
<pre><code class="ascii">mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py</code></pre>
<p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<p><code>mycompany.web</code>也是一个模块，该模块对应为<code>mycompany.web.__init__.py</code>文件。</p>
</blockquote>
<p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p>
<h3 id="5-1使用模块"><a href="#5-1使用模块" class="headerlink" title="5.1使用模块"></a>5.1使用模块</h3><p>Python模块的标准文件模板：</p>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Michael Liao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print(&#39;Hello, world!&#39;)
    elif len(args)==2:
        print(&#39;Hello, %s!&#39; % args[1])
    else:
        print(&#39;Too many arguments!&#39;)

if __name__==&#39;__main__&#39;:
    test()</code></pre>
<p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p>
<p>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p>
<p>第6行使用<code>__author__</code>变量把作者写进去</p>
<p>使用<code>sys</code>模块的第一步，就是导入该模块。导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p>
<p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称</p>
<blockquote>
<p>如：</p>
<p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；</p>
<p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael]</code>。</p>
</blockquote>
<p>注意到这两行代码：</p>
<pre><code class="python">if __name__==&#39;__main__&#39;:
    test()</code></pre>
<p>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<ul>
<li><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
</li>
<li><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
</li>
</ul>
<p>注意：private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
<h3 id="5-2安装第三方模块"><a href="#5-2安装第三方模块" class="headerlink" title="5.2安装第三方模块"></a>5.2安装第三方模块</h3><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p>
<p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是<code>pip3</code>。</p>
<p>一般来说，第三方库都会在Python官方的<a href="https://pypi.python.org/" target="_blank" rel="noopener">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称</p>
<p>推荐直接使用<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a>，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>下载安装后，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<h4 id="5-2-1模块搜索路径"><a href="#5-2-1模块搜索路径" class="headerlink" title="5.2.1模块搜索路径"></a>5.2.1模块搜索路径</h4><p>默认情况下，Python解释器会搜索 当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<pre><code class="python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#39;, ..., &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#39;]</code></pre>
<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。</p>
<p>第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。</p>
<h2 id="六、面向对象编程"><a href="#六、面向对象编程" class="headerlink" title="六、面向对象编程"></a>六、面向对象编程</h2><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>
<h3 id="6-1类和实例"><a href="#6-1类和实例" class="headerlink" title="6.1类和实例"></a>6.1类和实例</h3><p>以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p>
<pre><code class="python">class Student(object):
    pass</code></pre>
<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过类名+()实现的：</p>
<pre><code class="python">&gt;&gt;&gt; bart = Student()
&gt;&gt;&gt; bart
&lt;__main__.Student object at 0x10a67a590&gt;
&gt;&gt;&gt; Student
&lt;class &#39;__main__.Student&#39;&gt;</code></pre>
<p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p>
<p>可以自由地给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p>
<pre><code class="python">&gt;&gt;&gt; bart.name = &#39;Bart Simpson&#39;
&gt;&gt;&gt; bart.name
&#39;Bart Simpson&#39;</code></pre>
<p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p>
<pre><code class="python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score</code></pre>
<p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去</p>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h4 id="6-1-1数据封装"><a href="#6-1-1数据封装" class="headerlink" title="6.1.1数据封装"></a>6.1.1数据封装</h4><p>每个实例拥有各自的<code>name</code>和<code>score</code>这些数据，我们可以通过函数来访问这些数据。将这些封装数据的函数和<code>Student</code>类本身关联起来，我们称之为类的方法：</p>
<pre><code class="python">class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))</code></pre>
<p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p>
<pre><code class="python">&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
&gt;&gt;&gt; bart.print_score()
Bart Simpson: 59</code></pre>
<p>封装的另一个好处是随时可以给<code>Student</code>类增加新的方法</p>
<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p>
<pre><code class="python">&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
&gt;&gt;&gt; lisa = Student(&#39;Lisa Simpson&#39;, 87)
&gt;&gt;&gt; bart.age = 8
&gt;&gt;&gt; bart.age
8
&gt;&gt;&gt; lisa.age
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;age&#39;</code></pre>
<h3 id="6-2访问限制"><a href="#6-2访问限制" class="headerlink" title="6.2访问限制"></a>6.2访问限制</h3><p>从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的<code>name</code>、<code>score</code>属性</p>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p>
<blockquote>
<p>把Student类改一改：</p>
<pre><code class="python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.__name, self.__score))</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
</blockquote>
<p>如果外部代码要获取name和score，可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法</p>
<p>同理，要允许外部代码修改score，可以再给Student类增加<code>set_score</code>方法</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<pre><code class="python">&gt;&gt;&gt; bart._Student__name
&#39;Bart Simpson&#39;</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p>
<p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<h3 id="6-3继承和多态"><a href="#6-3继承和多态" class="headerlink" title="6.3继承和多态"></a>6.3继承和多态</h3><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）</p>
<blockquote>
<p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：</p>
<pre><code class="python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)</code></pre>
<p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p>
<pre><code class="python">class Dog(Animal):
    pass

class Cat(Animal):
    pass</code></pre>
<p>最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法</p>
<p>也可以对子类增加一些方法，比如Dog类：</p>
<pre><code class="python">class Dog(Animal):

    def run(self):
        print(&#39;Dog is running...&#39;)

    def eat(self):
        print(&#39;Eating meat...&#39;)</code></pre>
<p>对<code>Dog</code>和<code>Cat</code>类改进如下：</p>
<pre><code class="python">class Dog(Animal):

    def run(self):
        print(&#39;Dog is running...&#39;)

class Cat(Animal):

    def run(self):
        print(&#39;Cat is running...&#39;)</code></pre>
<p>再次运行，结果如下：</p>
<pre><code class="python">Dog is running...
Cat is running...</code></pre>
<p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p>
</blockquote>
<p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断</p>
<blockquote>
<p>例子：</p>
<pre><code class="python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
&gt;&gt;&gt; isinstance(a, list)
True
&gt;&gt;&gt; isinstance(b, Animal)
True
&gt;&gt;&gt; isinstance(c, Dog)
True</code></pre>
</blockquote>
<p><strong>多态</strong>：对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<ul>
<li>对扩展开放：允许新增<code>Animal</code>子类；</li>
<li>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</li>
</ul>
<blockquote>
<p>例子：</p>
<pre><code class="python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)
class Dog(Animal):
    def run(self):
        print(&#39;Dog is running...&#39;)
class Cat(Animal):
    def run(self):
        print(&#39;Cat is running...&#39;)
#只需要animal类型的变量即可
def run_twice(animal):
    animal.run()
    animal.run()
#调用：
&gt;&gt;&gt; run_twice(Animal())
Animal is running...
Animal is running...
&gt;&gt;&gt; run_twice(Dog())
Dog is running...
Dog is running...
&gt;&gt;&gt; run_twice(Cat())
Cat is running...
Cat is running...
#新增Tortoise类，并调用仍然可以正常运行
class Tortoise(Animal):
    def run(self):
        print(&#39;Tortoise is running slowly...&#39;)
&gt;&gt;&gt; run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...</code></pre>
</blockquote>
<p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p>
<pre><code class="ascii">                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘</code></pre>
<h4 id="6-3-1静态语言和动态语言在此处的区别"><a href="#6-3-1静态语言和动态语言在此处的区别" class="headerlink" title="6.3.1静态语言和动态语言在此处的区别"></a>6.3.1静态语言和动态语言在此处的区别</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="python">class Timer(object):
    def run(self):
        print(&#39;Start...&#39;)</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<h3 id="6-4获取对象信息"><a href="#6-4获取对象信息" class="headerlink" title="6.4获取对象信息"></a>6.4获取对象信息</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>基本类型都可以用<code>type()</code>判断：</p>
<pre><code class="python">&gt;&gt;&gt; type(123)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; type(&#39;str&#39;)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; type(None)
&lt;type(None) &#39;NoneType&#39;&gt;
#指向函数或者类
&gt;&gt;&gt; type(abs)
&lt;class &#39;builtin_function_or_method&#39;&gt;
&gt;&gt;&gt; type(a)
&lt;class &#39;__main__.Animal&#39;&gt;</code></pre>
<p><code>type()</code>函数返回对应的Class类型</p>
<p>比较：</p>
<pre><code class="python">#判断基本数据类型可以直接写int，str等
&gt;&gt;&gt; type(123)==type(456)
True
&gt;&gt;&gt; type(123)==int
True
&gt;&gt;&gt; type(&#39;abc&#39;)==type(&#39;123&#39;)
True
&gt;&gt;&gt; type(&#39;abc&#39;)==str
True
#判断一个对象是否是函数
#使用types模块中定义的常量
&gt;&gt;&gt; import types
&gt;&gt;&gt; def fn():
...     pass
...
&gt;&gt;&gt; type(fn)==types.FunctionType
True
&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType
True</code></pre>
<h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h4><p>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。</p>
<blockquote>
<p>例如上次的继承关系：</p>
<pre><code class="python">object -&gt; Animal -&gt; Dog -&gt; Husky</code></pre>
<p>那么，<code>isinstance()</code>就可以告诉我们，一个对象是否是某种类型。</p>
<pre><code class="python">&gt;&gt;&gt; a = Animal()
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; h = Husky()
&gt;&gt;&gt; isinstance(h, Husky)
True
&gt;&gt;&gt; isinstance(h, Dog)
True
&gt;&gt;&gt; isinstance(h, Animal)
True
#基本类型
&gt;&gt;&gt; isinstance(&#39;a&#39;, str)
True
&gt;&gt;&gt; isinstance(123, int)
True
&gt;&gt;&gt; isinstance(b&#39;a&#39;, bytes)
True
#判断一个变量是否是某些类型中的一种
&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))
True
&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))
True</code></pre>
</blockquote>
<p>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</p>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<pre><code class="python">&gt;&gt;&gt; dir(&#39;ABC&#39;)
[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p>
<p>自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合内置函数<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="python">&gt;&gt;&gt; class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？
True
&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81
&gt;&gt;&gt; obj = MyObject()
&gt;&gt;&gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
True
&gt;&gt;&gt; obj.x
9
&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
False
&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;
&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
True
&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;
19
&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;
19
#试图获取不存在的属性，会抛出AttributeError的错误
#可以传入一个default参数，如果属性不存在，就返回默认值
&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404
404
#也可以获得对象的方法
&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？
True
&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn
&gt;&gt;&gt; fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的
81</code></pre>
<p>注意：只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接获取就直接获取</p>
<h3 id="6-5实例属性和类属性"><a href="#6-5实例属性和类属性" class="headerlink" title="6.5实例属性和类属性"></a>6.5实例属性和类属性</h3><p>直接在class中定义属性，这种属性是<strong>类属性</strong>，归该类所有</p>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。</p>
<blockquote>
<p>例子：</p>
<pre><code class="python">&gt;&gt;&gt; class Student(object):
...     name = &#39;Student&#39;
...
&gt;&gt;&gt; s = Student() # 创建实例s
&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
&gt;&gt;&gt; print(Student.name) # 打印类的name属性
Student
&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性
&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
&gt;&gt;&gt; del s.name # 如果删除实例的name属性
&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student</code></pre>
</blockquote>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将<strong>屏蔽掉类属性</strong>，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<h2 id="七、面向对象高级编程"><a href="#七、面向对象高级编程" class="headerlink" title="七、面向对象高级编程"></a>七、面向对象高级编程</h2><h3 id="7-1使用-slots"><a href="#7-1使用-slots" class="headerlink" title="7.1使用_slots_"></a>7.1使用_<em>slots_</em></h3><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给class绑定方法。给class绑定方法后，所有实例均可调用</p>
<p>如果我们想要限制实例的属性，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</p>
<blockquote>
<p>例子：</p>
<pre><code class="python">class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称
&gt;&gt;&gt; s = Student() # 创建新的实例
&gt;&gt;&gt; s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;
&gt;&gt;&gt; s.age = 25 # 绑定属性&#39;age&#39;
&gt;&gt;&gt; s.score = 99 # 绑定属性&#39;score&#39;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;</code></pre>
</blockquote>
<p>注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h3 id="7-2使用-property"><a href="#7-2使用-property" class="headerlink" title="7.2使用@property"></a>7.2使用@property</h3><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把属性随便改。解决方法就是增加一个<code>set_xxx()</code>方法来设置属性，再通过一个<code>get_xxx()</code>来获取属性，这样，在<code>set_sss()</code>方法里，就可以检查参数。但是，这样的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>对于Python来说，可以利用之前的装饰器（decorator），对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="python">class Student(object):
    @property
    def score(self):
        return self._score
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value</code></pre>
<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="python">&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
&gt;&gt;&gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!</code></pre>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<pre><code class="python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<em>只读</em>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<h3 id="7-3多重继承"><a href="#7-3多重继承" class="headerlink" title="7.3多重继承"></a>7.3多重继承</h3><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>
<p>回忆一下<code>Animal</code>类层次的设计，假设我们要实现以下4种动物：</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。</li>
</ul>
<p>类的层次设计可以根据不同的需求来确定不同的设计，如果同时需要多种层次类型就需要多重继承。</p>
<blockquote>
<p>主要的类层次仍按照哺乳类和鸟类设计：</p>
<pre><code class="python">class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass
#给动物再加上Runnable和Flyable的功能
class Runnable(object):
    def run(self):
        print(&#39;Running...&#39;)

class Flyable(object):
    def fly(self):
        print(&#39;Flying...&#39;)
#需要Runnable功能的动物，就多继承一个Runnable
class Dog(Mammal, Runnable):
    pass
#需要Flyable功能的动物，就多继承一个Flyable
class Bat(Mammal, Flyable):
    pass</code></pre>
</blockquote>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<h4 id="7-3-1MinIn"><a href="#7-3-1MinIn" class="headerlink" title="7.3.1MinIn"></a>7.3.1MinIn</h4><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为MixIn。</p>
<p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<blockquote>
<p>python自带的很多库也使用了MixIn。举个例子，Python自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<pre><code class="python">#多进程模式的TCP服务
class MyTCPServer(TCPServer, ForkingMixIn):
    pass
#多线程模式的UDP服务
class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
#协程模型
class MyTCPServer(TCPServer, CoroutineMixIn):
    pass</code></pre>
<p>不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
</blockquote>
<h3 id="7-4定制类"><a href="#7-4定制类" class="headerlink" title="7.4定制类"></a>7.4定制类</h3><p>除<code>__slots__</code>、<code>__len__()</code>之外，Python的class中还有许多这种形如<code>__xxx__</code>的变量或者函数名，可以帮助我们定制类。</p>
<h4 id="7-4-1-str-、-repr"><a href="#7-4-1-str-、-repr" class="headerlink" title="7.4.1__str__、_repr_"></a>7.4.1__str__、_<em>repr_</em></h4><p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="python">&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...
&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
&lt;__main__.Student object at 0x109afb190&gt;</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="python">&gt;&gt;&gt; class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
...
&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
Student object (name: Michael)</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="python">&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x109afb310&gt;</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__</code></pre>
<h4 id="7-4-2-iter"><a href="#7-4-2-iter" class="headerlink" title="7.4.2_iter_"></a>7.4.2_<em>iter_</em></h4><p>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<pre><code class="python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值</code></pre>
<p>现在，试试把Fib实例作用于for循环：</p>
<pre><code class="python">&gt;&gt;&gt; for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025</code></pre>
<h4 id="7-4-3-getitem"><a href="#7-4-3-getitem" class="headerlink" title="7.4.3_getitem_"></a>7.4.3_<em>getitem_</em></h4><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<pre><code class="python">&gt;&gt;&gt; Fib()[5]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;Fib&#39; object does not support indexing</code></pre>
<p>要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a</code></pre>
<p>现在，就可以按下标访问数列的任意一项了：</p>
<pre><code class="python">&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0]
1
&gt;&gt;&gt; f[1]
1
&gt;&gt;&gt; f[2]
2
&gt;&gt;&gt; f[3]
3
&gt;&gt;&gt; f[10]
89
&gt;&gt;&gt; f[100]
573147844013817084101</code></pre>
<p>但是list有个神奇的切片方法：</p>
<pre><code class="python">&gt;&gt;&gt; list(range(100))[5:10]
[5, 6, 7, 8, 9]</code></pre>
<p>对于Fib却报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象<code>slice</code>，所以要做判断：</p>
<pre><code class="python">class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L</code></pre>
<p>现在试试Fib的切片：</p>
<pre><code class="python">&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[0:5]
[1, 1, 2, 3, 5]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>
<p>但是没有对step参数作处理：</p>
<pre><code class="python">&gt;&gt;&gt; f[:10:2]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</code></pre>
<p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>
<p>此外，如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h4 id="7-4-4-getattr"><a href="#7-4-4-getattr" class="headerlink" title="7.4.4_getattr_"></a>7.4.4_<em>getattr_</em></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="python">class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="python">&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; print(s.name)
Michael
&gt;&gt;&gt; print(s.score)
Traceback (most recent call last):
  ...
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个attribute。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="python">class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，Python解释器会试图调用<code>__getattr__(self, &#39;score&#39;)</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值：</p>
<pre><code class="python">&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name
&#39;Michael&#39;
&gt;&gt;&gt; s.score
99</code></pre>
<p>返回函数也是完全可以的：</p>
<pre><code class="python">class Student(object):

    def __getattr__(self, attr):
        if attr==&#39;age&#39;:
            return lambda: 25</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="python">&gt;&gt;&gt; s.age()
25</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>
<p>此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让class只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="python">class Student(object):

    def __getattr__(self, attr):
        if attr==&#39;age&#39;:
            return lambda: 25
        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<blockquote>
<p>举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<ul>
<li><a href="http://api.server/user/friends" target="_blank" rel="noopener">http://api.server/user/friends</a></li>
<li><a href="http://api.server/user/timeline/list" target="_blank" rel="noopener">http://api.server/user/timeline/list</a></li>
</ul>
<p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p>
<pre><code class="python">class Chain(object):

    def __init__(self, path=&#39;&#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__</code></pre>
<p>试试：</p>
<pre><code class="python">&gt;&gt;&gt; Chain().status.user.timeline.list
&#39;/status/user/timeline/list&#39;</code></pre>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<pre><code class="python">GET /users/:user/repos</code></pre>
<p>调用时，需要把<code>:user</code>替换为实际用户名。如果我们能写出这样的链式调用：</p>
<pre><code class="python">Chain().users(&#39;michael&#39;).repos</code></pre>
<p>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p>
</blockquote>
<h4 id="7-4-5-call"><a href="#7-4-5-call" class="headerlink" title="7.4.5_call_"></a>7.4.5_<em>call_</em></h4><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p>
<p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)</code></pre>
<p>调用方式如下：</p>
<pre><code class="python">&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s() # self参数不要传入
My name is Michael.</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例：</p>
<pre><code class="python">&gt;&gt;&gt; callable(Student())
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable(&#39;str&#39;)
False</code></pre>
<p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h3 id="7-5使用枚举类"><a href="#7-5使用枚举类" class="headerlink" title="7.5使用枚举类"></a>7.5使用枚举类</h3><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p>
<p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p>
<pre><code class="python">from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="python">for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="python">from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<pre><code class="python">&gt;&gt;&gt; day1 = Weekday.Mon
&gt;&gt;&gt; print(day1)
Weekday.Mon
&gt;&gt;&gt; print(Weekday.Tue)
Weekday.Tue
&gt;&gt;&gt; print(Weekday[&#39;Tue&#39;])
Weekday.Tue
&gt;&gt;&gt; print(Weekday.Tue.value)
2
&gt;&gt;&gt; print(day1 == Weekday.Mon)
True
&gt;&gt;&gt; print(day1 == Weekday.Tue)
False
&gt;&gt;&gt; print(Weekday(1))
Weekday.Mon
&gt;&gt;&gt; print(day1 == Weekday(1))
True
&gt;&gt;&gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday
&gt;&gt;&gt; for name, member in Weekday.__members__.items():
...     print(name, &#39;=&gt;&#39;, member)
...
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p>
<h3 id="7-6使用元类"><a href="#7-6使用元类" class="headerlink" title="7.6使用元类"></a>7.6使用元类</h3><h4 id="7-6-1type"><a href="#7-6-1type" class="headerlink" title="7.6.1type()"></a>7.6.1type()</h4><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p>比方说我们要定义一个<code>Hello</code>的class，就写一个<code>hello.py</code>模块：</p>
<pre><code class="python">class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s.&#39; % name)</code></pre>
<p>当Python解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的class对象，测试如下：</p>
<pre><code class="python">&gt;&gt;&gt; from hello import Hello
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;hello.Hello&#39;&gt;</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是class <code>Hello</code>。</p>
<p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出<code>Hello</code>类，而无需通过<code>class Hello(object)...</code>的定义：</p>
<pre><code class="python">&gt;&gt;&gt; def fn(self, name=&#39;world&#39;): # 先定义函数
...     print(&#39;Hello, %s.&#39; % name)
...
&gt;&gt;&gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class
&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world.
&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;__main__.Hello&#39;&gt;</code></pre>
<p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>
<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>
<p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h4 id="7-6-2metaclass"><a href="#7-6-2metaclass" class="headerlink" title="7.6.2metaclass"></a>7.6.2metaclass</h4><p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p>
<p>metaclass，直译为元类，简单的解释就是：</p>
<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
<p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>
<p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<pre><code class="python"># metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)</code></pre>
<p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数<code>metaclass</code>：</p>
<pre><code class="python">class MyList(list, metaclass=ListMetaclass):
    pass</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ol>
<p>测试一下<code>MyList</code>是否可以调用<code>add()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; L = MyList()
&gt;&gt;&gt; L.add(1)
&gt;&gt; L
[1]</code></pre>
<p>而普通的<code>list</code>没有<code>add()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; L2 = list()
&gt;&gt;&gt; L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;list&#39; object has no attribute &#39;add&#39;</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>
<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>
<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>
<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>
<p>让我们来尝试编写一个ORM框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个<code>User</code>类来操作对应的数据库表<code>User</code>，我们期待他写出这样的代码：</p>
<pre><code class="python">class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField(&#39;id&#39;)
    name = StringField(&#39;username&#39;)
    email = StringField(&#39;email&#39;)
    password = StringField(&#39;password&#39;)

# 创建一个实例：
u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)
# 保存到数据库：
u.save()</code></pre>
<p>其中，父类<code>Model</code>和属性类型<code>StringField</code>、<code>IntegerField</code>是由ORM框架提供的，剩下的魔术方法比如<code>save()</code>全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该ORM。</p>
<p>首先来定义<code>Field</code>类，它负责保存数据库表的字段名和字段类型：</p>
<pre><code class="python">class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return &#39;&lt;%s:%s&gt;&#39; % (self.__class__.__name__, self.name)</code></pre>
<p>在<code>Field</code>的基础上，进一步定义各种类型的<code>Field</code>，比如<code>StringField</code>，<code>IntegerField</code>等等：</p>
<pre><code class="python">class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, &#39;varchar(100)&#39;)

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, &#39;bigint&#39;)</code></pre>
<p>下一步，就是编写最复杂的<code>ModelMetaclass</code>了：</p>
<pre><code class="python">class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name==&#39;Model&#39;:
            return type.__new__(cls, name, bases, attrs)
        print(&#39;Found model: %s&#39; % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print(&#39;Found mapping: %s ==&gt; %s&#39; % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs[&#39;__mappings__&#39;] = mappings # 保存属性和列的映射关系
        attrs[&#39;__table__&#39;] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)</code></pre>
<p>以及基类<code>Model</code>：</p>
<pre><code class="python">class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Model&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append(&#39;?&#39;)
            args.append(getattr(self, k, None))
        sql = &#39;insert into %s (%s) values (%s)&#39; % (self.__table__, &#39;,&#39;.join(fields), &#39;,&#39;.join(params))
        print(&#39;SQL: %s&#39; % sql)
        print(&#39;ARGS: %s&#39; % str(args))</code></pre>
<p>当用户定义一个<code>class User(Model)</code>时，Python解释器首先在当前类<code>User</code>的定义中查找<code>metaclass</code>，如果没有找到，就继续在父类<code>Model</code>中查找<code>metaclass</code>，找到了，就使用<code>Model</code>中定义的<code>metaclass</code>的<code>ModelMetaclass</code>来创建<code>User</code>类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。</p>
<p>在<code>ModelMetaclass</code>中，一共做了几件事情：</p>
<ol>
<li>排除掉对<code>Model</code>类的修改；</li>
<li>在当前类（比如<code>User</code>）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个<code>__mappings__</code>的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</li>
<li>把表名保存到<code>__table__</code>中，这里简化为表名默认为类名。</li>
</ol>
<p>在<code>Model</code>类中，就可以定义各种操作数据库的方法，比如<code>save()</code>，<code>delete()</code>，<code>find()</code>，<code>update</code>等等。</p>
<p>我们实现了<code>save()</code>方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出<code>INSERT</code>语句。</p>
<p>编写代码试试：</p>
<pre><code class="python">u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)
u.save()</code></pre>
<p>输出如下：</p>
<pre><code class="python">Found model: User
Found mapping: email ==&gt; &lt;StringField:email&gt;
Found mapping: password ==&gt; &lt;StringField:password&gt;
Found mapping: id ==&gt; &lt;IntegerField:uid&gt;
Found mapping: name ==&gt; &lt;StringField:username&gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: [&#39;my-pwd&#39;, &#39;test@orm.org&#39;, &#39;Michael&#39;, 12345]</code></pre>
<p>可以看到，<code>save()</code>方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p>
<p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
<h2 id="八、错误、调试和测试"><a href="#八、错误、调试和测试" class="headerlink" title="八、错误、调试和测试"></a>八、错误、调试和测试</h2><h3 id="8-1错误处理"><a href="#8-1错误处理" class="headerlink" title="8.1错误处理"></a>8.1错误处理</h3><h4 id="8-1-1try"><a href="#8-1-1try" class="headerlink" title="8.1.1try"></a>8.1.1try</h4><p>高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>
<pre><code class="python">try:
    print(&#39;try...&#39;)
    r = 10 / 0
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e:
    print(&#39;except:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
#错误输出：
try...
except: division by zero
finally...
END
#如果把除数0改成2，即修改正确后，输出：
try...
result: 5
finally...
END</code></pre>
<p>由于没有错误发生，所以<code>except</code>语句块不会被执行，但是<code>finally</code>如果有，则一定会被执行（可以没有<code>finally</code>语句）。</p>
<p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句：</p>
<pre><code class="python">try:
    print(&#39;try...&#39;)
    r = 10 / int(&#39;2&#39;)
    print(&#39;result:&#39;, r)
except ValueError as e:
    print(&#39;ValueError:&#39;, e)
except ZeroDivisionError as e:
    print(&#39;ZeroDivisionError:&#39;, e)
else:
    print(&#39;no error!&#39;)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)</code></pre>
<p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”</p>
<p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/exceptions.html#exception-hierarchy</a></p>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理。也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。</p>
<h4 id="8-1-2调用栈"><a href="#8-1-2调用栈" class="headerlink" title="8.1.2调用栈"></a>8.1.2调用栈</h4><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p>
<blockquote>
<p>例子：</p>
<pre><code class="python"># err.py文件:
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar(&#39;0&#39;)

main()
#输出
$ python3 err.py
Traceback (most recent call last):#告诉我们这是错误的跟踪信息。
  File &quot;err.py&quot;, line 11, in &lt;module&gt;#调用main()出错了，在代码文件err.py的第11行代码
    main()
  File &quot;err.py&quot;, line 9, in main#调用bar(&#39;0&#39;)出错了，在代码文件err.py的第9行代码
    bar(&#39;0&#39;)
  File &quot;err.py&quot;, line 6, in bar#原因是return foo(s) * 2这个语句出错了，但这还不是最终原因
    return foo(s) * 2
  File &quot;err.py&quot;, line 3, in foo#原因是return 10 / int(s)这个语句出错了
    return 10 / int(s)
ZeroDivisionError: division by zero#表明这是错误产生的源头</code></pre>
<p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
</blockquote>
<h4 id="8-1-3记录错误"><a href="#8-1-3记录错误" class="headerlink" title="8.1.3记录错误"></a>8.1.3记录错误</h4><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>
<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p>
<pre><code class="python"># err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except Exception as e:
        logging.exception(e)

main()
print(&#39;END&#39;)</code></pre>
<p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：</p>
<pre><code class="python">$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File &quot;err_logging.py&quot;, line 13, in main
    bar(&#39;0&#39;)
  File &quot;err_logging.py&quot;, line 9, in bar
    return foo(s) * 2
  File &quot;err_logging.py&quot;, line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END</code></pre>
<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>
<h4 id="8-1-4抛出错误"><a href="#8-1-4抛出错误" class="headerlink" title="8.1.4抛出错误"></a>8.1.4抛出错误</h4><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>
<p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例：</p>
<pre><code class="python"># err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError(&#39;invalid value: %s&#39; % s)
    return 10 / n

foo(&#39;0&#39;)
#执行后：
$ python3 err_raise.py
Traceback (most recent call last):
  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;
    foo(&#39;0&#39;)
  File &quot;err_throw.py&quot;, line 8, in foo
    raise FooError(&#39;invalid value: %s&#39; % s)
__main__.FooError: invalid value: 0</code></pre>
<p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</p>
<p>最后，我们来看另一种错误处理的方式：</p>
<pre><code class="python"># err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError(&#39;invalid value: %s&#39; % s)
    return 10 / n

def bar():
    try:
        foo(&#39;0&#39;)
    except ValueError as e:
        print(&#39;ValueError!&#39;)
        raise

bar()</code></pre>
<p>在<code>bar()</code>函数中，已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError(&#39;input error!&#39;)</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<h3 id="8-2调试"><a href="#8-2调试" class="headerlink" title="8.2调试"></a>8.2调试</h3><p>第一种方法简单直接粗暴有效，就是用<code>print()</code>把可能有问题的变量打印出来看看</p>
<h4 id="8-2-1断言"><a href="#8-2-1断言" class="headerlink" title="8.2.1断言"></a>8.2.1断言</h4><p>第二种是用断言。凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代</p>
<pre><code class="python">def foo(s):
    n = int(s)
    assert n != 0, &#39;n is zero!&#39;
    return 10 / n

def main():
    foo(&#39;0&#39;)</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p>
<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="python">$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!</code></pre>
<p>程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p>
<pre><code class="python">$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero</code></pre>
<h4 id="8-2-2logging"><a href="#8-2-2logging" class="headerlink" title="8.2.2logging"></a>8.2.2logging</h4><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p>
<pre><code class="python">import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)</code></pre>
<p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。怎么回事？</p>
<p>别急，在<code>import logging</code>之后添加一行配置再试试：</p>
<pre><code class="python">import logging
logging.basicConfig(level=logging.INFO)</code></pre>
<p>看到输出了：</p>
<pre><code class="python">$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
<p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p>
<h4 id="8-2-3pdb"><a href="#8-2-3pdb" class="headerlink" title="8.2.3pdb"></a>8.2.3pdb</h4><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p>
<pre><code class="python"># err.py
s = &#39;0&#39;
n = int(s)
print(10 / n)</code></pre>
<p>然后启动：</p>
<pre><code class="python">$ python -m pdb err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
-&gt; s = &#39;0&#39;</code></pre>
<p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码<code>-&gt; s = &#39;0&#39;</code>。输入命令<code>l</code>来查看代码：</p>
<pre><code class="python">(Pdb) l
  1     # err.py
  2  -&gt; s = &#39;0&#39;
  3     n = int(s)
  4     print(10 / n)</code></pre>
<p>输入命令<code>n</code>可以单步执行代码：</p>
<pre><code class="python">(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()
-&gt; n = int(s)
(Pdb) n
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()
-&gt; print(10 / n)</code></pre>
<p>任何时候都可以输入命令<code>p 变量名</code>来查看变量：</p>
<pre><code class="python">(Pdb) p s
&#39;0&#39;
(Pdb) p n
0</code></pre>
<p>输入命令<code>q</code>结束调试，退出程序：</p>
<pre><code class="python">(Pdb) q</code></pre>
<p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p>
<pre><code class="python">pdb.set_trace()</code></pre>
<p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p>
<pre><code class="python"># err.py
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)</code></pre>
<p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行：</p>
<pre><code class="python">$ python err.py
&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File &quot;err.py&quot;, line 7, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero</code></pre>
<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>
<h3 id="8-3单元测试"><a href="#8-3单元测试" class="headerlink" title="8.3单元测试"></a>8.3单元测试</h3><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<p>比如对函数<code>abs()</code>，我们可以编写出以下几个测试用例：</p>
<ol>
<li>输入正数，比如<code>1</code>、<code>1.2</code>、<code>0.99</code>，期待返回值与输入相同；</li>
<li>输入负数，比如<code>-1</code>、<code>-1.2</code>、<code>-0.99</code>，期待返回值与输入相反；</li>
<li>输入<code>0</code>，期待返回<code>0</code>；</li>
<li>输入非数值类型，比如<code>None</code>、<code>[]</code>、<code>{}</code>，期待抛出<code>TypeError</code>。</li>
</ol>
<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>
<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p>
<p>单元测试通过后有什么意义呢？如果我们对<code>abs()</code>函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对<code>abs()</code>函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>
<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p>
<p>我们来编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p>
<pre><code class="python">&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a
1</code></pre>
<p><code>mydict.py</code>代码如下：</p>
<pre><code class="python">class Dict(dict):

    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value</code></pre>
<p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p>
<pre><code class="python">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEqual(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty</code></pre>
<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p>
<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>
<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p>
<pre><code class="python">self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等</code></pre>
<p>另一种重要的断言就是期待抛出指定类型的Error，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p>
<pre><code class="python">with self.assertRaises(KeyError):
    value = d[&#39;empty&#39;]</code></pre>
<p>而通过<code>d.empty</code>访问不存在的key时，我们期待抛出<code>AttributeError</code>：</p>
<pre><code class="python">with self.assertRaises(AttributeError):
    value = d.empty</code></pre>
<h4 id="8-3-1运行单元测试"><a href="#8-3-1运行单元测试" class="headerlink" title="8.3.1运行单元测试"></a>8.3.1运行单元测试</h4><p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p>
<pre><code class="python">if __name__ == &#39;__main__&#39;:
    unittest.main()</code></pre>
<p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p>
<pre><code class="python">$ python mydict_test.py</code></pre>
<p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p>
<pre><code class="python">$ python -m unittest mydict_test
.....
----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK</code></pre>
<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>
<h4 id="8-3-2setUp与tearDown"><a href="#8-3-2setUp与tearDown" class="headerlink" title="8.3.2setUp与tearDown"></a>8.3.2setUp与tearDown</h4><p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>
<p><code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>
<pre><code class="python">class TestDict(unittest.TestCase):

    def setUp(self):
        print(&#39;setUp...&#39;)

    def tearDown(self):
        print(&#39;tearDown...&#39;)</code></pre>
<p>可以再次运行测试看看每个测试方法调用前后是否会打印出<code>setUp...</code>和<code>tearDown...</code>。</p>
<h4 id="8-3-3文档测试"><a href="#8-3-3文档测试" class="headerlink" title="8.3.3文档测试"></a>8.3.3文档测试</h4><p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如<a href="https://docs.python.org/zh-cn/3/library/re.html" target="_blank" rel="noopener">re模块</a>就带了很多示例代码：</p>
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)
&gt;&gt;&gt; m.group(0)
&#39;def&#39;</code></pre>
<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>
<p>答案是肯定的。</p>
<p>当我们编写注释时，如果写上这样的注释：</p>
<pre><code class="python">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)</code></pre>
<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>
<p>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p>
<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>
<pre><code class="python"># mydict2.py
class Dict(dict):
    &#39;&#39;&#39;
    Simple dict but also support access as x.y style.

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    &#39;&#39;&#39;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__==&#39;__main__&#39;:
    import doctest
    doctest.testmod()</code></pre>
<p>运行<code>python mydict2.py</code>：</p>
<pre><code class="python">$ python mydict2.py</code></pre>
<p>什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把<code>__getattr__()</code>方法注释掉，再运行就会报错：</p>
<pre><code class="python">$ python mydict2.py
**********************************************************************
File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 10, in __main__.Dict
Failed example:
    d1.x
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;x&#39;
**********************************************************************
File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 16, in __main__.Dict
Failed example:
    d2.c
Exception raised:
    Traceback (most recent call last):
      ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;c&#39;
**********************************************************************
1 items had failures:
   2 of   9 in __main__.Dict
***Test Failed*** 2 failures.</code></pre>
<p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p>
<h2 id="九、IO编程"><a href="#九、IO编程" class="headerlink" title="九、IO编程"></a>九、IO编程</h2><p>举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p>
<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>
<p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>
<p>同步和异步的区别就在于是否等待IO执行的结果。很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。</p>
<p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p>
<p>注意，本章的IO编程都是<strong>同步模式</strong>，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p>
<h3 id="9-1文件读写"><a href="#9-1文件读写" class="headerlink" title="9.1文件读写"></a>9.1文件读写</h3><p>Python内置了读写文件的函数，用法和C是兼容的。</p>
<h4 id="9-1-1读文件"><a href="#9-1-1读文件" class="headerlink" title="9.1.1读文件"></a>9.1.1读文件</h4><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)#默认读取UTF-8编码的文本文件</code></pre>
<blockquote>
<p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<pre><code class="python">&gt;&gt;&gt; f=open(&#39;/Users/michael/notfound.txt&#39;, &#39;r&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
FileNotFoundError: [Errno 2] No such file or directory: &#39;/Users/michael/notfound.txt&#39;</code></pre>
</blockquote>
<blockquote>
<p>要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)
&gt;&gt;&gt; f.read()
b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节</code></pre>
<p>读取UTF-8编码的文本文件：</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)
&gt;&gt;&gt; f.read()
&#39;测试&#39;</code></pre>
<p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></pre>
</blockquote>
<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：</p>
<pre><code class="python">&gt;&gt;&gt; f.read()
&#39;Hello, world!&#39;</code></pre>
<p>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
<pre><code class="python">&gt;&gt;&gt; f.close()</code></pre>
<blockquote>
<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p>
<pre><code class="python">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)
    print(f.read())
finally:
    if f:
        f.close()</code></pre>
</blockquote>
<p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p>
<pre><code class="python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())</code></pre>
<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>
<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>
<pre><code class="python">for line in f.readlines():
    print(line.strip()) # 把末尾的&#39;\n&#39;删掉</code></pre>
<h4 id="9-1-2file-like-object"><a href="#9-1-2file-like-object" class="headerlink" title="9.1.2file-like object"></a>9.1.2file-like object</h4><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>
<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h4 id="9-1-3写文件"><a href="#9-1-3写文件" class="headerlink" title="9.1.3写文件"></a>9.1.3写文件</h4><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!&#39;)
&gt;&gt;&gt; f.close()</code></pre>
<p>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p>
<pre><code class="python">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f:
    f.write(&#39;Hello, world!&#39;)</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p>
<p>细心的童鞋会发现，以<code>&#39;w&#39;</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>&#39;a&#39;</code>以追加（append）模式写入。</p>
<p>所有模式的定义及含义可以参考Python内建函数的<a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="9-2StringIO和BytesIO"><a href="#9-2StringIO和BytesIO" class="headerlink" title="9.2StringIO和BytesIO"></a>9.2StringIO和BytesIO</h3><h4 id="9-2-1StringIO"><a href="#9-2-1StringIO" class="headerlink" title="9.2.1StringIO"></a>9.2.1StringIO</h4><p>StringIO顾名思义就是在内存中读写str。</p>
<p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p>
<pre><code class="python">&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; f = StringIO()
&gt;&gt;&gt; f.write(&#39;hello&#39;)
5
&gt;&gt;&gt; f.write(&#39; &#39;)
1
&gt;&gt;&gt; f.write(&#39;world!&#39;)
6
&gt;&gt;&gt; print(f.getvalue())
hello world!</code></pre>
<p><code>getvalue()</code>方法用于获得写入后的str。</p>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
<pre><code class="python">&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)
&gt;&gt;&gt; while True:
...     s = f.readline()
...     if s == &#39;&#39;:
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!</code></pre>
<h4 id="9-2-2BytesIO"><a href="#9-2-2BytesIO" class="headerlink" title="9.2.2BytesIO"></a>9.2.2BytesIO</h4><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<pre><code class="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO()
&gt;&gt;&gt; f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
&gt;&gt;&gt; print(f.getvalue())
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</code></pre>
<p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p>
<p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>
<pre><code class="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
&gt;&gt;&gt; f.read()
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</code></pre>
<p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p>
<h3 id="9-3操作文件和目录"><a href="#9-3操作文件和目录" class="headerlink" title="9.3操作文件和目录"></a>9.3操作文件和目录</h3><p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数：</p>
<pre><code class="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.name # 操作系统类型
&#39;posix&#39;</code></pre>
<p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p>
<p>要获取详细的系统信息，可以调用<code>uname()</code>函数：</p>
<pre><code class="python">&gt;&gt;&gt; os.uname()
posix.uname_result(sysname=&#39;Darwin&#39;, nodename=&#39;MichaelMacPro.local&#39;, release=&#39;14.3.0&#39;, version=&#39;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#39;, machine=&#39;x86_64&#39;)</code></pre>
<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，<code>os</code>模块的某些函数是跟操作系统相关的。</p>
<h4 id="9-3-1环境变量"><a href="#9-3-1环境变量" class="headerlink" title="9.3.1环境变量"></a>9.3.1环境变量</h4><p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个变量中，可以直接查看：</p>
<pre><code class="python">&gt;&gt;&gt; os.environ
environ({&#39;VERSIONER_PYTHON_PREFER_32_BIT&#39;: &#39;no&#39;, &#39;TERM_PROGRAM_VERSION&#39;: &#39;326&#39;, &#39;LOGNAME&#39;: &#39;michael&#39;, &#39;USER&#39;: &#39;michael&#39;, &#39;PATH&#39;: &#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#39;, ...})</code></pre>
<p>要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code>：</p>
<pre><code class="python">&gt;&gt;&gt; os.environ.get(&#39;PATH&#39;)
&#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#39;
&gt;&gt;&gt; os.environ.get(&#39;x&#39;, &#39;default&#39;)
&#39;default&#39;</code></pre>
<h4 id="9-3-2操作文件和目录"><a href="#9-3-2操作文件和目录" class="headerlink" title="9.3.2操作文件和目录"></a>9.3.2操作文件和目录</h4><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<pre><code class="python"># 查看当前目录的绝对路径:
&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)
&#39;/Users/michael&#39;
# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
&gt;&gt;&gt; os.path.join(&#39;/Users/michael&#39;, &#39;testdir&#39;)
&#39;/Users/michael/testdir&#39;
# 然后创建一个目录:
&gt;&gt;&gt; os.mkdir(&#39;/Users/michael/testdir&#39;)
# 删掉一个目录:
&gt;&gt;&gt; os.rmdir(&#39;/Users/michael/testdir&#39;)</code></pre>
<p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，<code>os.path.join()</code>返回这样的字符串：</p>
<pre><code class="python">part-1/part-2</code></pre>
<p>而Windows下会返回这样的字符串：</p>
<pre><code class="python">part-1\part-2</code></pre>
<p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
<pre><code class="python">&gt;&gt;&gt; os.path.split(&#39;/Users/michael/testdir/file.txt&#39;)
(&#39;/Users/michael/testdir&#39;, &#39;file.txt&#39;)</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="python">&gt;&gt;&gt; os.path.splitext(&#39;/path/to/file.txt&#39;)
(&#39;/path/to/file&#39;, &#39;.txt&#39;)</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p>
<p>文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<pre><code class="python"># 对文件重命名:
&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)
# 删掉文件:
&gt;&gt;&gt; os.remove(&#39;test.py&#39;)</code></pre>
<p>但是复制文件的函数居然在<code>os</code>模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p>
<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>
<pre><code class="python">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
[&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]</code></pre>
<p>要列出所有的<code>.py</code>文件，也只需一行代码：</p>
<pre><code class="python">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
[&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]</code></pre>
<h3 id="9-4序列化"><a href="#9-4序列化" class="headerlink" title="9.4序列化"></a>9.4序列化</h3><h4 id="9-4-1pickle"><a href="#9-4-1pickle" class="headerlink" title="9.4.1pickle"></a>9.4.1pickle</h4><p>在程序运行的过程中，所有的变量都是在内存中，</p>
<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<p>Python提供了<code>pickle</code>模块来实现序列化。</p>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object</p>
<pre><code class="python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; d = dict(name=&#39;Bob&#39;, age=20, score=88)
&gt;&gt;&gt; pickle.dumps(d)
b&#39;\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#39;
&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;wb&#39;)
&gt;&gt;&gt; pickle.dump(d, f)
&gt;&gt;&gt; f.close()</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;rb&#39;)
&gt;&gt;&gt; d = pickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; d
{&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}</code></pre>
<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h4 id="9-4-2JSON"><a href="#9-4-2JSON" class="headerlink" title="9.4.2JSON"></a>9.4.2JSON</h4><p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="python">import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;Bob&#39;, 20, 88)
print(json.dumps(s))</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p>
<p>如果连<code>class</code>的实例对象都无法序列化为JSON，这肯定不合理！</p>
<p>别急，我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/json.html#json.dumps" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/json.html#json.dumps</a></p>
<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p>
<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="python">def student2dict(std):
    return {
        &#39;name&#39;: std.name,
        &#39;age&#39;: std.age,
        &#39;score&#39;: std.score
    }</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为JSON：</p>
<pre><code class="python">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="python">print(json.dumps(s, default=lambda obj: obj.__dict__))</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>
<p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="python">def dict2student(d):
    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])</code></pre>
<p>运行结果如下：</p>
<pre><code class="python">&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<p>对中文进行JSON序列化时，<code>json.dumps()</code>提供了一个<code>ensure_ascii</code>参数，当<code>ensure_ascii=True</code>时，会将中文转化为unicode编码，反之<code>ensure_ascii=False</code>，仍转化为汉字</p>
<h2 id="十、进程和线程"><a href="#十、进程和线程" class="headerlink" title="十、进程和线程"></a>十、进程和线程</h2><h3 id="10-1多进程"><a href="#10-1多进程" class="headerlink" title="10.1多进程"></a>10.1多进程</h3><p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
<p>注意：由于Windows没有<code>fork</code>调用，上面的代码在Windows上无法运行。</p>
<h4 id="10-1-1multiprocessing"><a href="#10-1-1multiprocessing" class="headerlink" title="10.1.1multiprocessing"></a>10.1.1multiprocessing</h4><p><code>multiprocessing</code>模块是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<pre><code class="python">from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Process(target=run_proc, args=(&#39;test&#39;,))
    print(&#39;Child process will start.&#39;)
    p.start()
    p.join()
    print(&#39;Child process end.&#39;)</code></pre>
<p>执行结果如下：</p>
<pre><code class="python">Parent process 928.
Child process will start.
Run child process test (929)...
Child Process end.</code></pre>
<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h4 id="10-1-2pool"><a href="#10-1-2pool" class="headerlink" title="10.1.2pool"></a>10.1.2pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<pre><code class="python">from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses done...&#39;)
    p.close()
    p.join()
    print(&#39;All subprocesses done.&#39;)</code></pre>
<p>执行结果如下：</p>
<pre><code class="python">Parent process 669.
Waiting for all subprocesses done...
Run task 0 (671)...
Run task 1 (672)...
Run task 2 (673)...
Run task 3 (674)...
Task 2 runs 0.14 seconds.
Run task 4 (673)...
Task 1 runs 0.27 seconds.
Task 3 runs 0.86 seconds.
Task 0 runs 1.41 seconds.
Task 4 runs 1.91 seconds.
All subprocesses done.</code></pre>
<p>代码解读：</p>
<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：</p>
<pre><code class="python">p = Pool(5)</code></pre>
<p>就可以同时跑5个进程。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>
<h4 id="10-1-3子进程"><a href="#10-1-3子进程" class="headerlink" title="10.1.3子进程"></a>10.1.3子进程</h4><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p>
<pre><code class="python">import subprocess

print(&#39;$ nslookup www.python.org&#39;)
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])
print(&#39;Exit code:&#39;, r)</code></pre>
<p>运行结果：</p>
<pre><code class="python">$ nslookup www.python.org
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
www.python.org    canonical name = python.map.fastly.net.
Name:    python.map.fastly.net
Address: 199.27.79.223

Exit code: 0</code></pre>
<p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p>
<pre><code class="python">import subprocess

print(&#39;$ nslookup&#39;)
p = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(output.decode(&#39;utf-8&#39;))
print(&#39;Exit code:&#39;, p.returncode)</code></pre>
<p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p>
<pre><code class="python">set q=mx
python.org
exit</code></pre>
<p>运行结果如下：</p>
<pre><code class="python">$ nslookup
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
python.org    mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
mail.python.org    internet address = 82.94.164.166
mail.python.org    has AAAA address 2001:888:2000:d::a6


Exit code: 0</code></pre>
<h4 id="10-1-4进程间通信"><a href="#10-1-4进程间通信" class="headerlink" title="10.1.4进程间通信"></a>10.1.4进程间通信</h4><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<pre><code class="python">from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)
        print(&#39;Get %s from queue.&#39; % value)

if __name__==&#39;__main__&#39;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()</code></pre>
<p>运行结果如下：</p>
<pre><code class="python">Process to write: 50563
Put A to queue...
Process to read: 50564
Get A from queue.
Put B to queue...
Get B from queue.
Put C to queue...
Get C from queue.</code></pre>
<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所以，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h3 id="10-2多线程"><a href="#10-2多线程" class="headerlink" title="10.2多线程"></a>10.2多线程</h3><p>Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<pre><code class="python">import time, threading

# 新线程执行的代码:
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()
print(&#39;thread %s ended.&#39; % threading.current_thread().name)</code></pre>
<p>执行结果如下：</p>
<pre><code class="python">thread MainThread is running...
thread LoopThread is running...
thread LoopThread &gt;&gt;&gt; 1
thread LoopThread &gt;&gt;&gt; 2
thread LoopThread &gt;&gt;&gt; 3
thread LoopThread &gt;&gt;&gt; 4
thread LoopThread &gt;&gt;&gt; 5
thread LoopThread ended.
thread MainThread ended.</code></pre>
<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>
<h4 id="10-2-1Lock"><a href="#10-2-1Lock" class="headerlink" title="10.2.1Lock"></a>10.2.1Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p>
<p>此时需要创建一把锁，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<pre><code class="python">balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()</code></pre>
<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<h4 id="10-2-2多核CPU"><a href="#10-2-2多核CPU" class="headerlink" title="10.2.2多核CPU"></a>10.2.2多核CPU</h4><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>
<p>假设想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<pre><code class="python">import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()</code></pre>
<p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter  Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，可以使用多线程，但<strong>不要指望能有效利用多核</strong>。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p>
<h3 id="10-3ThreadLocal"><a href="#10-3ThreadLocal" class="headerlink" title="10.3ThreadLocal"></a>10.3ThreadLocal</h3><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p>
<pre><code class="python">def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)</code></pre>
<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的<code>Student</code>对象，不能共享。</p>
<p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p>
<pre><code class="python">global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...</code></pre>
<p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p>
<p>有没有更简单的方式？</p>
<p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p>
<pre><code class="python">import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target= process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()</code></pre>
<p>执行结果：</p>
<pre><code class="python">Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)</code></pre>
<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>
<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<h3 id="10-4分布式进程"><a href="#10-4分布式进程" class="headerlink" title="10.4分布式进程"></a>10.4分布式进程</h3><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>
<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p>
<pre><code class="python"># task_master.py

import random, time, queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = queue.Queue()
# 接收结果的队列:
result_queue = queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register(&#39;get_task_queue&#39;, callable=lambda: task_queue)
QueueManager.register(&#39;get_result_queue&#39;, callable=lambda: result_queue)
# 绑定端口5000, 设置验证码&#39;abc&#39;:
manager = QueueManager(address=(&#39;&#39;, 5000), authkey=b&#39;abc&#39;)
# 启动Queue:
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; % n)
    task.put(n)
# 从result队列读取结果:
print(&#39;Try get results...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result: %s&#39; % r)
# 关闭:
manager.shutdown()
print(&#39;master exit.&#39;)</code></pre>
<p>windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定，其次，在绑定端口并设置验证码中，windows下需要填写ip地址，linux下不填默认为本地：</p>
<pre><code class="python">def gettask():
    return task_queue;
def getresult():
    return result_queue;
def test():
    #windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定
    BaseManager.register(&#39;get_task&#39;,callable = gettask);
    BaseManager.register(&#39;get_result&#39;,callable = getresult);
    #绑定端口并设置验证码，windows下需要填写ip地址，linux下不填默认为本地
    manager = BaseManager(address = (&#39;127.0.0.1&#39;,5002),authkey = b&#39;123&#39;);</code></pre>
<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<pre><code class="python"># task_worker.py

import time, sys, queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行task_master.py的机器:
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)
# 端口和验证码注意保持与task_master.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=b&#39;abc&#39;)
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d * %d...&#39; % (n, n))
        r = &#39;%d * %d = %d&#39; % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)
# 处理结束:
print(&#39;worker exit.&#39;)</code></pre>
<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p>
<pre><code class="python">$ python3 task_master.py
Put task 3411...
Put task 1605...
Put task 1398...
Put task 4729...
Put task 5300...
Put task 7471...
Put task 68...
Put task 4219...
Put task 339...
Put task 7866...
Try get results...</code></pre>
<p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p>
<pre><code class="python">$ python3 task_worker.py
Connect to server 127.0.0.1...
run task 3411 * 3411...
run task 1605 * 1605...
run task 1398 * 1398...
run task 4729 * 4729...
run task 5300 * 5300...
run task 7471 * 7471...
run task 68 * 68...
run task 4219 * 4219...
run task 339 * 339...
run task 7866 * 7866...
worker exit.</code></pre>
<p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p>
<pre><code class="python">Result: 3411 * 3411 = 11634921
Result: 1605 * 1605 = 2576025
Result: 1398 * 1398 = 1954404
Result: 4729 * 4729 = 22363441
Result: 5300 * 5300 = 28090000
Result: 7471 * 7471 = 55815841
Result: 68 * 68 = 4624
Result: 4219 * 4219 = 17799961
Result: 339 * 339 = 114921
Result: 7866 * 7866 = 61873956</code></pre>
<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中：</p>
<pre><code class="ascii">                                             │
┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐
│task_master.py                           │  │  │task_worker.py                        │
│                                         │     │                                      │
│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │
│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │
│              │                          │  │  │              │                       │
│              │                          │     │              │                       │
│              ▼                          │  │  │              │                       │
│  ┌─────────────────────────────────┐    │     │              │                       │
│  │QueueManager                     │    │  │  │              │                       │
│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │
│  │ │ task_queue │ │ result_queue │ │&lt;───┼──┼──┼──────────────┘                       │
│  │ └────────────┘ └──────────────┘ │    │     │                                      │
│  └─────────────────────────────────┘    │  │  │                                      │
└─────────────────────────────────────────┘     └──────────────────────────────────────┘
                                             │

                                          Network</code></pre>
<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>
<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>
<p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>
<p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>
<h2 id="十二、正则表达式"><a href="#十二、正则表达式" class="headerlink" title="十二、正则表达式"></a>十二、正则表达式</h2><ul>
<li>通用的字符串表达框架</li>
<li>用来<strong>简洁</strong>的表达一组字符串的表达式</li>
<li>是字符串表达”简洁“和”特征“思想的工具</li>
<li>判断某字符串的特征归属</li>
</ul>
<p>正则表达式是由<strong>字符</strong>和<strong>操作符</strong>构成的</p>
<p>操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">表示任何单个字符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">字符集，对单个字符给出取值范围</td>
<td align="center">[abc]表示a、b、c，[a-z]表示a到z单个字符</td>
</tr>
<tr>
<td align="center">[^]</td>
<td align="center">非字符集，对单个字符给出排除范围</td>
<td align="center">[^abc]表示非a或b或c的单个字符</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">前一个字符0次或无限次扩展</td>
<td align="center">abc*表示ab、abc、abcc、abccc等</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">前一个字符1次或无限次扩展</td>
<td align="center">abc+表示abc、abcc、abccc等</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">前一个字符0次或1次扩展</td>
<td align="center">abc?表示abc、abcc、abccc等</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">左右表达式任意一个</td>
<td align="center">abc|def表示abc或者是def</td>
</tr>
<tr>
<td align="center">{m}</td>
<td align="center">扩展前一个字符m次</td>
<td align="center">ab{2}c表示abbc</td>
</tr>
<tr>
<td align="center">{m,n}</td>
<td align="center">扩展前一个字符m至n次（包含n）</td>
<td align="center">ab{1,2}c表示abc、abbc</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配字符串开头</td>
<td align="center">^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配字符串结尾</td>
<td align="center">abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">分组标记，内部只能使用|操作符</td>
<td align="center">(abc)表示abc，(abc|def)表示abc或def</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">数字，等价于[0-9]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">单词字符，等价于[A-Za-z0-9_]</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="12-1基础"><a href="#12-1基础" class="headerlink" title="12.1基础"></a>12.1基础</h3><p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配<strong>一个数字</strong>，<code>\w</code>可以匹配<strong>一个字母或数字</strong>，<code>\W</code>可一匹配一个<strong>非字母或数字的字符</strong>，所以：</p>
<ul>
<li><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</li>
<li><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</li>
<li><code>&#39;\w\w\d&#39;</code>可以匹配<code>&#39;py3&#39;</code>；</li>
</ul>
<p><code>.</code>可以匹配<strong>任意字符</strong>，所以：</p>
<ul>
<li><code>&#39;py.&#39;</code>可以匹配<code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code>等等。</li>
</ul>
<p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示<strong>任意个字符</strong>（包括0个），用<code>+</code>表示<strong>至少一个字符</strong>，用<code>?</code>表示<strong>0个或1个字符</strong>，用<code>{n}</code>表示<strong>n个字符</strong>，用<code>{n,m}</code>表示<strong>n-m个字符</strong>：</p>
<p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。</p>
<p>我们来从左到右解读一下：</p>
<ol>
<li><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li>
<li><code>\s</code>可以匹配<strong>一个空格</strong>（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39; &#39;</code>等；</li>
<li><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li>
</ol>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>
<p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p>
<h3 id="12-2进阶"><a href="#12-2进阶" class="headerlink" title="12.2进阶"></a>12.2进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示<strong>范围</strong>，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;Py3000&#39;</code>等等；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>A|B</code>可以匹配<strong>A或B</strong>，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p>
<p><code>^</code>表示<strong>行的开头</strong>，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示<strong>行的结束</strong>，<code>\d$</code>表示必须以数字结束。</p>
<p>你可能注意到了，<code>py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p>
<h3 id="12-3re模块"><a href="#12-3re模块" class="headerlink" title="12.3re模块"></a>12.3re模块</h3><p>Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p>
<pre><code class="python">s = &#39;ABC\\-001&#39; # Python的字符串
# 对应的正则表达式字符串变成：
# &#39;ABC\-001&#39;</code></pre>
<p>因此我们强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p>
<pre><code class="python">s = r&#39;ABC\-001&#39; # Python的字符串
# 对应的正则表达式字符串不变：
# &#39;ABC\-001&#39;</code></pre>
<p>先看看如何判断正则表达式是否匹配：</p>
<pre><code class="python">&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)
&lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;
&gt;&gt;&gt; re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010 12345&#39;)
&gt;&gt;&gt;</code></pre>
<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p>
<pre><code class="python">test = &#39;用户输入的字符串&#39;
if re.match(r&#39;正则表达式&#39;, test):
    print(&#39;ok&#39;)
else:
    print(&#39;failed&#39;)</code></pre>
<blockquote>
<p><code>match</code>只从字串的开始位置进行匹配，如果失败，它就此放弃；</p>
<p><code>search</code>则会锲而不舍地完全遍历整个字串中所有可能的位置，直到成功地找到一个匹配，或者搜索完字串，以失败告终。</p>
<p>如果你了解match的特性（在某些情况下比较快），大可以自由用它；如果不太清楚，search通常是你需要的那个函数。</p>
<p>从一堆文本中，找出所有可能的匹配，以列表的形式返回，这种情况用<code>findall</code>这个函数</p>
</blockquote>
<h3 id="12-4切分字符串"><a href="#12-4切分字符串" class="headerlink" title="12.4切分字符串"></a>12.4切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;a b   c&#39;.split(&#39; &#39;)
[&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</code></pre>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<pre><code class="python">&gt;&gt;&gt; re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<pre><code class="python">&gt;&gt;&gt; re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre>
<p>再加入<code>;</code>试试：</p>
<pre><code class="python">&gt;&gt;&gt; re.split(r&#39;[\s\,\;]+&#39;, &#39;a,b;; c  d&#39;)
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h3 id="12-5分组"><a href="#12-5分组" class="headerlink" title="12.5分组"></a>12.5分组</h3><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是<strong>要提取的分组</strong>（Group）。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<pre><code class="python">&gt;&gt;&gt; m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;
&gt;&gt;&gt; m.group(0)
&#39;010-12345&#39;
&gt;&gt;&gt; m.group(1)
&#39;010&#39;
&gt;&gt;&gt; m.group(2)
&#39;12345&#39;</code></pre>
<p>如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p>
<p>注意到<code>group(0)</code>永远是原始字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<pre><code class="python">&gt;&gt;&gt; t = &#39;19:05:30&#39;
&gt;&gt;&gt; m = re.match(r&#39;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#39;, t)
&gt;&gt;&gt; m.groups()
(&#39;19&#39;, &#39;05&#39;, &#39;30&#39;)</code></pre>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<pre><code class="python">&#39;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$&#39;</code></pre>
<p>对于<code>&#39;2-30&#39;</code>，<code>&#39;4-31&#39;</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h3 id="12-6贪婪匹配"><a href="#12-6贪婪匹配" class="headerlink" title="12.6贪婪匹配"></a>12.6贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<pre><code class="python">&gt;&gt;&gt; re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()
(&#39;102300&#39;, &#39;&#39;)</code></pre>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<pre><code class="python">&gt;&gt;&gt; re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups()
(&#39;1023&#39;, &#39;00&#39;)</code></pre>
<h3 id="12-7编译"><a href="#12-7编译" class="headerlink" title="12.7编译"></a>12.7编译</h3><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p>
<pre><code class="python">&gt;&gt;&gt; import re
# 编译:
&gt;&gt;&gt; re_telephone = re.compile(r&#39;^(\d{3})-(\d{3,8})$&#39;)
# 使用：
&gt;&gt;&gt; re_telephone.match(&#39;010-12345&#39;).groups()
(&#39;010&#39;, &#39;12345&#39;)
&gt;&gt;&gt; re_telephone.match(&#39;010-8086&#39;).groups()
(&#39;010&#39;, &#39;8086&#39;)</code></pre>
<p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
<h2 id="十三、常用内置模块"><a href="#十三、常用内置模块" class="headerlink" title="十三、常用内置模块"></a>十三、常用内置模块</h2><h3 id="13-1datetime"><a href="#13-1datetime" class="headerlink" title="13.1datetime"></a>13.1datetime</h3><h4 id="13-1-1获取当前日期和时间"><a href="#13-1-1获取当前日期和时间" class="headerlink" title="13.1.1获取当前日期和时间"></a>13.1.1获取当前日期和时间</h4><pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now() # 获取当前datetime
&gt;&gt;&gt; print(now)
2015-05-18 16:28:07.198690
&gt;&gt;&gt; print(type(now))
&lt;class &#39;datetime.datetime&#39;&gt;</code></pre>
<p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p>
<p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p>
<p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p>
<h4 id="13-1-2获取指定日期和时间"><a href="#13-1-2获取指定日期和时间" class="headerlink" title="13.1.2获取指定日期和时间"></a>13.1.2获取指定日期和时间</h4><p>直接用参数构造一个<code>datetime</code>：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; print(dt)
2015-04-19 12:20:00</code></pre>
<h4 id="13-1-3datetime转换为timestamp"><a href="#13-1-3datetime转换为timestamp" class="headerlink" title="13.1.3datetime转换为timestamp"></a>13.1.3datetime转换为timestamp</h4><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p>
<p>你可以认为：</p>
<pre><code class="python">timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00</code></pre>
<p>对应的北京时间是：</p>
<pre><code class="python">timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00</code></pre>
<p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p>
<p>把一个<code>datetime</code>类型转换为timestamp只需要简单调用<code>timestamp()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime
&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp
1429417200.0</code></pre>
<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p>
<p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p>
<h4 id="13-1-4timestamp转换为datetime"><a href="#13-1-4timestamp转换为datetime" class="headerlink" title="13.1.4timestamp转换为datetime"></a>13.1.4timestamp转换为datetime</h4><p>使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t))
2015-04-19 12:20:00</code></pre>
<p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间（当前操作系统设定的时区）做转换。</p>
<p>例如北京时区是东8区，则本地时间：</p>
<pre><code class="python">2015-04-19 12:20:00</code></pre>
<p>实际上就是UTC+8:00时区的时间：</p>
<pre><code class="python">2015-04-19 12:20:00 UTC+8:00</code></pre>
<p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p>
<pre><code class="python">2015-04-19 04:20:00 UTC+0:00</code></pre>
<p>timestamp也可以直接被转换到UTC标准时区的时间：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; t = 1429417200.0
&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间
2015-04-19 12:20:00
&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间
2015-04-19 04:20:00</code></pre>
<h4 id="13-1-5str转换为datetime"><a href="#13-1-5str转换为datetime" class="headerlink" title="13.1.5str转换为datetime"></a>13.1.5str转换为datetime</h4><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。通过<code>datetime.strptime()</code>实现即可，需要一个日期和时间的格式化字符串：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; cday = datetime.strptime(&#39;2015-6-1 18:19:59&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)
&gt;&gt;&gt; print(cday)
2015-06-01 18:19:59</code></pre>
<p>字符串<code>&#39;%Y-%m-%d %H:%M:%S&#39;</code>规定了日期和时间部分的格式。详细的说明请参考<a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">Python文档</a>。</p>
<p>注意转换后的datetime是没有时区信息的。</p>
<h4 id="13-1-6datetime转换为str"><a href="#13-1-6datetime转换为str" class="headerlink" title="13.1.6datetime转换为str"></a>13.1.6datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; print(now.strftime(&#39;%a, %b %d %H:%M&#39;))
Mon, May 05 16:28</code></pre>
<h4 id="13-1-7datetime加减"><a href="#13-1-7datetime加减" class="headerlink" title="13.1.7datetime加减"></a>13.1.7datetime加减</h4><p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(hours=10)
datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)
&gt;&gt;&gt; now - timedelta(days=1)
datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)
&gt;&gt;&gt; now + timedelta(days=2, hours=12)
datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)</code></pre>
<h4 id="13-1-8本地时间转换为UTC时间"><a href="#13-1-8本地时间转换为UTC时间" class="headerlink" title="13.1.8本地时间转换为UTC时间"></a>13.1.8本地时间转换为UTC时间</h4><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p>
<pre><code class="python">&gt;&gt;&gt; from datetime import datetime, timedelta, timezone
&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)
&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00
&gt;&gt;&gt; dt
datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</code></pre>
<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，<strong>不能强制设置</strong>为UTC+8:00时区。</p>
<h4 id="13-1-9时区转换"><a href="#13-1-9时区转换" class="headerlink" title="13.1.9时区转换"></a>13.1.9时区转换</h4><p>先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p>
<pre><code class="python"># 拿到UTC时间，并强制设置时区为UTC+0:00:
&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)
&gt;&gt;&gt; print(utc_dt)
2015-05-18 09:05:12.377316+00:00
# astimezone()将转换时区为北京时间:
&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))
&gt;&gt;&gt; print(bj_dt)
2015-05-18 17:05:12.377316+08:00
# astimezone()将转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt)
2015-05-18 18:05:12.377316+09:00
# astimezone()将bj_dt转换时区为东京时间:
&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))
&gt;&gt;&gt; print(tokyo_dt2)
2015-05-18 18:05:12.377316+09:00</code></pre>
<p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p>
<p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p>
<p><strong>总结</strong>：</p>
<p><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p>
<p>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h3 id="13-2collections"><a href="#13-2collections" class="headerlink" title="13.2collections"></a>13.2collections</h3><h4 id="13-2-1namedtuple"><a href="#13-2-1namedtuple" class="headerlink" title="13.2.1namedtuple"></a>13.2.1namedtuple</h4><p><code>tuple</code>可以表示不变集合，如一个点的二维坐标：</p>
<pre><code class="python">&gt;&gt;&gt; p = (1, 2)</code></pre>
<p>但是，很难看出这个<code>tuple</code>是用来表示一个坐标的。</p>
<p>定义一个class又小题大做了，这时，<code>namedtuple</code>就派上了用场：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import namedtuple
# namedtuple(&#39;名称&#39;, [属性list]):
&gt;&gt;&gt; Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p.x
1
&gt;&gt;&gt; p.y
2</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个<em>自定义的<code>tuple</code>对象</em>，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>
<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类：</p>
<pre><code class="python">&gt;&gt;&gt; isinstance(p, Point)
True
&gt;&gt;&gt; isinstance(p, tuple)
True</code></pre>
<p>类似的，如果要用坐标和半径表示一个圆，也可以用<code>namedtuple</code>定义：</p>
<pre><code class="python"># namedtuple(&#39;名称&#39;, [属性list]):
Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])</code></pre>
<h4 id="13-2-2deque"><a href="#13-2-2deque" class="headerlink" title="13.2.2deque"></a>13.2.2deque</h4><p>使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p>deque是为了高效实现插入和删除操作的<strong>双向列表</strong>，适合用于队列和栈：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; q = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; q.append(&#39;x&#39;)
&gt;&gt;&gt; q.appendleft(&#39;y&#39;)
&gt;&gt;&gt; q
deque([&#39;y&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;x&#39;])</code></pre>
<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="13-2-3defaultdict"><a href="#13-2-3defaultdict" class="headerlink" title="13.2.3defaultdict"></a>13.2.3defaultdict</h4><p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; dd = defaultdict(lambda: &#39;N/A&#39;)
&gt;&gt;&gt; dd[&#39;key1&#39;] = &#39;abc&#39;
&gt;&gt;&gt; dd[&#39;key1&#39;] # key1存在
&#39;abc&#39;
&gt;&gt;&gt; dd[&#39;key2&#39;] # key2不存在，返回默认值
&#39;N/A&#39;</code></pre>
<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>
<p>除了在Key不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="13-2-4OrderedDict"><a href="#13-2-4OrderedDict" class="headerlink" title="13.2.4OrderedDict"></a>13.2.4OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。</p>
<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])
&gt;&gt;&gt; d # dict的Key是无序的
{&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2}
&gt;&gt;&gt; od = OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])
&gt;&gt;&gt; od # OrderedDict的Key是有序的
OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])</code></pre>
<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>
<pre><code class="python">&gt;&gt;&gt; od = OrderedDict()
&gt;&gt;&gt; od[&#39;z&#39;] = 1
&gt;&gt;&gt; od[&#39;y&#39;] = 2
&gt;&gt;&gt; od[&#39;x&#39;] = 3
&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回
[&#39;z&#39;, &#39;y&#39;, &#39;x&#39;]</code></pre>
<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：</p>
<pre><code class="python">from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print(&#39;remove:&#39;, last)
        if containsKey:
            del self[key]
            print(&#39;set:&#39;, (key, value))
        else:
            print(&#39;add:&#39;, (key, value))
        OrderedDict.__setitem__(self, key, value)</code></pre>
<h4 id="13-2-5ChainMap"><a href="#13-2-5ChainMap" class="headerlink" title="13.2.5ChainMap"></a>13.2.5ChainMap</h4><p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。</p>
<p>什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p>下面的代码演示了如何查找<code>user</code>和<code>color</code>这两个参数：</p>
<pre><code class="python">from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    &#39;color&#39;: &#39;red&#39;,
    &#39;user&#39;: &#39;guest&#39;
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument(&#39;-u&#39;, &#39;--user&#39;)
parser.add_argument(&#39;-c&#39;, &#39;--color&#39;)
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print(&#39;color=%s&#39; % combined[&#39;color&#39;])
print(&#39;user=%s&#39; % combined[&#39;user&#39;])</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="python">$ python3 use_chainmap.py
color=red
user=guest</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="python">$ python3 use_chainmap.py -u bob
color=red
user=bob</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="python">$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob</code></pre>
<h4 id="13-2-6Counter"><a href="#13-2-6Counter" class="headerlink" title="13.2.6Counter"></a>13.2.6Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="python">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for ch in &#39;programming&#39;:
...     c[ch] = c[ch] + 1
...
&gt;&gt;&gt; c
Counter({&#39;g&#39;: 2, &#39;m&#39;: 2, &#39;r&#39;: 2, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;o&#39;: 1, &#39;n&#39;: 1, &#39;p&#39;: 1})
&gt;&gt;&gt; c.update(&#39;hello&#39;) # 也可以一次性update
&gt;&gt;&gt; c
Counter({&#39;r&#39;: 2, &#39;o&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;l&#39;: 2, &#39;p&#39;: 1, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;n&#39;: 1, &#39;h&#39;: 1, &#39;e&#39;: 1})</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<h3 id="13-3base64"><a href="#13-3base64" class="headerlink" title="13.3base64"></a>13.3base64</h3><p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>
<p>用记事本打开<code>exe</code>、<code>jpg</code>、<code>pdf</code>这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>
<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>
<pre><code class="python">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code></pre>
<p>然后，对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24</code>bit，划为4组，每组正好6个bit</p>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
<p>Python内置的<code>base64</code>可以直接进行base64的编解码：</p>
<pre><code class="python">&gt;&gt;&gt; import base64
&gt;&gt;&gt; base64.b64encode(b&#39;binary\x00string&#39;)
b&#39;YmluYXJ5AHN0cmluZw==&#39;
&gt;&gt;&gt; base64.b64decode(b&#39;YmluYXJ5AHN0cmluZw==&#39;)
b&#39;binary\x00string&#39;</code></pre>
<p>由于标准的Base64编码后可能出现字符<code>+</code>和<code>/</code>，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>：</p>
<pre><code class="python">&gt;&gt;&gt; base64.b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
b&#39;abcd++//&#39;
&gt;&gt;&gt; base64.urlsafe_b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
b&#39;abcd--__&#39;
&gt;&gt;&gt; base64.urlsafe_b64decode(&#39;abcd--__&#39;)
b&#39;i\xb7\x1d\xfb\xef\xff&#39;</code></pre>
<p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过通常情况下完全没有必要。</p>
<p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>
<p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p>
<p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉。</p>
<h3 id="13-4struct"><a href="#13-4struct" class="headerlink" title="13.4struct"></a>13.4struct</h3><p>准确地讲，Python没有专门处理字节的数据类型。但由于<code>b&#39;str&#39;</code>可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p>
<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的<code>bytes</code>，你得配合位运算符这么写：</p>
<pre><code class="python">&gt;&gt;&gt; n = 10240099
&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24
&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16
&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8
&gt;&gt;&gt; b4 = n &amp; 0xff
&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])
&gt;&gt;&gt; bs
b&#39;\x00\x9c@c&#39;</code></pre>
<p>非常麻烦。如果换成浮点数就无能为力了。</p>
<p>好在Python提供了一个<code>struct</code>模块来解决<code>bytes</code>和其他二进制数据类型的转换。</p>
<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code>：</p>
<pre><code class="python">&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack(&#39;&gt;I&#39;, 10240099)
b&#39;\x00\x9c@c&#39;</code></pre>
<p><code>pack</code>的第一个参数是处理指令，<code>&#39;&gt;I&#39;</code>的意思是：</p>
<p><code>&gt;</code>表示字节顺序是big-endian，也就是网络序，<code>I</code>表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p><code>unpack</code>把<code>bytes</code>变成相应的数据类型：</p>
<pre><code class="python">&gt;&gt;&gt; struct.unpack(&#39;&gt;IH&#39;, b&#39;\xf0\xf0\xf0\xf0\x80\x80&#39;)
(4042322160, 32896)</code></pre>
<p>根据<code>&gt;IH</code>的说明，后面的<code>bytes</code>依次变为<code>I</code>：4字节无符号整数和<code>H</code>：2字节无符号整数。</p>
<p><code>struct</code>模块定义的数据类型可以参考Python官方文档：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/struct.html#format-characters" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/struct.html#format-characters</a></p>
<blockquote>
<p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用<code>struct</code>分析一下。</p>
<p>首先找一个bmp文件，没有的话用“画图”画一个。</p>
<p>读入前30个字节来分析：</p>
<pre><code class="python">&gt;&gt;&gt; s = b&#39;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00&#39;</code></pre>
<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>
<p>两个字节：<code>&#39;BM&#39;</code>表示Windows位图，<code>&#39;BA&#39;</code>表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。</p>
<p>所以，组合起来用<code>unpack</code>读取：</p>
<pre><code class="python">&gt;&gt;&gt; struct.unpack(&#39;&lt;ccIIIIIIHH&#39;, s)
(b&#39;B&#39;, b&#39;M&#39;, 691256, 0, 54, 40, 640, 360, 1, 24)</code></pre>
<p>结果显示，<code>b&#39;B&#39;</code>、<code>b&#39;M&#39;</code>说明是Windows位图，位图大小为640x360，颜色数为24。</p>
</blockquote>
<h3 id="13-5hashlib"><a href="#13-5hashlib" class="headerlink" title="13.5hashlib"></a>13.5hashlib</h3><p>Python的hashlib提供了常见的摘要算法（又称哈希算法、散列算法），如MD5，SHA1等等。</p>
<p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>
<pre><code class="python">import hashlib

md5 = hashlib.md5()
md5.update(&#39;how to use md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;))
print(md5.hexdigest())</code></pre>
<p>计算结果如下：</p>
<pre><code class="python">d26a53750bc40b38b65a520292f69306</code></pre>
<p>如果数据量很大，可以分块多次调用<code>update()</code>，最后计算的结果是一样的：</p>
<pre><code class="python">import hashlib

md5 = hashlib.md5()
md5.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))
md5.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
print(md5.hexdigest())</code></pre>
<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p>
<p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<pre><code class="python">import hashlib

sha1 = hashlib.sha1()
sha1.update(&#39;how to use sha1 in &#39;.encode(&#39;utf-8&#39;))
sha1.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
print(sha1.hexdigest())</code></pre>
<p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p>
<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p>
<p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章<code>&#39;how to learn hashlib in python - by Bob&#39;</code>，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p>
<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p>
<p>考虑这么个情况，很多用户喜欢用<code>123456</code>，<code>888888</code>，<code>password</code>这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<pre><code class="python">&#39;e10adc3949ba59abbe56e057f20f883e&#39;: &#39;123456&#39;
&#39;21218cca77804d2ba1922c33e0151105&#39;: &#39;888888&#39;
&#39;5f4dcc3b5aa765d61d8327deb882cf99&#39;: &#39;password&#39;</code></pre>
<p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>
<p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>
<pre><code class="python">def calc_md5(password):
    return get_md5(password + &#39;the-Salt&#39;)</code></pre>
<p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>
<p>但是如果有两个用户都使用了相同的简单口令比如<code>123456</code>，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p>
<p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>
<h3 id="13-6hmac"><a href="#13-6hmac" class="headerlink" title="13.6hmac"></a>13.6hmac</h3><p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的<code>password_md5</code>对比计算<code>md5(password)</code>的结果，如果一致，用户输入的口令就是正确的。</p>
<p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p>
<p>如果salt是我们自己随机生成的，通常我们计算MD5时采用<code>md5(message + salt)</code>。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p>
<p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p>
<p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p>
<p>Python自带的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p>
<p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p>
<pre><code class="python">&gt;&gt;&gt; import hmac
&gt;&gt;&gt; message = b&#39;Hello, world!&#39;
&gt;&gt;&gt; key = b&#39;secret&#39;
&gt;&gt;&gt; h = hmac.new(key, message, digestmod=&#39;MD5&#39;)
&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)
&gt;&gt;&gt; h.hexdigest()
&#39;fa4ee7d173f2d97ee79022d1a7355bcf&#39;</code></pre>
<p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是<code>bytes</code>类型，<code>str</code>类型需要首先编码为<code>bytes</code>。</p>
<h3 id="13-7itertools"><a href="#13-7itertools" class="headerlink" title="13.7itertools"></a>13.7itertools</h3><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p>
<p>首先，我们看看<code>itertools</code>提供的几个“无限”迭代器：</p>
<pre><code class="python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; for n in natuals:
...     print(n)
...
1
2
3
...</code></pre>
<p>因为<code>count()</code>会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按<code>Ctrl+C</code>退出。</p>
<p><code>cycle()</code>会把传入的一个序列无限重复下去：</p>
<pre><code class="python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; cs = itertools.cycle(&#39;ABC&#39;) # 注意字符串也是序列的一种
&gt;&gt;&gt; for c in cs:
...     print(c)
...
&#39;A&#39;
&#39;B&#39;
&#39;C&#39;
&#39;A&#39;
&#39;B&#39;
&#39;C&#39;
...</code></pre>
<p>同样停不下来。</p>
<p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p>
<pre><code class="python">&gt;&gt;&gt; ns = itertools.repeat(&#39;A&#39;, 3)
&gt;&gt;&gt; for n in ns:
...     print(n)
...
A
A
A</code></pre>
<p>无限序列只有在<code>for</code>迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。</p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列：</p>
<pre><code class="python">&gt;&gt;&gt; natuals = itertools.count(1)
&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)
&gt;&gt;&gt; list(ns)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre>
<p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p>
<h4 id="13-7-1chain"><a href="#13-7-1chain" class="headerlink" title="13.7.1chain()"></a>13.7.1chain()</h4><p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>
<pre><code class="python">&gt;&gt;&gt; for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):
...     print(c)
# 迭代效果：&#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;X&#39; &#39;Y&#39; &#39;Z&#39;</code></pre>
<h4 id="13-7-2groupby"><a href="#13-7-2groupby" class="headerlink" title="13.7.2groupby()"></a>13.7.2groupby()</h4><p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p>
<pre><code class="python">&gt;&gt;&gt; for key, group in itertools.groupby(&#39;AAABBBCCAAA&#39;):
...     print(key, list(group))
...
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;]
C [&#39;C&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]</code></pre>
<p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素<code>&#39;A&#39;</code>和<code>&#39;a&#39;</code>都返回相同的key：</p>
<pre><code class="python">&gt;&gt;&gt; for key, group in itertools.groupby(&#39;AaaBBbcCAAa&#39;, lambda c: c.upper()):
...     print(key, list(group))
...
A [&#39;A&#39;, &#39;a&#39;, &#39;a&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;b&#39;]
C [&#39;c&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;a&#39;]</code></pre>
<h3 id="13-8contextlib"><a href="#13-8contextlib" class="headerlink" title="13.8contextlib"></a>13.8contextlib</h3><p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用<code>try...finally</code>：</p>
<pre><code class="python">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)
    f.read()
finally:
    if f:
        f.close()</code></pre>
<p>写<code>try...finally</code>非常繁琐。Python的<code>with</code>语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：</p>
<pre><code class="python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    f.read()</code></pre>
<p>并不是只有<code>open()</code>函数返回的fp对象才能使用<code>with</code>语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p>
<p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。例如，下面的class实现了这两个方法：</p>
<pre><code class="python">class Query(object):

    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print(&#39;Begin&#39;)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type:
            print(&#39;Error&#39;)
        else:
            print(&#39;End&#39;)

    def query(self):
        print(&#39;Query info about %s...&#39; % self.name)</code></pre>
<p>这样我们就可以把自己写的资源对象用于<code>with</code>语句：</p>
<pre><code class="python">with Query(&#39;Bob&#39;) as q:
    q.query()</code></pre>
<h4 id="13-8-1-contextmanager"><a href="#13-8-1-contextmanager" class="headerlink" title="13.8.1@contextmanager"></a>13.8.1@contextmanager</h4><p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法，上面的代码可以改写如下：</p>
<pre><code class="python">from contextlib import contextmanager

class Query(object):

    def __init__(self, name):
        self.name = name

    def query(self):
        print(&#39;Query info about %s...&#39; % self.name)

@contextmanager
def create_query(name):
    print(&#39;Begin&#39;)
    q = Query(name)
    yield q
    print(&#39;End&#39;)</code></pre>
<p><code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了：</p>
<pre><code class="python">with create_query(&#39;Bob&#39;) as q:
    q.query()</code></pre>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现。例如：</p>
<pre><code class="python">@contextmanager
def tag(name):
    print(&quot;&lt;%s&gt;&quot; % name)
    yield
    print(&quot;&lt;/%s&gt;&quot; % name)

with tag(&quot;h1&quot;):
    print(&quot;hello&quot;)
    print(&quot;world&quot;)</code></pre>
<p>上述代码执行结果为：</p>
<pre><code class="python">&lt;h1&gt;
hello
world
&lt;/h1&gt;</code></pre>
<p>代码的执行顺序是：</p>
<ol>
<li><code>with</code>语句首先执行<code>yield</code>之前的语句，因此打印出<code>&lt;h1&gt;</code>；</li>
<li><code>yield</code>调用会执行<code>with</code>语句内部的所有语句，因此打印出<code>hello</code>和<code>world</code>；</li>
<li>最后执行<code>yield</code>之后的语句，打印出<code>&lt;/h1&gt;</code>。</li>
</ol>
<p>因此，<code>@contextmanager</code>让我们通过编写generator来简化上下文管理。</p>
<h4 id="13-8-2-closing"><a href="#13-8-2-closing" class="headerlink" title="13.8.2@closing"></a>13.8.2@closing</h4><p>如果一个对象没有实现上下文，我们就不能把它用于<code>with</code>语句。这个时候，可以用<code>closing()</code>来把该对象变为上下文对象。例如，用<code>with</code>语句使用<code>urlopen()</code>：</p>
<pre><code class="python">from contextlib import closing
from urllib.request import urlopen

with closing(urlopen(&#39;https://www.python.org&#39;)) as page:
    for line in page:
        print(line)</code></pre>
<p><code>closing</code>也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：</p>
<pre><code class="python">@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()</code></pre>
<p>它的作用就是把任意对象变为上下文对象，并支持<code>with</code>语句。</p>
<p><code>@contextlib</code>还有一些其他decorator，便于我们编写更简洁的代码。</p>
<h3 id="13-9urllib"><a href="#13-9urllib" class="headerlink" title="13.9urllib"></a>13.9urllib</h3><p>urllib提供了一系列用于操作URL的功能。</p>
<h4 id="13-9-1Get"><a href="#13-9-1Get" class="headerlink" title="13.9.1Get"></a>13.9.1Get</h4><p>urllib的<code>request</code>模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p>
<p>例如，对豆瓣的一个URL<code>https://api.douban.com/v2/book/2129650</code>进行抓取，并返回响应：</p>
<pre><code class="python">from urllib import request

with request.urlopen(&#39;https://api.douban.com/v2/book/2129650&#39;) as f:
    data = f.read()
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, data.decode(&#39;utf-8&#39;))</code></pre>
<p>可以看到HTTP响应的头和JSON数据：</p>
<pre><code class="python">Status: 200 OK
Server: nginx
Date: Tue, 26 May 2015 10:02:27 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 2049
Connection: close
Expires: Sun, 1 Jan 2006 01:00:00 GMT
Pragma: no-cache
Cache-Control: must-revalidate, no-cache, private
X-DAE-Node: pidl1
Data: {&quot;rating&quot;:{&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0},&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...}</code></pre>
<p>如果我们要想模拟浏览器发送GET请求，就需要使用<code>Request</code>对象，通过往<code>Request</code>对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：</p>
<pre><code class="python">from urllib import request

req = request.Request(&#39;http://www.douban.com/&#39;)
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)
with request.urlopen(req) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))</code></pre>
<p>这样豆瓣会返回适合iPhone的移动版网页：</p>
<pre><code class="python">...
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;
    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;
    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;
...</code></pre>
<h4 id="13-9-2Post"><a href="#13-9-2Post" class="headerlink" title="13.9.2Post"></a>13.9.2Post</h4><p>如果要以POST发送一个请求，只需要把参数<code>data</code>以bytes形式传入。</p>
<p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以<code>username=xxx&amp;password=xxx</code>的编码传入：</p>
<pre><code class="python">from urllib import request, parse

print(&#39;Login to weibo.cn...&#39;)
email = input(&#39;Email: &#39;)
passwd = input(&#39;Password: &#39;)
login_data = parse.urlencode([
    (&#39;username&#39;, email),
    (&#39;password&#39;, passwd),
    (&#39;entry&#39;, &#39;mweibo&#39;),
    (&#39;client_id&#39;, &#39;&#39;),
    (&#39;savestate&#39;, &#39;1&#39;),
    (&#39;ec&#39;, &#39;&#39;),
    (&#39;pagerefer&#39;, &#39;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)
])

req = request.Request(&#39;https://passport.weibo.cn/sso/login&#39;)
req.add_header(&#39;Origin&#39;, &#39;https://passport.weibo.cn&#39;)
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)
req.add_header(&#39;Referer&#39;, &#39;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)

with request.urlopen(req, data=login_data.encode(&#39;utf-8&#39;)) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))</code></pre>
<p>如果登录成功，我们获得的响应如下：</p>
<pre><code class="python">Status: 200 OK
Server: nginx/1.2.0
...
Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn
...
Data: {&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:{...,&quot;uid&quot;:&quot;1658384301&quot;}}</code></pre>
<p>如果登录失败，我们获得的响应如下：</p>
<pre><code class="python">...
Data: {&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:{&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536}}</code></pre>
<h4 id="13-9-3Handler"><a href="#13-9-3Handler" class="headerlink" title="13.9.3Handler"></a>13.9.3Handler</h4><p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用<code>ProxyHandler</code>来处理，示例代码如下：</p>
<pre><code class="python">proxy_handler = urllib.request.ProxyHandler({&#39;http&#39;: &#39;http://www.example.com:3128/&#39;})
proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password(&#39;realm&#39;, &#39;host&#39;, &#39;username&#39;, &#39;password&#39;)
opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open(&#39;http://www.example.com/login.html&#39;) as f:
    pass</code></pre>
<p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，<code>User-Agent</code>头就是用来标识浏览器的。</p>
<h2 id="十四、常用第三方模块"><a href="#十四、常用第三方模块" class="headerlink" title="十四、常用第三方模块"></a>十四、常用第三方模块</h2><p>基本上，所有的第三方模块都会在<a href="https://pypi.python.org/" target="_blank" rel="noopener">PyPI - the Python Package Index</a>上注册，只要找到对应的模块名字，即可用pip安装。</p>
<h3 id="14-1Pillow"><a href="#14-1Pillow" class="headerlink" title="14.1Pillow"></a>14.1Pillow</h3><p>PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。</p>
<p>由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。</p>
<p>如果安装了Anaconda，Pillow就已经可用了。否则，需要在命令行下通过pip安装：</p>
<pre><code class="bash">$ pip install pillow</code></pre>
<h4 id="14-1-1操作图像"><a href="#14-1-1操作图像" class="headerlink" title="14.1.1操作图像"></a>14.1.1操作图像</h4><p>来看看最常见的图像缩放操作，只需三四行代码：</p>
<pre><code class="python">from PIL import Image

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open(&#39;test.jpg&#39;)
# 获得图像尺寸:
w, h = im.size
print(&#39;Original image size: %sx%s&#39; % (w, h))
# 缩放到50%:
im.thumbnail((w//2, h//2))
print(&#39;Resize image to: %sx%s&#39; % (w//2, h//2))
# 把缩放后的图像用jpeg格式保存:
im.save(&#39;thumbnail.jpg&#39;, &#39;jpeg&#39;)</code></pre>
<p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。</p>
<p>比如，模糊效果也只需几行代码：</p>
<pre><code class="python">from PIL import Image, ImageFilter

# 打开一个jpg图像文件，注意是当前路径:
im = Image.open(&#39;test.jpg&#39;)
# 应用模糊滤镜:
im2 = im.filter(ImageFilter.BLUR)
im2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)</code></pre>
<p>效果如下：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/966760155050624.jfif" alt="PIL-blur"></p>
<p>PIL的<code>ImageDraw</code>提供了一系列绘图方法，让我们可以直接绘图。比如要生成字母验证码图片：</p>
<pre><code class="python">from PIL import Image, ImageDraw, ImageFont, ImageFilter

import random

# 随机字母:
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1:
def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))

# 随机颜色2:
def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))

# 240 x 60:
width = 60 * 4
height = 60
image = Image.new(&#39;RGB&#39;, (width, height), (255, 255, 255))
# 创建Font对象:
font = ImageFont.truetype(&#39;Arial.ttf&#39;, 36)
# 创建Draw对象:
draw = ImageDraw.Draw(image)
# 填充每个像素:
for x in range(width):
    for y in range(height):
        draw.point((x, y), fill=rndColor())
# 输出文字:
for t in range(4):
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())
# 模糊:
image = image.filter(ImageFilter.BLUR)
image.save(&#39;code.jpg&#39;, &#39;jpeg&#39;)</code></pre>
<p>我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：</p>
<p><img src="//NU-LL.github.io/2020/01/10/python/966760380198752.jfif" alt="验证码"></p>
<p>如果运行的时候报错：</p>
<pre><code class="python">IOError: cannot open resource</code></pre>
<p>这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：</p>
<pre><code class="python">&#39;/Library/Fonts/Arial.ttf&#39;</code></pre>
<p>要详细了解PIL的强大功能，请请参考Pillow官方文档：</p>
<p><a href="https://pillow.readthedocs.org/" target="_blank" rel="noopener">https://pillow.readthedocs.org/</a></p>
<h3 id="14-2requests"><a href="#14-2requests" class="headerlink" title="14.2requests"></a>14.2requests</h3><p>Python内置的urllib模块用于访问网络资源，但是用起来比较麻烦，而且缺少很多实用的高级功能。</p>
<p>更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。</p>
<p>如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install requests</code></p>
<p>要通过GET访问一个页面，只需要几行代码：</p>
<pre><code class="python">&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/&#39;) # 豆瓣首页
&gt;&gt;&gt; r.status_code
200
&gt;&gt;&gt; r.text
r.text
&#39;&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta name=&quot;description&quot; content=&quot;提供图书、电影、音乐唱片的推荐、评论和...&#39;</code></pre>
<p>对于带参数的URL，传入一个dict作为<code>params</code>参数：</p>
<pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/search&#39;, params={&#39;q&#39;: &#39;python&#39;, &#39;cat&#39;: &#39;1001&#39;})
&gt;&gt;&gt; r.url # 实际请求的URL
&#39;https://www.douban.com/search?q=python&amp;cat=1001&#39;</code></pre>
<p>requests自动检测编码，可以使用<code>encoding</code>属性查看：</p>
<pre><code class="python">&gt;&gt;&gt; r.encoding
&#39;utf-8&#39;</code></pre>
<p>无论响应是文本还是二进制内容，我们都可以用<code>content</code>属性获得<code>bytes</code>对象：</p>
<pre><code class="python">&gt;&gt;&gt; r.content
b&#39;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n...&#39;</code></pre>
<p>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：</p>
<pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json&#39;)
&gt;&gt;&gt; r.json()
{&#39;query&#39;: {&#39;count&#39;: 1, &#39;created&#39;: &#39;2017-11-17T07:14:12Z&#39;, ...</code></pre>
<p>需要传入HTTP Header时，我们传入一个dict作为<code>headers</code>参数：</p>
<pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/&#39;, headers={&#39;User-Agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit&#39;})
&gt;&gt;&gt; r.text
&#39;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;豆瓣(手机版)&lt;/title&gt;...&#39;</code></pre>
<p>要发送POST请求，只需要把<code>get()</code>方法变成<code>post()</code>，然后传入<code>data</code>参数作为POST请求的数据：</p>
<pre><code class="python">&gt;&gt;&gt; r = requests.post(&#39;https://accounts.douban.com/login&#39;, data={&#39;form_email&#39;: &#39;abc@example.com&#39;, &#39;form_password&#39;: &#39;123456&#39;})</code></pre>
<p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数：</p>
<pre><code class="python">params = {&#39;key&#39;: &#39;value&#39;}
r = requests.post(url, json=params) # 内部自动序列化为JSON</code></pre>
<p>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成<code>files</code>参数：</p>
<pre><code class="python">&gt;&gt;&gt; upload_files = {&#39;file&#39;: open(&#39;report.xls&#39;, &#39;rb&#39;)}
&gt;&gt;&gt; r = requests.post(url, files=upload_files)</code></pre>
<p>在读取文件时，注意务必使用<code>&#39;rb&#39;</code>即二进制模式读取，这样获取的<code>bytes</code>长度才是文件的长度。</p>
<p>把<code>post()</code>方法替换为<code>put()</code>，<code>delete()</code>等，就可以以PUT或DELETE方式请求资源。</p>
<p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：</p>
<pre><code class="python">&gt;&gt;&gt; r.headers
{Content-Type&#39;: &#39;text/html; charset=utf-8&#39;, &#39;Transfer-Encoding&#39;: &#39;chunked&#39;, &#39;Content-Encoding&#39;: &#39;gzip&#39;, ...}
&gt;&gt;&gt; r.headers[&#39;Content-Type&#39;]
&#39;text/html; charset=utf-8&#39;</code></pre>
<p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p>
<pre><code class="python">&gt;&gt;&gt; r.cookies[&#39;ts&#39;]
&#39;example_cookie_12345&#39;</code></pre>
<p>要在请求中传入Cookie，只需准备一个dict传入<code>cookies</code>参数：</p>
<pre><code class="python">&gt;&gt;&gt; cs = {&#39;token&#39;: &#39;12345&#39;, &#39;status&#39;: &#39;working&#39;}
&gt;&gt;&gt; r = requests.get(url, cookies=cs)</code></pre>
<p>最后，要指定超时，传入以秒为单位的timeout参数：</p>
<pre><code class="python">&gt;&gt;&gt; r = requests.get(url, timeout=2.5) # 2.5秒后超时</code></pre>
<h3 id="14-3chardet"><a href="#14-3chardet" class="headerlink" title="14.3chardet"></a>14.3chardet</h3><p>字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的<code>str</code>和<code>bytes</code>两种数据类型，并且可以通过<code>encode()</code>和<code>decode()</code>方法转换，但是，在不知道编码的情况下，对<code>bytes</code>做<code>decode()</code>不好做。</p>
<p>对于未知编码的<code>bytes</code>，要把它转换成<code>str</code>，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p>
<p>当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。</p>
<p>如果安装了Anaconda，chardet就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install chardet</code></p>
<p>当我们拿到一个<code>bytes</code>时，就可以对其检测编码。用chardet检测编码，只需要一行代码：</p>
<pre><code class="python">&gt;&gt;&gt; chardet.detect(b&#39;Hello, world!&#39;)
{&#39;encoding&#39;: &#39;ascii&#39;, &#39;confidence&#39;: 1.0, &#39;language&#39;: &#39;&#39;}</code></pre>
<p>检测出的编码是<code>ascii</code>，注意到还有个<code>confidence</code>字段，表示检测的概率是1.0（即100%）。</p>
<p>再试试检测GBK编码的中文：</p>
<pre><code class="python">&gt;&gt;&gt; data = &#39;离离原上草，一岁一枯荣&#39;.encode(&#39;gbk&#39;)
&gt;&gt;&gt; chardet.detect(data)
{&#39;encoding&#39;: &#39;GB2312&#39;, &#39;confidence&#39;: 0.7407407407407407, &#39;language&#39;: &#39;Chinese&#39;}</code></pre>
<p>检测的编码是<code>GB2312</code>，注意到GBK是GB2312的超集，两者是同一种编码，检测正确的概率是74%，<code>language</code>字段指出的语言是<code>&#39;Chinese&#39;</code>。</p>
<p>对UTF-8编码进行检测：</p>
<pre><code class="python">&gt;&gt;&gt; data = &#39;离离原上草，一岁一枯荣&#39;.encode(&#39;utf-8&#39;)
&gt;&gt;&gt; chardet.detect(data)
{&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}</code></pre>
<p>我们再试试对日文进行检测：</p>
<pre><code class="python">&gt;&gt;&gt; data = &#39;最新の主要ニュース&#39;.encode(&#39;euc-jp&#39;)
&gt;&gt;&gt; chardet.detect(data)
{&#39;encoding&#39;: &#39;EUC-JP&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;Japanese&#39;}</code></pre>
<p>可见，用chardet检测编码，使用简单。获取到编码后，再转换为<code>str</code>，就可以方便后续处理。</p>
<p>chardet支持检测的编码列表请参考官方文档<a href="https://chardet.readthedocs.io/en/latest/supported-encodings.html" target="_blank" rel="noopener">Supported encodings</a>。</p>
<h3 id="14-4psutil"><a href="#14-4psutil" class="headerlink" title="14.4psutil"></a>14.4psutil</h3><p>要获取一些系统信息，Python可以通过<code>subprocess</code>模块调用并获取结果。但这样做显得很麻烦，尤其是要写很多解析代码。</p>
<p>在Python中获取系统信息的另一个好办法是使用<code>psutil</code>（ process and system utilities）这个第三方模块。它不仅可以通过一两行代码实现系统监控，还支持Linux／UNIX／OSX／Windows等。更多信息：<a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">https://github.com/giampaolo/psutil</a></p>
<p>如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install psutil</code></p>
<h4 id="14-4-1获取CPU信息"><a href="#14-4-1获取CPU信息" class="headerlink" title="14.4.1获取CPU信息"></a>14.4.1获取CPU信息</h4><pre><code class="python">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量
4
&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心
2
# 2说明是双核超线程, 4则是4核非超线程</code></pre>
<p>统计CPU的用户／系统／空闲时间：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.cpu_times()
scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)</code></pre>
<p>再实现类似<code>top</code>命令的CPU使用率，每秒刷新一次，累计10次：</p>
<pre><code class="python">&gt;&gt;&gt; for x in range(10):
...     psutil.cpu_percent(interval=1, percpu=True)
...
[14.0, 4.0, 4.0, 4.0]
[12.0, 3.0, 4.0, 3.0]
[8.0, 4.0, 3.0, 4.0]
[12.0, 3.0, 3.0, 3.0]
[18.8, 5.1, 5.9, 5.0]
[10.9, 5.0, 4.0, 3.0]
[12.0, 5.0, 4.0, 5.0]
[15.0, 5.0, 4.0, 4.0]
[19.0, 5.0, 5.0, 4.0]
[9.0, 3.0, 2.0, 3.0]</code></pre>
<h4 id="14-4-2获取内存信息"><a href="#14-4-2获取内存信息" class="headerlink" title="14.4.2获取内存信息"></a>14.4.2获取内存信息</h4><p>使用psutil获取物理内存和交换内存信息，分别使用：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.virtual_memory()
svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480)
&gt;&gt;&gt; psutil.swap_memory()
sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)</code></pre>
<p>返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。</p>
<p>而交换区大小是1073741824 = 1 GB。</p>
<h4 id="14-4-3获取磁盘信息"><a href="#14-4-3获取磁盘信息" class="headerlink" title="14.4.3获取磁盘信息"></a>14.4.3获取磁盘信息</h4><p>可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息
[sdiskpart(device=&#39;/dev/disk1&#39;, mountpoint=&#39;/&#39;, fstype=&#39;hfs&#39;, opts=&#39;rw,local,rootfs,dovolfs,journaled,multilabel&#39;)]
&gt;&gt;&gt; psutil.disk_usage(&#39;/&#39;) # 磁盘使用情况
sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)
&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IO
sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)</code></pre>
<p>可以看到，磁盘<code>&#39;/&#39;</code>的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，<code>opts</code>中包含<code>rw</code>表示可读写，<code>journaled</code>表示支持日志。</p>
<h4 id="14-4-4获取网络信息"><a href="#14-4-4获取网络信息" class="headerlink" title="14.4.4获取网络信息"></a>14.4.4获取网络信息</h4><p>psutil可以获取网络接口和网络连接信息：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数
snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0)
&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息
{
  &#39;lo0&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;127.0.0.1&#39;, netmask=&#39;255.0.0.0&#39;), ...],
  &#39;en1&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;10.0.1.80&#39;, netmask=&#39;255.255.255.0&#39;), ...],
  &#39;en0&#39;: [...],
  &#39;en2&#39;: [...],
  &#39;bridge0&#39;: [...]
}
&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态
{
  &#39;lo0&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=16384),
  &#39;en0&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=1500),
  &#39;en1&#39;: snicstats(...),
  &#39;en2&#39;: snicstats(...),
  &#39;bridge0&#39;: snicstats(...)
}</code></pre>
<p>要获取当前网络连接信息，使用<code>net_connections()</code>：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.net_connections()
Traceback (most recent call last):
  ...
PermissionError: [Errno 1] Operation not permitted

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  ...
psutil.AccessDenied: psutil.AccessDenied (pid=3847)</code></pre>
<p>你可能会得到一个<code>AccessDenied</code>错误，原因是psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用<code>sudo</code>重新启动：</p>
<pre><code class="python">$ sudo python3
Password: ******
Python 3.6.3 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_connections()
[
    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62911), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),
    sconn(fd=84, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62905), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),
    sconn(fd=93, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::&#39;, port=8080), raddr=(), status=&#39;LISTEN&#39;, pid=3725),
    sconn(fd=103, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62918), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),
    sconn(fd=105, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=106, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    sconn(fd=107, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),
    ...
    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)
]</code></pre>
<h4 id="14-4-5获取进程信息"><a href="#14-4-5获取进程信息" class="headerlink" title="14.4.5获取进程信息"></a>14.4.5获取进程信息</h4><p>通过psutil可以获取到所有进程的详细信息：</p>
<pre><code class="python">&gt;&gt;&gt; psutil.pids() # 所有进程ID
[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]
&gt;&gt;&gt; p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境
&gt;&gt;&gt; p.name() # 进程名称
&#39;python3.6&#39;
&gt;&gt;&gt; p.exe() # 进程exe路径
&#39;/Users/michael/anaconda3/bin/python3.6&#39;
&gt;&gt;&gt; p.cwd() # 进程工作目录
&#39;/Users/michael&#39;
&gt;&gt;&gt; p.cmdline() # 进程启动的命令行
[&#39;python3&#39;]
&gt;&gt;&gt; p.ppid() # 父进程ID
3765
&gt;&gt;&gt; p.parent() # 父进程
&lt;psutil.Process(pid=3765, name=&#39;bash&#39;) at 4503144040&gt;
&gt;&gt;&gt; p.children() # 子进程列表
[]
&gt;&gt;&gt; p.status() # 进程状态
&#39;running&#39;
&gt;&gt;&gt; p.username() # 进程用户名
&#39;michael&#39;
&gt;&gt;&gt; p.create_time() # 进程创建时间
1511052731.120333
&gt;&gt;&gt; p.terminal() # 进程终端
&#39;/dev/ttys002&#39;
&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间
pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)
&gt;&gt;&gt; p.memory_info() # 进程使用的内存
pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)
&gt;&gt;&gt; p.open_files() # 进程打开的文件
[]
&gt;&gt;&gt; p.connections() # 进程相关网络连接
[]
&gt;&gt;&gt; p.num_threads() # 进程的线程数量
1
&gt;&gt;&gt; p.threads() # 所有线程信息
[pthread(id=1, user_time=0.090318, system_time=0.062736)]
&gt;&gt;&gt; p.environ() # 进程环境变量
{&#39;SHELL&#39;: &#39;/bin/bash&#39;, &#39;PATH&#39;: &#39;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...&#39;, &#39;PWD&#39;: &#39;/Users/michael&#39;, &#39;LANG&#39;: &#39;zh_CN.UTF-8&#39;, ...}
&gt;&gt;&gt; p.terminate() # 结束进程
Terminated: 15 &lt;-- 自己把自己结束了</code></pre>
<p>和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者<code>.py</code>文件时，需要<code>sudo</code>权限。</p>
<p>psutil还提供了一个<code>test()</code>函数，可以模拟出<code>ps</code>命令的效果：</p>
<pre><code class="python">$ sudo python3
Password: ******
Python 3.6.3 ... on darwin
Type &quot;help&quot;, ... for more information.
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.test()
USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMAND
root           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_task
root           1  0.1 2494140    9484 ?             Nov18   01:39  launchd
root          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgent
root          45    ? 2474032    1516 ?             Nov18   00:14  syslogd
root          47  0.1 2504768    8912 ?             Nov18   00:03  kextd
root          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd
_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsd
root          53  0.1 2500592    6132 ?             Nov18   00:02  configd
...</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达。邮件：1125934312@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>Python</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">55k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="NU-LL">NU-LL</a></p>
    <p><span class="copy-title">发布时间:</span>2020-01-10, 20:18:52</p>
    <p><span class="copy-title">最后更新:</span>2020-02-24, 19:15:08</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/01/10/python/" title="Python">http://NU-LL.github.io/2020/01/10/python/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 NU-LL</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="/js/script.js?v=1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#ESP8266','#Docker','#DM9000C','#网卡移植','#Kconfig语法','#Latex','#Ctex','#IIC驱动','#Linux服务','#LiCheePi Zero','#文件描述符','#Linux内核','#Markdown','#Mininet','#字符驱动','#数据分析','#Xmanager','#远程链接','#NanoPi Neo Core','#Kubernetes','#git','#network namespace','#markdownlint','#python实战','#python','#爬虫','#u-boot','#二维数组','#指针','#存储器','#IAP','#BootLoader','#dual bank','#按键驱动','#异步通知机制','#根文件系统','#等待队列','#wait_queue_head_t','#wait_queue_t','#poll机制','#深度学习','#TensorFlow2','#快速排序','#网卡驱动框架','#虚拟网卡','#设备树','#输入子系统','#Go语言入门经典','#驱动API','#廖雪峰python教程',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    

    
</style>







</html>
