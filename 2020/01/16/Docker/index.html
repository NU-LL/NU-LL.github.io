<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Docker | spaceman</title><meta name="keywords" content="Docker"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、环境搭建（Ubuntu 18.04） 本文前期Docker环境为：Windows10 1809 企业版 + VMware Workstation 15 Pro + Ubuntu 18.04.2LTS 后期Kubernetes环境为：Windows10 1809 企业版 + Vagrant 2.2.7 + VirtualBox 6.1.4 + centos7&#x2F;Ubuntu 18.04 LTS V">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://nu-ll.github.io/2020/01/16/Docker/index.html">
<meta property="og:site_name" content="spaceman">
<meta property="og:description" content="一、环境搭建（Ubuntu 18.04） 本文前期Docker环境为：Windows10 1809 企业版 + VMware Workstation 15 Pro + Ubuntu 18.04.2LTS 后期Kubernetes环境为：Windows10 1809 企业版 + Vagrant 2.2.7 + VirtualBox 6.1.4 + centos7&#x2F;Ubuntu 18.04 LTS V">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2020-01-16T12:14:51.000Z">
<meta property="article:modified_time" content="2021-08-12T14:26:50.580Z">
<meta property="article:author" content="spaceman">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2020/01/16/Docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-12 22:26:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">spaceman</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-01-16T12:14:51.000Z" title="发表于 2020-01-16 20:14:51">2020-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-12T14:26:50.580Z" title="更新于 2021-08-12 22:26:50">2021-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、环境搭建（Ubuntu-18-04）">一、环境搭建（Ubuntu 18.04）</h2>
<p>本文前期Docker环境为：Windows10 1809 企业版 + VMware Workstation 15 Pro + Ubuntu 18.04.2LTS</p>
<p>后期Kubernetes环境为：Windows10 1809 企业版 + Vagrant 2.2.7 + VirtualBox 6.1.4 + centos7/Ubuntu 18.04 LTS</p>
<h3 id="Vagrant-VirtualBox">Vagrant+VirtualBox</h3>
<p>下载Vagrant安装包：<a target="_blank" rel="noopener" href="https://www.vagrantup.com/downloads.html">官网链接</a></p>
<p>下载VirtualBox安装包：<a target="_blank" rel="noopener" href="https://www.virtualbox.org/wiki/Downloads">官网链接</a>，不过VirtualBox下载需要梯子，可以通过<a target="_blank" rel="noopener" href="https://mirror.tuna.tsinghua.edu.cn/help/virtualbox/">清华镜像</a>下载</p>
<p>vagrant的相关image可以通过<a target="_blank" rel="noopener" href="https://app.vagrantup.com/boxes/search">该网址</a>进行搜索</p>
<p>上述两个软件均傻瓜式安装即可，可以通过下面的方法利用Vagrant在VirtualBox中创建虚拟机：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Vagrant版本</span></span><br><span class="line">vagrant <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line">mkdir centos7</span><br><span class="line"></span><br><span class="line"><span class="comment">####################创建centos 7的镜像#############################</span></span><br><span class="line"><span class="comment">#初始化一个centos7的Vagrant file（类似于makefile）</span></span><br><span class="line">vagrant init centos/<span class="number">7</span></span><br><span class="line"><span class="comment">#创建centos7的虚拟机，此处会下载image，时间较久</span></span><br><span class="line">vagrant up</span><br><span class="line"></span><br><span class="line"><span class="comment">####################创建ubuntu的镜像#############################</span></span><br><span class="line"><span class="comment">#初始化一个Ubuntu 18.04 LTS的Vagrant file</span></span><br><span class="line">vagrant init ubuntu/bionic64</span><br><span class="line"><span class="comment">#创建Ubuntu 18.04 LTS的虚拟机，此处会下载image，时间较久</span></span><br><span class="line">vagrant up</span><br><span class="line"></span><br><span class="line"><span class="comment">####################国内镜像源 创建ubuntu的镜像#############################</span></span><br><span class="line"><span class="comment">#初始化一个Ubuntu 18.04 LTS的Vagrant file</span></span><br><span class="line">vagrant init ubuntu/bionic64</span><br><span class="line"><span class="comment">#采用清华镜像 </span></span><br><span class="line">vagrant box add https://mirrors.tuna.tsinghua.edu.cn/ubuntu<span class="literal">-cloud-images</span>/bionic/current/bionic<span class="literal">-server-cloudimg-amd64-vagrant</span>.box <span class="literal">--name</span> ubuntu/bionic64</span><br><span class="line"><span class="comment">#创建Ubuntu 18.04 LTS的虚拟机，此处会下载image，时间较久</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如需换成其他镜像需要自己去<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/">清华镜像</a>（有可能没有）中查找对应的<code>box</code>文件</li>
<li>也可以采取用其他方式下载<code>box</code>文件（如百度网盘），再通过命令行添加，详细方法即相关地址可以参考<a target="_blank" rel="noopener" href="https://c4ys.com/archives/1230">这篇博客</a></li>
<li>如果Windows用户名是中文，则可能在<code>vagrant up</code>这一步报<code>incompatible character encodings: GBK and UTF-8 (Encoding::CompatibilityError)</code>类似错误，具体方法详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/eebaicai/article/details/82148901?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">这篇博客</a>，概括为以下几步：
<ul>
<li>设置环境变量VAGRANT_HOME为不包含中文的路径，该环境变量是用于保存Vagrant下载的<code>box</code>镜像文件（具体路径为<code>$(VAGRANT_HOME)/.vagrant.d</code>）</li>
<li>修改VirtualBox中全局配置选项中的 默认虚拟电脑位置VirtualBox VMs的路径 ，不能包含中文名</li>
</ul>
</li>
<li>注意Vagrant和VirtualBox版本需要匹配，有的版本不匹配可能会报各种错误，本文中测试一切正常</li>
<li>默认Vagrant当前配置为在启用<code>SharedFoldersEnableSymlinksCreate</code>选项的情况下创建VirtualBox同步的文件夹。 如果不信任Vagrant访客，则可能要禁用此选项。 有关此选项的更多信息，请参考<a target="_blank" rel="noopener" href="https://www.virtualbox.org/manual/ch04.html#sharedfolders">VirtualBox手册</a>。
<ul>
<li>可以通过环境变量全局禁用此选项：<code>VAGRANT_DISABLE_VBOXSYMLINKCREATE = 1</code></li>
<li>在Vagrantfile中配置如下代码：<code>config.vm.synced_folder '/host/path', '/guest/path', SharedFoldersEnableSymlinksCreate: false</code></li>
</ul>
</li>
</ul>
<p>通过Vagrant命令进入centos7中的shell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
<p>如果想通过其他方式登录虚拟机（如：Xshell），可以通过如下命令获取hostname、port、IdentityFile三个配置信息：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">E:\Ubuntu&gt;vagrant ssh<span class="literal">-config</span></span><br><span class="line">Host default</span><br><span class="line">  HostName <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">  User vagrant</span><br><span class="line">  Port <span class="number">2222</span></span><br><span class="line">  UserKnownHostsFile /dev/null</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  PasswordAuthentication no</span><br><span class="line">  IdentityFile E:/Ubuntu/.vagrant/machines/default/virtualbox/private_key</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  LogLevel FATAL</span><br></pre></td></tr></table></figure>
<p>其中：HostName为主机IP地址，Port为开放的端口，IdentityFile为Public Key秘钥文件的路径，依次填入其他软件的相应设置中即可访问该虚拟机</p>
<p>另外，该虚拟机默认登录账号用户名为vagrant，密码为vagrant，root账号密码为vagrant。也有可能没有root密码，需要通过<code>sudo passwd</code>命令重设密码</p>
<blockquote>
<p>附：ubuntu18.04换清华源：</p>
<p>编辑<code>/etc/apt/sources.list</code>文件，修改为以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="安装Docker-Engine-Community">安装Docker Engine - Community</h3>
<p>官方文档教程详见：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu | Docker Documentation</a></p>
<p>设置源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果有之前的版本 需要删除</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release</span><br><span class="line"><span class="comment">#添加Docker官方GPG秘钥</span></span><br><span class="line"> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="comment">#添加Docker源</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"><span class="comment">#建议采用国内源（docker ce）：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.bfsu.edu.cn/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于Docker hub源不稳定，推荐国内源：</p>
<ul>
<li>docker官方中国区 <code>https://registry.docker-cn.com</code></li>
<li>网易 <code>http://hub-mirror.c.163.com</code></li>
<li>ustc <code>http://docker.mirrors.ustc.edu.cn</code>
<ul>
<li>2020 年 4 月起失效</li>
</ul>
</li>
<li>阿里云 <code>http://&lt;你的ID&gt;.mirror.aliyuncs.com</code>
<ul>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/60750.html">官方镜像加速 - 容器镜像服务 ACR - 阿里云</a></li>
</ul>
</li>
</ul>
<p>ustc帮助文档：<a target="_blank" rel="noopener" href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#添加以下内容 注意不能是https 否则最后一点下载不下来</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>,<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,<span class="string">&quot;https://registry.docker-cn.com&quot;</span>],</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#重启docker服务</span></span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过<code>docker info</code>查看是否设置成功</li>
</ul>
</blockquote>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装Docker Engine - Community</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#安装最新版</span></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">sudo docker version</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者自己选择版本安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>
</blockquote>
<p>卸载Docker Engine - Community</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge docker-ce</span><br><span class="line"><span class="comment">#删除所有镜像，容器和卷(volumes)：</span></span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h3 id="nvidia-docker">nvidia docker</h3>
<p>NVIDIA于2016年开始设计NVIDIA-Docker以便于容器使用NVIDIA GPUs。 第一代nvidia-docker1.0实现了对docker client的封装，并在容器启动时，将必要的GPU device和libraries挂载到容器中。但是这种设计的方式高度的与docker运行时耦合，缺乏灵活性：</p>
<ul>
<li>设计高度与docker耦合，不支持其它的容器运行时。如: LXC, CRI-O及未来可能会增加的容器运行时。</li>
<li>不能更好的利用docker生态的其它工具。如: docker compose。</li>
<li>不能将GPU作为调度系统的一种资源来进行灵活的调度。</li>
<li>完善容器运行时对GPU的支持。如: 自动的获取用户层面的NVIDIA Driver libraries, NVIDIA kernel modules, device ordering等。</li>
</ul>
<p>基于上面描述的这些弊端，NVIDIA开始了对下一代容器运行时的设计: nvidia-docker2.0</p>
<p>nvidia-docker2.0中核心部分是<code>nvidia-container-runtime</code>，在原有的<code>docker</code>容器运行时<code>runc</code>的基础上增加一个<code>prestart hook</code>，用于调用libnvidia-container库</p>
<blockquote>
<p>RunC 是一个轻量级的工具，用来运行容器。可以认为它是个命令行小工具，可以不用通过 docker 引擎，直接运行容器。</p>
<p>事实上，runC 是标准化的产物，它根据 OCI 标准来创建和运行容器。而 OCI(Open Container Initiative)组织，旨在围绕容器格式和运行时制定一个开放的工业化标准。</p>
<p>直接使用RunC的命令行即可以完成创建一个容器，并提供了简单的交互能力。</p>
</blockquote>
<p>正常创建容器流程：<code>docker --&gt; dockerd --&gt; containerd--&gt; containerd-shim --&gt;runc --&gt; container-process</code></p>
<p>创建gpu容器：<code>docker--&gt; dockerd --&gt; containerd --&gt; containerd-shim--&gt; nvidia-container-runtime --&gt; nvidia-container-runtime-hook --&gt; libnvidia-container --&gt; runc -- &gt; container-process</code></p>
<h4 id="安装-3">安装</h4>
<blockquote>
<p>参考链接：</p>
<ul>
<li>项目源码：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker">NVIDIA/nvidia-docker: Build and run Docker containers leveraging NVIDIA GPUs</a></li>
<li>官方安装指南：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">Installation Guide — NVIDIA Cloud Native Technologies documentation</a></li>
<li>官方使用手册：<a target="_blank" rel="noopener" href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#environment-variables-oci-spec">User Guide — NVIDIA Cloud Native Technologies documentation</a></li>
<li>docker hub镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/nvidia/cuda">nvidia/cuda - Docker Image</a></li>
<li>官方FAQ：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker/wiki">NVIDIA/nvidia-docker Wiki</a></li>
</ul>
<p>配置要求：</p>
<ol>
<li>Linux内核版本 &gt; 3.10</li>
<li>Docker版本 &gt;= 19.03</li>
<li>NVIDIA GPU架构最低需求 &gt;= Kepler</li>
<li><a target="_blank" rel="noopener" href="http://www.nvidia.com/object/unix.html">NVIDIA Linux 驱动</a> &gt;= 418.81.07</li>
</ol>
</blockquote>
<p>根据上述章节安装完docker后即可安装nvidia docker。nvidia docker分为两个版本，推荐安装nvidia docker2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加nvidia官方GPG秘钥</span></span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> $ID<span class="variable">$VERSION_ID</span>) &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list</span><br></pre></td></tr></table></figure>
<ul>
<li>这里在Ubuntu20.04上最后安装的源是用的18.04的，可能是官方还未修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nvidia docker2</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y nvidia-docker2</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在之前换过docker hub源，这里在安装nvidia docker2是会报一个警告，直接按y同意替换即可，之后再手动将源修改回来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启并验证nvidia docker2</span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure>
<ul>
<li>nvidia docker提供三种类型的镜像：
<ul>
<li>base：包括cuda（cudart）</li>
<li>runtime：base+cuda数学库+NCCL+cuDNN</li>
<li>devel：runtime+各种cuda头文件+cuda开发工具包</li>
</ul>
</li>
</ul>
<h4 id="环境变量设置">环境变量设置</h4>
<p>可以通过设置特定的环境变量或者CLI中传入特定参数使用</p>
<h5 id="gpu数量">gpu数量</h5>
<p>用户能够通过系统环境变量<code>NVIDIA_VISIBLE_DEVICES</code>或者docker CLI的<code>--gpu</code>选项指定gpu：</p>
<table>
<thead>
<tr>
<th>变量值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0,1,2,</code> 或 <code>GPU-fef8089b</code></td>
<td>GPU UUID 或索引列表</td>
</tr>
<tr>
<td><code>all</code></td>
<td>所有gpu均可用，默认值</td>
</tr>
<tr>
<td><code>none</code></td>
<td>所有gpu均不可用，但是驱动仍正常使用</td>
</tr>
<tr>
<td><code>void</code> or empty or unset</td>
<td><code>nvidia-container-runtime</code> 将与 <code>runc</code>行为一样 (如：没有gpu也没有驱动)</td>
</tr>
</tbody>
</table>
<ul>
<li>使用环境变量时，需要添加<code>--runtime=nvidia</code>参数，否则将使用默认参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用--gpus参数</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda nvidia-smi</span><br><span class="line">docker run --gpus <span class="string">&#x27;&quot;device=1,2&quot;&#x27;</span> nvidia/cuda nvidia-smi --query-gpu=uuid --format-csv</span><br><span class="line"><span class="comment"># 用环境变量</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all nvidia/cuda nvidia-smi</span><br><span class="line">docker run --<span class="built_in">rm</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=1,2 nvidia/cuda nvidia-smi --query-gpu=uuid --format=csv</span><br><span class="line"><span class="comment"># 使用uuid</span></span><br><span class="line">nvidia-smi -i 3 --query-gpu=uuid --format=csv <span class="comment">#  查询uuid</span></span><br><span class="line">docker run --gpus device=GPU-18a3e86f-4c0e-cd9f-59c3-55488c4b0c24 nvidia/cuda nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在两块GPU上启动GPU的容器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --gpus 2 nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure>
<h5 id="驱动">驱动</h5>
<p>设置环境变量<code>NVIDIA_DRIVER_CAPABILITIES</code>，或<code>--gpus参数</code>即可：</p>
<table>
<thead>
<tr>
<th>变量值</th>
<th>描述值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compute,video</code> 或 <code>graphics,utility</code></td>
<td>容器需要的驱动程序功能的逗号分隔列表</td>
</tr>
<tr>
<td><code>all</code></td>
<td>使能全部功能</td>
</tr>
<tr>
<td>empty or unset</td>
<td>默认<code>utility</code></td>
</tr>
</tbody>
</table>
<p>下面提供了支持的驱动程序功能：</p>
<table>
<thead>
<tr>
<th>驱动参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compute</code></td>
<td>CUDA + OpenCL</td>
</tr>
<tr>
<td><code>compat32</code></td>
<td>32位程序</td>
</tr>
<tr>
<td><code>graphics</code></td>
<td>OpenGL + Vulkan</td>
</tr>
<tr>
<td><code>utility</code></td>
<td><code>nvidia-smi</code> 和 NVML</td>
</tr>
<tr>
<td><code>video</code></td>
<td>Video Codec SDK</td>
</tr>
<tr>
<td><code>display</code></td>
<td>X11</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要CUDA 和 NVML 能力</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=2,3 -e NVIDIA_DRIVER_CAPABILITIES=compute,utility nvidia/cuda nvidia-smi</span><br><span class="line">docker run --<span class="built_in">rm</span> --gpus <span class="string">&#x27;all,&quot;capabilities=compute,utility&quot;&#x27;</span> nvidia/cuda:11.0-base nvidia-smi</span><br></pre></td></tr></table></figure>
<h5 id="资源限制">资源限制</h5>
<p>通过如下的一个逻辑表达式，定义容器上软件版本或 GPU 架构的约束。</p>
<p>基本形式为<code>NVIDIA_REQUIRE_*</code>，支持以下几种：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cuda</code></td>
<td>限制CUDA版本</td>
</tr>
<tr>
<td><code>driver</code></td>
<td>限制驱动版本</td>
</tr>
<tr>
<td><code>arch</code></td>
<td>限制gpu的架构</td>
</tr>
<tr>
<td><code>brand</code></td>
<td>限制gpu的型号(如：GeForce, Tesla, GRID)</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制驱动与cuda版本</span></span><br><span class="line">NVIDIA_REQUIRE_CUDA <span class="string">&quot;cuda&gt;=11.0 driver&gt;=450&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>NVIDIA_DISABLE_REQUIRE</code>宏则会禁用上述限制</p>
<h2 id="二、Docker的镜像和容器">二、Docker的镜像和容器</h2>
<h3 id="架构和底层">架构和底层</h3>
<ul>
<li>Docker是一个平台，提供一个开发、打包、运行app的平台</li>
<li>把app和底层设备隔离开</li>
</ul>
<p><img src="/2020/01/16/Docker/image-20200204233756060.png" alt="Docker架构"></p>
<p>Docker Engine：</p>
<ul>
<li>后台进程（dockerd）
<ul>
<li>提供 REST API 的服务（Server）
<ul>
<li>提供 CLI（client，客户端）</li>
</ul>
</li>
<li>C-S架构</li>
</ul>
</li>
</ul>
<p><img src="/2020/01/16/Docker/image-20200204233846121.png" alt="Docker Engine"></p>
<p>整体架构：</p>
<p><img src="/2020/01/16/Docker/image-20200204234359788.png" alt="整体架构"></p>
<ul>
<li>Client：Docker提供的命令（可以和host在一台机器上）</li>
<li>Docker Host：启动了dockerd的机器
<ul>
<li>images</li>
<li>containers</li>
</ul>
</li>
<li>Registry：库，类似于GitHub</li>
</ul>
<p>docker底层技术支持：</p>
<ul>
<li>Namespaces:隔离pid、net、ipc、mnt、uts</li>
<li>Control groups:做资源限制</li>
<li>Union file systems:Container和 nimage的分层</li>
</ul>
<h3 id="Image">Image</h3>
<p>官方命令手册：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/image/">https://docs.docker.com/engine/reference/commandline/image/</a></p>
<ul>
<li>文件和 meta data的集合( root filesystem)</li>
<li>分层的,并且每一层都可以添加改变删除文件,成为一个新的image</li>
<li>不同的image可以共享相同的 layer</li>
<li>Image本身是read-only的</li>
</ul>
<p>Dockerfile：通过该文件定义一个image并能够构建该image</p>
<p>BaseImge：直接基于Linux的内核，在内核上制作的一个镜像（如各种Linux的发行版：ubuntu、centos等），可以在该镜像上在制作一个新的image</p>
<p><img src="/2020/01/16/Docker/image-20200205000255254.png" alt="image-20200205000255254"></p>
<h3 id="Container">Container</h3>
<p>官方命令手册：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/container/">https://docs.docker.com/engine/reference/commandline/container/</a></p>
<ul>
<li>通过image创建(copy)</li>
<li>在image layer之上建立一个container layer(可读写)</li>
<li>类比面向对象:类（image）和实例（container）</li>
<li>Image负责app的存储和分发, Container负责运行app</li>
</ul>
<p><img src="/2020/01/16/Docker/image-20200205001054091.png" alt="Container"></p>
<h3 id="构建自己的image">构建自己的image</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于container(xxx,名字,name)创建一个image(yyy)  不提倡，不安全</span></span><br><span class="line">sudo docker container commit xxx yyy</span><br><span class="line">sudo docker commit xxx yyy</span><br><span class="line"><span class="comment">#从dockerfile构建一个image</span></span><br><span class="line">sudo docker image build -t tag(docker的tag) .(基于那个目录构建)</span><br><span class="line">sudo docker build -t tag(docker的tag) .(基于那个目录构建)</span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">sudo docker build -t dockerusernull/flask-hello-world /home/null/Code/docker/helloworld/</span><br></pre></td></tr></table></figure>
<h4 id="调试">调试</h4>
<p>每次构建的时候，在每一层都会生成临时容器并通过<code>--&gt;</code>显示出该容器的id（<code>docker images</code>也可以，注意观察生成时间），可以通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it 临时容器<span class="built_in">id</span> /bin/bash</span><br></pre></td></tr></table></figure>
<p>有时候会因为升级docker镜像中的软件失败而导致镜像生成失败，此时通过进入docker内部更换<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/">清华源</a>即可</p>
<h4 id="运行">运行</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run image名字</span><br><span class="line">sudo docker run -d image名字<span class="comment">#后台运行</span></span><br><span class="line">sudo docker run -d --name=demo image名字<span class="comment">#后台运行 并指定一个名字 否则会自动分配</span></span><br><span class="line"><span class="comment">#停止contaniner</span></span><br><span class="line">sudo docker container stop <span class="built_in">id</span></span><br><span class="line">sudo docker stop <span class="built_in">id</span></span><br><span class="line"><span class="comment">#启动contaniner</span></span><br><span class="line">sudo docker start <span class="built_in">id</span>或名字</span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">sudo docker run dockerusernull/flask-hello-world</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--name</code>指定的名字具有唯一性，可以替代id用于别的命令</li>
<li><code>docker start</code>：只要不删除，该命令就能够重新启动stop的容器</li>
</ul>
<p><strong>exec</strong>：进运行中的容器内部，看具体的细节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash<span class="comment">#exec：对运行中的容器执行的命令(/bin/bash) -it：交互式的执行</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> ip a<span class="comment">#打印运行中的容器的ip地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不止运行/bin/bash，还可运行其他命令，如：python等</li>
</ul>
<h3 id="DockerFile">DockerFile</h3>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p>
<ul>
<li>
<p><code>FROM</code>：选择base image，在该base image上构建新的image</p>
<ul>
<li><code>FROM scratch</code>：从头制作base image</li>
<li>尽量使用官方的image作为 base image</li>
</ul>
</li>
<li>
<p><code>LABEL</code>：定义image的metadata（类似代码中的注释）</p>
<ul>
<li>
<pre><code class="language-dockerfile">  LABEL maintainer=&quot;xiaoquwl@gmail.com&quot;
  LABEL version=&quot;1.0&quot;
  LABEL description=&quot;This is description&quot;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	* 不可少，能够让人更加明白</span><br><span class="line"></span><br><span class="line">* `RUN`：运行命令，每一次RUN都会使image生成新的一层</span><br><span class="line"></span><br><span class="line">	* 为了美观,复杂的RUN请用反斜线换行</span><br><span class="line"></span><br><span class="line">	* 避免无用分层,合并多条命令成一行</span><br><span class="line"></span><br><span class="line">	* ```dockerfile</span><br><span class="line">		RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">			python-dev#反斜线换行</span><br><span class="line">		RUN apt-get update &amp;&amp; apt-get install -y perl \</span><br><span class="line">			pwgen --no-install-recommends &amp;&amp; rm -rf \</span><br><span class="line">			/var/ib/apt/ists/*#注意清理 cache </span><br><span class="line">		RUN /bin/bash -c &#x27;source $HOME/.bashrc; echo $HOME&#x27;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><code>WORKDIR</code>：设定当前工作目录（类似于cd）</p>
<ul>
<li>
<pre><code class="language-dockerfile">  WORKDIR /test#如果没有会自动创建test目录
  WORKDIR demo
  RUN pwd#输出结果应该是/test/demo
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	* 用 `WORKDIR`,不要用 `RUN cd`</span><br><span class="line"></span><br><span class="line">	* 尽量使用绝对目录</span><br><span class="line"></span><br><span class="line">* `ADD`和`COPY`：把本地的一些文件添加到docker image中</span><br><span class="line"></span><br><span class="line">	* ADD除了拷贝的功能外还能够解压缩</span><br><span class="line"></span><br><span class="line">	* 大部分情况,COPY优于ADD</span><br><span class="line"></span><br><span class="line">	* 添加远程文件/目录请使用curl或者wget</span><br><span class="line"></span><br><span class="line">	* ```dockerfile</span><br><span class="line">		ADd hello /#简单拷贝</span><br><span class="line">		ADD test.tar.gz /#添加到根目录并解压</span><br><span class="line">		#WORKDIR和ADD联合使用</span><br><span class="line">		WORKDIR /root</span><br><span class="line">		ADD hello test/ #hello文件位置/root/test/hello </span><br><span class="line">		WORKDIR /root</span><br><span class="line">		COPY hello test/ #hello文件位置/root/test/hello </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><code>ENV</code>：设置一个环境变量或常量</p>
<ul>
<li>
<p>尽量使用ENV增加可维护性</p>
</li>
<li>
<pre><code class="language-dockerfile">  ENV MYSQL_VERSION 5.6#设置常量
  RUN apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot; \
  	&amp;&amp; rm -rf /var/lib/apt/lists/*#引用常量
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `VOLUME`和`EXPOSE`：主要用于存储和网络</span><br><span class="line"></span><br><span class="line">  * `VOLUME`：指定在容器中某一个目录中产生的数据，同时挂载到Linux主机中的某一个目录上，并且会创建一个docker volume的对象</span><br><span class="line">  * `EXPOSE`：会将运行中的container中的端口暴露出来</span><br><span class="line"></span><br><span class="line">* shell和exec格式</span><br><span class="line"></span><br><span class="line">	* shell格式：后面是shell命令</span><br><span class="line"></span><br><span class="line">		* ```dockerfile</span><br><span class="line">			RUN apt-get install -y vim</span><br><span class="line">			CMD echo &quot;hello docker&quot;</span><br><span class="line">			ENTRYPOINT echo &quot;hello docker&quot;</span><br></pre></td></tr></table></figure>

  	

</code></pre>
</li>
<li>
<p>exec格式：需要根据特点的格式指出命令和参数</p>
<ul>
<li>
<pre><code class="language-dockerfile">  #XXX [&quot;命令&quot;,&quot;参数&quot;,...]
  RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]
  CMD [&quot;/bin/echo&quot;,&quot;hello docker&quot;]
  ENTRYPOINT [&quot;/bin/echo&quot;,&quot;hello docker&quot;]
  #以下两种输出结果不一样
  ENV name Docker
  ENTRYPOINT [&quot;/bin/echo&quot;,&quot;hello $name&quot;]#hello $name
  ENTRYPOINT [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]#hello Docker(-c表示后面的事bash的参数)
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `CMD`和`ENTRYPOINT`：</span><br><span class="line"></span><br><span class="line">	* `RUN`:执行命令并创建新的 image Layer</span><br><span class="line"></span><br><span class="line">	* `CMD`:设置容器启动后默认执行的命令和参数</span><br><span class="line"></span><br><span class="line">		* 容器启动时默认执行的命令</span><br><span class="line">		* 如果 docker run指定了其它命令,CMD命令被忽略</span><br><span class="line">			* 此处docker run指`docker run 镜像名`，再加任意一个参数均会忽略CMD命令，如`docker run -it 镜像名 /bin/bash`</span><br><span class="line">		* 如果定义了多个CMD,只有最后一个会执行</span><br><span class="line"></span><br><span class="line">	* `ENTRYPOINT`:设置容器启动时运行的命令</span><br><span class="line"></span><br><span class="line">		* 让容器以应用程序或者服务的形式运行</span><br><span class="line"></span><br><span class="line">		* 不会被忽略,一定会执行</span><br><span class="line"></span><br><span class="line">		* ```dockerfile</span><br><span class="line">			#执行一个shel脚本</span><br><span class="line">			COPY docker-entrypoint.sh /usr/local/bin/ </span><br><span class="line">			ENTRYPOINT [&quot;docker-entrypoint sh&quot;]</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="发布镜像">发布镜像</h3>
<p>直接发布镜像：</p>
<ul>
<li>
<p>在<a target="_blank" rel="noopener" href="https://hub.docker.com/">DockerHub</a>网站上注册账号</p>
</li>
<li>
<p><code>sudo docker login</code>，在本机上通过命令行登录DockerHub</p>
</li>
<li>
<p><code>sudo docker push 账号名/image名字:tag</code>或<code>sudo push 账号名/image名字:tag</code>往DockerHub上推</p>
</li>
</ul>
<p>发布Dockerfile：</p>
<ul>
<li>在DockerHub上绑定Github账号</li>
<li>在GitHub上分享Dockerfile</li>
<li>DockerHub会自动从GitHub上克隆Dockerfile</li>
<li>DockerHub后台服务器会自动根据Dockerfile构建image</li>
</ul>
<h3 id="容器资源限制">容器资源限制</h3>
<p>不做限制的容器会尽最大可能占用物理机的资源，可以通过<code>docker run</code>命令指定对容器的限制</p>
<ul>
<li>对memory的限制
<ul>
<li><code>--memory</code>：若只指定该参数，则swap memory也是同样大小，总共消耗内存为2*memory
<ul>
<li>eg：sudo docker run --memory=200M 容器id</li>
</ul>
</li>
<li><code>--memory-swap</code>：指定swap memory参数</li>
</ul>
</li>
<li>对cpu的限制
<ul>
<li><code>--cpu-shares</code>：限制相对权重，即每个容器根据该值来分配物理机上的cpu算力
<ul>
<li>sudo docker run --cpu-shares=10 --name=test1 容器id --cpu 1</li>
<li>sudo docker run --cpu-shares=5 --name=test2 容器id --cpu 1</li>
<li>上述两个容器会按照test1：test2=2：1占用cpu</li>
</ul>
</li>
<li><code>--cpu</code>：利用编号指定运行的cpu</li>
</ul>
</li>
</ul>
<h3 id="实战——ubuntu上打包stress">实战——ubuntu上打包stress</h3>
<h4 id="python常驻程序">python常驻程序</h4>
<p>新建Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;NULL&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /pyapp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /pyapp</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> python app.py</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>EXPOSE</code>：在此处代表要暴露出去的端口</li>
<li><code>CMD</code>：此处用于表示之后一直运行的程序</li>
</ul>
<h4 id="ubuntu上打包stress">ubuntu上打包stress</h4>
<p>新建Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get updata &amp;&amp; apt-get install -y stress</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/user/bin/stress&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> []</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ENTRYPOINT</code>：在此处代表要执行的命令</li>
<li><code>CMD</code>：此处用于接受之后docker run后的参数，传递给<code>ENTRYPOINT</code>指定的命令
<ul>
<li>可以在<code>[]</code>中指定默认的参数</li>
</ul>
</li>
</ul>
<h3 id="常用命令-3">常用命令</h3>
<p>全部命令详见<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/docker/">官方文档</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使docker前不需要加sudo</span></span><br><span class="line">sudo groupadd docker<span class="comment">#新建一个组</span></span><br><span class="line">sudo gpasswd -a 用户名 组名<span class="comment">#添加用户到组</span></span><br><span class="line">sudo service docker restart<span class="comment">#重启docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看dockerhub上的镜像</span></span><br><span class="line">sudo docker search image名字</span><br><span class="line"><span class="comment">#查看本机上的镜像</span></span><br><span class="line">sudo docker image <span class="built_in">ls</span></span><br><span class="line">sudo docker images</span><br><span class="line"><span class="comment">#从Dockerhub上拉取</span></span><br><span class="line">sudo docker pull ubuntu:14.04</span><br><span class="line"><span class="comment">#从Dockerhub上xxx处拉取（第三方）</span></span><br><span class="line">sudo docker pull ubuntu:14.04/XXX</span><br><span class="line"><span class="comment">#运行docker</span></span><br><span class="line">sudo docker run image名字</span><br><span class="line">sudo docker run -d image名字<span class="comment">#-d：后台运行</span></span><br><span class="line">sudo docker run -d -e PENG=xxxx image名字<span class="comment">#后台运行，且设置一个PENG的环境变量，值为xxxx（-e：设置环境变量）</span></span><br><span class="line"><span class="comment">#-it：交互式的运行docker，并进入其控制台</span></span><br><span class="line">sudo docker run -it image名字</span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#退出交互环境</span></span><br><span class="line"><span class="comment">#查看本机上的在运行的容器（正在运行的，常驻内存）</span></span><br><span class="line">sudo docker container <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#查看本机上所有的容器（正在运行的和已经退出的）</span></span><br><span class="line">sudo docker container <span class="built_in">ls</span> -a</span><br><span class="line">sudo docker container <span class="built_in">ls</span> -aq<span class="comment">#列出所有的id</span></span><br><span class="line">sudo docker ps -a</span><br><span class="line"><span class="comment">#删除contaniner</span></span><br><span class="line">sudo docker container <span class="built_in">rm</span> <span class="built_in">id</span></span><br><span class="line">sudo docker <span class="built_in">rm</span> <span class="built_in">id</span></span><br><span class="line">sudo docker <span class="built_in">rm</span> $(sudo docker container <span class="built_in">ls</span> -aq)<span class="comment">#删除所有</span></span><br><span class="line"><span class="comment">#停止contaniner</span></span><br><span class="line">sudo docker container stop <span class="built_in">id</span></span><br><span class="line">sudo docker stop <span class="built_in">id</span></span><br><span class="line"><span class="comment">#删除image</span></span><br><span class="line">sudo docker image <span class="built_in">rm</span> <span class="built_in">id</span></span><br><span class="line">sudo docker rmi <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本机传输文件到docker container中</span></span><br><span class="line">sudo docker <span class="built_in">cp</span> [OPTIONS] 本地文件 container的<span class="built_in">id</span>:container中的目录</span><br><span class="line"><span class="comment">#docker container传输文件到本机中</span></span><br><span class="line">sudo docker <span class="built_in">cp</span> [OPTIONS] container的<span class="built_in">id</span>:container中的目录 本地文件</span><br><span class="line"><span class="comment">#将宿主机上的目录挂载到镜像中</span></span><br><span class="line">docker run -it -v /home/dock/Downloads:/usr/Downloads</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示容器的详细信息</span></span><br><span class="line">sudo docker inspect <span class="built_in">id</span></span><br><span class="line"><span class="comment">#查看容器运行的输出log</span></span><br><span class="line">sudo docker logs <span class="built_in">id</span>或--name指定的名字</span><br></pre></td></tr></table></figure>
<h4 id="生命周期管理">生命周期管理</h4>
<h5 id="run-2">run</h5>
<p>创建一个新的容器并运行一个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>COMMAND</code>和<code>ARG</code>为在起来的容器中执行的命令与参数</li>
</ul>
<p>OPTIONS：</p>
<ul>
<li><code>-d</code>：后台运行，并返回容器ID</li>
<li><code>-e</code>：设置环境变量
<ul>
<li><code>--env-file=[]</code>：从指定文件读入环境变量</li>
</ul>
</li>
<li><code>-it</code>：交互运行，并进入其shell
<ul>
<li><code>-i</code>：以交互模式运行容器</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端</li>
</ul>
</li>
<li><code>--name</code>：为容器指定一个名称（设置别名）</li>
<li>网络参数
<ul>
<li><code>--net=&quot;bridge&quot;</code>：指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型，详见 [三、docker网络](# 三、docker网络)</li>
<li><code>--link=[]</code>：添加链接到另一个容器，详见 [docker之间的link](# docker之间的link)</li>
<li><code>-p</code>：端口映射，格式为：<code>主机(宿主)端口:容器端口</code>，详见 [端口映射](# 端口映射)</li>
<li><code>--expose=[]</code>：开放一个端口或一组端口；</li>
<li><code>--dns 8.8.8.8</code>：指定容器使用的DNS服务器，默认和宿主一致</li>
<li><code>--dns-search example.com</code>：指定容器DNS搜索域名，默认和宿主一致；</li>
<li><code>-h &quot;mars&quot;</code>：指定容器的hostname；</li>
</ul>
</li>
<li>资源参数
<ul>
<li><code>--volume</code>，<code>-v</code>：绑定一个卷，详见 [四、Docker的持久化存储和数据共享](# 四、Docker的持久化存储和数据共享)</li>
<li><code>--cpuset=&quot;0-2&quot;</code>，<code>--cpuset=&quot;0,1,2&quot;</code>：绑定容器到指定CPU运行</li>
<li><code>-m</code>：设置容器使用内存最大值</li>
</ul>
</li>
</ul>
<h5 id="start-stop-restart">start/stop/restart</h5>
<p>启动、停止、重启容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<h5 id="kill">kill</h5>
<p>杀掉一个运行中的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>：向容器发送一个信号</li>
</ul>
<h5 id="rm">rm</h5>
<p>删除一个或多个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>：通过 <code>SIGKILL</code> 信号强制删除一个运行中的容器</li>
<li><code>-l</code>：同时移除容器间的网络连接，而非容器本身（不加CONTAINER则只删除连接）</li>
<li><code>-v</code>：同时删除与容器关联的卷（不加CONTAINER则只删除卷）</li>
</ul>
<h5 id="pause-unpause">pause/unpause</h5>
<p>暂停/恢复容器中所有的进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pause CONTAINER [CONTAINER...]</span><br><span class="line">docker unpause CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<h5 id="create">create</h5>
<p>创建一个新的容器但不启动它（用法同[docker run](# run)）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<h5 id="exec">exec</h5>
<p>在运行的容器中执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：后台运行，并返回容器ID</li>
<li><code>-it</code>：交互运行，并进入其shell
<ul>
<li><code>-i</code>：以交互模式运行容器</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端</li>
</ul>
</li>
</ul>
<h4 id="容器操作">容器操作</h4>
<p>以下操作全都是<code>docker container</code>打头，可以省略<code>container</code>。一般来说容器有以下几种状态：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<h5 id="ps">ps</h5>
<p>列出所有在运行的容器信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>-aq</code>：列出所有创建的容器ID</p>
<ul>
<li><code>-a</code>：显示所有的容器，包括未运行的</li>
<li><code>-q</code>：静默模式，只显示容器编号</li>
</ul>
</li>
<li>
<p><code>-f，--filter</code>：根据条件过滤显示的内容</p>
<ul>
<li>
<pre><code class="language-bash"># 根据名称过滤
docker ps --filter &quot;name=test-nginx&quot;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `-l`：显示最近创建的容器</span><br><span class="line"></span><br><span class="line">* `-n`：列出最近创建的n个容器</span><br><span class="line"></span><br><span class="line">* `--no-trunc`：不截断输出（防止信息显示不全）</span><br><span class="line"></span><br><span class="line">* `-s`：显示该容器占用的大小</span><br><span class="line"></span><br><span class="line">##### inspect</span><br><span class="line"></span><br><span class="line">获取容器/镜像的元数据（即配置时的`.yml`文件）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><code>-f</code>：指定返回值的Go模板文件，该模板有相关的语法，具体可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/65377285662e">docker inspect -f 模版</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有容器(包括未运行)的容器状态</span></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> $(docker ps -aq)</span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> $(docker ps -aq)</span><br><span class="line"><span class="comment"># 可以通过级联调用直接读取子对象 State 的 Status 属性，以获取容器的状态信息：</span></span><br><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;/*读取容器状态*/&#125;&#125;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> <span class="variable">$INSTANCE_ID</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大括号内处理模版指令，大括号外的任何字符都将直接输出</li>
<li><code>.</code>：当前上下文</li>
<li>可以使用 <code>$</code> 来获取根上下文</li>
</ul>
</li>
</ul>
<h5 id="top">top</h5>
<p>查看容器中运行的进程信息，支持 ps 命令参数。主要用于容器内没有shell或top命令的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure>
<h5 id="attach">attach</h5>
<p>连接到<strong>正在运行</strong>中的容器，可以同时连接一个容器来共享shell输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--sig-proxy=false</code>：确保<code>CTRL-D</code>或<code>CTRL-C</code>不会关闭容器，仅仅用作退出该连接（即detach）</li>
</ul>
<h5 id="events">events</h5>
<p>从服务器获取实时事件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [OPTIONS]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>：根据条件过滤事件</li>
<li>时间设置（如果指定的时间是到<strong>秒</strong>级的，需要将时间转成<strong>时间戳</strong>。如果时间为<strong>日期</strong>的话，可以直接使用，如<code>--since=&quot;2016-07-01&quot;</code>）
<ul>
<li><code>--since</code>：从指定的时间戳后显示所有事件</li>
<li><code>--until</code>：流水时间显示到指定的时间为止</li>
</ul>
</li>
</ul>
<h5 id="logs">logs</h5>
<p>获取容器的日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>：跟踪日志输出</li>
<li><code>--tail</code>：仅列出最新N条容器日志</li>
<li><code>-t</code>：显示时间戳</li>
<li><code>--since</code>：显示某个开始时间的所有日志</li>
</ul>
<h5 id="wait">wait</h5>
<p>阻塞运行直到容器停止，然后打印出它的退出代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">wait</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<h5 id="export">export</h5>
<p>将<strong>容器</strong>的<code>文件系统</code>作为一个tar归档文件导出，主要用来制作基础镜像（导入命令[docker import](# import)）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-o</code>：设置导出的文件</li>
</ul>
<h5 id="port">port</h5>
<p>列出指定的容器的端口映射情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></pre></td></tr></table></figure>
<h4 id="images管理">images管理</h4>
<h5 id="images">images</h5>
<p>列出本地镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>：列出本地所有的镜像（含中间映像层，默认情况下会过滤掉中间映像层）</li>
<li><code>--digests</code>：显示镜像的摘要信息</li>
<li><code>-f</code>：显示满足条件的镜像</li>
<li><code>--format</code>：指定返回值的模板文件</li>
<li><code>--no-trunc</code>：显示完整的镜像信息（防止信息显示不全）</li>
<li><code>-q</code>：静默模式，只显示镜像ID</li>
</ul>
<h5 id="rmi">rmi</h5>
<p>删除本地一个或多少镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f</code>：强制删除</li>
</ul>
<h5 id="tag">tag</h5>
<p>标记本地镜像，将其归入某一仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure>
<h5 id="build">build</h5>
<p>通过 Dockerfile 创建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>
<ul>
<li>资源限制
<ul>
<li><code>--cpu-shares</code>：设置 cpu 使用权重</li>
<li><code>--cpuset-cpus</code>：指定使用的CPU id</li>
<li><code>-m</code>：设置内存最大值</li>
<li><code>--memory-swap</code>：设置swap的最大值，&quot;-1&quot;表示不限swap</li>
</ul>
</li>
<li><code>--disable-content-trust</code>：忽略校验，默认开启</li>
<li><code>-f</code>：指定要使用的Dockerfile路径，默认为当前目录</li>
<li><code>--force-rm，--rm</code>：设置镜像过程中删除中间容器</li>
<li><code>--quiet，-q</code>：安静模式，成功后只输出镜像 ID</li>
<li><code>--squash</code>：将 Dockerfile 中所有的操作压缩为一层</li>
<li><code>--tag，-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签</li>
</ul>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1</span></span><br><span class="line">docker build -t runoob/ubuntu:v1 . </span><br><span class="line"><span class="comment"># 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span></span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line"><span class="comment"># 通过 -f Dockerfile 设置dockerfile文件的位置</span></span><br><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<h5 id="history">history</h5>
<p>查看指定镜像的创建历史</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--no-trunc</code>：显示完整的提交记录（防止信息显示不全）</li>
<li><code>-q</code>：安静模式，仅列出提交记录ID</li>
</ul>
<h5 id="save">save</h5>
<p>将指定<strong>镜像</strong>保存成 tar 归档文件（导入命令[docker load](# load)）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-o</code>：设置导出的文件</li>
</ul>
<h5 id="load">load</h5>
<p>导入使用 [docker save](# save) 命令导出的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load [OPTIONS]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>--input，-i</code>：指定导入的文件，代替 STDIN（默认为标准输入）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; busybox.tar.gz</span><br><span class="line">docker load --input fedora.tar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>--quiet，-q</code>：精简输出信息</p>
</li>
</ul>
<h5 id="import">import</h5>
<p>从 [docker export](# export) 创建的归档文件中创建<strong>镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：应用 [docker export](# export) 指令创建镜像（默认为标准输入）</li>
<li><code>-m</code>：提交时的说明文字</li>
</ul>
<h5 id="导入导出汇总">导入导出汇总</h5>
<p>一般来说，分为以下两种，不能混用：</p>
<ul>
<li>导入/导出image：[docker save](# save)、[docker load](# load)
<ul>
<li>保存完整记录，但是体积较大</li>
</ul>
</li>
<li>导入/导出快照：[docker export](# export)、[docker import](# import)
<ul>
<li>没有 layer 信息，dockerfile 里的 workdir，entrypoint 之类的所有东西都会丢失，commit 也会丢失。即丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），体积较小</li>
</ul>
</li>
</ul>
<p>其区别如下：</p>
<ul>
<li>[docker save](# save) 保存的是镜像（image），[docker export](# export) 保存的是容器（container）；</li>
<li>[docker load](# load) 用来载入镜像包，[docker import](# import) 用来载入容器包，但两者都会恢复为镜像；</li>
<li>[docker load](# load) 不能对载入的镜像重命名，而 [docker import](# import) 可以为镜像指定新名称。</li>
</ul>
<h4 id="仓库管理">仓库管理</h4>
<h5 id="login-logout">login/logout</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">docker <span class="built_in">logout</span> [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>：登陆的用户名</li>
<li><code>-p</code>：登陆的密码</li>
</ul>
<h5 id="pull">pull</h5>
<p>从镜像仓库中拉取或者更新指定镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>：拉取所有 tagged 镜像</li>
</ul>
<h5 id="push">push</h5>
<p>将本地的镜像上传到镜像仓库，需要先登陆到镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure>
<h5 id="search">search</h5>
<p>从Docker Hub查找镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>--automated</code>：只列出自动构建类型的镜像</p>
</li>
<li>
<p><code>--no-trunc</code>：显示完整的镜像描述</p>
</li>
<li>
<p><code>-f &lt;过滤条件&gt;</code>：列出收藏数不小于指定值的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有镜像名包含 java，并且收藏数大于 10 的镜像</span></span><br><span class="line">docker search -f stars=10 java</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="容器文件系统管理">容器文件系统管理</h4>
<h5 id="commit">commit</h5>
<p>从容器创建一个新的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>：提交的镜像作者</li>
<li><code>-c</code>：使用Dockerfile指令来创建镜像</li>
<li><code>-m</code>：提交时的说明文字</li>
<li><code>-p</code>：在commit时，将容器暂停</li>
</ul>
<h5 id="cp-2">cp</h5>
<p>容器与主机之间的数据拷贝</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH</span><br><span class="line">docker <span class="built_in">cp</span> [OPTIONS] SRC_PATH CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-L</code>：保持源目标中的链接</li>
</ul>
<h5 id="diff-2">diff</h5>
<p>检查容器里文件结构的更改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<h2 id="三、docker网络">三、docker网络</h2>
<p>docker网络分类：</p>
<ul>
<li>单机网络
<ul>
<li><strong>Bridge Network</strong></li>
<li>Host Network</li>
<li>None Network</li>
</ul>
</li>
<li>多机网络
<ul>
<li>Overlay Network</li>
</ul>
</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<p>整个网络的数据传输是通过<strong>数据包</strong>的形式来传输的</p>
<p>数据包的打包有一个分层的概念，即ISO/OSI的七层模型和TCP/IP的五层模型：</p>
<p><img src="/2020/01/16/Docker/image-20200209142623011.png" alt="网络分层"></p>
<p>数据包到达另一台电脑或服务器，需要通过<strong>路由</strong></p>
<p>IP地址：设备的标识</p>
<ul>
<li>公有IP：互联网上的唯一标识,可以访问 Internet</li>
<li>私有IP：不可在互联网上使用,仅供机构内部使用</li>
<li>ABC三类ip地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kzadmxz/article/details/73658168">https://blog.csdn.net/kzadmxz/article/details/73658168</a></li>
</ul>
<p>私有IP地址访问互联网，需要<strong>网络地址转换</strong>，即<strong>NAT</strong></p>
<p><img src="/2020/01/16/Docker/image-20200209150545483.png" alt="网络地址转换"></p>
<p>Linux命令：</p>
<ul>
<li><code>ping</code>：<strong>检查ip的可达性</strong>，ping不通不能保证机器出问题了，可能是中间路由或者防火墙等其他某一环节出问题了</li>
<li><code>telnet</code>：<strong>检查服务的可用性</strong></li>
</ul>
<h3 id="Linux中network-namespace">Linux中network namespace</h3>
<p>每创建一个container，会同时创建一个network namespace</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看本机network namespace</span></span><br><span class="line">sudo ip netns list</span><br><span class="line"><span class="comment">#删除本机network namespace</span></span><br><span class="line">sudo ip netns delete xxxx</span><br><span class="line"><span class="comment">#添加network namespace</span></span><br><span class="line">sudo ip netns add xxxx</span><br><span class="line"><span class="comment">#在xxxx这个network namespace中执行命令</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> xxxx ip a</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> xxxx ip <span class="built_in">link</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> xxxx ip <span class="built_in">link</span> <span class="built_in">set</span> dev lo up<span class="comment">#将xxxx中的lo网卡up</span></span><br></pre></td></tr></table></figure>
<p>其他相关命令和知识可以参考<a target="_blank" rel="noopener" href="https://cizixs.com/2017/02/10/network-virtualization-network-namespace/">这篇博客</a>，如链接消失，可见我博客中的备份</p>
<h3 id="Docker-Bridge0详解">Docker Bridge0详解</h3>
<p>即bridge Network。</p>
<p>建议参考上一小节中提到的博客</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出当前docker中有哪些网络</span></span><br><span class="line">sudo docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#列出bridge的详细情况，通过Containers一栏可以看出哪个container连接上该bridge</span></span><br><span class="line">sudo docker network inspect bridge</span><br><span class="line"><span class="comment">#列出本机上bridge的相关信息，可以通过该命令看出docker0网卡接上了那个veth接口</span></span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>
<p>两个容器之间相互通信的情况：</p>
<p><img src="/2020/01/16/Docker/image-20200210150411463.png" alt="image-20200210150411463"></p>
<ul>
<li>蓝色框框为两个容器</li>
<li>绿色的一对为veth（虚拟网络接口）</li>
<li>docker容器中会连接到主机的docker0网卡上</li>
</ul>
<p>单个容器访问internet的情况：</p>
<p><img src="/2020/01/16/Docker/image-20200210150701170.png" alt="image-20200210150701170"></p>
<ul>
<li>主机通过eth0访问外网</li>
<li>docker0中的数据通过NAT（网络地址转换）转换到eth0中</li>
<li>这里的NAT是通过iptables实现</li>
</ul>
<h3 id="docker之间的link">docker之间的link</h3>
<p>即通过<code>link</code>指令，可以将一个容器只需指定对方容器名字就可以链接到另一个容器上，而无需指定IP地址及端口。注意，link指令含有方向，只能单向链接</p>
<p>该指令实际使用不多</p>
<p>直接上例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建busybox容器test1</span></span><br><span class="line">sudo docker run -d --name test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#创建busybox容器test2，并连接到test1</span></span><br><span class="line">sudo docker run -d --name test2 --<span class="built_in">link</span> test1 busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#进入test2中</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it test2 /bin/sh</span><br><span class="line"><span class="comment">#在test2中ping test1(ip:172.17.0.3) 无论名字还是ip均可</span></span><br><span class="line">ping 172.17.0.3</span><br><span class="line">ping test1</span><br><span class="line"><span class="comment">#反之，进入test1</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it test1 /bin/sh</span><br><span class="line"><span class="comment">#在test1中ping test2(ip:172.17.0.2) 只有ip可以</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line">ping test2<span class="comment">#ping不通</span></span><br><span class="line">ping 172.17.0.3</span><br><span class="line">ping test1</span><br></pre></td></tr></table></figure>
<p>创建一个新的Bridge并连接上Container：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个新的bridge，叫my-bridge（-d：driver）</span></span><br><span class="line">sudo docker nerwork create -d bridge my-bridge</span><br><span class="line"><span class="comment">#查看bridge</span></span><br><span class="line">sudo docker network <span class="built_in">ls</span></span><br><span class="line">brctl show<span class="comment">#和上个命令一样</span></span><br><span class="line"><span class="comment">#创建busybox容器test3，指定network为my-bridge</span></span><br><span class="line">sudo docker run -d --name test3 --network my-bridge busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#显示bridge及连接的情况</span></span><br><span class="line">brctl show</span><br><span class="line"><span class="comment">#显示bridge的详细信息</span></span><br><span class="line">sudo docker network inspect bridge的<span class="built_in">id</span>(通过sudo docker network <span class="built_in">ls</span>和brctl show可以查看)</span><br><span class="line"><span class="comment">#将其他container连接到新建的bridge上</span></span><br><span class="line">sudo docker network connect my-bridge test2</span><br></pre></td></tr></table></figure>
<p>多个容器若都连接在了同一个用户自己创建的bridge上，则可以<strong>不需通过链接</strong>就能够通过名字直接访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入my-bridge绑定的test3中，可以直接通过名字ping通后来接入的test2(ip:192.18.0.3)</span></span><br><span class="line">sudo docker rxrc -it test3 /bin/sh</span><br><span class="line">ping 192.18.0.3</span><br><span class="line">ping test2</span><br></pre></td></tr></table></figure>
<h3 id="端口映射">端口映射</h3>
<p>如果想要将docker中的端口转发给外部：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将容器中的80端口映射到本地的80端口</span></span><br><span class="line">sudo docker run --name web -d -p 80:80 nginx</span><br><span class="line"><span class="comment">#查看映射的端口</span></span><br><span class="line">sudo docker ps</span><br><span class="line"><span class="comment">#此时可以通过curl在外部（虚拟机上）直接访问容器内部的端口</span></span><br><span class="line">curl 192.168.205.10</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img src="/2020/01/16/Docker/image-20200211000724333.png" alt="image-20200211000724333"></p>
<ul>
<li>注：eth1到本地网卡上的端口转发是通过设置虚拟机修改而成的</li>
</ul>
<h3 id="host和none网络">host和none网络</h3>
<p>none network：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建busybox容器test1，指定network为none</span></span><br><span class="line">sudo docker run -d --name test1 --network none busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#查看none上连接的container</span></span><br><span class="line">sudo docker network inspect none</span><br><span class="line"><span class="comment">#进入container中</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it test1 /bin/sh</span><br><span class="line"><span class="comment">#运行命令</span></span><br><span class="line">ip a<span class="comment">#发现只有lo</span></span><br></pre></td></tr></table></figure>
<ul>
<li>none network表示一种孤立的网络，除了<code>sudo docker exec -it</code>命令能够访问之外，不能通过其他方法访问</li>
</ul>
<p>host network：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建busybox容器test1，指定network为host</span></span><br><span class="line">sudo docker run -d --name test1 --network host busybox /bin/sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#查看host上连接的container</span></span><br><span class="line">sudo docker network inspect host</span><br><span class="line"><span class="comment">#进入container中</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it test1 /bin/sh</span><br><span class="line"><span class="comment">#运行命令</span></span><br><span class="line">ip a<span class="comment">#发现此处的网卡和Linux主机上的一样</span></span><br></pre></td></tr></table></figure>
<ul>
<li>host network表示该容器没有自己独立的namespace，根Linux主机中的namespace network共享同一套</li>
<li>可能会和Linux主机上的一些端口存在冲突</li>
</ul>
<h3 id="多机通信">多机通信</h3>
<p>为实现如下效果：</p>
<p><img src="/2020/01/16/Docker/image-20200211004225893.png" alt="多机通信"></p>
<ul>
<li>两个docker的ip地址需要不一样</li>
<li>运用VXLAN技术</li>
<li>通过overlay network实现，创建overlay与bridge、host、none一致</li>
<li>需要用到分布式存储技术（采用etcd），用于在单机上占据ip地址</li>
</ul>
<h2 id="四、Docker的持久化存储和数据共享">四、Docker的持久化存储和数据共享</h2>
<p>回顾之前讲的Container，Container具有可读可写的能力，image只具有可读的能力。但是在stop再rm Container之后，Container中的数据不会保存，Container中的数据相当于一个临时的数据</p>
<p><img src="/2020/01/16/Docker/image-20200205001054091.png" alt="Container"></p>
<p>docker持久化数据的方案分以下两种：</p>
<ul>
<li>基于<strong>本地文件系统</strong>的 Volume.可以在执行 Docker create或 Docker run时,通过<code>-v</code>参数将主机的目录作为容器的数据卷.这部分功能便是基于本地文件系统的 volume管理.</li>
<li>基于<strong>plugin</strong>的 Volume,支持第三方的存储方案,比如NAS，aws</li>
</ul>
<p>Volume的类型：</p>
<ul>
<li>受管理的 data Volume,由 docker后台自动创建.</li>
<li>绑定挂载的 Volume,具体挂载位置可以由用户指定.</li>
</ul>
<h3 id="Data-Volume">Data Volume</h3>
<p>场景：一般来说有些容器自己会产生一些数据，我们需要保证这些数据的安全，不想随着container的消失而消失，比如说数据库等，通过Dockerfile中的<code>VOLUME</code>关键字实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建mysql container(mysql的Dockerfile中有：VOLUME /var/lib/mysql),初始密码为空，将在/var/lib/mysql处产生的volume重命名为mysql(将mysql volume映射到container中的/var/lib/mysql目录)</span></span><br><span class="line">sudo docker run -d -v mysql:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=<span class="literal">true</span> mysql</span><br><span class="line">sudo docker ps</span><br><span class="line"><span class="comment">#查看volume</span></span><br><span class="line">sudo docker volume <span class="built_in">ls</span></span><br><span class="line">sudo docker volume 上一步命令查看的<span class="built_in">id</span>   <span class="comment">#会自动挂载到/var/lib/docker/volumes/xxxx(id)/_data</span></span><br><span class="line"><span class="comment">#删除volume</span></span><br><span class="line">sudo docker volume <span class="built_in">rm</span> <span class="built_in">id</span>或者-v指定的名字</span><br></pre></td></tr></table></figure>
<h3 id="Bind-Mounting（挂载宿主机目录）">Bind Mounting（挂载宿主机目录）</h3>
<p>bind Mounting不需要在Dockerfile中定义文件产生的路径，只需在命令行中指定即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器，将当前目录$(pwd)映射到container中的/usr/share/nginx/html目录</span></span><br><span class="line">sudo docker run -d -v $(<span class="built_in">pwd</span>):/usr/share/nginx/html <span class="built_in">id</span></span><br></pre></td></tr></table></figure>
<h2 id="五、Docker-Compose多容器部署">五、Docker Compose多容器部署</h2>
<p>官方链接：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>多容器的app会带来的缺点：</p>
<ul>
<li>要从 Dockerfile build image或者 Dockerhub拉取 image</li>
<li>要创建多个 container</li>
<li>要管理这些 container(启动、停止、删除)</li>
</ul>
<p>Docker Compose的诞生就是为了解决该问题，可以看成是批处理</p>
<ul>
<li>Docker Compose是一个命令行工具</li>
<li>这个工具可以通过一个<code>yml</code>文件定义多容器的 docker应用</li>
<li>通过一条命令就可以根据<code>yml</code>文件的定义去创建或者管理这多个容器</li>
</ul>
<p>yml文件默认名：<code>docker-compose.yml</code>，包含三个重要概念：Services、Networks、Volumes</p>
<p>Services：</p>
<ul>
<li>
<p>一个 service代表一个 container,这个 container可以从dockerhub的image来创建,或者从本地的 Dockerfile build出来的image来创建</p>
</li>
<li>
<p>Service的启动类似 docker run,我们可以给其指定network和 volume,所以可以给 service指定 network和Volume的引用（service中的参数和docker run中的参数类似）</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="string">db:#services名字</span></span><br><span class="line">    <span class="string">image:postgres:9.4#采用的image</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">“db-data:/var/lib/postgresql/data”</span></span><br><span class="line">    <span class="string">network:#新建的bridge</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">back-tier</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">worker:</span></span><br><span class="line">    <span class="string">build:./worker</span></span><br><span class="line">    <span class="string">links:#有了network，links可有可无</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">network:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">back-tier</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-bridge:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
<h3 id="安装和基本使用">安装和基本使用</h3>
<p>安装：</p>
<ul>
<li>
<p>docker for mac或windows 会自动安装</p>
</li>
<li>
<p>Linux安装步骤：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载至/usr/local/bin/docker-compose</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.25.3/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment">#添加可执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment">#查看版本信息 验证是否安装成功</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用：</p>
<p>docker Compose的使用大部分都会联合<code>yml</code>文件的使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建docker-compose.yml文件中的service</span></span><br><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d<span class="comment">#后台运行，但是不会打印log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看docker-compose中的情况</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose images<span class="comment">#列出所定义的container以及使用的image</span></span><br><span class="line"><span class="comment">#执行container中的命令</span></span><br><span class="line">docker-compose <span class="built_in">exec</span> yml文件中定义的service container中的命令</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止docker-compose中的容器</span></span><br><span class="line">docker-compose stop</span><br><span class="line"><span class="comment">#停止并删除docker-compose中的容器、bridge、volume</span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>
<h3 id="水平扩展和负载均衡">水平扩展和负载均衡</h3>
<p>通过docker-compose命令的<code>--scale</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多开service中的container</span></span><br><span class="line">docker-compose up --sacle yml文件service中的某一个container=个数</span><br></pre></td></tr></table></figure>
<h2 id="六、容器编排Swarm-mode">六、容器编排Swarm mode</h2>
<p>Swarm是一种集群的架构，其中含有节点，每一个节点中可以含有两种角色，即manager和worker</p>
<ul>
<li>manager：整个集群的大脑，至少需要2个及以上，所以需要同步，docker提供了一个内置的分布式的存储数据库，通过raft协议进行同步</li>
<li>worker：节点比manager多，通过gossip网络进行同步</li>
</ul>
<p><img src="/2020/01/16/Docker/image-20200212235626905.png" alt="底层架构"></p>
<p>重要概念：</p>
<ul>
<li>Service：与docker Compose中的service类似，但是最终运行在那台机器上是不确定的</li>
<li>Replicas：横向扩展时，一个replicas就是一个容器</li>
</ul>
<p><img src="/2020/01/16/Docker/image-20200212235931699.png" alt="Service和Replicas"></p>
<p>注：此图产生了三个容器，会调度系统调度到不同的节点上去，即该service最终会运行在那些swarm节点上是不知道的</p>
<p><img src="/2020/01/16/Docker/image-20200213000340881.png" alt="swarm上创建service时的调度过程"></p>
<p>例子：</p>
<p>创建一个三节点的swarm集群：</p>
<p>节点一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化swarm并创建manager节点，同时指定manager的地址</span></span><br><span class="line">sudo docker swarm init --advertise-addr=192.168.205.10</span><br><span class="line"><span class="comment">#查看swarm当前的节点</span></span><br><span class="line">sudo docker node <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>借点二：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建worker节点并加入该swarm集群（init后会提供该命令），用于将另一台机器加入称为worker</span></span><br><span class="line">sudo docker <span class="built_in">join</span> --token xxxx(init后会提供) 192.168.205.10:端口号</span><br></pre></td></tr></table></figure>
<p>节点三：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建worker节点并加入该swarm集群（init后会提供该命令），用于将另一台机器加入称为worker</span></span><br><span class="line">sudo docker <span class="built_in">join</span> --token xxxx(init后会提供) 192.168.205.10:端口号</span><br></pre></td></tr></table></figure>
<h3 id="Service的创建维护和水平扩展">Service的创建维护和水平扩展</h3>
<p><code>docker service</code>命令类似于<code>docker run</code>，只是不是在本地上运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个busybox的service，叫demo</span></span><br><span class="line">sudo docker service create --name demo busybox sh -c <span class="string">&quot;while true; do sleep 3600;done&quot;</span></span><br><span class="line"><span class="comment">#查看service</span></span><br><span class="line">sudo docker service <span class="built_in">ls</span></span><br><span class="line">sudo docker service ps service名字<span class="comment">#查看service的详细情况（包括分布在那台机器/节点上）</span></span><br><span class="line"><span class="comment">#横向扩展service</span></span><br><span class="line">sudo docker service scale service名字=扩展数<span class="comment">#通过ls命令显示的REPLICAS栏可以查看</span></span><br><span class="line"><span class="comment">#删除service</span></span><br><span class="line">sudo docker service <span class="built_in">rm</span> demo<span class="comment">#由于可能存在横向扩展，所以实际上会比较慢</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sudo docker service ls</code>命令显示的REPLICAS栏：
<ul>
<li>分母：创建时规定的横向扩展数量（scale）</li>
<li>分子：有几个已经ready了</li>
</ul>
</li>
<li><code>scale</code>命令扩展时，如果有部分节点上的service失效了（退出、shutdown等），系统会在任意节点上再起一个直到达到scale规定的数目</li>
</ul>
<h3 id="集群服务器通信——RoutingMesh">集群服务器通信——RoutingMesh</h3>
<p>RoutingMesh的两种体现：</p>
<ul>
<li>Internal：Container和Container之间的访问通过overlay网络（通过VIP虚拟IP）</li>
<li>Ingress：如果服务有绑定接口，则此服务可以通过任意swarm节点的相应接口访问</li>
</ul>
<h4 id="Internal">Internal</h4>
<p>docker Compose在单机的情况下，不同的service可以通过对方的名字相互访问（底层通过DNS服务实现）。而在swarm class中，不同的service有可能在不同的节点上，不同的service之间也能通过service name通信，也有DNS服务。</p>
<p>对于Swarm来说，有内置的DNS服务发现的功能，通过service命令创建service时，如果是连接到一个overlay的网络上，会为连接到overlay网络上的所有的service去增加一条DNS的记录，通过该记录就能知道IP地址（并不是实际上该service所在的容器的ip地址，而是虚拟的ip地址，即VIP，一旦service创建好后，VIP就不会改变，但是和具体的ip地址绑定是通过LVS（Linux Virtual Service）实现的），就可以访问其服务</p>
<p>例子：</p>
<p><code>swarm-manager</code>节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建overlay网络，命名demo</span></span><br><span class="line">sudo docker network create -d overlay demo</span><br><span class="line"><span class="comment">#创建一个whoami的service，提供web服务，如果访问8000端口会返回他的hostname</span></span><br><span class="line">sudo docker service create --name <span class="built_in">whoami</span> -p 8000:8000 --network demo -d jwilder/whoami<span class="comment">#将内部8000端口映射到本地8000端口</span></span><br><span class="line"><span class="comment">#查看是否运行</span></span><br><span class="line">sudo docker service <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#查看运行在哪里</span></span><br><span class="line">sudo docker service ps <span class="built_in">whoami</span><span class="comment">#swarm-manager</span></span><br><span class="line"><span class="comment">#查看容器 是否映射出了8000</span></span><br><span class="line">sudo docker ps</span><br><span class="line"><span class="comment">#查看8000端口</span></span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建第二个service，采用busybox，命名client</span></span><br><span class="line">sudo docker service create --name client -d --network demo busybox sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#查看是否运行</span></span><br><span class="line">sudo docker service <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#查看运行在哪里</span></span><br><span class="line">sudo docker service ps client<span class="comment">#swarm-worker1</span></span><br><span class="line"><span class="comment">#查看容器 是否映射出了8000</span></span><br><span class="line">sudo docker ps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展下whoami</span></span><br><span class="line">sudo docker service scale <span class="built_in">whoami</span>=2</span><br><span class="line"><span class="comment">#查看另一台在哪里</span></span><br><span class="line">sudo docker service ps <span class="built_in">whoami</span><span class="comment">#swarm-manager、swarm-worker2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入<code>swarm-worker1</code>节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#尚未扩展前：</span></span><br><span class="line"><span class="comment">#查看service是否运行</span></span><br><span class="line">sudo docker ps</span><br><span class="line"><span class="comment">#进入service中</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it service的<span class="built_in">id</span> sh</span><br><span class="line"><span class="comment">#直接ping另一台service</span></span><br><span class="line">ping <span class="built_in">whoami</span><span class="comment">#能够ping通，能够发现实际上是ping10.0.0.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#横向扩展后：</span></span><br><span class="line">ping <span class="built_in">whoami</span><span class="comment">#能够ping通，能够发现实际上是ping10.0.0.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接去查看swarm class中维护的dns服务器</span></span><br><span class="line">nslookup <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">#查看真正的容器地址</span></span><br><span class="line">nslookup tasks.whoami</span><br></pre></td></tr></table></figure>
<ul>
<li>不管service有几个横向扩展，但是最后的VIP只有一个，而且访问这个VIP时，Swarm会自动做负载均衡，依次轮流访问这几个横向扩展的service</li>
<li>上述的负载均衡以及VIP均通过LVS（Linux Virtual Service）实现</li>
</ul>
<h4 id="Ingress">Ingress</h4>
<ul>
<li>外部访问的负载均衡</li>
<li>服务端口被暴露到各个 swarm节点</li>
<li>内部通过IPVS进行负载均衡</li>
</ul>
<p>当我们去任何一台Swarm节点上去访问端口服务的时候，会把该服务通过本地节点的IPVS（IP的virtual service），通过LVS把该服务负载均衡：</p>
<p><img src="/2020/01/16/Docker/image-20200218173537430.png" alt="示意图"></p>
<ul>
<li>当外部访问docker host3的8080端口时（该节点上没有对应service），IPVS会将该请求转发到另外两台具有service的节点上</li>
</ul>
<p>例子：</p>
<p><code>swarm-manager</code>节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建overlay网络，命名demo</span></span><br><span class="line">sudo docker network create -d overlay demo</span><br><span class="line"><span class="comment">#创建一个whoami的service，提供web服务，如果访问8000端口会返回他的hostname</span></span><br><span class="line">sudo docker service create --name <span class="built_in">whoami</span> -p 8000:8000 --network demo -d jwilder/whoami<span class="comment">#将内部8000端口映射到本地8000端口</span></span><br><span class="line"><span class="comment">#扩展下whoami</span></span><br><span class="line">sudo docker service scale <span class="built_in">whoami</span>=2</span><br><span class="line"><span class="comment">#查看运行情况</span></span><br><span class="line">suod docker service ps <span class="built_in">whoami</span><span class="comment">#swarm-manager、swarm-worker2</span></span><br><span class="line"><span class="comment">#不断获取，会依次返回两台不同节点机器的id(负载均衡)</span></span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>进入<code>swarm-worker1</code>节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取，发现任可以访问</span></span><br><span class="line">curl 127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看本地转发规则</span></span><br><span class="line">iptables -<span class="built_in">nl</span> -t nat</span><br></pre></td></tr></table></figure>
<h3 id="docker-stack部署swarm">docker stack部署swarm</h3>
<p>利用Docker compose file，即<code>yml</code>文件，主要通过<code>deploy</code>命令，官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/#deploy">https://docs.docker.com/compose/compose-file/#deploy</a></p>
<p>注意：该处的docker compose file中不能利用build命令构建本地image，只能通过<strong>远程拉取</strong></p>
<p>以下均为<code>deploy</code>下的子命令：</p>
<ul>
<li><code>endpoint_mode</code>：
<ul>
<li>vip（默认）：service之间通过vip互访（底层会通过LVS自动做均衡负载）</li>
<li>dnsrr：直接使用service的ip地址互访，也会通过dnsrr（DNS round-robin）做均衡负载</li>
</ul>
</li>
<li><code>labels</code>：帮助信息</li>
<li><code>mode</code>：
<ul>
<li>global：不能通过scale命令做横向扩展，整个class中只有一个service</li>
<li>replicated（默认）：可以横向扩展</li>
</ul>
</li>
<li><code>placement</code>：
<ul>
<li>constraints：
<ul>
<li><code>- node.role==manager</code>：一定会部署到manager上</li>
</ul>
</li>
<li>preferences：
<ul>
<li>详见：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/#placement">https://docs.docker.com/compose/compose-file/#placement</a></li>
</ul>
</li>
</ul>
</li>
<li><code>replicas</code>：
<ul>
<li>当<code>mode</code>设置成replicated时，可以在初始化时就指定需要几个service</li>
</ul>
</li>
<li><code>resources</code>：资源的限制
<ul>
<li>cpu：‘0.5’</li>
<li>memory：20M</li>
</ul>
</li>
<li><code>restart_policy</code>：重启条件即参数设置
<ul>
<li>delay：延时</li>
<li>max_attempts：最大尝试次数</li>
</ul>
</li>
<li><code>update_config</code>：更新时要遵循的原则
<ul>
<li>parallelism：并行数（最多能够同时更新几个service）</li>
<li>delay：延时（每次更新的间隔时间）</li>
</ul>
</li>
</ul>
<p>例子：</p>
<p>利用yml文件部署wordpress</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br></pre></td></tr></table></figure>
<p>进入swarm manager节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法：sudo docker stack deploy 自定义的名字 --compose-file=xxxx.yml</span></span><br><span class="line">sudo docker stack deploy wordpress --compose-file=docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看情况</span></span><br><span class="line">sudo docker stack ps wordpress</span><br><span class="line"><span class="comment">#只查看service</span></span><br><span class="line">sudo docker stack services wordpress</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有container及网络</span></span><br><span class="line">sudo docker stack <span class="built_in">rm</span> wordpress</span><br></pre></td></tr></table></figure>
<h3 id="密码管理">密码管理</h3>
<p>docker compose file中有些是关于数据库的用户名和密码的，为了安全性考虑需要secret manager</p>
<p>需要加密的部分：</p>
<ul>
<li>用户名密码</li>
<li>SSH Key</li>
<li>TLS认证</li>
<li>任何不想让别人看到的数据</li>
</ul>
<p>docker secret management特点：</p>
<ul>
<li>存在 Swarm Manager节点 Raft database里（加密的）.
<ul>
<li>多个manager节点通过Raft database确保数据一致</li>
</ul>
</li>
<li>Secret可以 assign给一个 service,这个 service就能看到这个 secret</li>
<li>在 container内部 Secret看起来像文件,但是实际是在内存中</li>
</ul>
<p>使用例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建secret</span></span><br><span class="line"><span class="comment">#方法一：</span></span><br><span class="line"><span class="comment">#从文件中创建secret，创建完成后最好删除掉该文件</span></span><br><span class="line">sudo docker secret create secret的名字 要加密的文件</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">sudo docker secret <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line"><span class="comment">#从标准输入中创建secret</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;admin&quot;</span> | sudo docker secret create secret的名字 -</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">sudo docker secret <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除secret</span></span><br><span class="line">sudo docker secret <span class="built_in">rm</span> secret的名字</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用secret</span></span><br><span class="line"><span class="comment">#创建一个busybox的container，命名client（可以通过多次使用--secret传入几个secret）</span></span><br><span class="line">sudo docker service create --name client --secret secret的名字 busybox sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br><span class="line"><span class="comment">#进入container</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it 容器的<span class="built_in">id</span>(可通过docker ps查看) sh</span><br><span class="line"><span class="built_in">cd</span> /run/secrets<span class="comment">#会存在一个secret名字的文件</span></span><br><span class="line"><span class="comment">#可以直接查看secret的明文</span></span><br><span class="line"><span class="built_in">cat</span> secret名字的文件</span><br></pre></td></tr></table></figure>
<p>最典型使用mysql时传入密码的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;admin&quot;</span> | sudo docker secret create my-pw -</span><br><span class="line"><span class="comment">#通过MYSQL中的MYSQL_ROOT_PASSWORD_FILE环境变量指定密码</span></span><br><span class="line">sudo docker service create --name db --secret my-pw -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-pw mysql</span><br><span class="line"><span class="comment">#进入container内部确认mysql密码</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it 容器的<span class="built_in">id</span>(可通过docker ps查看) sh</span><br><span class="line">mysql -u root -p<span class="comment">#之后输入密码：admin即可进入mysql的交互中</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-stack中使用secret">docker stack中使用secret</h3>
<p>通过<code>secret</code>指定使用哪个secret</p>
<p>例子：</p>
<p>利用yml文件部署wordpress</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-pw</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD_FILE:</span> <span class="string">/run/secrets/my-pw</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-pw</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/my-pw</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># secrets:</span></span><br><span class="line"><span class="comment">#   my-pw:</span></span><br><span class="line"><span class="comment">#    file: ./password</span></span><br></pre></td></tr></table></figure>
<h3 id="service更新">service更新</h3>
<p>注意：为保证service不会中断，需要保证scale&gt;=2</p>
<p>对正在运行的service进行更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建overlay网络，命名demo</span></span><br><span class="line">sudo docker network create -d overlay demo</span><br><span class="line"><span class="comment">#创建一个whoami的service，提供web服务，将本地的5000映射到class中的8080端口</span></span><br><span class="line">sudo docker service create --name web -p 8080:5000 --network demo xiaopeng163/python-flask-demo:1.0</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">sudo docker service ps web</span><br><span class="line"><span class="comment">#扩展下web</span></span><br><span class="line">sudo docker service scale web=2</span><br><span class="line"><span class="comment">#查看运行情况</span></span><br><span class="line">curl 127.0.0.1:8080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新image</span></span><br><span class="line">sudo docker service update --image xiaopeng163/python-flask-demo:2.0 web</span><br><span class="line"><span class="comment">#再次查看，会发现1.0的已经被shutdown了，并重新开了两个2.0的container</span></span><br><span class="line">sudo docker service ps web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新端口</span></span><br><span class="line">sudo service updata --publish-rm 8080:5000 --publish-add 8088:5000 web</span><br></pre></td></tr></table></figure>
<h2 id="七、容器编排Kubernetes">七、容器编排Kubernetes</h2>
<p>kubernetes架构：</p>
<p><img src="/2020/01/16/Docker/image-20200219235941920.png" alt="架构图"></p>
<p>其中Master节点架构：</p>
<p><img src="/2020/01/16/Docker/image-20200220000101254.png" alt="Master节点架构"></p>
<ul>
<li>API Service：暴露给外界访问</li>
<li>Scheduler：调度模块</li>
<li>Controller：控制模块，对节点的控制</li>
<li>etcd：分布式的存储，存储k8s的状态和配置</li>
</ul>
<p>node节点架构：</p>
<p><img src="/2020/01/16/Docker/image-20200220000307417.png" alt="node节点架构"></p>
<ul>
<li>Pod：在k8s中，是在容器中调度的最小单位，是具有相同的namespace（包含了所有namespace，如user namespace、network namespace）的一些Container组合</li>
<li>Docker：容器技术之一（k8s中采用docker，还有其他容器技术）</li>
<li>kubelet：类似于一个代理，受master节点控制，负责在node节点上创建、管理容器、network以及volume</li>
<li>kube-proxy：端口的代理转发以及service的服务发现和负载均衡</li>
<li>Flientd：日志的采集、存储、查询</li>
<li>Optional Add-ons：插件</li>
</ul>
<h3 id="搭建k8s单节点环境">搭建k8s单节点环境</h3>
<p>k8s首席构造师github：<a target="_blank" rel="noopener" href="https://github.com/kelseyhightower">https://github.com/kelseyhightower</a></p>
<p>常用工具介绍：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kelseyhightower/kubernetes-the-hard-way">kubernetes-the-hard-way</a>：不借助任何脚本，从命令行去操作安装kubernetes</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/minikube">minikube</a>：本地快速创建一个节点的kubernetes集群
<ul>
<li>通过利用virtualbox创建一台虚拟机，该虚拟机中会安装好kubernetes</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubeadm">kubeadm</a>：方便的本地搭建多节点的kubernetes集群</li>
<li><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kops">kops</a>：在云上搭建kubernetes集群</li>
<li><a target="_blank" rel="noopener" href="https://cores.com/tectonic">tectonic</a>：少于10个节点免费</li>
<li><a target="_blank" rel="noopener" href="https://labs.play-with-k8s.com">play with kubernetes</a>：网站上搭建，无需任何工作，四个小时保存时间</li>
</ul>
<p>minikube安装（<a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/start/">参考文档</a>）：</p>
<ul>
<li>
<p>ubuntu上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_1.7.2-0_amd64.deb \</span><br><span class="line"> &amp;&amp; sudo dpkg -i minikube_1.7.2-0_amd64.deb</span><br><span class="line"><span class="comment">#使用以下命令检查下</span></span><br><span class="line">egrep -q <span class="string">&#x27;vmx|svm&#x27;</span> /proc/cpuinfo &amp;&amp; <span class="built_in">echo</span> <span class="built_in">yes</span> || <span class="built_in">echo</span> no</span><br><span class="line"><span class="comment">#如果输出 no 且如本文一样使用Windows + VirtualBox + minikube，需要通过以下命令创建一个单节点的kubernetes集群（具体命令后文会细说）</span></span><br><span class="line">sudo minikube start --vm-driver=none<span class="comment">#</span></span><br><span class="line">sudo minikube config <span class="built_in">set</span> vm-driver none<span class="comment">#</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要安装依赖的<code>kubectl</code>（客户端的CLI，可看上面的架构图）</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu上可以使用该命令安装：</span></span><br><span class="line">sudo snap install kubectl --classic</span><br><span class="line"><span class="comment">#其余Linux发行版可以使用以下命令</span></span><br><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</span><br><span class="line"><span class="built_in">chmod</span> +x ./kubectl</span><br><span class="line">sudo <span class="built_in">mv</span> ./kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>虚拟化工具virtualbox</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试版本号</span></span><br><span class="line">minikube version</span><br><span class="line">kubectl version</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>kubectl</code>的上下文：一些配置信息或者认证信息，称之为context，即上下文</p>
<p>kubectl的<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands">官方帮助文档</a></p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个单节点的kubernetes集群（适用于mac或Linux上直接装minikube+virtualbox用户）</span></span><br><span class="line">sudo minikube start --vm-driver=virtualbox</span><br><span class="line"><span class="comment">#适用于本文中Windows+virtualbox，在virtualbox中的虚拟机中安装minikube用户，缺点是有可能会影响Linux虚拟机和不能使用minikube ssh等命令</span></span><br><span class="line">sudo minikube start --vm-driver=none</span><br><span class="line"><span class="comment">#如果是国内，可以尝试如下命令</span></span><br><span class="line">sudo minikube start --vm-driver=none --image-mirror-country=cn</span><br><span class="line">sudo minikube start --vm-driver=none --image-mirror-country=cn --registry-mirror=https://registry.docker-cn.com --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"><span class="comment">#进入通过minikube创建的虚拟机中</span></span><br><span class="line">sudo minikube ssh</span><br><span class="line"><span class="comment">#停止虚拟机</span></span><br><span class="line">sudo minikube stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#当前使用的config的基本情况</span></span><br><span class="line">sudo kubectl config view</span><br><span class="line"><span class="comment">#查看当前使用的上下文</span></span><br><span class="line">sudo kubectl config get-contexts</span><br><span class="line"><span class="comment">#当前的kubernetes的集群情况</span></span><br><span class="line">sudo kubectl cluster-info</span><br></pre></td></tr></table></figure>
<h4 id="kubectl命令行补全补丁">kubectl命令行补全补丁</h4>
<p>kubectl自带命令行补全的脚本，通过命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Linux</span></span><br><span class="line">kubectl completion bash</span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure>
<p>进行打补丁补全。其他系统可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">官方文档</a>最后一节<code>Optional kubectl configurations</code></p>
<h3 id="最小调度单位pod">最小调度单位pod</h3>
<p>Pod是k8s集群中运行部署应用或服务的最小单元，一个Pod由一个或多个容器组成，kubernetes中不对容器进行直接操作。在一个Pod中，容器共享网络和存储，并且在一个Node上运行。</p>
<p>Kubernetes为每个Pod都分配了唯一的IP地址，称之为Pod IP，一个Pod里的多个容器共享Pod IP地址。Kubernetes要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用虚拟二层网络技术来实现，例如Flannel、Open vSwitch等。因此，在Kubernetes里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。</p>
<p>pod具有如下的一些特性：</p>
<ul>
<li>pod共享一个namespace（包含用户、网络、存储等）
<ul>
<li>如果一个pod中有两个Container，则这两个Container可以直接通过localhost进行通信，如同在本地一个Linux上运行的两个进程</li>
</ul>
</li>
</ul>
<p>基本操作例子：</p>
<p>pod_nginx.yml文件（根据kubernetes提供的一个API格式定义一个资源，这里是pod）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment">#pod名字</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">#pod中的关键部分</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment">#可以包含多个容器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment">#第一个Container Container名字</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>创建及基本管理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看kubernetes集群是否正常</span></span><br><span class="line">kubectl version</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据pod_nginx.yml创建pod</span></span><br><span class="line">kubectl create -f pod_nginx.yml</span><br><span class="line"><span class="comment">#kubectl delete -f pod_nginx.yml#删除pod</span></span><br><span class="line"><span class="comment">#查看pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment">#显示pod的详细信息(包括容器的ip(172.17.0.4)、在那个节点上)</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入minikube中的虚拟机中</span></span><br><span class="line">minikube ssh</span><br><span class="line"><span class="comment">#查看虚拟机中container</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">#进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> sh</span><br><span class="line"><span class="comment">#退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#查看bridge网络的详细情况 可以找到创建的iginx连接到了bridge网络上（ip:172.17.0.4/16）</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line"><span class="built_in">exit</span><span class="comment">#退出minikube</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接对pod进行可交互的操作，进入pod中的第一个容器内部（可以通过-c指定进入那个容器内部，默认第一个） 执行sh</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx(pod名字) sh</span><br><span class="line"><span class="comment">#具体描述一个pod</span></span><br><span class="line">kubectl desrcibe pods nginx(pod名字)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将minikube中的80端口暴露出来为8080端口</span></span><br><span class="line">kubectl port-forward nginx8080:80<span class="comment">#一旦停止，端口映射就会停止</span></span><br></pre></td></tr></table></figure>
<h3 id="横向扩展">横向扩展</h3>
<p><strong>ReplicationController</strong>种类：</p>
<p>rc_nginx.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment">#3个横向扩展</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过ReplicationController创建的pod，kubernetes能够自动帮我们维持对应数量的pods</li>
</ul>
<p>创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据rc_nginx.yml创建pod</span></span><br><span class="line">kubectl create -f rc_nginx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 ReplicationController 情况</span></span><br><span class="line">kubectl get rc</span><br><span class="line"><span class="comment">#查看pod(可以发现有3个pod)</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试删除一个pod</span></span><br><span class="line">kubectl delete pods pod的<span class="built_in">id</span>(通过get pods查询)</span><br><span class="line"><span class="comment">#再次查看pod(发现仍有3个pod)</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#横向扩展 修改为2</span></span><br><span class="line">kubectl scale rc nginx(名字) --replicas=2</span><br><span class="line">kubectl get pods<span class="comment">#查看后只有两个</span></span><br><span class="line">kubectl get rc</span><br></pre></td></tr></table></figure>
<p><strong>ReplicaSet</strong>种类：</p>
<p>rs_nginx.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment">#3个横向扩展</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ReplicaSet是ReplicationController的升级版，ReplicaSet支持new set-based selector</li>
</ul>
<p>创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据rs_nginx.yml创建pod</span></span><br><span class="line">kubectl create -f rs_nginx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 ReplicaSet 情况</span></span><br><span class="line">kubectl get rs</span><br><span class="line"><span class="comment">#查看pod(可以发现有3个pod)</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#横向扩展 修改为2</span></span><br><span class="line">kubectl scale rs nginx(名字) --replicas=2</span><br><span class="line">kubectl get pods<span class="comment">#查看后只有两个</span></span><br><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure>
<h3 id="Deployments">Deployments</h3>
<p>官方文档：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></p>
<p>Deployments控制器提供了Pod和ReplicaSets的声明性更新。即Deployments会描述一种希望的状态，如有三个扩展（–replicas=3）、pod中的具体的docker image版本以及相关的更新，Deployments controller都会努力使该声明实现（Deployments会通过创建ReplicaSet进而来创建pods）</p>
<p>注意：不能独立对 通过Deployments创建的Pod和ReplicaSets 进行操作（尤其是删除操作）</p>
<h4 id="创建和管理">创建和管理</h4>
<p>deployment_nginx.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment">#类型为Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>  <span class="comment">#此处其实就是ReplicaSet 保证pod的数量</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span>  <span class="comment">#指定pod需要的Container</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>  <span class="comment">#Container名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.12.2</span>  <span class="comment">#Container image</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据deployment_nginx.yml创建Deployment</span></span><br><span class="line">kubectl create -f deployment_nginx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment">#查看 ReplicaSet 情况</span></span><br><span class="line">kubectl get rs</span><br><span class="line"><span class="comment">#查看 pod 情况</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<p>Deployment相关命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment">#查看Deployment 显示更多信息</span></span><br><span class="line">kubectl get deployment -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#对deployment中的image进行升级</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment(resource) nginx-deployment(名字) nginx=nginx:1.13(image)</span><br><span class="line"><span class="comment">#查看Deployment 显示更多信息（包括image版本）</span></span><br><span class="line">kubectl get deployment -o wide</span><br><span class="line"><span class="comment">#查看 ReplicaSet 情况</span></span><br><span class="line">kubectl get rs<span class="comment">#会发现存在一个旧的（停止）一个新的</span></span><br><span class="line"><span class="comment">#查看 pod 情况</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看整个 deployment 的历史</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment(resource) nginx-deployment(名字)</span><br><span class="line"><span class="comment">#退回 deployment 的之前版本（即没有更新image之前）</span></span><br><span class="line">kubectl rollout undo deployment(resource) nginx-deployment(名字)</span><br><span class="line"><span class="comment">#查看Deployment 显示更多信息（包括image版本）</span></span><br><span class="line">kubectl get deployment -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看节点信息（ip地址）</span></span><br><span class="line">kubectl get node -o wide</span><br></pre></td></tr></table></figure>
<h3 id="使用Tectonic搭建本地多节点">使用Tectonic搭建本地多节点</h3>
<p><a target="_blank" rel="noopener" href="https://coreos.com/tectonic/">Tectonic</a>为CoreOS的产品：收费企业级产品，可免费试用。</p>
<p>搭建本地多节点教程：<a target="_blank" rel="noopener" href="https://coreos.com/tectonic/docs/latest/tutorials/sandbox/install.html">https://coreos.com/tectonic/docs/latest/tutorials/sandbox/install.html</a>（实测Tectonic下的sandbox已经不能正常获取！！！该实验无法正常进行！！！）</p>
<p>本质是通过vagrant在virtualbox上创建多台虚拟机（CoreOS系统，Container Linux）</p>
<p>修改kubeconfig文件，使kubectl命令同时支持minikube和tectnic（修改kubeconfig文件，添加新的cluster、context、user，具体配置可以参看<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">官方说明</a>），通过以下命令可以进行切换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看目前的上下文变量</span></span><br><span class="line">kubectl config get-contexts</span><br><span class="line"><span class="comment">#切换</span></span><br><span class="line">kubectl config use-context 上一个命令中的NAME栏名字</span><br></pre></td></tr></table></figure>
<h3 id="基础网络Cluster-Network">基础网络Cluster Network</h3>
<p>Cluster Network的<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/cluster-administration/networking">官方说明</a></p>
<p>pod_busybox.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;360000&quot;</span></span><br></pre></td></tr></table></figure>
<p>pod_nginx.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>service_nginx.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">nginx-port</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
<p>w1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据.yml创建pod</span></span><br><span class="line">kubectl create -f pod_busybox.yml</span><br><span class="line">kubectl create -f pod_nginx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看具体情况</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment">#两个pod详细情况：</span></span><br><span class="line"><span class="comment">#busybox-pod ip:10.2.0.50  节点w1</span></span><br><span class="line"><span class="comment">#nginx-pod   ip:10.2.0.51  节点w1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在w1中（未进入pod中）ping</span></span><br><span class="line">ping 10.2.0.50<span class="comment">#能够ping通</span></span><br><span class="line">ping 10.2.0.51<span class="comment">#能够ping通</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入busybox-pod</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it busybox-pod sh</span><br><span class="line"><span class="comment">#查看ip</span></span><br><span class="line">ip a</span><br><span class="line"><span class="comment">#尝试ping nginx-pod</span></span><br><span class="line">ping 10.2.0.51<span class="comment">#能够ping通</span></span><br></pre></td></tr></table></figure>
<p>c1节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#c1节点ping w1节点上的busybox-pod</span></span><br><span class="line">ping 10.2.0.50<span class="comment">#能够ping通</span></span><br><span class="line"><span class="comment">#c1节点ping w1节点上的nginx-pod</span></span><br><span class="line">ping 10.2.0.51<span class="comment">#能够ping通</span></span><br></pre></td></tr></table></figure>
<p>上述网络关系的拓扑图：</p>
<p><img src="/2020/01/16/Docker/image-20200225225507153.png" alt="网络关系拓扑图"></p>
<ul>
<li>flannel插件：coreos出品，开源免费，通过该插件实现了两台机器之间的overlay网络</li>
<li>诸如flannel插件的其他开源插件还有很多，在本节开头的网址进入后会有其他插件介绍说明以及插件必须遵守的原则</li>
</ul>
<h3 id="Service-2">Service</h3>
<p>在cluster中，每个pod都有自己独立的ip地址，并且都能够相互ping通，不论pod是否在同一台设备（节点）上（机器本身也能够ping通任意一个pod的ip地址，详见上一节）</p>
<p>注意：不要直接去使用和管理pods：</p>
<ul>
<li>当我们使用 ReplicaSet 或者 ReplicationController 水平扩展 scale 的时候,Pods有可能会被 terminated(终止)</li>
<li>当我们使用 Deployment 的时候,我们去更新 Docker Image Version,旧的Pods会被 terminated(终止),然后新的Pods创建</li>
</ul>
<p>在Kubernetes中，Pod会经历“生老病死”而无法复活，也就是说，分配给Pod的IP会随着Pod的销毁而消失，这就导致一个问题——如果有一组Pod组成一个集群来提供服务，某些Pod提供后端服务API，某些Pod提供前端界面UI，那么该如何保证前端能够稳定地访问这些后端服务呢？这就是Service的由来。</p>
<p>Service在Kubernetes中是一个抽象的概念，它定义了一组逻辑上的Pod和一个访问它们的策略（通常称之为微服务）。这一组Pod能够被Service访问到，通常是通过Label选择器确定的。</p>
<p>创建service：</p>
<p>1、命令行创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给pod创建service 供外部访问</span></span><br><span class="line">kubectl expoese &lt;resources&gt; &lt;resources名字&gt;</span><br></pre></td></tr></table></figure>
<p>2、yml文件中通过<code>kind: Service</code>定义，主要有以下三种service</p>
<ul>
<li><strong>ClusterIP</strong>：ip地址是cluster内部均可以访问的，但是外界缺无法访问（这种内部的ip称为ClusterIP），外界可以通过service的ip访问（一般service的ip不会变动，而pod的ip会变动）</li>
<li><strong>NodePort</strong>：将要访问的port绑定到所有node上，因为node对外可以提供访问（假设node的ip为公网ip），所以该类型的service外界也是可以访问的，但是这种方式暴露的port有范围限制（30000-32767）</li>
<li><strong>LoadBalancer</strong>：一般需要结合云服务使用，由云服务商提供。实际环境中运用较多</li>
<li><strong>ExternalName</strong>：通过DNS的方式。实际环境中运用较多</li>
<li>Default：即ClusterIP，默认为ClusterIP方式</li>
</ul>
<p>以上均是通过ip地址访问的，但是其实也是可以通过dns访问，但是需要相关的插件</p>
<hr>
<p>ClusterIP的相关例子：</p>
<p>例子1：</p>
<p>w1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据上一节.yml创建pod</span></span><br><span class="line">kubectl create -f pod_busybox.yml</span><br><span class="line">kubectl create -f pod_nginx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看具体情况</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment">#两个pod详细情况：</span></span><br><span class="line"><span class="comment">#busybox-pod ip:10.2.0.254  节点w1</span></span><br><span class="line"><span class="comment">#nginx-pod   ip:10.2.0.252  节点w1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建service</span></span><br><span class="line">kubectl expoese pods nginx-pod</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看service状态</span></span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment">#service name:nginx-pod  ip:10.3.248.3</span></span><br></pre></td></tr></table></figure>
<p>c1节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.3.248.3<span class="comment">#可以直接通过service访问pod</span></span><br></pre></td></tr></table></figure>
<hr>
<p>例子2：</p>
<p>deployment_python_http.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">service_test_pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">service_test_pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">simple-http</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">python:2.7</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>]</span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;&lt;p&gt;Hello from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;</span>]</span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>w1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker pull python:2.7</span></span><br><span class="line"><span class="comment">#根据.yml文件创建Deployment</span></span><br><span class="line">kubectl create -f deployment_python_http.yml</span><br><span class="line"></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="comment">#pod1 name:service-test-1863849916-b13b6 ip:10.2.0.142  节点w1</span></span><br><span class="line"><span class="comment">#pod2 name:service-test-1863849916-ts7xr ip:10.2.0.141  节点w1</span></span><br></pre></td></tr></table></figure>
<p>c1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl 10.2.0.142:8080<span class="comment">#可以直接访问pod1</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;</span><br><span class="line">curl 10.2.0.141:8080<span class="comment">#可以直接访问pod2</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>w1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看deployment情况</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="comment">#创建deployment服务service-test</span></span><br><span class="line">kubectl expose deployment service-test</span><br><span class="line"><span class="comment">#查看服务情况</span></span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment">#service name: service-test  ip:10.3.120.168</span></span><br></pre></td></tr></table></figure>
<p>c1节点上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl 10.3.120.168:8080<span class="comment">#可以直接通过service访问pod</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;</span><br><span class="line">curl 10.3.120.168:8080<span class="comment">#可以直接通过service访问pod</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;</span><br><span class="line">curl 10.3.120.168:8080<span class="comment">#可以直接通过service访问pod</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;</span><br><span class="line">curl 10.3.120.168:8080<span class="comment">#可以直接通过service访问pod</span></span><br><span class="line">&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>访问service ip会自动做一个<strong>负载均衡</strong></li>
</ul>
<hr>
<p>例子3：</p>
<p>接例子2中的换件，在c1中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不停地调用</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl 10.3.120.168:8080; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>w1节点中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接编辑deployment_python_http.yml 达到应用升级</span></span><br><span class="line">kubectl edit deployment service-test<span class="comment">#会自动打开deployment_python_http.yml文件</span></span><br><span class="line"><span class="comment">#将 Hello from $(hostname) 修改为 Hello new version from $(hostname)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看pods</span></span><br><span class="line">kubectl get pods<span class="comment">#可以看到旧的pods已经终止，同时会生成并运行一个新的pods</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改deployment_python_http.yml文件后，c1中的程序检测到该服务会停止一段时间，但是最后会恢复至正常</li>
<li>该更新并不是Rolling Updata，即并不是零宕机更新，有一段时间会存在不能访问服务器</li>
</ul>
<h3 id="NodePort类型service以及Label简单应用">NodePort类型service以及Label简单应用</h3>
<p>演示：</p>
<p>service中（c1节点pod_nginx.yml）：</p>
<p>创建pod_nginx.yml：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment">#具体的label，与后文中的service的yml文件中的label对应</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span> <span class="comment">#端口名字</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment">#具体的端口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>labels：几乎所有的资源都可以设置一个label，由一对key value组成，且可以设置不止一个</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建pod</span></span><br><span class="line">kubectl create -f pod_nginx.yml</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过expose给改pod创建一个NodePort类型的service</span></span><br><span class="line">kubectl expose pods nginx-pod --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment">#name:kubernetes ClusterIP ip:10.3.0.1 port:443/TCP</span></span><br><span class="line"><span class="comment">#name:nginx-pod NodePort ip:10.3.38.138 port:80:31404/TCP</span></span><br><span class="line">kubectl get node -o wide</span><br><span class="line"><span class="comment">#查看c1的ip</span></span><br><span class="line">kubectl describe node c1的<span class="built_in">id</span><span class="comment">#172.17.4.101</span></span><br><span class="line"><span class="comment">#查看w1的ip</span></span><br><span class="line">kubectl describe node w1的<span class="built_in">id</span><span class="comment">#172.17.4.201</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除该service，注意pod还在</span></span><br><span class="line">kubectl delete service nginx-pod</span><br></pre></td></tr></table></figure>
<ul>
<li>直接在浏览器中打开<code>172.17.4.101:31404</code>或<code>172.17.4.201:31404</code>即可正常访问Nginx</li>
</ul>
<p><strong>NodePort</strong>类型的service会将端口映射到整个Cluster上的每个node的ip地址上，所以可以通过Cluster的任意一个节点的ip地址+端口去访问服务</p>
<p>类似创建pod，该service也可以通过<code>.yml</code>文件（service_nginx.yml）创建：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment">#创建service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span> <span class="comment">#名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">32333</span> <span class="comment">#需要暴露的端口</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32333</span> <span class="comment">#暴露到nodeport上</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">nginx-port</span> <span class="comment">#目标端口名，对应上述pod的yml文件中描述的port</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment">#通过label去选择到底暴露那个pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment">#创建service的类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意<code>selector</code>应该和上文中的pod创建时指名的label一致，指名是该pod</li>
</ul>
<p>再次创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看运行中的pod的label是否和yml文件中描述的吻合</span></span><br><span class="line">kubectl get pods --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建service</span></span><br><span class="line">kubectl create -f service_nginx.yml</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl get svc</span><br><span class="line"><span class="comment">#name:kubernetes ClusterIP ip:10.3.0.1 port:443/TCP</span></span><br><span class="line"><span class="comment">#name:nginx-pod NodePort ip:10.3.124.158 port:32333:32333/TCP</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时，直接在浏览器中打开<code>172.17.4.101:32333</code>或<code>172.17.4.201:32333</code>即可正常访问Nginx</li>
</ul>
<hr>
<p>label例子演示：</p>
<p>由上文中提到的，几乎所有的资源都可以设置一个label，由一对key value组成，且可以设置不止一个，具体使用如下：</p>
<p>pod_busybox.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="comment">#定义一个node的selector（筛选器）</span></span><br><span class="line">    <span class="attr">hardware:</span> <span class="string">good</span> <span class="comment">#自定义的label</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;360000&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建pod</span></span><br><span class="line">kubectl create -f pod_busybox.yml</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">kubectl get pods<span class="comment">#可以发现现在该busybox pod的状态都是pending</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pod_busybox状态一直是pending的原因为：整个Cluster中的所有node上的label匹配不到<code>hardware=good</code>的label，所以该pod一直不能正常部署到node上</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有node上的所有label</span></span><br><span class="line">kubectl get node --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取node的id(name)</span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="comment">#手动在node上添加label</span></span><br><span class="line">kubectl label node node的<span class="built_in">id</span> hardware=good</span><br><span class="line"></span><br><span class="line"><span class="comment">#等待一阵之后，查看</span></span><br><span class="line">kubectl get pods<span class="comment">#发现已经由pending状态变为Running状态</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2020/01/16/Docker/">http://nu-ll.github.io/2020/01/16/Docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/29/python%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python实战</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/10/python/"><img class="next-cover" src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/spaceman.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">spaceman</div><div class="author-info__description">CtrlC CtrlV大师</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NU-LL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">白嫖一时爽，一直白嫖一直爽</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88Ubuntu-18-04%EF%BC%89"><span class="toc-text">一、环境搭建（Ubuntu 18.04）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vagrant-VirtualBox"><span class="toc-text">Vagrant+VirtualBox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker-Engine-Community"><span class="toc-text">安装Docker Engine - Community</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nvidia-docker"><span class="toc-text">nvidia docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-3"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">环境变量设置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gpu%E6%95%B0%E9%87%8F"><span class="toc-text">gpu数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8"><span class="toc-text">驱动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-text">资源限制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-text">二、Docker的镜像和容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BA%95%E5%B1%82"><span class="toc-text">架构和底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Image"><span class="toc-text">Image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container"><span class="toc-text">Container</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84image"><span class="toc-text">构建自己的image</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-text">运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile"><span class="toc-text">DockerFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E9%95%9C%E5%83%8F"><span class="toc-text">发布镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-text">容器资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94ubuntu%E4%B8%8A%E6%89%93%E5%8C%85stress"><span class="toc-text">实战——ubuntu上打包stress</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E5%B8%B8%E9%A9%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">python常驻程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ubuntu%E4%B8%8A%E6%89%93%E5%8C%85stress"><span class="toc-text">ubuntu上打包stress</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#run-2"><span class="toc-text">run</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#start-stop-restart"><span class="toc-text">start&#x2F;stop&#x2F;restart</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kill"><span class="toc-text">kill</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rm"><span class="toc-text">rm</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pause-unpause"><span class="toc-text">pause&#x2F;unpause</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#create"><span class="toc-text">create</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exec"><span class="toc-text">exec</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ps"><span class="toc-text">ps</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#top"><span class="toc-text">top</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#attach"><span class="toc-text">attach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#events"><span class="toc-text">events</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#logs"><span class="toc-text">logs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait"><span class="toc-text">wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#export"><span class="toc-text">export</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#port"><span class="toc-text">port</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#images%E7%AE%A1%E7%90%86"><span class="toc-text">images管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#images"><span class="toc-text">images</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rmi"><span class="toc-text">rmi</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tag"><span class="toc-text">tag</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#build"><span class="toc-text">build</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#history"><span class="toc-text">history</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#save"><span class="toc-text">save</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#load"><span class="toc-text">load</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import"><span class="toc-text">import</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%B1%87%E6%80%BB"><span class="toc-text">导入导出汇总</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="toc-text">仓库管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#login-logout"><span class="toc-text">login&#x2F;logout</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pull"><span class="toc-text">pull</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#push"><span class="toc-text">push</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#search"><span class="toc-text">search</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">容器文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#commit"><span class="toc-text">commit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cp-2"><span class="toc-text">cp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#diff-2"><span class="toc-text">diff</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81docker%E7%BD%91%E7%BB%9C"><span class="toc-text">三、docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%ADnetwork-namespace"><span class="toc-text">Linux中network namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Bridge0%E8%AF%A6%E8%A7%A3"><span class="toc-text">Docker Bridge0详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E4%B9%8B%E9%97%B4%E7%9A%84link"><span class="toc-text">docker之间的link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-text">端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#host%E5%92%8Cnone%E7%BD%91%E7%BB%9C"><span class="toc-text">host和none网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E9%80%9A%E4%BF%A1"><span class="toc-text">多机通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Docker%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-text">四、Docker的持久化存储和数据共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Volume"><span class="toc-text">Data Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bind-Mounting%EF%BC%88%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-text">Bind Mounting（挂载宿主机目录）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Docker-Compose%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2"><span class="toc-text">五、Docker Compose多容器部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">安装和基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">水平扩展和负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92Swarm-mode"><span class="toc-text">六、容器编排Swarm mode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%9A%84%E5%88%9B%E5%BB%BA%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95"><span class="toc-text">Service的创建维护和水平扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94RoutingMesh"><span class="toc-text">集群服务器通信——RoutingMesh</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Internal"><span class="toc-text">Internal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress"><span class="toc-text">Ingress</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stack%E9%83%A8%E7%BD%B2swarm"><span class="toc-text">docker stack部署swarm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86"><span class="toc-text">密码管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stack%E4%B8%AD%E4%BD%BF%E7%94%A8secret"><span class="toc-text">docker stack中使用secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service%E6%9B%B4%E6%96%B0"><span class="toc-text">service更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92Kubernetes"><span class="toc-text">七、容器编排Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAk8s%E5%8D%95%E8%8A%82%E7%82%B9%E7%8E%AF%E5%A2%83"><span class="toc-text">搭建k8s单节点环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kubectl%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A1%A5%E5%85%A8%E8%A1%A5%E4%B8%81"><span class="toc-text">kubectl命令行补全补丁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B0%83%E5%BA%A6%E5%8D%95%E4%BD%8Dpod"><span class="toc-text">最小调度单位pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95"><span class="toc-text">横向扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployments"><span class="toc-text">Deployments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-text">创建和管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Tectonic%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%A4%9A%E8%8A%82%E7%82%B9"><span class="toc-text">使用Tectonic搭建本地多节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9CCluster-Network"><span class="toc-text">基础网络Cluster Network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-2"><span class="toc-text">Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NodePort%E7%B1%BB%E5%9E%8Bservice%E4%BB%A5%E5%8F%8ALabel%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="toc-text">NodePort类型service以及Label简单应用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/15/JetsonNano%E6%91%84%E5%83%8F%E5%A4%B4%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/" title="JetsonNano摄像头驱动开发指南">JetsonNano摄像头驱动开发指南</a><time datetime="2022-03-15T06:07:34.000Z" title="发表于 2022-03-15 14:07:34">2022-03-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/22/JetsonTX2%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" title="JetsonTX2避坑指南">JetsonTX2避坑指南</a><time datetime="2022-02-21T17:46:24.000Z" title="发表于 2022-02-22 01:46:24">2022-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/13/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" title="python迭代器与生成器">python迭代器与生成器</a><time datetime="2021-12-13T06:28:34.000Z" title="发表于 2021-12-13 14:28:34">2021-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/22/Arch%20Linux%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/" title="Arch Linux安装指南">Arch Linux安装指南</a><time datetime="2021-11-22T04:43:24.000Z" title="发表于 2021-11-22 12:43:24">2021-11-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/04/Arduino%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%BF%E5%8D%A1/" title="Arduino中添加自定义板卡">Arduino中添加自定义板卡</a><time datetime="2021-11-04T10:37:40.000Z" title="发表于 2021-11-04 18:37:40">2021-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By spaceman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> <iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tx&color=eee" frameborder="0" allowtransparency="false" align="middle" height="20"></iframe></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>