<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>Linux驱动常用API整理 | 无名小卒</title>
  <meta name="keywords" content=" 驱动API ">
  <meta name="description" content="Linux驱动常用API整理 | 无名小卒">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="关于">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://NU-LL.github.io/about/index.html">
<meta property="og:site_name" content="无名小卒">
<meta property="og:description" content="关于">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-21T14:30:10.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="关于">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>NU-LL</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/NU-LL" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="csdn" href="https://blog.csdn.net/CSDN_JZ_" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="email" href="mailto:1125934312@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1125934312&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=323374922" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(44)</small></div></li>
    
        
            
            <li><div data-rel="Linux">Linux<small>(25)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程语言">编程语言<small>(6)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="MCU">MCU<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="人工智能">人工智能<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="感悟与总结">感悟与总结<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a style="border-right: 1px solid #fff; width: 49%"  class="about site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="44">
<input type="hidden" id="yelog_site_word_count" value="288.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://github.com/NU-LL">NU-LL</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">DM9000C</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">网卡移植</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">GO</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">ESP32</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">ESP8266</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Kconfig语法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">IIC驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Latex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">Ctex</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">LiCheePi Zero</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux服务</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Linux内核</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">文件描述符</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Markdown</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">Mininet</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">数据分析</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">NanoPi Neo Core</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">字符驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">TensorFlow2</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">SVM</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Xmanager</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">远程链接</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">network namespace</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">Kubernetes</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">等待队列</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_head_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">wait_queue_t</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">markdownlint</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">python实战</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">u-boot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">爬虫</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">二维数组</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">指针</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">存储器</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">IAP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">BootLoader</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">dual bank</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">快速排序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">按键驱动</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">poll机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">异步通知机制</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">根文件系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">网卡驱动框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">虚拟网卡</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">设备树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">输入子系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">Go语言入门经典</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">驱动API</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">廖雪峰python教程</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="Linux "
           href="/2019/08/04/DM9000C网卡移植/"
           data-tag="DM9000C,网卡移植"
           data-author="" >
            <span class="post-title" title="DM9000C网卡移植">DM9000C网卡移植</span>
            <span class="post-date" title="2019-08-04 23:07:22">2019/08/04</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/05/09/C和GO的语法对比/"
           data-tag="GO"
           data-author="" >
            <span class="post-title" title="C和GO的语法对比">C和GO的语法对比</span>
            <span class="post-date" title="2020-05-09 19:55:39">2020/05/09</span>
        </a>
        
        <a  class="Linux "
           href="/2020/01/16/Docker/"
           data-tag="Docker"
           data-author="" >
            <span class="post-title" title="Docker">Docker</span>
            <span class="post-date" title="2020-01-16 20:14:51">2020/01/16</span>
        </a>
        
        <a  class="MCU "
           href="/2020/05/16/ESP32/"
           data-tag="ESP32"
           data-author="" >
            <span class="post-title" title="ESP8266">ESP8266</span>
            <span class="post-date" title="2020-05-16 10:30:54">2020/05/16</span>
        </a>
        
        <a  class="MCU "
           href="/2020/04/28/ESP8266/"
           data-tag="ESP8266"
           data-author="" >
            <span class="post-title" title="ESP8266">ESP8266</span>
            <span class="post-date" title="2020-04-28 14:27:54">2020/04/28</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/15/Kconfig文件语法分析/"
           data-tag="Kconfig语法"
           data-author="" >
            <span class="post-title" title="Kconfig文件语法分析">Kconfig文件语法分析</span>
            <span class="post-date" title="2019-08-15 19:38:40">2019/08/15</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/05/IIC驱动/"
           data-tag="IIC驱动"
           data-author="" >
            <span class="post-title" title="IIC驱动">IIC驱动</span>
            <span class="post-date" title="2019-08-05 14:39:10">2019/08/05</span>
        </a>
        
        <a  class="工具 "
           href="/2019/08/19/Latex排版全解/"
           data-tag="Latex,Ctex"
           data-author="" >
            <span class="post-title" title="Latex排版全解">Latex排版全解</span>
            <span class="post-date" title="2019-08-19 16:02:27">2019/08/19</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/LiCheePi_Zero底层开发/"
           data-tag="LiCheePi Zero"
           data-author="" >
            <span class="post-title" title="LiCheePi_Zero底层开发">LiCheePi_Zero底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/28/Linux上常见服务搭建/"
           data-tag="Linux服务"
           data-author="" >
            <span class="post-title" title="Linux上常见服务搭建">Linux上常见服务搭建</span>
            <span class="post-date" title="2020-03-28 01:27:58">2020/03/28</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/13/Linux内核启动流程/"
           data-tag="Linux内核"
           data-author="" >
            <span class="post-title" title="Linux内核启动流程">Linux内核启动流程</span>
            <span class="post-date" title="2019-08-13 16:13:46">2019/08/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/Linux编程--文件描述符fd/"
           data-tag="文件描述符"
           data-author="" >
            <span class="post-title" title="Linux编程--文件描述符fd">Linux编程--文件描述符fd</span>
            <span class="post-date" title="2019-07-21 10:13:47">2019/07/21</span>
        </a>
        
        <a  class="工具 "
           href="/2019/07/12/Markdown 语法整理/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 语法整理">Markdown 语法整理</span>
            <span class="post-date" title="2019-07-12 13:57:24">2019/07/12</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/13/Mininet/"
           data-tag="Mininet"
           data-author="" >
            <span class="post-title" title="Mininet">Mininet</span>
            <span class="post-date" title="2020-02-13 18:37:12">2020/02/13</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/03/10/Python数据分析与展示/"
           data-tag="数据分析"
           data-author="" >
            <span class="post-title" title="Python数据分析与展示">Python数据分析与展示</span>
            <span class="post-date" title="2020-03-10 15:10:50">2020/03/10</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/18/NanoPi_Neo_Core底层开发/"
           data-tag="NanoPi Neo Core"
           data-author="" >
            <span class="post-title" title="NanoPi_Neo_Core底层开发">NanoPi_Neo_Core底层开发</span>
            <span class="post-date" title="2019-10-18 12:25:42">2019/10/18</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/RTC驱动分析/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="RTC驱动分析">RTC驱动分析</span>
            <span class="post-date" title="2019-08-07 13:37:33">2019/08/07</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/05/03/TensorFlow2/"
           data-tag="TensorFlow2"
           data-author="" >
            <span class="post-title" title="TensorFlow2入门与实践">TensorFlow2入门与实践</span>
            <span class="post-date" title="2020-05-03 00:52:53">2020/05/03</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/06/05/SVM/"
           data-tag="SVM"
           data-author="" >
            <span class="post-title" title="SVM（线性模型）数学推导">SVM（线性模型）数学推导</span>
            <span class="post-date" title="2020-06-05 21:12:53">2020/06/05</span>
        </a>
        
        <a  class="Linux "
           href="/2019/11/08/Xmanager远程Ubuntu系统图像化界面/"
           data-tag="Xmanager,远程链接"
           data-author="" >
            <span class="post-title" title="Xmanager远程Ubuntu系统图像化界面">Xmanager远程Ubuntu系统图像化界面</span>
            <span class="post-date" title="2019-11-08 22:58:53">2019/11/08</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/git/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <span class="post-date" title="2019-09-17 09:59:56">2019/09/17</span>
        </a>
        
        <a  class="Linux "
           href="/2020/02/10/linux 网络虚拟化： network namespace 简介/"
           data-tag="network namespace"
           data-author="" >
            <span class="post-title" title="linux 网络虚拟化： network namespace 简介">linux 网络虚拟化： network namespace 简介</span>
            <span class="post-date" title="2020-02-10 14:24:09">2020/02/10</span>
        </a>
        
        <a  class="Linux "
           href="/2020/03/15/kubernetes/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes">Kubernetes</span>
            <span class="post-date" title="2020-03-15 13:48:53">2020/03/15</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/linux等待队列wait_queue_head_t和wait_queue_t/"
           data-tag="等待队列,wait_queue_head_t,wait_queue_t"
           data-author="" >
            <span class="post-title" title="linux等待队列wait_queue_head_t和wait_queue_t">linux等待队列wait_queue_head_t和wait_queue_t</span>
            <span class="post-date" title="2019-07-21 18:18:54">2019/07/21</span>
        </a>
        
        <a  class="工具 "
           href="/2019/09/17/markdownlint规则详细介绍/"
           data-tag="markdownlint"
           data-author="" >
            <span class="post-title" title="VSC插件之markdownlint规则详细介绍">VSC插件之markdownlint规则详细介绍</span>
            <span class="post-date" title="2019-09-17 15:00:13">2019/09/17</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/29/python实战/"
           data-tag="python实战"
           data-author="" >
            <span class="post-title" title="python实战">python实战</span>
            <span class="post-date" title="2020-01-29 21:36:32">2020/01/29</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/02/18/python爬虫/"
           data-tag="python,爬虫"
           data-author="" >
            <span class="post-title" title="python爬虫">python爬虫</span>
            <span class="post-date" title="2020-02-18 23:40:18">2020/02/18</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/06/二维数组与指针的一些问题/"
           data-tag="二维数组,指针"
           data-author="" >
            <span class="post-title" title="二维数组与指针的一些问题">二维数组与指针的一些问题</span>
            <span class="post-date" title="2019-08-06 13:11:26">2019/08/06</span>
        </a>
        
        <a  class="感悟与总结 "
           href="/2019/08/11/各种存储器的区别/"
           data-tag="存储器"
           data-author="" >
            <span class="post-title" title="各种存储器的区别">各种存储器的区别</span>
            <span class="post-date" title="2019-08-11 10:57:19">2019/08/11</span>
        </a>
        
        <a  class="MCU "
           href="/2019/11/12/基于STM32L476的IAP升级/"
           data-tag="IAP,BootLoader,dual bank"
           data-author="" >
            <span class="post-title" title="基于STM32L476的IAP升级">基于STM32L476的IAP升级</span>
            <span class="post-date" title="2019-11-12 22:47:40">2019/11/12</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/07/字符驱动设备的另一种写法/"
           data-tag="字符驱动"
           data-author="" >
            <span class="post-title" title="字符驱动设备的另一种写法">字符驱动设备的另一种写法</span>
            <span class="post-date" title="2019-08-07 12:20:30">2019/08/07</span>
        </a>
        
        <a  class="算法 "
           href="/2019/07/29/快速排序/"
           data-tag="快速排序"
           data-author="" >
            <span class="post-title" title="快速排序">快速排序</span>
            <span class="post-date" title="2019-07-29 22:27:34">2019/07/29</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/21/按键驱动——poll机制/"
           data-tag="按键驱动,poll机制"
           data-author="" >
            <span class="post-title" title="按键驱动——poll机制">按键驱动——poll机制</span>
            <span class="post-date" title="2019-07-21 20:30:38">2019/07/21</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/22/按键驱动：异步通知机制/"
           data-tag="按键驱动,异步通知机制"
           data-author="" >
            <span class="post-title" title="按键驱动：异步通知机制">按键驱动：异步通知机制</span>
            <span class="post-date" title="2019-07-22 19:04:24">2019/07/22</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/14/构造根文件系统/"
           data-tag="根文件系统"
           data-author="" >
            <span class="post-title" title="构造根文件系统">构造根文件系统</span>
            <span class="post-date" title="2019-08-14 20:18:45">2019/08/14</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/04/网卡驱动程序/"
           data-tag="网卡驱动框架,虚拟网卡"
           data-author="" >
            <span class="post-title" title="网卡驱动程序">网卡驱动程序</span>
            <span class="post-date" title="2019-08-04 21:24:07">2019/08/04</span>
        </a>
        
        <a  class="Linux "
           href="/2019/10/13/设备树/"
           data-tag="设备树"
           data-author="" >
            <span class="post-title" title="设备树">设备树</span>
            <span class="post-date" title="2019-10-13 15:53:24">2019/10/13</span>
        </a>
        
        <a  class="Linux "
           href="/2019/07/25/输入子系统/"
           data-tag="按键驱动,输入子系统"
           data-author="" >
            <span class="post-title" title="输入子系统">输入子系统</span>
            <span class="post-date" title="2019-07-25 00:05:15">2019/07/25</span>
        </a>
        
        <a  class="编程语言 "
           href="/2019/10/23/Go语言/"
           data-tag="Go语言入门经典"
           data-author="" >
            <span class="post-title" title="Go语言">Go语言</span>
            <span class="post-date" title="2019-10-23 21:07:25">2019/10/23</span>
        </a>
        
        <a  class="Linux "
           href="/2020/04/06/Linux驱动常用API整理/"
           data-tag="驱动API"
           data-author="" >
            <span class="post-title" title="Linux驱动常用API整理">Linux驱动常用API整理</span>
            <span class="post-date" title="2020-04-06 22:48:09">2020/04/06</span>
        </a>
        
        <a  class="Linux "
           href="/2019/08/12/u-boot分析与使用/u-boot分析与使用 - 老版本备份/"
           data-tag="u-boot"
           data-author="" >
            <span class="post-title" title="u-boot分析与使用">u-boot分析与使用</span>
            <span class="post-date" title="2019-08-12 19:16:50">2019/08/12</span>
        </a>
        
        <a  class="人工智能 "
           href="/2020/01/03/深度学习与TensorFlow2/"
           data-tag="TensorFlow2,深度学习"
           data-author="" >
            <span class="post-title" title="深度学习与TensorFlow2">深度学习与TensorFlow2</span>
            <span class="post-date" title="2020-01-03 21:04:26">2020/01/03</span>
        </a>
        
        <a  class="编程语言 "
           href="/2020/01/10/python/"
           data-tag="廖雪峰python教程"
           data-author="" >
            <span class="post-title" title="Python">Python</span>
            <span class="post-date" title="2020-01-10 20:18:52">2020/01/10</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-Linux驱动常用API整理" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Linux驱动常用API整理</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="Linux">Linux</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color1">驱动API</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-05-02 22:54:24'>2020-04-06 22:48</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:12.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发与竞争"><span class="toc-text">并发与竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作"><span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁"><span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥体"><span class="toc-text">互斥体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符设备驱动"><span class="toc-text">字符设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用宏"><span class="toc-text">常用宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册与注销"><span class="toc-text">注册与注销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设备节点"><span class="toc-text">设备节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设备号"><span class="toc-text">设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户空间与内核空间"><span class="toc-text">用户空间与内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址映射"><span class="toc-text">地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux常用命令"><span class="toc-text">Linux常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核定时器"><span class="toc-text">内核定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断"><span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#上半部"><span class="toc-text">上半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#申请"><span class="toc-text">申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放"><span class="toc-text">释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断处理函数"><span class="toc-text">中断处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使能与禁止"><span class="toc-text">使能与禁止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下半部"><span class="toc-text">下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#软中断"><span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet"><span class="toc-text">tasklet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作队列"><span class="toc-text">工作队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞与非阻塞"><span class="toc-text">阻塞与非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待队列"><span class="toc-text">等待队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#等待队列头"><span class="toc-text">等待队列头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待队列项"><span class="toc-text">等待队列项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加-移除等待队列"><span class="toc-text">添加/移除等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待唤醒"><span class="toc-text">等待唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待事件"><span class="toc-text">等待事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轮询"><span class="toc-text">轮询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#驱动中的poll函数"><span class="toc-text">驱动中的poll函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步通知（信号）"><span class="toc-text">异步通知（信号）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用程序API"><span class="toc-text">应用程序API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#驱动程序API"><span class="toc-text">驱动程序API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用框架API"><span class="toc-text">常用框架API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#platform"><span class="toc-text">platform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MISC"><span class="toc-text">MISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INPUT"><span class="toc-text">INPUT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化及卸载"><span class="toc-text">初始化及卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上报数据"><span class="toc-text">上报数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层相关"><span class="toc-text">应用层相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多点触摸"><span class="toc-text">多点触摸</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Type-A"><span class="toc-text">Type A</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Type-B"><span class="toc-text">Type B</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Framebuffer"><span class="toc-text">Framebuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC"><span class="toc-text">RTC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC"><span class="toc-text">IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iic通信"><span class="toc-text">iic通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#内核驱动"><span class="toc-text">内核驱动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#应用层直接访问"><span class="toc-text">应用层直接访问</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板"><span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spi通信"><span class="toc-text">spi通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板-1"><span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWM"><span class="toc-text">PWM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备树"><span class="toc-text">设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用"><span class="toc-text">通用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查找节点"><span class="toc-text">查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提取属性"><span class="toc-text">提取属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他常用函数"><span class="toc-text">其他常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO子系统"><span class="toc-text">GPIO子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#of函数"><span class="toc-text">of函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#驱动层函数"><span class="toc-text">驱动层函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断相关"><span class="toc-text">中断相关</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="并发与竞争"><a href="#并发与竞争" class="headerlink" title="并发与竞争"></a>并发与竞争</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>定义：</p>
<pre><code class="c">typedef struct {
    int counter;
} atomic_t;</code></pre>
<p>整形操作：</p>
<pre><code class="c">ATOMIC_INIT(int i);//定义时初始化
int atomic_read(atomic_t *v);
void atomic_set(atomic_t *v, int i)
void atomic_add(int i, atomic_t *v)
void atomic_sub(int i, atomic_t *v)
void atomic_dec(atomic_t *v)//自减
void atomic_inc(atomic_t *v)//自增
int atomic_dec_return(atomic_t *v)//自减并返回v
int atomic_inc_return(atomic_t *v)//自增并返回v
int atomic_sub_and_test(int i, atomic_t *v)//(v-i)==0?1:0（返回真、假）
int atomic_dec_and_test(atomic_t *v)//(v--)==0?1:0（返回真、假）
int atomic_inc_and_test(atomic_t *v)//(v++)==0?1:0（返回真、假）
int atomic_add_negative(int i, atomic_t *v)//(v+i)&lt;0?1:0（返回真、假）</code></pre>
<p>位操作（直接对内存操作）：</p>
<pre><code class="c">void set_bit(int nr, void *p)//将p地址的第nr位置 1
void clear_bit(int nr,void *p)
void change_bit(int nr, void *p)//翻转
int test_bit(int nr, void *p)//获取
int test_and_set_bit(int nr, void *p)//将p地址的第nr位置1，并返回nr位原来的值
int test_and_clear_bit(int nr, void *p)//...清零...
int test_and_change_bit(int nr, void *p)//...翻转...</code></pre>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>基本API</p>
<pre><code class="c">DEFINE_SPINLOCK(spinlock_t lock)//定义并初始化
int spin_lock_init(spinlock_t *lock)//初始化
void spin_lock(spinlock_t *lock)//加锁
void spin_unlock(spinlock_t *lock)//解锁
int spin_trylock(spinlock_t *lock)//尝试加锁
int spin_is_locked(spinlock_t *lock)//检查是否加锁，是返回非 0，否返回 0</code></pre>
<p>中断相关：</p>
<p>一般在线程中使用 <code>spin_lock_irqsave</code>/<code>spin_unlock_irqrestore</code>，在中断中使用<code>spin_lock</code>/<code>spin_unlock</code>  </p>
<pre><code class="c">void spin_lock_irq(spinlock_t *lock)//禁止本地中断，并获取自旋锁
void spin_unlock_irq(spinlock_t *lock)//激活本地中断，并释放自旋锁
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)//保存中断状态，禁止本地中断，并获取自旋锁
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)//恢复中断状态，并且激活本地中断，释放自旋锁</code></pre>
<p>中断下半部相关：</p>
<pre><code class="c">void spin_lock_bh(spinlock_t *lock)//关闭下半部，并获取自旋锁
void spin_unlock_bh(spinlock_t *lock)//打开下半部，并释放自旋锁</code></pre>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><pre><code class="c">DEFINE_SEAMPHORE(name)//定义信号量 并设值为1
void sema_init(struct semaphore *sem, int val)//初始化，并设值为val
void down(struct semaphore *sem)//获取信号量（会导致休眠，不能在中断中使用，不能被信号打断）
int down_interruptible(struct semaphore *sem)//获取信号量(会导致休眠，不能在中断中使用，可以被信号打断)
int down_trylock(struct semaphore *sem)//尝试获取信号量(成功返回 0。否则返回非 0)
void up(struct semaphore *sem)//释放信号量</code></pre>
<h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><p>会导致休眠，不能在中断中使用 <code>mutex</code>，中断中只能使用<code>自旋锁</code></p>
<pre><code class="c">DEFINE_MUTEX(name)//定义并初始化
void mutex_init(mutex *lock)//初始化
void mutex_lock(struct mutex *lock)//上锁，失败则休眠，不可以被信号打断
int mutex_lock_interruptible(struct mutex *lock)//上锁，失败则休眠，可以被信号打断
void mutex_unlock(struct mutex *lock)//解锁
int mutex_trylock(struct mutex *lock)//尝试加锁，成功返回1，失败返回0
int mutex_is_locked(struct mutex *lock)//判断是否加锁，是返回1，否返回0</code></pre>
<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h3><pre><code class="c">module_init(xxx_init);
module_exit(xxx_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;author&quot;);
//printk
#define KERN_EMERG KERN_SOH &quot;0&quot; /* 紧急事件，一般是内核崩溃 */
#define KERN_ALERT KERN_SOH &quot;1&quot; /* 必须立即采取行动 */
#define KERN_CRIT KERN_SOH &quot;2&quot; /* 临界条件，比如严重的软件或硬件错误*/
#define KERN_ERR KERN_SOH &quot;3&quot; /* 错误状态，一般设备驱动程序中使用KERN_ERR 报告硬件错误 */
#define KERN_WARNING KERN_SOH &quot;4&quot; /* 警告信息，不会对系统造成严重影响 */
#define KERN_NOTICE KERN_SOH &quot;5&quot; /* 有必要进行提示的一些信息 */
#define KERN_INFO KERN_SOH &quot;6&quot; /* 提示性的信息 */
#define KERN_DEBUG KERN_SOH &quot;7&quot; /* 调试信息 */</code></pre>
<h3 id="注册与注销"><a href="#注册与注销" class="headerlink" title="注册与注销"></a>注册与注销</h3><p>老方法，不推荐：</p>
<pre><code class="c">//注册字符设备（浪费设备号）
static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops);
//注销字符设备
static inline void unregister_chrdev(unsigned int major, const char *name);</code></pre>
<ul>
<li>name：设备名字，指向一串字符串</li>
</ul>
<p>新方法，推荐：</p>
<pre><code class="c">/*注册（方法一，自己确定设备号）*/
int register_chrdev_region(dev_t from, unsigned count, const char *name);//详见设备号API
cdev.owner = THIS_MODULE;
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
int cdev_add(struct cdev *p, dev_t dev, unsigned count);
/*注册（方法二，系统分配设备号）*/
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);//详见设备号API
cdev.owner = THIS_MODULE;
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
int cdev_add(struct cdev *p, dev_t dev, unsigned count);
/*注销*/
void cdev_del(struct cdev *p);
void unregister_chrdev_region(dev_t from, unsigned count);</code></pre>
<h3 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h3><p>类相关：</p>
<pre><code class="c">class_create(owner, name)//创建类 owner一般为THIS_MODULE
void class_destroy(struct class *cls);//卸载类</code></pre>
<p>设备相关：</p>
<pre><code class="c">struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);//创建设备 parent=NULL drvdata=NULL
void device_destroy(struct class *class, dev_t devt)//卸载设备</code></pre>
<h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>相关宏：</p>
<pre><code class="c">MAJOR(dev)//dev_t -&gt; 主设备号
MINOR(dev)//dev_t -&gt; 次设备号
MKDEV(ma,mi)//主设备号+次设备号 -&gt; dev_t</code></pre>
<p>动态分配设备号：</p>
<p>系统分配设备号+自动注册设备号</p>
<pre><code class="c">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</code></pre>
<ul>
<li>dev：存放起始设备编号的指针，当注册成功，*dev就会等于分配到的起始设备编号，可以通过<code>MAJOR()</code>和<code>MINNOR()</code>宏来提取主次设备号</li>
<li>baseminor：次设备号基地址，也就是起始次设备号</li>
<li>count：要申请的数量，一般都是一个</li>
<li>name：字符设备名称</li>
<li>返回值小于0,表示注册失败</li>
</ul>
<p>注册设备号：</p>
<p>手动确定设备号+手动注册设备号</p>
<pre><code class="c">int register_chrdev_region(dev_t from, unsigned count, const char *name)</code></pre>
<ul>
<li>from：要申请的起始设备号，也就是<strong>给定的设备号</strong></li>
<li>count：要申请的数量，一般都是一个</li>
<li>name：设备名字</li>
<li>当返回值小于0,表示注册失败</li>
</ul>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>内核空间–&gt;用户空间</p>
<pre><code class="c">static inline long copy_to_user(void __user *to, const void *from, unsigned long n)</code></pre>
<ul>
<li>to：用户空间指针</li>
<li>from：内核空间指针</li>
<li>n：从内核空间向用户空间拷贝数据的字节数</li>
<li>成功返回0，失败返回失败数目</li>
</ul>
<p>用户空间–&gt;内核空间</p>
<pre><code class="c">static inline long copy_from_user(void *to, const void __user * from, unsigned long n)</code></pre>
<ul>
<li>to：内核空间指针</li>
<li>from：用户空间指针</li>
<li>n：从用户空间向内核空间拷贝数据的字节数</li>
<li>成功返回0，失败返回失败数目</li>
</ul>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><pre><code class="c">#define ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE)</code></pre>
<ul>
<li>phys_addr：要映射的物理起始地址。</li>
<li>size：要映射的内存空间大小。</li>
</ul>
<pre><code class="c">void iounmap (volatile void __iomem *addr)</code></pre>
<p>对映射后的内存进行读写操作的函数：</p>
<pre><code class="c">//读
u8 readb(const volatile void __iomem *addr)
u16 readw(const volatile void __iomem *addr)
u32 readl(const volatile void __iomem *addr)
//写
void writeb(u8 value, volatile void __iomem *addr)
void writew(u16 value, volatile void __iomem *addr)
void writel(u32 value, volatile void __iomem *addr)</code></pre>
<h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><pre><code class="bash">#查看设备号
cat /proc/devices
#创建设备节点
mknod /dev/xxx c 主设备号 次设备号
#查看设备树节点
ls /proc/device-tree
ls /sys/firmware/devicetree/base
#查看platform相关
ls /sys/bus/platform/devices # 设备
ls /sys/bus/platform/drivers # 驱动
#查看misc相关
ls /sys/class/misc # 驱动
#驱动相关
depmod
modprobe xxx.ko
insmod xxx.ko
lsmod
rmmod xxx.ko</code></pre>
<h2 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h2><pre><code class="c">extern u64 __jiffy_data jiffies_64;
extern unsigned long volatile __jiffy_data jiffies;</code></pre>
<p>相关变量：</p>
<ul>
<li><code>HZ</code>：宏，就是CONFIG_HZ，系统频率，通过menuconfig配置，默认100</li>
<li><code>jiffies</code>、<code>jiffies_64</code>：系统运行的<strong>节拍数</strong>，由宏<code>HZ</code>确定，默认10ms累加一次</li>
<li><code>jiffies/HZ</code>：系统运行时间（s）</li>
</ul>
<p>时间先后函数：</p>
<pre><code class="c">//unkown 通常为 jiffies，known 通常是需要对比的值
time_after(unkown, known)//unkown 时间上超过 known 则返回真
time_before(unkown, known)//unkown 时间上滞后 known 则返回真
time_after_eq(unkown, known)//unkown 时间上超过或等于 known 则返回真
time_before_eq(unkown, known)//unkown 时间上滞后或等于 known 则返回真</code></pre>
<p>时间转换函数：</p>
<pre><code class="c">int jiffies_to_msecs(const unsigned long j)//jiffies类型j --&gt; ms
int jiffies_to_usecs(const unsigned long j)//jiffies类型j --&gt; us
u64 jiffies_to_nsecs(const unsigned long j)//jiffies类型j --&gt; ns
long msecs_to_jiffies(const unsigned int m)//ms --&gt; jiffies
long usecs_to_jiffies(const unsigned int u)//us --&gt; jiffies
unsigned long nsecs_to_jiffies(u64 n)//ns --&gt; jiffies</code></pre>
<p>短延时函数：</p>
<pre><code class="c">void ndelay(unsigned long nsecs)
void udelay(unsigned long usecs)
void mdelay(unsigned long mseces)</code></pre>
<p>定时器类型：</p>
<pre><code class="c">struct timer_list {
    struct list_head entry;
    unsigned long expires; /* 定时器超时时间，单位是节拍数 */
    struct tvec_base *base;
    void (*function)(unsigned long); /* 定时处理函数 */
    unsigned long data; /* 要传递给 function 函数的参数 */
    int slack;
};</code></pre>
<p>定时器函数：</p>
<pre><code class="c">void init_timer(struct timer_list *timer);//初始化
void add_timer(struct timer_list *timer);//注册并使能
int del_timer(struct timer_list * timer);//删除（需等待 定时处理函数 退出）
int del_timer_sync(struct timer_list *timer);//删除（需等待其他处理器使用完定时器，中断上下文勿用）
int mod_timer(struct timer_list *timer, unsigned long expires);//修改定时值（会使能定时器）</code></pre>
<ul>
<li>返回值： 0，定时器未被使能； 1，定时器已经使能</li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h3><h4 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h4><pre><code class="c">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)</code></pre>
<ul>
<li>irq：要申请中断的中断号。</li>
<li>handler：中断处理函数，当中断发生以后就会执行此中断处理函数。</li>
<li>flags：中断标志，可以在文件<code>include/linux/interrupt.h</code>里面查看所有的中断标志。</li>
</ul>
<blockquote>
<p>常用的中断标志：</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IRQF_SHARED</td>
<td align="center">多个设备共享一个中断线，共享的所有中断都必须指定此标志。 如果使用共享中断的话，request_irq函数的 dev 参数是唯一区分他们的标志</td>
</tr>
<tr>
<td align="center">IRQF_ONESHOT</td>
<td align="center">单次中断，中断执行一次就结束</td>
</tr>
<tr>
<td align="center">IRQF_TRIGGER_NONE</td>
<td align="center">无触发</td>
</tr>
<tr>
<td align="center">IRQF_TRIGGER_RISING</td>
<td align="center">上升沿触发</td>
</tr>
<tr>
<td align="center">IRQF_TRIGGER_FALLING</td>
<td align="center">下降沿触发</td>
</tr>
<tr>
<td align="center">IRQF_TRIGGER_HIGH</td>
<td align="center">高电平触发</td>
</tr>
<tr>
<td align="center">IRQF_TRIGGER_LOW</td>
<td align="center">低电平触发</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>name：中断名字，设置以后可以在<code>/proc/interrupts</code>文件中看到对应的中断名字</li>
<li>dev： 如果将 flags 设置为 IRQF_SHARED 的话， dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体， dev 会传递给中断处理函数 irq_handler_t 的第二个参数</li>
<li>返回值： 0 中断申请成功；其他负值：中断申请失败；-EBUSY：中断已经被申请了</li>
</ul>
<p>对于一种不太重要而又比较耗时的中断，可以使用以下函数进行申请：</p>
<pre><code class="c">int devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)</code></pre>
<ul>
<li>该函数会使得中断线程化（中断使用下半部虽然可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比较耗时的下半部与进程进行公平竞争）</li>
<li>带<code>devm_</code>前缀表明申请到的资源可以由系统自动释放，无需手动处理</li>
<li>注意：并不是所有的中断都可以被线程化。该函数有利有弊，具体是否使用需要根据实际情况来衡量（触摸中断一般会用）</li>
</ul>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><pre><code class="c">void free_irq(unsigned int irq, void *dev)</code></pre>
<ul>
<li>irq： 要释放的中断</li>
<li>dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉</li>
</ul>
<h4 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h4><p>格式：</p>
<pre><code class="c">irqreturn_t (*irq_handler_t) (int, void *)</code></pre>
<p>返回值：</p>
<p>一般为<code>return IRQ_RETVAL(IRQ_HANDLED)</code></p>
<pre><code class="c">enum irqreturn {
    IRQ_NONE = (0 &lt;&lt; 0),
    IRQ_HANDLED = (1 &lt;&lt; 0),
    IRQ_WAKE_THREAD = (1 &lt;&lt; 1),
};
typedef enum irqreturn irqreturn_t;</code></pre>
<h4 id="使能与禁止"><a href="#使能与禁止" class="headerlink" title="使能与禁止"></a>使能与禁止</h4><pre><code class="c">void enable_irq(unsigned int irq)
void disable_irq(unsigned int irq)//需等待 正在执行的中断处理函数执行完
void disable_irq_nosync(unsigned int irq)//无需等待 正在执行的中断处理函数执行完
//不推荐
local_irq_disable()//关闭全局中断
local_irq_enable()//使能全局中断
//推荐
local_irq_save(flags)//保存中断标志到flags并 关闭全局中断
local_irq_restore(flags)//根据flags设置中断标志并 使能全局中断</code></pre>
<h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><p>推荐使用<code>tasklet</code>实现</p>
<h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>定义：</p>
<pre><code class="c">struct softirq_action
{
    void (*action)(struct softirq_action *);
};</code></pre>
<p>系统定义的10个软中断：</p>
<p>多核处理器中，各个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断，但是所执行的软中断服务函数却是相同的：</p>
<pre><code class="c">enum
{
    HI_SOFTIRQ=0,//高优先级软中断
    TIMER_SOFTIRQ,//定时器软中断
    NET_TX_SOFTIRQ,//网络数据发送软中断
    NET_RX_SOFTIRQ,//网络数据接收软中断
    BLOCK_SOFTIRQ,
    BLOCK_IOPOLL_SOFTIRQ,
    TASKLET_SOFTIRQ,//tasklet 软中断
    SCHED_SOFTIRQ,//调度软中断
    HRTIMER_SOFTIRQ,//高精度定时器软中断
    RCU_SOFTIRQ,//RCU 软中断
    NR_SOFTIRQS
};

static struct softirq_action softirq_vec[NR_SOFTIRQS];</code></pre>
<p>注册软中断：</p>
<p>软中断必须在编译的时候静态注册。Linux内核默认会在软中断初始化函数<code>softirq_init</code>中打开<code>TASKLET_SOFTIRQ</code>和<code>HI_SOFTIRQ</code>软中断</p>
<pre><code class="c">void open_softirq(int nr, void (*action)(struct softirq_action *))</code></pre>
<ul>
<li>nr：要开启的软中断，在上述<code>enum</code>中选择一个</li>
<li>action：软中断对应的处理函数</li>
</ul>
<p>触发软中断：</p>
<pre><code class="c">void raise_softirq(unsigned int nr)</code></pre>
<h4 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h4><p>定义：</p>
<pre><code class="c">struct tasklet_struct
{
    struct tasklet_struct *next; /* 下一个 tasklet */
    unsigned long state; /* tasklet 状态 */
    atomic_t count; /* 计数器，记录对 tasklet 的引用数 */
    void (*func)(unsigned long); /* tasklet 执行的函数，用户定义，相当于中断处理函数 */
    unsigned long data; /* 函数 func 的参数 */
};</code></pre>
<p>初始化：</p>
<pre><code class="c">void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);//初始化
DECLARE_TASKLET(name, func, data)//宏，定义并初始化</code></pre>
<ul>
<li>func：tasklet 的处理函数</li>
<li>data：要传递给 func 函数的参数</li>
</ul>
<p>调度函数：</p>
<p>一般在中断的上半部中调用</p>
<pre><code class="c">void tasklet_schedule(struct tasklet_struct *t)</code></pre>
<ul>
<li>t：要调度的 tasklet，也就是 <code>DECLARE_TASKLET</code> 宏里面的 <code>name</code></li>
</ul>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列在进程上下文执行，即，将要推后的工作交给一个内核线程去执行，因此工作队列允许<strong>睡眠</strong>或<strong>重新调度</strong>。</p>
<p>如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet</p>
<p>定义：</p>
<p>工作–&gt;工作队列–&gt;工作者线程</p>
<pre><code class="c">//工作（重点关注）：
struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func; /* 工作队列处理函数 */
};
//工作队列：
struct workqueue_struct {
    struct list_head pwqs;
    struct list_head list;
    struct mutex mutex;
    int work_color;
    int flush_color;
    atomic_t nr_pwqs_to_flush;
    struct wq_flusher *first_flusher;
    struct list_head flusher_queue;
    struct list_head flusher_overflow;
    struct list_head maydays;
    struct worker *rescuer;
    int nr_drainers;
    int saved_max_active;
    struct workqueue_attrs *unbound_attrs;
    struct pool_workqueue *dfl_pwq;
    char name[WQ_NAME_LEN];
    struct rcu_head rcu;
    unsigned int flags ____cacheline_aligned;
    struct pool_workqueue __percpu *cpu_pwqs;
    struct pool_workqueue __rcu *numa_pwq_tbl[];
};
//工作者线程
struct worker {
    union {
        struct list_head entry;
        struct hlist_node hentry;
    };
    struct work_struct *current_work;
    work_func_t current_func;
    struct pool_workqueue *current_pwq;
    bool desc_valid;
    struct list_head scheduled;
    struct task_struct *task;
    struct worker_pool *pool;
    struct list_head node;
    unsigned long last_active;
    unsigned int flags;
    int id;
    char desc[WORKER_DESC_LEN];
    struct workqueue_struct *rescue_wq;
};</code></pre>
<p>初始化：</p>
<pre><code class="c">#define INIT_WORK(_work, _func)//初始化，需要自己创建work_struct
#define DECLARE_WORK(n, f)//创建和初始化，无需自己创建work_struct</code></pre>
<p>调度：</p>
<p>一般在中断的上半部中调用</p>
<pre><code class="c">bool schedule_work(struct work_struct *work)</code></pre>
<ul>
<li>work： 要调度的工作</li>
<li>返回值： 0 成功，其他值 失败</li>
</ul>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞：访问资源时，如果资源不可用，将会<strong>挂起线程</strong>，直到资源可用再唤醒。open函数中大部分flag均为阻塞访问</p>
<p>非阻塞：访问资源时，如果资源不可用，将会<strong>直接返回错误码</strong>。open函数中flag参数<code>O_NONBLOCK</code>为非阻塞访问</p>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>一般用于在<strong>中断</strong>中唤醒<strong>阻塞</strong>操作而引起的线程挂起</p>
<h4 id="等待队列头"><a href="#等待队列头" class="headerlink" title="等待队列头"></a>等待队列头</h4><p>等待队列的头部</p>
<p>定义：</p>
<pre><code class="c">struct __wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;</code></pre>
<p>初始化：</p>
<pre><code class="c">void init_waitqueue_head(wait_queue_head_t *q)//仅初始化
DECLARE_WAIT_QUEUE_HEAD//宏，定义+初始化</code></pre>
<h4 id="等待队列项"><a href="#等待队列项" class="headerlink" title="等待队列项"></a>等待队列项</h4><p>每个访问设备的进程都需要创建一个队列项，当设备不可用的时候需要将这些进程对应的等待队列项添加到等待队列里面</p>
<p>定义：</p>
<pre><code class="c">struct __wait_queue {
    unsigned int flags;
    void *private;
    wait_queue_func_t func;
    struct list_head task_list;
};
typedef struct __wait_queue wait_queue_t;</code></pre>
<p>初始化：</p>
<pre><code class="c">DECLARE_WAITQUEUE(name, tsk)//宏，定义并初始化</code></pre>
<ul>
<li>name：等待队列项的名字</li>
<li>tsk：这个等待队列项属于哪个任务(进程)，一般设置为<code>current</code>（全局变量，表示当前进程）</li>
</ul>
<h4 id="添加-移除等待队列"><a href="#添加-移除等待队列" class="headerlink" title="添加/移除等待队列"></a>添加/移除等待队列</h4><p>当设备不可用的时候需要将该进程对应的等待队列项添加到等待队列里面</p>
<pre><code class="c">void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)//添加
void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)//删除</code></pre>
<ul>
<li>q： 等待队列项要加入的等待队列头</li>
<li>wait：要加入/删除的等待队列项</li>
</ul>
<h4 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程</p>
<pre><code class="c">void wake_up(wait_queue_head_t *q)//唤醒队列中的所有进程（包括TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE状态）
void wake_up_interruptible(wait_queue_head_t *q)//唤醒队列中的所有进程（仅唤醒TASK_INTERRUPTIBLE状态进程）</code></pre>
<h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><p>当事件满足以后能够自动唤醒等待队列中的进程</p>
<pre><code class="c">wait_event(wq, condition)//若condition为真，则唤醒等待队列，否则一直阻塞。（会将进程设置为TASK_UNINTERRUPTIBLE状态）
wait_event_timeout(wq, condition, timeout)//与wait_event类似，timeout为超时时间，单位为jiffies。返回0：超时时间到，且condition为假；返回1：condition为真
wait_event_interruptible(wq, condition)//与wait_event类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断
wait_event_interruptible_timeout(wq, condition, timeout)//与wait_event_timeout类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断</code></pre>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>一般用于<strong>非阻塞</strong>操作</p>
<p><code>poll</code>、 <code>epoll</code> 和 <code>select</code> 用于处理轮询。应用程序通过 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 函数的时候设备驱动程序中的 <code>poll</code> 函数就会执行</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>单线程中 select 函数能够监视的文件描述符数量一般最大为1024，可以修改该数量但会降低效率</p>
<pre><code class="c">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</code></pre>
<ul>
<li>nfds： 要操作的文件描述符个数</li>
<li>readfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>读</u>变化，所指定集合中有一个文件可以<u>读取</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>读</u>变化</li>
<li>writefds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>写</u>变化，所指定集合中有一个文件可以<u>写入</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>写</u>变化</li>
<li>exceptfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>异常</u>变化，所指定集合中有一个文件<u>异常</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>异常</u>变化</li>
</ul>
<blockquote>
<p>fd_set变量定义相关宏：</p>
<pre><code class="c">void FD_ZERO(fd_set *set)//将 fd_set 变量的所有位都清零
void FD_SET(int fd, fd_set *set)//将 fd_set 变量的某个位置 1（向 fd_set 添加一个文件描述符）， fd：要加入的文件描述符
void FD_CLR(int fd, fd_set *set)//将 fd_set 变量的某个位清零（向 fd_set 删除一个文件描述符）， fd：要删除的文件描述符
int FD_ISSET(int fd, fd_set *set)//测试 fd_set 的某个位是否置 1（判断某个文件是否可以进行操作）， fd：要判断的文件描述符</code></pre>
</blockquote>
<ul>
<li><p>timeout：超时时间，设为 NULL 表示无限期等待。timeval结构体类型</p>
<pre><code class="c">  struct timeval {
   long tv_sec; /* 秒 */
   long tv_usec; /* 微秒 */
  };</code></pre>
</li>
<li><p>返回值： 0，超时发生，没有任何文件描述符可以进行操作； -1，发生错误；其他值，可以进行操作的文件描述符个数</p>
</li>
</ul>
<blockquote>
<p>select使用示例：</p>
<pre><code class="c">void main(void)
{
    int ret, fd; /* 要监视的文件描述符 */
    fd_set readfds; /* 读操作文件描述符集 */
    struct timeval timeout; /* 超时结构体 */
    fd = open(&quot;dev_xxx&quot;, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */
    FD_ZERO(&amp;readfds); /* 清除 readfds */
    FD_SET(fd, &amp;readfds); /* 将 fd 添加到 readfds 里面 */
    /* 构造超时时间 */
    timeout.tv_sec = 0;
    timeout.tv_usec = 500000; /* 500ms */
    ret = select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);
    switch (ret) {
        case 0: /* 超时 */
            ......
            break;
        case -1: /* 错误 */
            ......
            break;
        default: /* 可以读取数据 */
            if(FD_ISSET(fd, &amp;readfds)) { /* 判断是否为 fd 文件描述符 */
                /* 使用 read 函数读取数据 */
            }
            break;
    }
}</code></pre>
</blockquote>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制</p>
<pre><code class="c">int poll(struct pollfd *fds, nfds_t nfds, int timeout)</code></pre>
<ul>
<li><p>fds： 要监视的文件描述符集合以及要监视的事件，为结构体<code>pollfd</code>数组类型，<code>pollfd</code>类型定义：</p>
<pre><code class="c">  struct pollfd {
      int fd; /* 文件描述符 */
      short events; /* 请求的事件 */
      short revents; /* 返回的事件 */
  };</code></pre>
<ul>
<li><p>fd：要监视的文件描述符，如果 fd 无效则 events 监视事件也无效，并且 revents 返回 0</p>
</li>
<li><p>events：要监视的事件，类型如下：</p>
<pre><code class="c">  POLLIN 有数据可以读取
  POLLPRI 有紧急的数据需要读取
  POLLOUT 可以写数据
  POLLERR 指定的文件描述符发生错误
  POLLHUP 指定的文件描述符挂起
  POLLNVAL 无效的请求
  POLLRDNORM 等同于POLLIN</code></pre>
</li>
<li><p>revents：返回参数，由 Linux 内核设置具体的返回事件</p>
</li>
</ul>
</li>
<li><p>nfds：poll 函数要监视的文件描述符数量</p>
</li>
<li><p>timeout：超时时间，单位为 ms</p>
</li>
<li><p>返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，即发生事件或错误的文件描述符数量； 0，超时； -1，发生错误，并设置相应的错误码</p>
</li>
</ul>
<blockquote>
<p>poll使用示例：</p>
<pre><code class="c">void main(void)
{
    int ret;
    int fd; /* 要监视的文件描述符 */
    struct pollfd fds;
    fd = open(filename, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */
    /* 构造结构体 */
    fds.fd = fd;
    fds.events = POLLIN; /* 监视数据是否可以读取 */
    ret = poll(&amp;fds, 1, 500); /* 轮询文件是否可操作，超时 500ms */
    if (ret) { /* 数据有效 */
        ......
        /* 读取数据 */
        ......
    } else if (ret == 0) { /* 超时 */
        ......
    } else if (ret &lt; 0) { /* 错误 */
        ......
    }
}</code></pre>
</blockquote>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>selcet 和 poll 函数会随着所监听的 fd 数量的增加，而导致效率的降低，且遍历所有的描述符比较浪费时间。epoll 专为处理大并发而准备，一般用于网络编程中。  其相关函数如下：</p>
<p>创建 epoll 句柄：</p>
<pre><code class="c">int epoll_create(int size)</code></pre>
<ul>
<li>size：Linux2.6.8 后此参数已无意义，大于 0 即可</li>
<li>返回值： epoll 句柄，如果为-1 的话表示创建失败</li>
</ul>
<p>向 epoll 句柄中添加要监视的文件描述符以及监视的事件：</p>
<pre><code class="c">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></pre>
<ul>
<li><p>epfd：epoll 句柄（即epoll_create的返回值）</p>
</li>
<li><p>op：对 epfd 的操作，可以设置为：</p>
<pre><code class="c">  EPOLL_CTL_ADD 向epfd添加文件参数fd表示的描述符
  EPOLL_CTL_MOD 修改参数fd的event事件
  EPOLL_CTL_DEL 从epfd中删除fd描述符</code></pre>
</li>
<li><p>fd：要监视的文件描述符</p>
</li>
<li><p>event：要监视的事件类型，epoll_event结构体指针类型：</p>
<pre><code class="c">  struct epoll_event {
      uint32_t events; /* epoll 事件 */
      epoll_data_t data; /* 用户数据 */
  };</code></pre>
<ul>
<li><p>events：要监视的事件：</p>
<pre><code class="c">  EPOLLIN 有数据可以读取
  EPOLLPRI 有紧急的数据需要读取
  EPOLLOUT 可以写数据
  EPOLLERR 指定的文件描述符发生错误
  EPOLLHUP 指定的文件描述符挂起
  EPOLLET 设置epoll为边沿触发（默认为水平触发）
  EPOLLONESHOT 一次性监视（当监视完成以后需要再次监视某个fd，就需要将fd重新添加到epoll里面）</code></pre>
</li>
</ul>
</li>
<li><p>返回值： 0，成功； -1，失败，并设置相应的错误码</p>
</li>
</ul>
<p>等待事件发生：</p>
<pre><code class="c">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></pre>
<ul>
<li>epfd：epoll 句柄</li>
<li>events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件</li>
<li>maxevents：events 数组大小（必须大于 0）</li>
<li>timeout：超时时间，单位为 ms</li>
<li>返回值： 0，超时； -1，错误；其他值，准备就绪的文件描述符数量</li>
</ul>
<h4 id="驱动中的poll函数"><a href="#驱动中的poll函数" class="headerlink" title="驱动中的poll函数"></a>驱动中的poll函数</h4><p>函数原型：</p>
<pre><code class="c">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</code></pre>
<ul>
<li><p>filp： 要打开的设备文件(文件描述符)</p>
</li>
<li><p>wait： 结构体 poll_table_struct 类型指针， 由应用程序传递进来的。一般将此参数传递给<br>  poll_wait 函数</p>
</li>
<li><p>返回值：向应用程序返回设备或者资源状态，可以返回的资源状态如下：</p>
<pre><code class="c">  POLLIN 有数据可以读取
  POLLPRI 有紧急的数据需要读取
  POLLOUT 可以写数据
  POLLERR 指定的文件描述符发生错误
  POLLHUP 指定的文件描述符挂起
  POLLNVAL 无效的请求
  POLLRDNORM 等同于POLLIN，普通数据可读</code></pre>
</li>
</ul>
<p>添加到poll_table：</p>
<p>非阻塞函数，不会引起阻塞，只是将应用程序添加到 poll_table 中</p>
<pre><code class="c">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</code></pre>
<ul>
<li>wait_address：要添加到 poll_table 中的等待队列头</li>
<li>p：poll_table，就是file_operations 中 poll 函数的 wait 参数</li>
</ul>
<blockquote>
<p>驱动通用模板：</p>
<pre><code class="c">struct xxxx_dev {
    ......
    struct wait_queue_head_t r_wait; /* 等待队列头 */
};

unsigned int xxx_poll(struct file *filp, struct poll_table_struct *wait)
{
    unsigned int mask = 0;
    struct xxxx_dev *dev = (struct xxxx_dev *)filp-&gt;private_data;

    poll_wait(filp, &amp;dev-&gt;r_wait, wait);

    if(......) { /* 相关条件满足 */
        mask = POLLIN | POLLRDNORM; /* 返回 PLLIN */
    }
    return mask;
}</code></pre>
</blockquote>
<h2 id="异步通知（信号）"><a href="#异步通知（信号）" class="headerlink" title="异步通知（信号）"></a>异步通知（信号）</h2><p>Linux中的信号宏：</p>
<pre><code class="c">#define SIGHUP         1 /* 终端挂起或控制进程终止 */
#define SIGINT         2 /* 终端中断(Ctrl+C 组合键) */
#define SIGQUIT     3 /* 终端退出(Ctrl+\组合键) */
#define SIGILL         4 /* 非法指令 */
#define SIGTRAP     5 /* debug 使用，有断点指令产生 */
#define SIGABRT     6 /* 由 abort(3)发出的退出指令 */
#define SIGIOT         6 /* IOT 指令 */
#define SIGBUS         7 /* 总线错误 */
#define SIGFPE         8 /* 浮点运算错误 */
#define SIGKILL     9 /* 杀死、终止进程 */
#define SIGUSR1     10 /* 用户自定义信号 1 */
#define SIGSEGV     11 /* 段违例(无效的内存段) */
#define SIGUSR2     12 /* 用户自定义信号 2 */
#define SIGPIPE     13 /* 向非读管道写入数据 */
#define SIGALRM     14 /* 闹钟 */
#define SIGTERM     15 /* 软件终止 */
#define SIGSTKFLT     16 /* 栈异常 */
#define SIGCHLD     17 /* 子进程结束 */
#define SIGCONT     18 /* 进程继续 */
#define SIGSTOP     19 /* 停止进程的执行，只是暂停 */
#define SIGTSTP     20 /* 停止进程的运行(Ctrl+Z 组合键) */
#define SIGTTIN     21 /* 后台进程需要从终端读取数据 */
#define SIGTTOU     22 /* 后台进程需要向终端写数据 */
#define SIGURG         23 /* 有&quot;紧急&quot;数据 */
#define SIGXCPU     24 /* 超过 CPU 资源限制 */
#define SIGXFSZ     25 /* 文件大小超额 */
#define SIGVTALRM     26 /* 虚拟时钟信号 */
#define SIGPROF     27 /* 时钟信号描述 */
#define SIGWINCH     28 /* 窗口大小改变 */
#define SIGIO         29 /* 可以进行输入/输出操作 */
#define SIGPOLL     SIGIO
/* #define SIGLOS 29 */
#define SIGPWR         30 /* 断点重启 */
#define SIGSYS         31 /* 非法的系统调用 */
#define SIGUNUSED     31 /* 未使用信号 */</code></pre>
<p>上述信号中，除了 <code>SIGKILL</code>(9)和 <code>SIGSTOP</code>(19)这两个信号不能被忽略外，其他的信号都可以忽略</p>
<h3 id="应用程序API"><a href="#应用程序API" class="headerlink" title="应用程序API"></a>应用程序API</h3><p>指定信号的处理函数：</p>
<pre><code class="c">sighandler_t signal(int signum, sighandler_t handler)</code></pre>
<ul>
<li><p>signum：要设置处理函数的信号</p>
</li>
<li><p>handler： 信号的处理函数，函数原型：</p>
<pre><code class="c">  typedef void (*sighandler_t)(int)</code></pre>
</li>
<li><p>返回值： 设置成功返回信号的前一个处理函数，设置失败返回 SIG_ERR</p>
</li>
</ul>
<blockquote>
<p>应用程序的一般模板：</p>
<pre><code class="c">fd = open(filename, O_RDWR);
if (fd &lt; 0) {
    printf(&quot;Can&#39;t open file %s\r\n&quot;, filename);
    return -1;
}

/* 设置信号 SIGIO 的处理函数 */
signal(SIGIO, sigio_signal_func);

fcntl(fd, F_SETOWN, getpid()); /* 将当前进程的进程号告诉给内核 */
flags = fcntl(fd, F_GETFD); /* 获取当前的进程状态 */
fcntl(fd, F_SETFL, flags | FASYNC);/* 设置进程状态为 FASYNC 启用异步通知功能（此时会调用驱动中的fasync函数） */

while(1) {
    sleep(2);
}

close(fd);
return 0;</code></pre>
</blockquote>
<h3 id="驱动程序API"><a href="#驱动程序API" class="headerlink" title="驱动程序API"></a>驱动程序API</h3><p>异步相关结构体：</p>
<pre><code class="c">struct fasync_struct {
    spinlock_t fa_lock;
    int magic;
    int fa_fd;
    struct fasync_struct *fa_next;
    struct file *fa_file;
    struct rcu_head fa_rcu;
};</code></pre>
<p>向应用程序发送中断信号：</p>
<pre><code class="c">void kill_fasync(struct fasync_struct **fp, int sig, int band)</code></pre>
<ul>
<li>fp：要操作的 fasync_struct 结构体</li>
<li>sig： 要发送的信号</li>
<li>band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT</li>
<li>返回值： 无</li>
</ul>
<p>file_operations操作集中异步接口函数：</p>
<p>应用程序通过<code>fcntl(fd, F_SETFL, flags | FASYNC)</code>改变fasync标记的时候，该函数就会执行</p>
<pre><code class="c">int (*fasync) (int fd, struct file *filp, int on)</code></pre>
<p>初始化 fasync_struct 结构体：</p>
<pre><code class="c">int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)</code></pre>
<ul>
<li>前三个参数与<code>fasync</code>函数中参数一致</li>
<li>fapp：要初始化的 fasync_struct 结构体指针变量</li>
</ul>
<blockquote>
<p>驱动一般模板：</p>
<pre><code class="c">struct xxx_dev {
    ......
    struct fasync_struct *async_queue; /* 异步相关结构体 */
};

static int xxx_fasync(int fd, struct file *filp, int on)
{
    struct xxx_dev *dev = (xxx_dev)filp-&gt;private_data;

    if (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)//直接调用该函数即可，不用干其他事
        return -EIO;
    return 0;
}

static struct file_operations xxx_ops = {
    ......
    .fasync = xxx_fasync,
    .release = xxx_release,
    ......
};

static int xxx_release(struct inode *inode, struct file *filp)
{
    return xxx_fasync(-1, filp, 0); /* 删除异步通知 */
}</code></pre>
</blockquote>
<h2 id="常用框架API"><a href="#常用框架API" class="headerlink" title="常用框架API"></a>常用框架API</h2><h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>platform设备相关：</p>
<pre><code class="c">void platform_device_unregister(struct platform_device *pdev)//卸载platform设备
int platform_device_register(struct platform_device *pdev)//注册platform设备</code></pre>
<p>platform驱动相关：</p>
<pre><code class="c">void platform_driver_unregister(struct platform_driver *drv)//卸载platform驱动
int platform_driver_register (struct platform_driver *driver)//注册platform驱动</code></pre>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。 MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动</p>
<p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。MISC 设备会自动创建 cdev</p>
<pre><code class="c">int misc_register(struct miscdevice * misc)//注册MISC驱动
int misc_deregister(struct miscdevice *misc)//销毁MISC驱动</code></pre>
<h3 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h3><h4 id="初始化及卸载"><a href="#初始化及卸载" class="headerlink" title="初始化及卸载"></a>初始化及卸载</h4><p>申请及释放：</p>
<pre><code class="c">struct input_dev *input_allocate_device(void)//申请input_dev
void input_free_device(struct input_dev *dev)//释放input_dev</code></pre>
<p>注册及注销：</p>
<pre><code class="c">int input_register_device(struct input_dev *dev)//注册
void input_unregister_device(struct input_dev *dev)//注销</code></pre>
<p>修改input_dev：</p>
<pre><code class="c">struct input_dev *inputdev;
inputdev = input_allocate_device(); /* 申请 input_dev */
inputdev-&gt;name = &quot;test_inputdev&quot;; /* 设置 input_dev 名字 */

/*********第一种设置事件和事件值的方法***********/
__set_bit(EV_KEY, inputdev-&gt;evbit); /* 设置产生按键事件 */
__set_bit(EV_REP, inputdev-&gt;evbit); /* 重复事件 */
__set_bit(KEY_0, inputdev-&gt;keybit); /*设置产生哪些按键值 */
/************************************************/

/*********第二种设置事件和事件值的方法***********/
keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);
/************************************************/

/*********第三种设置事件和事件值的方法***********/
keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);
/************************************************/

/* 注册 input_dev */
input_register_device(inputdev);</code></pre>
<h4 id="上报数据"><a href="#上报数据" class="headerlink" title="上报数据"></a>上报数据</h4><p>上报指定的事件以对应值：</p>
<pre><code class="c">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</code></pre>
<ul>
<li>dev：需要上报的 input_dev</li>
<li>type：上报的事件类型，比如 EV_KEY</li>
<li>code：事件码，即注册的按键值，比如 KEY_0、 KEY_1 等等</li>
<li>value：事件值，比如 1 表示按键按下， 0 表示按键松开</li>
</ul>
<p>专用上报函数（本质是调用input_event）：</p>
<pre><code class="c">void input_report_key(struct input_dev *dev, unsigned int code, int value)//上报按键
void input_report_rel(struct input_dev *dev, unsigned int code, int value)
void input_report_abs(struct input_dev *dev, unsigned int code, int value)
void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)
void input_report_switch(struct input_dev *dev, unsigned int code, int value)
void input_mt_sync(struct input_dev *dev)</code></pre>
<p>同步事件：</p>
<pre><code class="c">void input_sync(struct input_dev *dev)</code></pre>
<h4 id="应用层相关"><a href="#应用层相关" class="headerlink" title="应用层相关"></a>应用层相关</h4><p>应用层通过获得 <code>input_event</code> 结构体来获取input子系统发送的输入事件</p>
<pre><code class="c">struct input_event {
    struct timeval time;
    __u16 type;
    __u16 code;
    __s32 value;
};</code></pre>
<ul>
<li><p>time：时间，即此事件发生的时间，timeval 结构体类型：</p>
<pre><code class="c">  typedef long __kernel_long_t;
  typedef __kernel_long_t __kernel_time_t;
  typedef __kernel_long_t __kernel_suseconds_t;

  struct timeval {
      __kernel_time_t tv_sec; /* 秒 */
      __kernel_suseconds_t tv_usec; /* 微秒 */
  };</code></pre>
</li>
<li><p>type： 事件类型，比如 EV_KEY 表示此次事件为按键事件</p>
</li>
<li><p>code： 事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如： KEY_0、KEY_1等</p>
</li>
<li><p>value：值，比如 EV_KEY 事件中 value 就是按键值，为 1 表示按键按下，为 0 的话表示按键没有被按下</p>
</li>
</ul>
<p>应用层读取方式：</p>
<pre><code class="c">static struct input_event inputevent;
int err = 0;
err = read(fd, &amp;inputevent, sizeof(inputevent));
if (err &gt; 0) { /* 读取数据成功 */
    switch (inputevent.type) {
        case EV_KEY:
            if (inputevent.code &lt; BTN_MISC) { /* 键盘键值 */
                printf(&quot;key %d %s\r\n&quot;, inputevent.code, inputevent.value ? &quot;press&quot; : &quot;release&quot;);
            } else {
                printf(&quot;button %d %s\r\n&quot;, inputevent.code, inputevent.value ? &quot;press&quot; : &quot;release&quot;);
            }
            break;
            /* 其他类型的事件，自行处理 */
        case EV_REL:
            break;
        case EV_ABS:
            break;
        case EV_MSC:
            break;
        case EV_SW:
            break;
    }
} else {
    printf(&quot;读取数据失败\r\n&quot;);
}</code></pre>
<h4 id="多点触摸"><a href="#多点触摸" class="headerlink" title="多点触摸"></a>多点触摸</h4><ul>
<li>linux内核中讲解多点电容触摸屏协议文档路径：<code>Documentation/input/multitouch-protocol.txt</code></li>
<li>老版本（2.x 版本）的 linux内核不支持多点电容触摸(Multi-touch，简称 MT)</li>
</ul>
<p>MT 协议分为两种类型：</p>
<ul>
<li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)</li>
<li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，一般的多点电容触摸屏 IC 都有此能力</li>
</ul>
<h5 id="Type-A"><a href="#Type-A" class="headerlink" title="Type A"></a>Type A</h5><p>步骤（时序）如下：</p>
<pre><code class="c">ABS_MT_POSITION_X x[0]//上报第一个点的x坐标 input_report_abs()
ABS_MT_POSITION_Y y[0]//上报第一个点的y坐标
SYN_MT_REPORT// input_mt_sync()

ABS_MT_POSITION_X x[1]//上报第二个点的x坐标 input_report_abs()
ABS_MT_POSITION_Y y[1]//上报第二个点的y坐标
SYN_MT_REPORT// input_mt_sync()

SYN_REPORT// input_sync() 该轮数据发送完毕</code></pre>
<p>例子：drivers/input/touchscreen/st1232.c</p>
<h5 id="Type-B"><a href="#Type-B" class="headerlink" title="Type B"></a>Type B</h5><p>步骤（时序）如下：</p>
<pre><code class="c">ABS_MT_SLOT 0// input_mt_slot()
ABS_MT_TRACKING_ID 45// input_mt_report_slot_state()
ABS_MT_POSITION_X x[0]//上报第一个点的x坐标 input_report_abs()
ABS_MT_POSITION_Y y[0]//上报第一个点的y坐标

ABS_MT_SLOT 1// input_mt_slot()
ABS_MT_TRACKING_ID 46// input_mt_report_slot_state()
ABS_MT_POSITION_X x[1]//上报第二个点的x坐标 input_report_abs()
ABS_MT_POSITION_Y y[1]//上报第二个点的y坐标

SYN_REPORT// input_sync() 该轮数据发送完毕</code></pre>
<p>例子：drivers/input/touchscreen/ili210x.c</p>
<p>相关函数：</p>
<p>初始化 MT 的输入 slots（初始化时使用）：</p>
<pre><code class="c">int input_mt_init_slots(struct input_dev *dev, unsigned int num_slots, unsigned int flags)</code></pre>
<ul>
<li><p>dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev</p>
</li>
<li><p>num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量</p>
</li>
<li><p>flags： 其他一些 flags 信息</p>
<pre><code class="c">  #define INPUT_MT_POINTER 0x0001 /* pointer device, e.g. trackpad */
  #define INPUT_MT_DIRECT 0x0002 /* direct device, e.g. touchscreen */
  #define INPUT_MT_DROP_UNUSED0x0004 /* drop contacts not seen in frame */
  #define INPUT_MT_TRACK 0x0008 /* use in-kernel tracking */
  #define INPUT_MT_SEMI_MT 0x0010 /* semi-mt device, finger count handled manually */</code></pre>
</li>
<li><p>返回值： 0，成功；负值，失败</p>
</li>
</ul>
<p>产生 ABS_MT_SLOT 事件：</p>
<pre><code class="c">static inline void input_mt_slot(struct input_dev *dev, int slot)</code></pre>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点</li>
</ul>
<p>产生ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件：</p>
<pre><code class="c">void input_mt_report_slot_state(struct input_dev *dev, unsigned int tool_type, bool active)</code></pre>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>tool_type：上报触摸工具类型（即ABS_MT_TOOL_TYPE事件），目前的协议支持MT_TOOL_FINGER(手指)、 MT_TOOL_PEN(笔)和 MT_TOOL_PALM(手掌)</li>
<li>active：true，连续触摸，添加一个新的触摸点，linux 内核自动分配一个 ABS_MT_TRACKING_ID；false，触摸点抬起，移除一个触摸点，ABS_MT_TRACKING_ID由内核设为-1</li>
</ul>
<p>上传真实的触摸点数量：</p>
<pre><code class="c">void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)</code></pre>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>use_count：true，有效的触摸点数量（上报数量就是当前数模点数量）； false，追踪到的触摸点数量多于当前上报的数量（使用 BTN_TOOL_TAP     事件通知用户空间当前追踪到的触摸点总数量）</li>
<li>举个例子：硬件能够追踪5个触摸点，无论是否有触摸，硬件都会有5个值输出，此时use_count就是false，即无论触摸的数量为多少，追踪到的（硬件输出的5个值）总比上报的（真实触摸数量）多</li>
</ul>
<p>例子：</p>
<pre><code class="c">static irqreturn_t ft5x06_handler(int irq, void *dev_id)
{
    ......
    /* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */
    ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);

    /* 上报每一个触摸点坐标 */
    for (i = 0; i &lt; MAX_SUPPORT_POINTS; i++) {
        u8 *buf = &amp;rdbuf[i * tplen + offset];

        /* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：
         * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件
         * bit5:4  保留
         * bit3:0  X轴触摸点的11~8位。
         */
        type = buf[0] &gt;&gt; 6;     /* 获取触摸类型 */
        if (type == TOUCH_EVENT_RESERVED)
            continue;

        /* 我们所使用的触摸屏和FT5X06是反过来的 */
        x = ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff;
        y = ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff;

        /* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：
         * bit7:4  Touch ID  触摸ID，表示是哪个触摸点
         * bit3:0  Y轴触摸点的11~8位。
         */
        id = (buf[2] &gt;&gt; 4) &amp; 0x0f;
        down = type != TOUCH_EVENT_UP;//是否按下 1：按下 0：松开

        input_mt_slot(multidata-&gt;input, id);
        input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);

        if (!down)
            continue;

        input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);
        input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);
    }

    input_mt_report_pointer_emulation(multidata-&gt;input, true);
    input_sync(multidata-&gt;input);
    ......
}</code></pre>
<h3 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h3><p>fb_info结构体：</p>
<pre><code class="c">struct fb_info *framebuffer_alloc(size_t size, struct device *dev)
void framebuffer_release(struct fb_info *info)</code></pre>
<ul>
<li>size：分配完framebuffer结构体后附加的额外空间（一般用于存放用户私有数据）</li>
<li>dev：最终会绑定到fb_info-&gt;device上，可以设为NULL</li>
</ul>
<p>注册与卸载：</p>
<pre><code class="c">int register_framebuffer(struct fb_info *fb_info)
int unregister_framebuffer(struct fb_info *fb_info)</code></pre>
<p>显存分配与释放：</p>
<pre><code class="c">static inline void *dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *dma_addr, gfp_t gfp)
static inline void dma_free_writecombine(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_addr)</code></pre>
<h3 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h3><p>申请并注册rtc_device：</p>
<pre><code class="c">struct rtc_device *rtc_device_register(const char *name, struct device *dev, const struct rtc_class_ops *ops, struct module *owner)</code></pre>
<ul>
<li>name：设备名字</li>
<li>dev： 设备</li>
<li>ops： RTC 底层驱动函数集</li>
<li>owner：驱动模块拥有者</li>
</ul>
<p>注销rtc_device：</p>
<pre><code class="c">void rtc_device_unregister(struct rtc_device *rtc)</code></pre>
<h3 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h3><p>适配器注册和注销：</p>
<p>一般不会用到，SOC厂商会写好这部分代码</p>
<pre><code class="c">//注册
int i2c_add_adapter(struct i2c_adapter *adapter)/* 使用动态总线号 */
int i2c_add_numbered_adapter(struct i2c_adapter *adap)/* 使用静态总线号 */
//注销
void i2c_del_adapter(struct i2c_adapter * adap)</code></pre>
<p>i2c驱动注册与注销：</p>
<pre><code class="c">#define i2c_add_driver(driver) i2c_register_driver(THIS_MODULE, driver)
void i2c_del_driver(struct i2c_driver *driver)</code></pre>
<h4 id="iic通信"><a href="#iic通信" class="headerlink" title="iic通信"></a>iic通信</h4><h5 id="内核驱动"><a href="#内核驱动" class="headerlink" title="内核驱动"></a>内核驱动</h5><p>内核文档：<code>Documentation\i2c\i2c-protocol</code>、<code>Documentation\i2c\smbus-protocol</code></p>
<p>其中smbus-protocol是i2c-protocol的一个子集，官方更加推荐使用后者的smbus-protoco中的函数</p>
<p>收发函数：</p>
<pre><code class="c">//S Addr Rd [A] [Data] NA S Addr Wr [A] Data [A] P
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</code></pre>
<ul>
<li><p>adap： 所使用的 I2C 适配器， i2c_client 会保存其对应的 i2c_adapter</p>
</li>
<li><p>msgs： I2C 要发送的一个或多个消息</p>
<pre><code class="c">  struct i2c_msg {
      __u16 addr; /* 从机地址 */
      __u16 flags; /* 标志 */
      #define I2C_M_TEN 0x0010
      #define I2C_M_RD 0x0001
      #define I2C_M_STOP 0x8000
      #define I2C_M_NOSTART 0x4000
      #define I2C_M_REV_DIR_ADDR 0x2000
      #define I2C_M_IGNORE_NAK 0x1000
      #define I2C_M_NO_RD_ACK 0x0800
      #define I2C_M_RECV_LEN 0x0400
      __u16 len; /* 消息(本 msg)长度 */
      __u8 *buf; /* 消息数据 */
  };</code></pre>
</li>
<li><p>num： 消息数量，即 msgs 的数量</p>
</li>
<li><p>返回值： 负值，失败，其他非负值，发送的 msgs 数量</p>
</li>
</ul>
<p>发送函数（最终调用i2c_transfer）：</p>
<pre><code class="c">//S Addr Wr [A] Data [A] Data [A] ... [A] Data [A] P
int i2c_master_send(const struct i2c_client *client, const char *buf, int count)</code></pre>
<ul>
<li>client： I2C 设备对应的 i2c_client</li>
<li>buf：要发送的数据</li>
<li>count： 要发送的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li>
<li>返回值： 负值，失败，其他非负值，发送的字节数</li>
</ul>
<p>接收函数（最终调用i2c_transfer）：</p>
<pre><code class="c">//S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P
int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</code></pre>
<ul>
<li>client： I2C 设备对应的 i2c_client</li>
<li>buf：要接收的数据</li>
<li>count： 要接收的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li>
<li>返回值： 负值，失败，其他非负值，发送的字节数</li>
</ul>
<p>smbus-protoco中的函数：</p>
<pre><code class="c">i2c_smbus_read_byte()//S Addr Rd [A] [Data] NA P
i2c_smbus_write_byte()//S Addr Wr [A] Data [A] P
i2c_smbus_read_byte_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] NA P
i2c_smbus_read_word_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P
i2c_smbus_write_byte_data()//S Addr Wr [A] Comm [A] Data [A] P
i2c_smbus_write_word_data()//S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] P
i2c_smbus_read_block_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA P
i2c_smbus_write_block_data()//S Addr Wr [A] Comm [A] Count [A] Data [A] Data [A] ... [A] Data [A] P
i2c_smbus_read_i2c_block_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P
i2c_smbus_write_i2c_block_data()//S Addr Wr [A] Comm [A] Data [A] Data [A] ... [A] Data [A] P</code></pre>
<h5 id="应用层直接访问"><a href="#应用层直接访问" class="headerlink" title="应用层直接访问"></a>应用层直接访问</h5><p>内核文档：<code>Documentation\i2c\dev-interface</code></p>
<p>通常，I2C设备由设备驱动来控制，但是通过/dev接口也可以提供用户空间直接访问适配器上的设备。前提是需要加载I2C-DEV内核模块</p>
<p>在应用层，<a href="https://i2c.wiki.kernel.org/index.php/I2C_Tools" target="_blank" rel="noopener">i2c-tools工具包</a>帮你写好了接口，<a href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/" target="_blank" rel="noopener">下载链接</a>，<a href="http://jdelvare.nerim.net/mirror/i2c-tools/" target="_blank" rel="noopener">镜像仓库</a>，只需要包含该库的头文件<code>include\linux\i2c-dev.h</code>即可直接控制iic（最新版本的4.1没有发现该文件）。其本质是调用的内核自带的驱动模块I2C-DEV。该模块位于<code>\drivers\i2c\i2c-dev.c</code>，通过宏<code>CONFIG_I2C_CHARDEV</code>配置，内核menuconfig路径为<code>Device Drivers-&gt; I2C support</code>，一般默认为通过模块加载</p>
<p>i2c-tools工具包的本质是通过调用<code>ioctl</code>打开实现各种功能：</p>
<pre><code class="c">//include\linux\i2c-dev.h部分源码
static inline __s32 i2c_smbus_access(int file, char read_write, __u8 command, int size, union i2c_smbus_data *data)
{
    struct i2c_smbus_ioctl_data args;

    args.read_write = read_write;
    args.command = command;
    args.size = size;
    args.data = data;
    return ioctl(file,I2C_SMBUS,&amp;args);//本质就是调用ioctl
}


static inline __s32 i2c_smbus_write_quick(int file, __u8 value)
{
    return i2c_smbus_access(file,value,0,I2C_SMBUS_QUICK,NULL);
}</code></pre>
<p>上述部分源码中file就是需要访问的iic控制器，如：<code>/dev/i2c-0</code>，与自己写的驱动程序类似</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre><code class="c">/* 设备结构体 */
struct xxx_dev {
    ......
        void *private_data; /* 私有数据，一般会设置为 i2c_client */
};

/*
* @description : 读取 I2C 设备多个寄存器数据
* @param – dev : I2C 设备
* @param – reg : 要读取的寄存器首地址
* @param – val : 读取到的数据
* @param – len : 要读取的数据长度
* @return : 操作结果
*/
static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len)
{
    int ret;
    struct i2c_msg msg[2];
    struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data;

    /* msg[0]，第一条写消息，发送要读取的寄存器首地址 */
    msg[0].addr = client-&gt;addr; /* I2C 器件地址 */
    msg[0].flags = 0; /* 标记为发送数据 */
    msg[0].buf = &amp;reg; /* 读取的首地址 */
    msg[0].len = 1; /* reg 长度 */

    /* msg[1]，第二条读消息，读取寄存器数据 */
    msg[1].addr = client-&gt;addr; /* I2C 器件地址 */
    msg[1].flags = I2C_M_RD; /* 标记为读取数据 */
    msg[1].buf = val; /* 读取数据缓冲区 */
    msg[1].len = len; /* 要读取的数据长度 */
    ret = i2c_transfer(client-&gt;adapter, msg, 2);
    if(ret == 2) {
        ret = 0;
    } else {
        ret = -EREMOTEIO;
    }
    return ret;
}

/*
* @description : 向 I2C 设备多个寄存器写入数据
* @param – dev : 要写入的设备结构体
* @param – reg : 要写入的寄存器首地址
* @param – val : 要写入的数据缓冲区
* @param – len : 要写入的数据长度
* @return : 操作结果
*/
static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)
{
    u8 b[256];
    struct i2c_msg msg;
    struct i2c_client *client = (struct i2c_client *)
        dev-&gt;private_data;

    b[0] = reg; /* 寄存器首地址 */
    memcpy(&amp;b[1],buf,len); /* 将要发送的数据拷贝到数组 b 里面 */

    msg.addr = client-&gt;addr; /* I2C 器件地址 */
    msg.flags = 0; /* 标记为写数据 */

    msg.buf = b; /* 要发送的数据缓冲区 */
    msg.len = len + 1; /* 要发送的数据长度 */

    return i2c_transfer(client-&gt;adapter, &amp;msg, 1);
}</code></pre>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>spi_master注册和注销：</p>
<p>一般不会用到，SOC厂商会写好这部分代码</p>
<pre><code class="c">//注册
struct spi_master *spi_alloc_master(struct device *dev,unsigned size)//申请
int spi_register_master(struct spi_master *master)//注册 spi_bitbang_start
//注销
void spi_master_put(struct spi_master *master)//释放
void spi_unregister_master(struct spi_master *master)//注销 spi_bitbang_stop</code></pre>
<p>spi驱动注册与注销：</p>
<pre><code class="c">int spi_register_driver(struct spi_driver *sdrv);
void spi_unregister_driver(struct spi_driver *sdrv)</code></pre>
<p>相关结构体：</p>
<pre><code class="c">/*-----------------------spi_message-----------------------*/
struct spi_message {
    struct list_head    transfers;
    struct spi_device   *spi;
    unsigned        is_dma_mapped:1;
    /* REVISIT:  we might want a flag affecting the behavior of the
     * last transfer ... allowing things like &quot;read 16 bit length L&quot;
     * immediately followed by &quot;read L bytes&quot;.  Basically imposing
     * a specific message scheduling algorithm.
     *
     * Some controller drivers (message-at-a-time queue processing)
     * could provide that as their default scheduling algorithm.  But
     * others (with multi-message pipelines) could need a flag to
     * tell them about such special cases.
     */
    /* completion is reported through a callback */
    void            (*complete)(void *context);/*异步传输完成后，会调用该函数*/
    void            *context;
    unsigned        frame_length;
    unsigned        actual_length;
    int         status;
    /* for optional use by whatever driver currently owns the
     * spi_message ...  between calls to spi_async and then later
     * complete(), that&#39;s the spi_master controller driver.
     */
    struct list_head    queue;
    void            *state;
};
/*-----------------------spi_transfer-----------------------*/
struct spi_transfer {
    /* it&#39;s ok if tx_buf == rx_buf (right?)
     * for MicroWire, one buffer must be null
     * buffers must work with dma_*map_single() calls, unless
     *   spi_message.is_dma_mapped reports a pre-existing mapping
     */
    const void  *tx_buf;/* 要发送的数据 */
    void        *rx_buf;/* 保存接收到的数据 */
    unsigned    len;/* 进行传输的数据长度 */
    dma_addr_t  tx_dma;
    dma_addr_t  rx_dma;
    struct sg_table tx_sg;
    struct sg_table rx_sg;
    unsigned    cs_change:1;
    unsigned    tx_nbits:3;
    unsigned    rx_nbits:3;
#define SPI_NBITS_SINGLE    0x01 /* 1bit transfer */
#define SPI_NBITS_DUAL      0x02 /* 2bits transfer */
#define SPI_NBITS_QUAD      0x04 /* 4bits transfer */
    u8      bits_per_word;
    u16     delay_usecs;
    u32     speed_hz;
    struct list_head transfer_list;
};</code></pre>
<h4 id="spi通信"><a href="#spi通信" class="headerlink" title="spi通信"></a>spi通信</h4><p>初始化：</p>
<pre><code class="c">int spi_setup(struct spi_device *spi)//初始化时钟和SPI模式
void spi_message_init(struct spi_message *m)
void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)//将spi_transfer添加到spi_message队列中</code></pre>
<p>同步传输（阻塞，会等待SPI数据传输完成）</p>
<pre><code class="c">int spi_sync(struct spi_device *spi, struct spi_message *message)</code></pre>
<p>异步传输（不会阻塞，不会等到SPI数据传输完成）</p>
<p>异步传输需要设置 spi_message 中的<code>complete</code>成员变量，当 SPI 异步传输完成以后<code>complete</code>函数就会被调用</p>
<pre><code class="c">int spi_async(struct spi_device *spi, struct spi_message *message)</code></pre>
<h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre><code class="c">/* SPI 多字节发送 */
static int spi_send(struct spi_device *spi, u8 *buf, int len)
{
    int ret;
    struct spi_message m;
    struct spi_transfer t = {
        .tx_buf = buf,
        .len = len,
    };
    spi_message_init(&amp;m); /* 初始化 spi_message */
    spi_message_add_tail(t, &amp;m);/* 将 spi_transfer 添加到 spi_message 队列 */
    ret = spi_sync(spi, &amp;m); /* 同步传输 */
    return ret;
}
/* SPI 多字节接收 */
static int spi_receive(struct spi_device *spi, u8 *buf, int len)
{
    int ret;
    struct spi_message m;
    struct spi_transfer t = {
        .rx_buf = buf,
        .len = len,
    };
    spi_message_init(&amp;m); /* 初始化 spi_message */
    spi_message_add_tail(t, &amp;m);/* 将 spi_transfer 添加到 spi_message 队列 */
    ret = spi_sync(spi, &amp;m); /* 同步传输 */
    return ret;
}</code></pre>
<h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p>设备树绑定内核参考文档：<code>Documentation/devicetree/bindings/pwm/imx-pwm.txt</code></p>
<h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol>
<li><p>通过名字查找</p>
<pre><code class="c"> struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>name：要查找的节点名字（不是table和name属性）。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li>
</ul>
</li>
<li><p>通过device_type 属性查找</p>
<pre><code class="c"> struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li>
</ul>
</li>
<li><p>根据 device_type 和 compatible查找</p>
<pre><code class="c"> struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li>
<li>compatible： 要查找的节点所对应的 compatible 属性列表。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败  </li>
</ul>
</li>
<li><p>通过 of_device_id 匹配表来查找</p>
<pre><code class="c"> struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</code></pre>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li>
<li>match： 找到的匹配的 of_device_id。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li><p>通过路径查找</p>
<pre><code class="c"> inline struct device_node *of_find_node_by_path(const char *path)</code></pre>
<ul>
<li>path：带有全路径的节点名，可以使用节点的别名。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li><p>查找指定节点的父节点</p>
<pre><code class="c"> struct device_node *of_get_parent(const struct device_node *node)</code></pre>
<ul>
<li>node：要查找的父节点的节点。</li>
<li>返回值： 找到的父节点。</li>
</ul>
</li>
<li><p>查找指定节点的子节点</p>
<pre><code class="c"> struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)</code></pre>
<ul>
<li>node：父节点。</li>
<li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li>
<li>返回值： 找到的下一个子节点。</li>
</ul>
</li>
</ol>
<h4 id="提取属性"><a href="#提取属性" class="headerlink" title="提取属性"></a>提取属性</h4><ol>
<li><p>查找节点中的指定属性</p>
<pre><code class="c"> property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>name： 属性名字。</li>
<li>lenp：属性值的字节数，一般为NULL</li>
<li>返回值： 找到的属性。</li>
</ul>
</li>
<li><p>获取属性中元素的数量</p>
<pre><code class="c"> int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 需要统计元素数量的属性名字。</li>
<li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li>
<li>返回值： 得到的属性元素数量。</li>
</ul>
</li>
<li><p>从属性中获取指定标号的 u32 类型数据值</p>
<pre><code class="c"> int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>index：要读取的值标号。</li>
<li>out_value：读取到的值</li>
<li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p>
<pre><code class="c"> int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz)
 int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz)
 int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz)
 int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li>
<li>sz： 要读取的数组元素数量。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取只有一个整形值的属性</p>
<pre><code class="c"> int of_property_read_u8(const struct device_node *np,const char *propname, u8 *out_value)
 int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value)
 int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)
 int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_value：读取到的数组值。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li><p>读取属性中字符串值</p>
<pre><code class="c"> int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_string：读取到的字符串值。</li>
<li>返回值： 0，读取成功，负值，读取失败。</li>
</ul>
</li>
<li><p>获取#address-cells 属性值</p>
<pre><code class="c"> int of_n_addr_cells(struct device_node *np)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#address-cells 属性值。</li>
</ul>
</li>
<li><p>获取#size-cells 属性值</p>
<pre><code class="c"> int of_n_size_cells(struct device_node *np)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#size-cells 属性值。</li>
</ul>
</li>
</ol>
<h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><ol>
<li><p>查看节点的 compatible 属性是否有包含指定的字符串</p>
<pre><code class="c"> int of_device_is_compatible(const struct device_node *device, const char *compat)</code></pre>
<ul>
<li>device：设备节点。</li>
<li>compat：要查看的字符串。</li>
<li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li>
</ul>
</li>
<li><p>获取地址相关属性</p>
<p> 主要是“reg”或者“assigned-addresses”属性值</p>
<pre><code class="c"> const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>index：要读取的地址标号。</li>
<li>size：地址长度。</li>
<li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li>
<li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li>
</ul>
</li>
<li><p>将从设备树读取到的地址转换为物理地址</p>
<pre><code class="c"> u64 of_translate_address(struct device_node *dev, const __be32 *in_addr)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>in_addr：要转换的地址。</li>
<li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li>
</ul>
</li>
<li><p>从设备树里面提取资源值</p>
<p> 本质上是将 reg 属性值转换为 resource 结构体类型</p>
<pre><code class="c"> int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</code></pre>
<ul>
<li>dev：设备节点。</li>
<li>index：地址资源标号。</li>
<li>r：得到的 resource 类型的资源值。</li>
<li>返回值： 0，成功；负值，失败。</li>
</ul>
</li>
<li><p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p>
<p> 本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p>
<pre><code class="c"> void __iomem *of_iomap(struct device_node *np, int index)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li>
<li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li>
</ul>
</li>
</ol>
<h3 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h3><h4 id="of函数"><a href="#of函数" class="headerlink" title="of函数"></a>of函数</h4><ol>
<li><p>获取设备树某个属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p>
<pre><code class="c"> int of_gpio_named_count(struct device_node *np, const char *propname)</code></pre>
<ul>
<li>np：设备节点。</li>
<li>propname：要统计的 GPIO 属性。</li>
<li>返回值： 正值，统计到的 GPIO 数量；负值，失败。</li>
</ul>
</li>
<li><p>获取设备树<code>gpios</code>属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p>
<pre><code class="c"> int of_gpio_count(struct device_node *np)</code></pre>
</li>
<li><p>获取 GPIO 编号</p>
<pre><code class="c"> int of_get_named_gpio(struct device_node *np, const char *propname, int index)</code></pre>
<ul>
<li>index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO 的编号，如果只有一个 GPIO 信息的话此参数为 0</li>
</ul>
</li>
</ol>
<h4 id="驱动层函数"><a href="#驱动层函数" class="headerlink" title="驱动层函数"></a>驱动层函数</h4><ol>
<li><p>申请GPIO</p>
<pre><code class="c"> int gpio_request(unsigned gpio, const char *label)</code></pre>
<ul>
<li>gpio：要申请的 gpio 标号，使用 <code>of_get_named_gpio</code> 函数返回值</li>
<li>label：给 gpio 设置个名字。</li>
<li>返回值： 0，申请成功；其他值，申请失败。</li>
</ul>
</li>
<li><p>释放GPIO</p>
<pre><code class="c"> void gpio_free(unsigned gpio)</code></pre>
</li>
<li><p>设置方向</p>
<pre><code class="c"> int gpio_direction_input(unsigned gpio)
 int gpio_direction_output(unsigned gpio, int value)</code></pre>
<ul>
<li>返回值： 0，设置成功；负值，设置失败</li>
</ul>
</li>
<li><p>设置值</p>
<pre><code class="c"> #define gpio_get_value __gpio_get_value
 int __gpio_get_value(unsigned gpio)</code></pre>
<ul>
<li>返回值： 非负值，得到的 GPIO 值；负值，获取失败</li>
</ul>
</li>
<li><p>获取值</p>
<pre><code class="c"> #define gpio_set_value __gpio_set_value
 void __gpio_set_value(unsigned gpio, int value)</code></pre>
</li>
<li><p>获取 gpio 对应的中断号</p>
<pre><code class="c"> int gpio_to_irq(unsigned int gpio)</code></pre>
<ul>
<li>gpio： 要获取的 GPIO 编号</li>
<li>返回值： GPIO 对应的中断号</li>
</ul>
</li>
</ol>
<h3 id="中断相关"><a href="#中断相关" class="headerlink" title="中断相关"></a>中断相关</h3><p>提取 interrupts 属性中的中断号</p>
<pre><code class="c">unsigned int irq_of_parse_and_map(struct device_node *dev, int index)</code></pre>
<ul>
<li>dev： 设备节点</li>
<li>index：索引号， interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息</li>
<li>返回值：中断号</li>
</ul>
<p>获取 gpio 对应的中断号（与上面的函数功能一样）</p>
<pre><code class="c">int gpio_to_irq(unsigned int gpio)</code></pre>
<ul>
<li>gpio： 要获取的 GPIO 编号，由<code>gpio_request</code>申请而来</li>
<li>返回值： GPIO 对应的中断号</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎指出任何有错误或不够清晰的表达。邮件：1125934312@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>Linux驱动常用API整理</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">12.8k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="NU-LL">NU-LL</a></p>
    <p><span class="copy-title">发布时间:</span>2020-04-06, 22:48:09</p>
    <p><span class="copy-title">最后更新:</span>2020-05-02, 22:54:24</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/04/06/Linux驱动常用API整理/" title="Linux驱动常用API整理">http://NU-LL.github.io/2020/04/06/Linux驱动常用API整理/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 NU-LL</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="/js/script.js?v=1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#DM9000C','#网卡移植','#GO','#Docker','#ESP32','#ESP8266','#Kconfig语法','#IIC驱动','#Latex','#Ctex','#LiCheePi Zero','#Linux服务','#Linux内核','#文件描述符','#Markdown','#Mininet','#数据分析','#NanoPi Neo Core','#字符驱动','#TensorFlow2','#SVM','#Xmanager','#远程链接','#git','#network namespace','#Kubernetes','#等待队列','#wait_queue_head_t','#wait_queue_t','#markdownlint','#python实战','#u-boot','#python','#爬虫','#二维数组','#指针','#存储器','#IAP','#BootLoader','#dual bank','#快速排序','#按键驱动','#poll机制','#异步通知机制','#根文件系统','#网卡驱动框架','#虚拟网卡','#设备树','#输入子系统','#Go语言入门经典','#驱动API','#深度学习','#廖雪峰python教程',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    

    
</style>







</html>
