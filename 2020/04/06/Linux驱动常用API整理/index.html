<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux驱动常用API整理 | spaceman</title><meta name="keywords" content="驱动API"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发与竞争  原子操作 定义： 123typedef struct &amp;#123;    int counter;&amp;#125; atomic_t; 整形操作： 12345678910111213ATOMIC_INIT(int i);&#x2F;&#x2F;定义时初始化int atomic_read(atomic_t *v);void atomic_set(atomic_t *v, int i)void atomic_">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux驱动常用API整理">
<meta property="og:url" content="http://nu-ll.github.io/2020/04/06/Linux%E9%A9%B1%E5%8A%A8%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="spaceman">
<meta property="og:description" content="并发与竞争  原子操作 定义： 123typedef struct &amp;#123;    int counter;&amp;#125; atomic_t; 整形操作： 12345678910111213ATOMIC_INIT(int i);&#x2F;&#x2F;定义时初始化int atomic_read(atomic_t *v);void atomic_set(atomic_t *v, int i)void atomic_">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/NU-LL/image-host/raw/master/12.jpg">
<meta property="article:published_time" content="2020-04-06T14:48:09.000Z">
<meta property="article:modified_time" content="2020-05-02T14:54:24.318Z">
<meta property="article:author" content="spaceman">
<meta property="article:tag" content="驱动API">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/NU-LL/image-host/raw/master/12.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2020/04/06/Linux%E9%A9%B1%E5%8A%A8%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-05-02 22:54:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/NU-LL/image-host/raw/master/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">spaceman</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux驱动常用API整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-06T14:48:09.000Z" title="发表于 2020-04-06 22:48:09">2020-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-02T14:54:24.318Z" title="更新于 2020-05-02 22:54:24">2020-05-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="并发与竞争"><a class="markdownIt-Anchor" href="#并发与竞争"></a> 并发与竞争</h2>
<h3 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h3>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>整形操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC_INIT(<span class="keyword">int</span> i);<span class="comment">//定义时初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_read</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_set</span><span class="params">(<span class="keyword">atomic_t</span> *v, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_dec</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_inc</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_dec_return</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//自减并返回v</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_inc_return</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//自增并返回v</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_sub_and_test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span><span class="comment">//(v-i)==0?1:0（返回真、假）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_dec_and_test</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//(v--)==0?1:0（返回真、假）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_inc_and_test</span><span class="params">(<span class="keyword">atomic_t</span> *v)</span><span class="comment">//(v++)==0?1:0（返回真、假）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_add_negative</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span><span class="comment">//(v+i)&lt;0?1:0（返回真、假）</span></span></span><br></pre></td></tr></table></figure>
<p>位操作（直接对内存操作）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//将p地址的第nr位置 1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//翻转</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//获取</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//将p地址的第nr位置1，并返回nr位原来的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//...清零...</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_change_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> *p)</span><span class="comment">//...翻转...</span></span></span><br></pre></td></tr></table></figure>
<h3 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h3>
<p>基本API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(<span class="keyword">spinlock_t</span> lock)<span class="comment">//定义并初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_lock_init</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//加锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//解锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_trylock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//尝试加锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_is_locked</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//检查是否加锁，是返回非 0，否返回 0</span></span></span><br></pre></td></tr></table></figure>
<p>中断相关：</p>
<p>一般在线程中使用 <code>spin_lock_irqsave</code>/<code>spin_unlock_irqrestore</code>，在中断中使用<code>spin_lock</code>/<code>spin_unlock</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//禁止本地中断，并获取自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//激活本地中断，并释放自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irqsave</span><span class="params">(<span class="keyword">spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><span class="comment">//保存中断状态，禁止本地中断，并获取自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irqrestore</span><span class="params">(<span class="keyword">spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><span class="comment">//恢复中断状态，并且激活本地中断，释放自旋锁</span></span></span><br></pre></td></tr></table></figure>
<p>中断下半部相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//关闭下半部，并获取自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span><span class="comment">//打开下半部，并释放自旋锁</span></span></span><br></pre></td></tr></table></figure>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SEAMPHORE(name)<span class="comment">//定义信号量 并设值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore *sem, <span class="keyword">int</span> val)</span><span class="comment">//初始化，并设值为val</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span><span class="comment">//获取信号量（会导致休眠，不能在中断中使用，不能被信号打断）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore *sem)</span><span class="comment">//获取信号量(会导致休眠，不能在中断中使用，可以被信号打断)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_trylock</span><span class="params">(struct semaphore *sem)</span><span class="comment">//尝试获取信号量(成功返回 0。否则返回非 0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span><span class="comment">//释放信号量</span></span></span><br></pre></td></tr></table></figure>
<h3 id="互斥体"><a class="markdownIt-Anchor" href="#互斥体"></a> 互斥体</h3>
<p>会导致休眠，不能在中断中使用 <code>mutex</code>，中断中只能使用<code>自旋锁</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_MUTEX(name)<span class="comment">//定义并初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_init</span><span class="params">(mutex *lock)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span><span class="comment">//上锁，失败则休眠，不可以被信号打断</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_lock_interruptible</span><span class="params">(struct mutex *lock)</span><span class="comment">//上锁，失败则休眠，可以被信号打断</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(struct mutex *lock)</span><span class="comment">//解锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_trylock</span><span class="params">(struct mutex *lock)</span><span class="comment">//尝试加锁，成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_is_locked</span><span class="params">(struct mutex *lock)</span><span class="comment">//判断是否加锁，是返回1，否返回0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="字符设备驱动"><a class="markdownIt-Anchor" href="#字符设备驱动"></a> 字符设备驱动</h2>
<h3 id="常用宏"><a class="markdownIt-Anchor" href="#常用宏"></a> 常用宏</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;author&quot;</span>);</span><br><span class="line"><span class="comment">//printk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_EMERG KERN_SOH <span class="meta-string">&quot;0&quot;</span> <span class="comment">/* 紧急事件，一般是内核崩溃 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_ALERT KERN_SOH <span class="meta-string">&quot;1&quot;</span> <span class="comment">/* 必须立即采取行动 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_CRIT KERN_SOH <span class="meta-string">&quot;2&quot;</span> <span class="comment">/* 临界条件，比如严重的软件或硬件错误*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_ERR KERN_SOH <span class="meta-string">&quot;3&quot;</span> <span class="comment">/* 错误状态，一般设备驱动程序中使用KERN_ERR 报告硬件错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_WARNING KERN_SOH <span class="meta-string">&quot;4&quot;</span> <span class="comment">/* 警告信息，不会对系统造成严重影响 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_NOTICE KERN_SOH <span class="meta-string">&quot;5&quot;</span> <span class="comment">/* 有必要进行提示的一些信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_INFO KERN_SOH <span class="meta-string">&quot;6&quot;</span> <span class="comment">/* 提示性的信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_DEBUG KERN_SOH <span class="meta-string">&quot;7&quot;</span> <span class="comment">/* 调试信息 */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="注册与注销"><a class="markdownIt-Anchor" href="#注册与注销"></a> 注册与注销</h3>
<p>老方法，不推荐：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册字符设备（浪费设备号）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> struct file_operations *fops)</span></span>;</span><br><span class="line"><span class="comment">//注销字符设备</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unregister_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：设备名字，指向一串字符串</li>
</ul>
<p>新方法，推荐：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注册（方法一，自己确定设备号）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;<span class="comment">//详见设备号API</span></span><br><span class="line">cdev.owner = THIS_MODULE;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*注册（方法二，系统分配设备号）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;<span class="comment">//详见设备号API</span></span><br><span class="line">cdev.owner = THIS_MODULE;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*注销*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="设备节点"><a class="markdownIt-Anchor" href="#设备节点"></a> 设备节点</h3>
<p>类相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class_create(owner, name)<span class="comment">//创建类 owner一般为THIS_MODULE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_destroy</span><span class="params">(struct class *cls)</span></span>;<span class="comment">//卸载类</span></span><br></pre></td></tr></table></figure>
<p>设备相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device *<span class="title">device_create</span><span class="params">(struct class *class, struct device *parent, <span class="keyword">dev_t</span> devt, <span class="keyword">void</span> *drvdata, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;<span class="comment">//创建设备 parent=NULL drvdata=NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_destroy</span><span class="params">(struct class *class, <span class="keyword">dev_t</span> devt)</span><span class="comment">//卸载设备</span></span></span><br></pre></td></tr></table></figure>
<h3 id="设备号"><a class="markdownIt-Anchor" href="#设备号"></a> 设备号</h3>
<p>相关宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(dev)<span class="comment">//dev_t -&gt; 主设备号</span></span><br><span class="line">MINOR(dev)<span class="comment">//dev_t -&gt; 次设备号</span></span><br><span class="line">MKDEV(ma,mi)<span class="comment">//主设备号+次设备号 -&gt; dev_t</span></span><br></pre></td></tr></table></figure>
<p>动态分配设备号：</p>
<p>系统分配设备号+自动注册设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：存放起始设备编号的指针，当注册成功，*dev就会等于分配到的起始设备编号，可以通过<code>MAJOR()</code>和<code>MINNOR()</code>宏来提取主次设备号</li>
<li>baseminor：次设备号基地址，也就是起始次设备号</li>
<li>count：要申请的数量，一般都是一个</li>
<li>name：字符设备名称</li>
<li>返回值小于0,表示注册失败</li>
</ul>
<p>注册设备号：</p>
<p>手动确定设备号+手动注册设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：要申请的起始设备号，也就是<strong>给定的设备号</strong></li>
<li>count：要申请的数量，一般都是一个</li>
<li>name：设备名字</li>
<li>当返回值小于0,表示注册失败</li>
</ul>
<h3 id="用户空间与内核空间"><a class="markdownIt-Anchor" href="#用户空间与内核空间"></a> 用户空间与内核空间</h3>
<p>内核空间–&gt;用户空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>to：用户空间指针</li>
<li>from：内核空间指针</li>
<li>n：从内核空间向用户空间拷贝数据的字节数</li>
<li>成功返回0，失败返回失败数目</li>
</ul>
<p>用户空间–&gt;内核空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user * from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>to：内核空间指针</li>
<li>from：用户空间指针</li>
<li>n：从用户空间向内核空间拷贝数据的字节数</li>
<li>成功返回0，失败返回失败数目</li>
</ul>
<h3 id="地址映射"><a class="markdownIt-Anchor" href="#地址映射"></a> 地址映射</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>phys_addr：要映射的物理起始地址。</li>
<li>size：要映射的内存空间大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span> <span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br></pre></td></tr></table></figure>
<p>对映射后的内存进行读写操作的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="function">u8 <span class="title">readb</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br><span class="line"><span class="function">u16 <span class="title">readw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br><span class="line"><span class="function">u32 <span class="title">readl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//写</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeb</span><span class="params">(u8 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="linux常用命令"><a class="markdownIt-Anchor" href="#linux常用命令"></a> Linux常用命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看设备号</span></span><br><span class="line">cat /proc/devices</span><br><span class="line"><span class="comment">#创建设备节点</span></span><br><span class="line">mknod /dev/xxx c 主设备号 次设备号</span><br><span class="line"><span class="comment">#查看设备树节点</span></span><br><span class="line">ls /proc/device-tree</span><br><span class="line">ls /sys/firmware/devicetree/base</span><br><span class="line"><span class="comment">#查看platform相关</span></span><br><span class="line">ls /sys/bus/platform/devices <span class="comment"># 设备</span></span><br><span class="line">ls /sys/bus/platform/drivers <span class="comment"># 驱动</span></span><br><span class="line"><span class="comment">#查看misc相关</span></span><br><span class="line">ls /sys/class/misc <span class="comment"># 驱动</span></span><br><span class="line"><span class="comment">#驱动相关</span></span><br><span class="line">depmod</span><br><span class="line">modprobe xxx.ko</span><br><span class="line">insmod xxx.ko</span><br><span class="line">lsmod</span><br><span class="line">rmmod xxx.ko</span><br></pre></td></tr></table></figure>
<h2 id="内核定时器"><a class="markdownIt-Anchor" href="#内核定时器"></a> 内核定时器</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __jiffy_data jiffies_64;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure>
<p>相关变量：</p>
<ul>
<li><code>HZ</code>：宏，就是CONFIG_HZ，系统频率，通过menuconfig配置，默认100</li>
<li><code>jiffies</code>、<code>jiffies_64</code>：系统运行的<strong>节拍数</strong>，由宏<code>HZ</code>确定，默认10ms累加一次</li>
<li><code>jiffies/HZ</code>：系统运行时间（s）</li>
</ul>
<p>时间先后函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unkown 通常为 jiffies，known 通常是需要对比的值</span></span><br><span class="line">time_after(unkown, known)<span class="comment">//unkown 时间上超过 known 则返回真</span></span><br><span class="line">time_before(unkown, known)<span class="comment">//unkown 时间上滞后 known 则返回真</span></span><br><span class="line">time_after_eq(unkown, known)<span class="comment">//unkown 时间上超过或等于 known 则返回真</span></span><br><span class="line">time_before_eq(unkown, known)<span class="comment">//unkown 时间上滞后或等于 known 则返回真</span></span><br></pre></td></tr></table></figure>
<p>时间转换函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jiffies_to_msecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span><span class="comment">//jiffies类型j --&gt; ms</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jiffies_to_usecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span><span class="comment">//jiffies类型j --&gt; us</span></span></span><br><span class="line"><span class="function">u64 <span class="title">jiffies_to_nsecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span><span class="comment">//jiffies类型j --&gt; ns</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">msecs_to_jiffies</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span><span class="comment">//ms --&gt; jiffies</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">usecs_to_jiffies</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span><span class="comment">//us --&gt; jiffies</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nsecs_to_jiffies</span><span class="params">(u64 n)</span><span class="comment">//ns --&gt; jiffies</span></span></span><br></pre></td></tr></table></figure>
<p>短延时函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ndelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nsecs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> usecs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> mseces)</span></span></span><br></pre></td></tr></table></figure>
<p>定时器类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires; <span class="comment">/* 定时器超时时间，单位是节拍数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">/* 定时处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; <span class="comment">/* 要传递给 function 函数的参数 */</span></span><br><span class="line">    <span class="keyword">int</span> slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定时器函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">(struct timer_list *timer)</span></span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(struct timer_list *timer)</span></span>;<span class="comment">//注册并使能</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer</span><span class="params">(struct timer_list * timer)</span></span>;<span class="comment">//删除（需等待 定时处理函数 退出）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer_sync</span><span class="params">(struct timer_list *timer)</span></span>;<span class="comment">//删除（需等待其他处理器使用完定时器，中断上下文勿用）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>;<span class="comment">//修改定时值（会使能定时器）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值： 0，定时器未被使能； 1，定时器已经使能</li>
</ul>
<h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h2>
<h3 id="上半部"><a class="markdownIt-Anchor" href="#上半部"></a> 上半部</h3>
<h4 id="申请"><a class="markdownIt-Anchor" href="#申请"></a> 申请</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>irq：要申请中断的中断号。</li>
<li>handler：中断处理函数，当中断发生以后就会执行此中断处理函数。</li>
<li>flags：中断标志，可以在文件<code>include/linux/interrupt.h</code>里面查看所有的中断标志。</li>
</ul>
<blockquote>
<p>常用的中断标志：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IRQF_SHARED</td>
<td style="text-align:center">多个设备共享一个中断线，共享的所有中断都必须指定此标志。 如果使用共享中断的话，request_irq函数的 dev 参数是唯一区分他们的标志</td>
</tr>
<tr>
<td style="text-align:center">IRQF_ONESHOT</td>
<td style="text-align:center">单次中断，中断执行一次就结束</td>
</tr>
<tr>
<td style="text-align:center">IRQF_TRIGGER_NONE</td>
<td style="text-align:center">无触发</td>
</tr>
<tr>
<td style="text-align:center">IRQF_TRIGGER_RISING</td>
<td style="text-align:center">上升沿触发</td>
</tr>
<tr>
<td style="text-align:center">IRQF_TRIGGER_FALLING</td>
<td style="text-align:center">下降沿触发</td>
</tr>
<tr>
<td style="text-align:center">IRQF_TRIGGER_HIGH</td>
<td style="text-align:center">高电平触发</td>
</tr>
<tr>
<td style="text-align:center">IRQF_TRIGGER_LOW</td>
<td style="text-align:center">低电平触发</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li>name：中断名字，设置以后可以在<code>/proc/interrupts</code>文件中看到对应的中断名字</li>
<li>dev： 如果将 flags 设置为 IRQF_SHARED 的话， dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体， dev 会传递给中断处理函数 irq_handler_t 的第二个参数</li>
<li>返回值： 0 中断申请成功；其他负值：中断申请失败；-EBUSY：中断已经被申请了</li>
</ul>
<p>对于一种不太重要而又比较耗时的中断，可以使用以下函数进行申请：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">devm_request_threaded_irq</span><span class="params">(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags, <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会使得中断线程化（中断使用下半部虽然可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比较耗时的下半部与进程进行公平竞争）</li>
<li>带<code>devm_</code>前缀表明申请到的资源可以由系统自动释放，无需手动处理</li>
<li>注意：并不是所有的中断都可以被线程化。该函数有利有弊，具体是否使用需要根据实际情况来衡量（触摸中断一般会用）</li>
</ul>
<h4 id="释放"><a class="markdownIt-Anchor" href="#释放"></a> 释放</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>irq： 要释放的中断</li>
<li>dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉</li>
</ul>
<h4 id="中断处理函数"><a class="markdownIt-Anchor" href="#中断处理函数"></a> 中断处理函数</h4>
<p>格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> (*<span class="keyword">irq_handler_t</span>) (<span class="keyword">int</span>, <span class="keyword">void</span> *)</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<p>一般为<code>return IRQ_RETVAL(IRQ_HANDLED)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">    IRQ_NONE = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    IRQ_HANDLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    IRQ_WAKE_THREAD = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> <span class="title">irqreturn_t</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="使能与禁止"><a class="markdownIt-Anchor" href="#使能与禁止"></a> 使能与禁止</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><span class="comment">//需等待 正在执行的中断处理函数执行完</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq_nosync</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span><span class="comment">//无需等待 正在执行的中断处理函数执行完</span></span></span><br><span class="line"><span class="function"><span class="comment">//不推荐</span></span></span><br><span class="line"><span class="function"><span class="title">local_irq_disable</span><span class="params">()</span><span class="comment">//关闭全局中断</span></span></span><br><span class="line"><span class="function"><span class="title">local_irq_enable</span><span class="params">()</span><span class="comment">//使能全局中断</span></span></span><br><span class="line"><span class="function"><span class="comment">//推荐</span></span></span><br><span class="line"><span class="function"><span class="title">local_irq_save</span><span class="params">(flags)</span><span class="comment">//保存中断标志到flags并 关闭全局中断</span></span></span><br><span class="line"><span class="function"><span class="title">local_irq_restore</span><span class="params">(flags)</span><span class="comment">//根据flags设置中断标志并 使能全局中断</span></span></span><br></pre></td></tr></table></figure>
<h3 id="下半部"><a class="markdownIt-Anchor" href="#下半部"></a> 下半部</h3>
<p>推荐使用<code>tasklet</code>实现</p>
<h4 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h4>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>系统定义的10个软中断：</p>
<p>多核处理器中，各个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断，但是所执行的软中断服务函数却是相同的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,<span class="comment">//高优先级软中断</span></span><br><span class="line">    TIMER_SOFTIRQ,<span class="comment">//定时器软中断</span></span><br><span class="line">    NET_TX_SOFTIRQ,<span class="comment">//网络数据发送软中断</span></span><br><span class="line">    NET_RX_SOFTIRQ,<span class="comment">//网络数据接收软中断</span></span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,<span class="comment">//tasklet 软中断</span></span><br><span class="line">    SCHED_SOFTIRQ,<span class="comment">//调度软中断</span></span><br><span class="line">    HRTIMER_SOFTIRQ,<span class="comment">//高精度定时器软中断</span></span><br><span class="line">    RCU_SOFTIRQ,<span class="comment">//RCU 软中断</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure>
<p>注册软中断：</p>
<p>软中断必须在编译的时候静态注册。Linux内核默认会在软中断初始化函数<code>softirq_init</code>中打开<code>TASKLET_SOFTIRQ</code>和<code>HI_SOFTIRQ</code>软中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>nr：要开启的软中断，在上述<code>enum</code>中选择一个</li>
<li>action：软中断对应的处理函数</li>
</ul>
<p>触发软中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="tasklet"><a class="markdownIt-Anchor" href="#tasklet"></a> tasklet</h4>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个 tasklet */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state; <span class="comment">/* tasklet 状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count; <span class="comment">/* 计数器，记录对 tasklet 的引用数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">/* tasklet 执行的函数，用户定义，相当于中断处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; <span class="comment">/* 函数 func 的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t, <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;<span class="comment">//初始化</span></span><br><span class="line">DECLARE_TASKLET(name, func, data)<span class="comment">//宏，定义并初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>func：tasklet 的处理函数</li>
<li>data：要传递给 func 函数的参数</li>
</ul>
<p>调度函数：</p>
<p>一般在中断的上半部中调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>t：要调度的 tasklet，也就是 <code>DECLARE_TASKLET</code> 宏里面的 <code>name</code></li>
</ul>
<h4 id="工作队列"><a class="markdownIt-Anchor" href="#工作队列"></a> 工作队列</h4>
<p>工作队列在进程上下文执行，即，将要推后的工作交给一个内核线程去执行，因此工作队列允许<strong>睡眠</strong>或<strong>重新调度</strong>。</p>
<p>如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet</p>
<p>定义：</p>
<p>工作–&gt;工作队列–&gt;工作者线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工作（重点关注）：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func; <span class="comment">/* 工作队列处理函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工作队列：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="keyword">int</span> work_color;</span><br><span class="line">    <span class="keyword">int</span> flush_color;</span><br><span class="line">    <span class="keyword">atomic_t</span> nr_pwqs_to_flush;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span> *<span class="title">first_flusher</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_overflow</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">maydays</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nr_drainers;</span><br><span class="line">    <span class="keyword">int</span> saved_max_active;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">unbound_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">dfl_pwq</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[WQ_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags ____cacheline_aligned;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工作者线程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hentry</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> current_func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">current_pwq</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> desc_valid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">scheduled</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> last_active;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> desc[WORKER_DESC_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">rescue_wq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_WORK(_work, _func)<span class="comment">//初始化，需要自己创建work_struct</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_WORK(n, f)<span class="comment">//创建和初始化，无需自己创建work_struct</span></span></span><br></pre></td></tr></table></figure>
<p>调度：</p>
<p>一般在中断的上半部中调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>work： 要调度的工作</li>
<li>返回值： 0 成功，其他值 失败</li>
</ul>
<h2 id="阻塞与非阻塞"><a class="markdownIt-Anchor" href="#阻塞与非阻塞"></a> 阻塞与非阻塞</h2>
<p>阻塞：访问资源时，如果资源不可用，将会<strong>挂起线程</strong>，直到资源可用再唤醒。open函数中大部分flag均为阻塞访问</p>
<p>非阻塞：访问资源时，如果资源不可用，将会<strong>直接返回错误码</strong>。open函数中flag参数<code>O_NONBLOCK</code>为非阻塞访问</p>
<h3 id="等待队列"><a class="markdownIt-Anchor" href="#等待队列"></a> 等待队列</h3>
<p>一般用于在<strong>中断</strong>中唤醒<strong>阻塞</strong>操作而引起的线程挂起</p>
<h4 id="等待队列头"><a class="markdownIt-Anchor" href="#等待队列头"></a> 等待队列头</h4>
<p>等待队列的头部</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_waitqueue_head</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span><span class="comment">//仅初始化</span></span></span><br><span class="line"><span class="function">DECLARE_WAIT_QUEUE_HEAD<span class="comment">//宏，定义+初始化</span></span></span><br></pre></td></tr></table></figure>
<h4 id="等待队列项"><a class="markdownIt-Anchor" href="#等待队列项"></a> 等待队列项</h4>
<p>每个访问设备的进程都需要创建一个队列项，当设备不可用的时候需要将这些进程对应的等待队列项添加到等待队列里面</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WAITQUEUE(name, tsk)<span class="comment">//宏，定义并初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>name：等待队列项的名字</li>
<li>tsk：这个等待队列项属于哪个任务(进程)，一般设置为<code>current</code>（全局变量，表示当前进程）</li>
</ul>
<h4 id="添加移除等待队列"><a class="markdownIt-Anchor" href="#添加移除等待队列"></a> 添加/移除等待队列</h4>
<p>当设备不可用的时候需要将该进程对应的等待队列项添加到等待队列里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span><span class="comment">//添加</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span><span class="comment">//删除</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>q： 等待队列项要加入的等待队列头</li>
<li>wait：要加入/删除的等待队列项</li>
</ul>
<h4 id="等待唤醒"><a class="markdownIt-Anchor" href="#等待唤醒"></a> 等待唤醒</h4>
<p>当设备可以使用的时候就要唤醒进入休眠态的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span><span class="comment">//唤醒队列中的所有进程（包括TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE状态）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_interruptible</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span><span class="comment">//唤醒队列中的所有进程（仅唤醒TASK_INTERRUPTIBLE状态进程）</span></span></span><br></pre></td></tr></table></figure>
<h4 id="等待事件"><a class="markdownIt-Anchor" href="#等待事件"></a> 等待事件</h4>
<p>当事件满足以后能够自动唤醒等待队列中的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait_event(wq, condition)<span class="comment">//若condition为真，则唤醒等待队列，否则一直阻塞。（会将进程设置为TASK_UNINTERRUPTIBLE状态）</span></span><br><span class="line">wait_event_timeout(wq, condition, timeout)<span class="comment">//与wait_event类似，timeout为超时时间，单位为jiffies。返回0：超时时间到，且condition为假；返回1：condition为真</span></span><br><span class="line">wait_event_interruptible(wq, condition)<span class="comment">//与wait_event类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断</span></span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout)<span class="comment">//与wait_event_timeout类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断</span></span><br></pre></td></tr></table></figure>
<h3 id="轮询"><a class="markdownIt-Anchor" href="#轮询"></a> 轮询</h3>
<p>一般用于<strong>非阻塞</strong>操作</p>
<p><code>poll</code>、 <code>epoll</code> 和 <code>select</code> 用于处理轮询。应用程序通过 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 函数的时候设备驱动程序中的 <code>poll</code> 函数就会执行</p>
<h4 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h4>
<p>单线程中 select 函数能够监视的文件描述符数量一般最大为1024，可以修改该数量但会降低效率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>nfds： 要操作的文件描述符个数</li>
<li>readfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>读</u>变化，所指定集合中有一个文件可以<u>读取</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>读</u>变化</li>
<li>writefds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>写</u>变化，所指定集合中有一个文件可以<u>写入</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>写</u>变化</li>
<li>exceptfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>异常</u>变化，所指定集合中有一个文件<u>异常</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>异常</u>变化</li>
</ul>
<blockquote>
<p>fd_set变量定义相关宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span><span class="comment">//将 fd_set 变量的所有位都清零</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将 fd_set 变量的某个位置 1（向 fd_set 添加一个文件描述符）， fd：要加入的文件描述符</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将 fd_set 变量的某个位清零（向 fd_set 删除一个文件描述符）， fd：要删除的文件描述符</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//测试 fd_set 的某个位是否置 1（判断某个文件是否可以进行操作）， fd：要判断的文件描述符</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>
<p>timeout：超时时间，设为 NULL 表示无限期等待。timeval结构体类型</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"> <span class="keyword">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="keyword">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回值： 0，超时发生，没有任何文件描述符可以进行操作； -1，发生错误；其他值，可以进行操作的文件描述符个数</p>
</li>
</ul>
<blockquote>
<p>select使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret, fd; <span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line">    fd_set readfds; <span class="comment">/* 读操作文件描述符集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span> <span class="comment">/* 超时结构体 */</span></span><br><span class="line">    fd = open(<span class="string">&quot;dev_xxx&quot;</span>, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line">    FD_ZERO(&amp;readfds); <span class="comment">/* 清除 readfds */</span></span><br><span class="line">    FD_SET(fd, &amp;readfds); <span class="comment">/* 将 fd 添加到 readfds 里面 */</span></span><br><span class="line">    <span class="comment">/* 构造超时时间 */</span></span><br><span class="line">    timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">500000</span>; <span class="comment">/* 500ms */</span></span><br><span class="line">    ret = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 超时 */</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* 错误 */</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 可以读取数据 */</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; <span class="comment">/* 判断是否为 fd 文件描述符 */</span></span><br><span class="line">                <span class="comment">/* 使用 read 函数读取数据 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h4>
<p>本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>fds： 要监视的文件描述符集合以及要监视的事件，为结构体<code>pollfd</code>数组类型，<code>pollfd</code>类型定义：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* 请求的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* 返回的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>fd：要监视的文件描述符，如果 fd 无效则 events 监视事件也无效，并且 revents 返回 0</p>
</li>
<li>
<p>events：要监视的事件，类型如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 有数据可以读取</span><br><span class="line">POLLPRI 有紧急的数据需要读取</span><br><span class="line">POLLOUT 可以写数据</span><br><span class="line">POLLERR 指定的文件描述符发生错误</span><br><span class="line">POLLHUP 指定的文件描述符挂起</span><br><span class="line">POLLNVAL 无效的请求</span><br><span class="line">POLLRDNORM 等同于POLLIN</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>revents：返回参数，由 Linux 内核设置具体的返回事件</p>
</li>
</ul>
</li>
<li>
<p>nfds：poll 函数要监视的文件描述符数量</p>
</li>
<li>
<p>timeout：超时时间，单位为 ms</p>
</li>
<li>
<p>返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，即发生事件或错误的文件描述符数量； 0，超时； -1，发生错误，并设置相应的错误码</p>
</li>
</ul>
<blockquote>
<p>poll使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line">    fd = open(filename, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line">    <span class="comment">/* 构造结构体 */</span></span><br><span class="line">    fds.fd = fd;</span><br><span class="line">    fds.events = POLLIN; <span class="comment">/* 监视数据是否可以读取 */</span></span><br><span class="line">    ret = poll(&amp;fds, <span class="number">1</span>, <span class="number">500</span>); <span class="comment">/* 轮询文件是否可操作，超时 500ms */</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123; <span class="comment">/* 数据有效 */</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 读取数据 */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">/* 超时 */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 错误 */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h4>
<p>selcet 和 poll 函数会随着所监听的 fd 数量的增加，而导致效率的降低，且遍历所有的描述符比较浪费时间。epoll 专为处理大并发而准备，一般用于网络编程中。  其相关函数如下：</p>
<p>创建 epoll 句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>size：Linux2.6.8 后此参数已无意义，大于 0 即可</li>
<li>返回值： epoll 句柄，如果为-1 的话表示创建失败</li>
</ul>
<p>向 epoll 句柄中添加要监视的文件描述符以及监视的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>epfd：epoll 句柄（即epoll_create的返回值）</p>
</li>
<li>
<p>op：对 epfd 的操作，可以设置为：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD 向epfd添加文件参数fd表示的描述符</span><br><span class="line">EPOLL_CTL_MOD 修改参数fd的event事件</span><br><span class="line">EPOLL_CTL_DEL 从epfd中删除fd描述符</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fd：要监视的文件描述符</p>
</li>
<li>
<p>event：要监视的事件类型，epoll_event结构体指针类型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* epoll 事件 */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>events：要监视的事件：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN 有数据可以读取</span><br><span class="line">EPOLLPRI 有紧急的数据需要读取</span><br><span class="line">EPOLLOUT 可以写数据</span><br><span class="line">EPOLLERR 指定的文件描述符发生错误</span><br><span class="line">EPOLLHUP 指定的文件描述符挂起</span><br><span class="line">EPOLLET 设置epoll为边沿触发（默认为水平触发）</span><br><span class="line">EPOLLONESHOT 一次性监视（当监视完成以后需要再次监视某个fd，就需要将fd重新添加到epoll里面）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>返回值： 0，成功； -1，失败，并设置相应的错误码</p>
</li>
</ul>
<p>等待事件发生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>epfd：epoll 句柄</li>
<li>events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件</li>
<li>maxevents：events 数组大小（必须大于 0）</li>
<li>timeout：超时时间，单位为 ms</li>
<li>返回值： 0，超时； -1，错误；其他值，准备就绪的文件描述符数量</li>
</ul>
<h4 id="驱动中的poll函数"><a class="markdownIt-Anchor" href="#驱动中的poll函数"></a> 驱动中的poll函数</h4>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *filp, struct poll_table_struct *wait)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>filp： 要打开的设备文件(文件描述符)</p>
</li>
<li>
<p>wait： 结构体 poll_table_struct 类型指针， 由应用程序传递进来的。一般将此参数传递给<br>
poll_wait 函数</p>
</li>
<li>
<p>返回值：向应用程序返回设备或者资源状态，可以返回的资源状态如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 有数据可以读取</span><br><span class="line">POLLPRI 有紧急的数据需要读取</span><br><span class="line">POLLOUT 可以写数据</span><br><span class="line">POLLERR 指定的文件描述符发生错误</span><br><span class="line">POLLHUP 指定的文件描述符挂起</span><br><span class="line">POLLNVAL 无效的请求</span><br><span class="line">POLLRDNORM 等同于POLLIN，普通数据可读</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>添加到poll_table：</p>
<p>非阻塞函数，不会引起阻塞，只是将应用程序添加到 poll_table 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>wait_address：要添加到 poll_table 中的等待队列头</li>
<li>p：poll_table，就是file_operations 中 poll 函数的 wait 参数</li>
</ul>
<blockquote>
<p>驱动通用模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxxx_dev</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head_t</span> <span class="title">r_wait</span>;</span> <span class="comment">/* 等待队列头 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">xxx_poll</span><span class="params">(struct file *filp, struct poll_table_struct *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxxx_dev</span> *<span class="title">dev</span> =</span> (struct xxxx_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;r_wait, wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(......) &#123; <span class="comment">/* 相关条件满足 */</span></span><br><span class="line">        mask = POLLIN | POLLRDNORM; <span class="comment">/* 返回 PLLIN */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="异步通知信号"><a class="markdownIt-Anchor" href="#异步通知信号"></a> 异步通知（信号）</h2>
<p>Linux中的信号宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 		1 <span class="comment">/* 终端挂起或控制进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 		2 <span class="comment">/* 终端中断(Ctrl+C 组合键) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 	3 <span class="comment">/* 终端退出(Ctrl+\组合键) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 		4 <span class="comment">/* 非法指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 	5 <span class="comment">/* debug 使用，有断点指令产生 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 	6 <span class="comment">/* 由 abort(3)发出的退出指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 		6 <span class="comment">/* IOT 指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGBUS 		7 <span class="comment">/* 总线错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 		8 <span class="comment">/* 浮点运算错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 	9 <span class="comment">/* 杀死、终止进程 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR1 	10 <span class="comment">/* 用户自定义信号 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV 	11 <span class="comment">/* 段违例(无效的内存段) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR2 	12 <span class="comment">/* 用户自定义信号 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE 	13 <span class="comment">/* 向非读管道写入数据 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM 	14 <span class="comment">/* 闹钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM 	15 <span class="comment">/* 软件终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT 	16 <span class="comment">/* 栈异常 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD 	17 <span class="comment">/* 子进程结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT 	18 <span class="comment">/* 进程继续 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP 	19 <span class="comment">/* 停止进程的执行，只是暂停 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP 	20 <span class="comment">/* 停止进程的运行(Ctrl+Z 组合键) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN 	21 <span class="comment">/* 后台进程需要从终端读取数据 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU 	22 <span class="comment">/* 后台进程需要向终端写数据 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGURG 		23 <span class="comment">/* 有&quot;紧急&quot;数据 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGXCPU 	24 <span class="comment">/* 超过 CPU 资源限制 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGXFSZ 	25 <span class="comment">/* 文件大小超额 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGVTALRM 	26 <span class="comment">/* 虚拟时钟信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPROF 	27 <span class="comment">/* 时钟信号描述 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGWINCH 	28 <span class="comment">/* 窗口大小改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIO 		29 <span class="comment">/* 可以进行输入/输出操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPOLL 	SIGIO</span></span><br><span class="line"><span class="comment">/* #define SIGLOS 29 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPWR 		30 <span class="comment">/* 断点重启 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSYS 		31 <span class="comment">/* 非法的系统调用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 	31 <span class="comment">/* 未使用信号 */</span></span></span><br></pre></td></tr></table></figure>
<p>上述信号中，除了 <code>SIGKILL</code>(9)和 <code>SIGSTOP</code>(19)这两个信号不能被忽略外，其他的信号都可以忽略</p>
<h3 id="应用程序api"><a class="markdownIt-Anchor" href="#应用程序api"></a> 应用程序API</h3>
<p>指定信号的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>signum：要设置处理函数的信号</p>
</li>
<li>
<p>handler： 信号的处理函数，函数原型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回值： 设置成功返回信号的前一个处理函数，设置失败返回 SIG_ERR</p>
</li>
</ul>
<blockquote>
<p>应用程序的一般模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fd = open(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置信号 SIGIO 的处理函数 */</span></span><br><span class="line">signal(SIGIO, sigio_signal_func);</span><br><span class="line"></span><br><span class="line">fcntl(fd, F_SETOWN, getpid()); <span class="comment">/* 将当前进程的进程号告诉给内核 */</span></span><br><span class="line">flags = fcntl(fd, F_GETFD); <span class="comment">/* 获取当前的进程状态 */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);<span class="comment">/* 设置进程状态为 FASYNC 启用异步通知功能（此时会调用驱动中的fasync函数） */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="驱动程序api"><a class="markdownIt-Anchor" href="#驱动程序api"></a> 驱动程序API</h3>
<p>异步相关结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> fa_lock;</span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="keyword">int</span> fa_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fa_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fa_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">fa_rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>向应用程序发送中断信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_fasync</span><span class="params">(struct fasync_struct **fp, <span class="keyword">int</span> sig, <span class="keyword">int</span> band)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>fp：要操作的 fasync_struct 结构体</li>
<li>sig： 要发送的信号</li>
<li>band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT</li>
<li>返回值： 无</li>
</ul>
<p>file_operations操作集中异步接口函数：</p>
<p>应用程序通过<code>fcntl(fd, F_SETFL, flags | FASYNC)</code>改变fasync标记的时候，该函数就会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fasync) (<span class="keyword">int</span> fd, struct file *filp, <span class="keyword">int</span> on)</span><br></pre></td></tr></table></figure>
<p>初始化 fasync_struct 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fasync_helper</span><span class="params">(<span class="keyword">int</span> fd, struct file * filp, <span class="keyword">int</span> on, struct fasync_struct **fapp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>前三个参数与<code>fasync</code>函数中参数一致</li>
<li>fapp：要初始化的 fasync_struct 结构体指针变量</li>
</ul>
<blockquote>
<p>驱动一般模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span> <span class="comment">/* 异步相关结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_fasync</span><span class="params">(<span class="keyword">int</span> fd, struct file *filp, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">dev</span> =</span> (xxx_dev)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; <span class="number">0</span>)<span class="comment">//直接调用该函数即可，不用干其他事</span></span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_ops</span> =</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    .fasync = xxx_fasync,</span><br><span class="line">    .release = xxx_release,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> xxx_fasync(<span class="number">-1</span>, filp, <span class="number">0</span>); <span class="comment">/* 删除异步通知 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="常用框架api"><a class="markdownIt-Anchor" href="#常用框架api"></a> 常用框架API</h2>
<h3 id="platform"><a class="markdownIt-Anchor" href="#platform"></a> platform</h3>
<p>platform设备相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">platform_device_unregister</span><span class="params">(struct platform_device *pdev)</span><span class="comment">//卸载platform设备</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_register</span><span class="params">(struct platform_device *pdev)</span><span class="comment">//注册platform设备</span></span></span><br></pre></td></tr></table></figure>
<p>platform驱动相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">platform_driver_unregister</span><span class="params">(struct platform_driver *drv)</span><span class="comment">//卸载platform驱动</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_driver_register</span> <span class="params">(struct platform_driver *driver)</span><span class="comment">//注册platform驱动</span></span></span><br></pre></td></tr></table></figure>
<h3 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> MISC</h3>
<p>MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。 MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动</p>
<p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。MISC 设备会自动创建 cdev</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">misc_register</span><span class="params">(struct miscdevice * misc)</span><span class="comment">//注册MISC驱动</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">misc_deregister</span><span class="params">(struct miscdevice *misc)</span><span class="comment">//销毁MISC驱动</span></span></span><br></pre></td></tr></table></figure>
<h3 id="input"><a class="markdownIt-Anchor" href="#input"></a> INPUT</h3>
<h4 id="初始化及卸载"><a class="markdownIt-Anchor" href="#初始化及卸载"></a> 初始化及卸载</h4>
<p>申请及释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct input_dev *<span class="title">input_allocate_device</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//申请input_dev</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_free_device</span><span class="params">(struct input_dev *dev)</span><span class="comment">//释放input_dev</span></span></span><br></pre></td></tr></table></figure>
<p>注册及注销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span><span class="comment">//注册</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_unregister_device</span><span class="params">(struct input_dev *dev)</span><span class="comment">//注销</span></span></span><br></pre></td></tr></table></figure>
<p>修改input_dev：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span></span><br><span class="line">inputdev = input_allocate_device(); <span class="comment">/* 申请 input_dev */</span></span><br><span class="line">inputdev-&gt;name = <span class="string">&quot;test_inputdev&quot;</span>; <span class="comment">/* 设置 input_dev 名字 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********第一种设置事件和事件值的方法***********/</span></span><br><span class="line">__set_bit(EV_KEY, inputdev-&gt;evbit); <span class="comment">/* 设置产生按键事件 */</span></span><br><span class="line">__set_bit(EV_REP, inputdev-&gt;evbit); <span class="comment">/* 重复事件 */</span></span><br><span class="line">__set_bit(KEY_0, inputdev-&gt;keybit); <span class="comment">/*设置产生哪些按键值 */</span></span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********第二种设置事件和事件值的方法***********/</span></span><br><span class="line">keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********第三种设置事件和事件值的方法***********/</span></span><br><span class="line">keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册 input_dev */</span></span><br><span class="line">input_register_device(inputdev);</span><br></pre></td></tr></table></figure>
<h4 id="上报数据"><a class="markdownIt-Anchor" href="#上报数据"></a> 上报数据</h4>
<p>上报指定的事件以对应值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：需要上报的 input_dev</li>
<li>type：上报的事件类型，比如 EV_KEY</li>
<li>code：事件码，即注册的按键值，比如 KEY_0、 KEY_1 等等</li>
<li>value：事件值，比如 1 表示按键按下， 0 表示按键松开</li>
</ul>
<p>专用上报函数（本质是调用input_event）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span><span class="comment">//上报按键</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_rel</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_ff_status</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_report_switch</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_mt_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br></pre></td></tr></table></figure>
<p>同步事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="应用层相关"><a class="markdownIt-Anchor" href="#应用层相关"></a> 应用层相关</h4>
<p>应用层通过获得 <code>input_event</code> 结构体来获取input子系统发送的输入事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>time：时间，即此事件发生的时间，timeval 结构体类型：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">__kernel_long_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_long_t</span> <span class="keyword">__kernel_time_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_long_t</span> <span class="keyword">__kernel_suseconds_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="keyword">__kernel_suseconds_t</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>type： 事件类型，比如 EV_KEY 表示此次事件为按键事件</p>
</li>
<li>
<p>code： 事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如： KEY_0、KEY_1等</p>
</li>
<li>
<p>value：值，比如 EV_KEY 事件中 value 就是按键值，为 1 表示按键按下，为 0 的话表示按键没有被按下</p>
</li>
</ul>
<p>应用层读取方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">inputevent</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">err = read(fd, &amp;inputevent, <span class="keyword">sizeof</span>(inputevent));</span><br><span class="line"><span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123; <span class="comment">/* 读取数据成功 */</span></span><br><span class="line">    <span class="keyword">switch</span> (inputevent.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EV_KEY:</span><br><span class="line">            <span class="keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="comment">/* 键盘键值 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;key %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;button %d %s\r\n&quot;</span>, inputevent.code, inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* 其他类型的事件，自行处理 */</span></span><br><span class="line">        <span class="keyword">case</span> EV_REL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_ABS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_MSC:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EV_SW:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取数据失败\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多点触摸"><a class="markdownIt-Anchor" href="#多点触摸"></a> 多点触摸</h4>
<ul>
<li>linux内核中讲解多点电容触摸屏协议文档路径：<code>Documentation/input/multitouch-protocol.txt</code></li>
<li>老版本（2.x 版本）的 linux内核不支持多点电容触摸(Multi-touch，简称 MT)</li>
</ul>
<p>MT 协议分为两种类型：</p>
<ul>
<li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)</li>
<li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，一般的多点电容触摸屏 IC 都有此能力</li>
</ul>
<h5 id="type-a"><a class="markdownIt-Anchor" href="#type-a"></a> Type A</h5>
<p>步骤（时序）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//上报第一个点的x坐标 input_report_abs()</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报第一个点的y坐标</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">// input_mt_sync()</span></span><br><span class="line"></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//上报第二个点的x坐标 input_report_abs()</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//上报第二个点的y坐标</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">// input_mt_sync()</span></span><br><span class="line"></span><br><span class="line">SYN_REPORT<span class="comment">// input_sync() 该轮数据发送完毕</span></span><br></pre></td></tr></table></figure>
<p>例子：drivers/input/touchscreen/st1232.c</p>
<h5 id="type-b"><a class="markdownIt-Anchor" href="#type-b"></a> Type B</h5>
<p>步骤（时序）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT <span class="number">0</span><span class="comment">// input_mt_slot()</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span><span class="comment">// input_mt_report_slot_state()</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//上报第一个点的x坐标 input_report_abs()</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报第一个点的y坐标</span></span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span><span class="comment">// input_mt_slot()</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span><span class="comment">// input_mt_report_slot_state()</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//上报第二个点的x坐标 input_report_abs()</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//上报第二个点的y坐标</span></span><br><span class="line"></span><br><span class="line">SYN_REPORT<span class="comment">// input_sync() 该轮数据发送完毕</span></span><br></pre></td></tr></table></figure>
<p>例子：drivers/input/touchscreen/ili210x.c</p>
<p>相关函数：</p>
<p>初始化 MT 的输入 slots（初始化时使用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_mt_init_slots</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> num_slots, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev</p>
</li>
<li>
<p>num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量</p>
</li>
<li>
<p>flags： 其他一些 flags 信息</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MT_POINTER 0x0001 <span class="comment">/* pointer device, e.g. trackpad */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MT_DIRECT 0x0002 <span class="comment">/* direct device, e.g. touchscreen */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MT_DROP_UNUSED0x0004 <span class="comment">/* drop contacts not seen in frame */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MT_TRACK 0x0008 <span class="comment">/* use in-kernel tracking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_MT_SEMI_MT 0x0010 <span class="comment">/* semi-mt device, finger count handled manually */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回值： 0，成功；负值，失败</p>
</li>
</ul>
<p>产生 ABS_MT_SLOT 事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_mt_slot</span><span class="params">(struct input_dev *dev, <span class="keyword">int</span> slot)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点</li>
</ul>
<p>产生ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_mt_report_slot_state</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> tool_type, <span class="keyword">bool</span> active)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>tool_type：上报触摸工具类型（即ABS_MT_TOOL_TYPE事件），目前的协议支持MT_TOOL_FINGER(手指)、 MT_TOOL_PEN(笔)和 MT_TOOL_PALM(手掌)</li>
<li>active：true，连续触摸，添加一个新的触摸点，linux 内核自动分配一个 ABS_MT_TRACKING_ID；false，触摸点抬起，移除一个触摸点，ABS_MT_TRACKING_ID由内核设为-1</li>
</ul>
<p>上传真实的触摸点数量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_mt_report_pointer_emulation</span><span class="params">(struct input_dev *dev, <span class="keyword">bool</span> use_count)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev： MT 设备对应的 input_dev</li>
<li>use_count：true，有效的触摸点数量（上报数量就是当前数模点数量）； false，追踪到的触摸点数量多于当前上报的数量（使用 BTN_TOOL_TAP     事件通知用户空间当前追踪到的触摸点总数量）</li>
<li>举个例子：硬件能够追踪5个触摸点，无论是否有触摸，硬件都会有5个值输出，此时use_count就是false，即无论触摸的数量为多少，追踪到的（硬件输出的5个值）总比上报的（真实触摸数量）多</li>
</ul>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">ft5x06_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span></span><br><span class="line">	ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 上报每一个触摸点坐标 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">		u8 *buf = &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span></span><br><span class="line"><span class="comment">		 * bit5:4  保留</span></span><br><span class="line"><span class="comment">		 * bit3:0  X轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		type = buf[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>;     <span class="comment">/* 获取触摸类型 */</span></span><br><span class="line">		<span class="keyword">if</span> (type == TOUCH_EVENT_RESERVED)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span></span><br><span class="line">		x = ((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">3</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		y = ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span></span><br><span class="line"><span class="comment">		 * bit3:0  Y轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		id = (buf[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">		down = type != TOUCH_EVENT_UP;<span class="comment">//是否按下 1：按下 0：松开</span></span><br><span class="line"></span><br><span class="line">		input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">		input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!down)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_mt_report_pointer_emulation(multidata-&gt;input, <span class="literal">true</span>);</span><br><span class="line">	input_sync(multidata-&gt;input);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="framebuffer"><a class="markdownIt-Anchor" href="#framebuffer"></a> Framebuffer</h3>
<p>fb_info结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct fb_info *<span class="title">framebuffer_alloc</span><span class="params">(<span class="keyword">size_t</span> size, struct device *dev)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_release</span><span class="params">(struct fb_info *info)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>size：分配完framebuffer结构体后附加的额外空间（一般用于存放用户私有数据）</li>
<li>dev：最终会绑定到fb_info-&gt;device上，可以设为NULL</li>
</ul>
<p>注册与卸载：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_framebuffer</span><span class="params">(struct fb_info *fb_info)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unregister_framebuffer</span><span class="params">(struct fb_info *fb_info)</span></span></span><br></pre></td></tr></table></figure>
<p>显存分配与释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">dma_alloc_writecombine</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *dma_addr, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dma_free_writecombine</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> dma_addr)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC</h3>
<p>申请并注册rtc_device：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rtc_device *<span class="title">rtc_device_register</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct device *dev, <span class="keyword">const</span> struct rtc_class_ops *ops, struct <span class="keyword">module</span> *owner)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>name：设备名字</li>
<li>dev： 设备</li>
<li>ops： RTC 底层驱动函数集</li>
<li>owner：驱动模块拥有者</li>
</ul>
<p>注销rtc_device：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtc_device_unregister</span><span class="params">(struct rtc_device *rtc)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="iic"><a class="markdownIt-Anchor" href="#iic"></a> IIC</h3>
<p>适配器注册和注销：</p>
<p>一般不会用到，SOC厂商会写好这部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adapter)</span><span class="comment">/* 使用动态总线号 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_numbered_adapter</span><span class="params">(struct i2c_adapter *adap)</span><span class="comment">/* 使用静态总线号 */</span></span></span><br><span class="line"><span class="function"><span class="comment">//注销</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_adapter</span><span class="params">(struct i2c_adapter * adap)</span></span></span><br></pre></td></tr></table></figure>
<p>i2c驱动注册与注销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_add_driver(driver) i2c_register_driver(THIS_MODULE, driver)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_driver</span><span class="params">(struct i2c_driver *driver)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="iic通信"><a class="markdownIt-Anchor" href="#iic通信"></a> iic通信</h4>
<h5 id="内核驱动"><a class="markdownIt-Anchor" href="#内核驱动"></a> 内核驱动</h5>
<p>内核文档：<code>Documentation\i2c\i2c-protocol</code>、<code>Documentation\i2c\smbus-protocol</code></p>
<p>其中smbus-protocol是i2c-protocol的一个子集，官方更加推荐使用后者的smbus-protoco中的函数</p>
<p>收发函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S Addr Rd [A] [Data] NA S Addr Wr [A] Data [A] P</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(struct i2c_adapter *adap, struct i2c_msg *msgs, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>adap： 所使用的 I2C 适配器， i2c_client 会保存其对应的 i2c_adapter</p>
</li>
<li>
<p>msgs： I2C 要发送的一个或多个消息</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">    __u16 addr; <span class="comment">/* 从机地址 */</span></span><br><span class="line">    __u16 flags; <span class="comment">/* 标志 */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN 0x0010</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD 0x0001</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP 0x8000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART 0x4000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR 0x2000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK 0x1000</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK 0x0800</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN 0x0400</span></span><br><span class="line">    __u16 len; <span class="comment">/* 消息(本 msg)长度 */</span></span><br><span class="line">    __u8 *buf; <span class="comment">/* 消息数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>num： 消息数量，即 msgs 的数量</p>
</li>
<li>
<p>返回值： 负值，失败，其他非负值，发送的 msgs 数量</p>
</li>
</ul>
<p>发送函数（最终调用i2c_transfer）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S Addr Wr [A] Data [A] Data [A] ... [A] Data [A] P</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_send</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>client： I2C 设备对应的 i2c_client</li>
<li>buf：要发送的数据</li>
<li>count： 要发送的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li>
<li>返回值： 负值，失败，其他非负值，发送的字节数</li>
</ul>
<p>接收函数（最终调用i2c_transfer）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_recv</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>client： I2C 设备对应的 i2c_client</li>
<li>buf：要接收的数据</li>
<li>count： 要接收的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li>
<li>返回值： 负值，失败，其他非负值，发送的字节数</li>
</ul>
<p>smbus-protoco中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i2c_smbus_read_byte()<span class="comment">//S Addr Rd [A] [Data] NA P</span></span><br><span class="line">i2c_smbus_write_byte()<span class="comment">//S Addr Wr [A] Data [A] P</span></span><br><span class="line">i2c_smbus_read_byte_data()<span class="comment">//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] NA P</span></span><br><span class="line">i2c_smbus_read_word_data()<span class="comment">//S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P</span></span><br><span class="line">i2c_smbus_write_byte_data()<span class="comment">//S Addr Wr [A] Comm [A] Data [A] P</span></span><br><span class="line">i2c_smbus_write_word_data()<span class="comment">//S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] P</span></span><br><span class="line">i2c_smbus_read_block_data()<span class="comment">//S Addr Wr [A] Comm [A] S Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA P</span></span><br><span class="line">i2c_smbus_write_block_data()<span class="comment">//S Addr Wr [A] Comm [A] Count [A] Data [A] Data [A] ... [A] Data [A] P</span></span><br><span class="line">i2c_smbus_read_i2c_block_data()<span class="comment">//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P</span></span><br><span class="line">i2c_smbus_write_i2c_block_data()<span class="comment">//S Addr Wr [A] Comm [A] Data [A] Data [A] ... [A] Data [A] P</span></span><br></pre></td></tr></table></figure>
<h5 id="应用层直接访问"><a class="markdownIt-Anchor" href="#应用层直接访问"></a> 应用层直接访问</h5>
<p>内核文档：<code>Documentation\i2c\dev-interface</code></p>
<p>通常，I2C设备由设备驱动来控制，但是通过/dev接口也可以提供用户空间直接访问适配器上的设备。前提是需要加载I2C-DEV内核模块</p>
<p>在应用层，<a target="_blank" rel="noopener" href="https://i2c.wiki.kernel.org/index.php/I2C_Tools">i2c-tools工具包</a>帮你写好了接口，<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/">下载链接</a>，<a target="_blank" rel="noopener" href="http://jdelvare.nerim.net/mirror/i2c-tools/">镜像仓库</a>，只需要包含该库的头文件<code>include\linux\i2c-dev.h</code>即可直接控制iic（最新版本的4.1没有发现该文件）。其本质是调用的内核自带的驱动模块I2C-DEV。该模块位于<code>\drivers\i2c\i2c-dev.c</code>，通过宏<code>CONFIG_I2C_CHARDEV</code>配置，内核menuconfig路径为<code>Device Drivers-&gt; I2C support</code>，一般默认为通过模块加载</p>
<p>i2c-tools工具包的本质是通过调用<code>ioctl</code>打开实现各种功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include\linux\i2c-dev.h部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __s32 <span class="title">i2c_smbus_access</span><span class="params">(<span class="keyword">int</span> file, <span class="keyword">char</span> read_write, __u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_smbus_ioctl_data</span> <span class="title">args</span>;</span></span><br><span class="line"></span><br><span class="line">    args.read_write = read_write;</span><br><span class="line">    args.command = command;</span><br><span class="line">    args.size = size;</span><br><span class="line">    args.data = data;</span><br><span class="line">    <span class="keyword">return</span> ioctl(file,I2C_SMBUS,&amp;args);<span class="comment">//本质就是调用ioctl</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __s32 <span class="title">i2c_smbus_write_quick</span><span class="params">(<span class="keyword">int</span> file, __u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_smbus_access(file,value,<span class="number">0</span>,I2C_SMBUS_QUICK,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述部分源码中file就是需要访问的iic控制器，如：<code>/dev/i2c-0</code>，与自己写的驱动程序类似</p>
<h4 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">void</span> *private_data; <span class="comment">/* 私有数据，一般会设置为 i2c_client */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读取 I2C 设备多个寄存器数据</span></span><br><span class="line"><span class="comment">* @param – dev : I2C 设备</span></span><br><span class="line"><span class="comment">* @param – reg : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 读取到的数据</span></span><br><span class="line"><span class="comment">* @param – len : 要读取的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_read_regs</span><span class="params">(struct xxx_dev *dev, u8 reg, <span class="keyword">void</span> *val, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (struct i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr; <span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>; <span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">    msg[<span class="number">0</span>].buf = &amp;reg; <span class="comment">/* 读取的首地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">1</span>; <span class="comment">/* reg 长度 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr; <span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD; <span class="comment">/* 标记为读取数据 */</span></span><br><span class="line">    msg[<span class="number">1</span>].buf = val; <span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">    msg[<span class="number">1</span>].len = len; <span class="comment">/* 要读取的数据长度 */</span></span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 向 I2C 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment">* @param – dev : 要写入的设备结构体</span></span><br><span class="line"><span class="comment">* @param – reg : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment">* @param – val : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment">* @param – len : 要写入的数据长度</span></span><br><span class="line"><span class="comment">* @return : 操作结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> s32 <span class="title">xxx_write_regs</span><span class="params">(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 b[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (struct i2c_client *)</span><br><span class="line">        dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = reg; <span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len); <span class="comment">/* 将要发送的数据拷贝到数组 b 里面 */</span></span><br><span class="line"></span><br><span class="line">    msg.addr = client-&gt;addr; <span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg.flags = <span class="number">0</span>; <span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">    msg.buf = b; <span class="comment">/* 要发送的数据缓冲区 */</span></span><br><span class="line">    msg.len = len + <span class="number">1</span>; <span class="comment">/* 要发送的数据长度 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spi"><a class="markdownIt-Anchor" href="#spi"></a> SPI</h3>
<p>spi_master注册和注销：</p>
<p>一般不会用到，SOC厂商会写好这部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line"><span class="function">struct spi_master *<span class="title">spi_alloc_master</span><span class="params">(struct device *dev,<span class="keyword">unsigned</span> size)</span><span class="comment">//申请</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spi_register_master</span><span class="params">(struct spi_master *master)</span><span class="comment">//注册 spi_bitbang_start</span></span></span><br><span class="line"><span class="function"><span class="comment">//注销</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_master_put</span><span class="params">(struct spi_master *master)</span><span class="comment">//释放</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_unregister_master</span><span class="params">(struct spi_master *master)</span><span class="comment">//注销 spi_bitbang_stop</span></span></span><br></pre></td></tr></table></figure>
<p>spi驱动注册与注销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spi_register_driver</span><span class="params">(struct spi_driver *sdrv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_unregister_driver</span><span class="params">(struct spi_driver *sdrv)</span></span></span><br></pre></td></tr></table></figure>
<p>相关结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------spi_message-----------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">transfers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>   *<span class="title">spi</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span>        is_dma_mapped:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* REVISIT:  we might want a flag affecting the behavior of the</span></span><br><span class="line"><span class="comment">     * last transfer ... allowing things like &quot;read 16 bit length L&quot;</span></span><br><span class="line"><span class="comment">     * immediately followed by &quot;read L bytes&quot;.  Basically imposing</span></span><br><span class="line"><span class="comment">     * a specific message scheduling algorithm.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Some controller drivers (message-at-a-time queue processing)</span></span><br><span class="line"><span class="comment">     * could provide that as their default scheduling algorithm.  But</span></span><br><span class="line"><span class="comment">     * others (with multi-message pipelines) could need a flag to</span></span><br><span class="line"><span class="comment">     * tell them about such special cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* completion is reported through a callback */</span></span><br><span class="line">    <span class="keyword">void</span>            (*complete)(<span class="keyword">void</span> *context);<span class="comment">/*异步传输完成后，会调用该函数*/</span></span><br><span class="line">    <span class="keyword">void</span>            *context;</span><br><span class="line">    <span class="keyword">unsigned</span>        frame_length;</span><br><span class="line">    <span class="keyword">unsigned</span>        actual_length;</span><br><span class="line">    <span class="keyword">int</span>         status;</span><br><span class="line">    <span class="comment">/* for optional use by whatever driver currently owns the</span></span><br><span class="line"><span class="comment">     * spi_message ...  between calls to spi_async and then later</span></span><br><span class="line"><span class="comment">     * complete(), that&#x27;s the spi_master controller driver.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">queue</span>;</span></span><br><span class="line">    <span class="keyword">void</span>            *state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*-----------------------spi_transfer-----------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">    <span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment">     * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment">     * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment">     *   spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>  *tx_buf;<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">    <span class="keyword">void</span>        *rx_buf;<span class="comment">/* 保存接收到的数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    len;<span class="comment">/* 进行传输的数据长度 */</span></span><br><span class="line">    <span class="keyword">dma_addr_t</span>  tx_dma;</span><br><span class="line">    <span class="keyword">dma_addr_t</span>  rx_dma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span>    cs_change:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>    tx_nbits:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>    rx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_NBITS_SINGLE    0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_NBITS_DUAL      0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_NBITS_QUAD      0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line">    u8      bits_per_word;</span><br><span class="line">    u16     delay_usecs;</span><br><span class="line">    u32     speed_hz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="spi通信"><a class="markdownIt-Anchor" href="#spi通信"></a> spi通信</h4>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spi_setup</span><span class="params">(struct spi_device *spi)</span><span class="comment">//初始化时钟和SPI模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_message_init</span><span class="params">(struct spi_message *m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_message_add_tail</span><span class="params">(struct spi_transfer *t, struct spi_message *m)</span><span class="comment">//将spi_transfer添加到spi_message队列中</span></span></span><br></pre></td></tr></table></figure>
<p>同步传输（阻塞，会等待SPI数据传输完成）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spi_sync</span><span class="params">(struct spi_device *spi, struct spi_message *message)</span></span></span><br></pre></td></tr></table></figure>
<p>异步传输（不会阻塞，不会等到SPI数据传输完成）</p>
<p>异步传输需要设置 spi_message 中的<code>complete</code>成员变量，当 SPI 异步传输完成以后<code>complete</code>函数就会被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spi_async</span><span class="params">(struct spi_device *spi, struct spi_message *message)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI 多字节发送 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spi_send</span><span class="params">(struct spi_device *spi, u8 *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">        .tx_buf = buf,</span><br><span class="line">        .len = len,</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">    spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">    ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* SPI 多字节接收 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">spi_receive</span><span class="params">(struct spi_device *spi, u8 *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">        .rx_buf = buf,</span><br><span class="line">        .len = len,</span><br><span class="line">    &#125;;</span><br><span class="line">    spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">    spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">    ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pwm"><a class="markdownIt-Anchor" href="#pwm"></a> PWM</h3>
<p>设备树绑定内核参考文档：<code>Documentation/devicetree/bindings/pwm/imx-pwm.txt</code></p>
<h2 id="设备树"><a class="markdownIt-Anchor" href="#设备树"></a> 设备树</h2>
<h3 id="通用"><a class="markdownIt-Anchor" href="#通用"></a> 通用</h3>
<h4 id="查找节点"><a class="markdownIt-Anchor" href="#查找节点"></a> 查找节点</h4>
<ol>
<li>
<p>通过名字查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_name</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>name：要查找的节点名字（不是table和name属性）。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li>
<p>通过device_type 属性查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_type</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败。</li>
</ul>
</li>
<li>
<p>根据 device_type 和 compatible查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_compatible_node</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *compatible)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li>
<li>compatible： 要查找的节点所对应的 compatible 属性列表。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>通过 of_device_id 匹配表来查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_matching_node_and_match</span><span class="params">(struct device_node *from, <span class="keyword">const</span> struct of_device_id *matches, <span class="keyword">const</span> struct of_device_id **match)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li>
<li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li>
<li>match： 找到的匹配的 of_device_id。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>通过路径查找</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> struct device_node *<span class="title">of_find_node_by_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>path：带有全路径的节点名，可以使用节点的别名。</li>
<li>返回值： 找到的节点，如果为 NULL 表示查找失败</li>
</ul>
</li>
<li>
<p>查找指定节点的父节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_parent</span><span class="params">(<span class="keyword">const</span> struct device_node *node)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>node：要查找的父节点的节点。</li>
<li>返回值： 找到的父节点。</li>
</ul>
</li>
<li>
<p>查找指定节点的子节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_next_child</span><span class="params">(<span class="keyword">const</span> struct device_node *node, struct device_node *prev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>node：父节点。</li>
<li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li>
<li>返回值： 找到的下一个子节点。</li>
</ul>
</li>
</ol>
<h4 id="提取属性"><a class="markdownIt-Anchor" href="#提取属性"></a> 提取属性</h4>
<ol>
<li>
<p>查找节点中的指定属性</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">property *<span class="title">of_find_property</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> *lenp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>name： 属性名字。</li>
<li>lenp：属性值的字节数，一般为NULL</li>
<li>返回值： 找到的属性。</li>
</ul>
</li>
<li>
<p>获取属性中元素的数量</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_count_elems_of_size</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">int</span> elem_size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 需要统计元素数量的属性名字。</li>
<li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li>
<li>返回值： 得到的属性元素数量。</li>
</ul>
</li>
<li>
<p>从属性中获取指定标号的 u32 类型数据值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_index</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 index, u32 *out_value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>index：要读取的值标号。</li>
<li>out_value：读取到的值</li>
<li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u8 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u16 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u64 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li>
<li>sz： 要读取的数组元素数量。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取只有一个整形值的属性</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8</span><span class="params">(<span class="keyword">const</span> struct device_node *np,<span class="keyword">const</span> <span class="keyword">char</span> *propname, u8 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u16 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 *out_value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64</span><span class="params">(<span class="keyword">const</span> struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, u64 *out_value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_value：读取到的数组值。</li>
<li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li>
</ul>
</li>
<li>
<p>读取属性中字符串值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_string</span><span class="params">(struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">const</span> <span class="keyword">char</span> **out_string)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>proname： 要读取的属性名字。</li>
<li>out_string：读取到的字符串值。</li>
<li>返回值： 0，读取成功，负值，读取失败。</li>
</ul>
</li>
<li>
<p>获取#address-cells 属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_addr_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#address-cells 属性值。</li>
</ul>
</li>
<li>
<p>获取#size-cells 属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_size_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>返回值： 获取到的#size-cells 属性值。</li>
</ul>
</li>
</ol>
<h4 id="其他常用函数"><a class="markdownIt-Anchor" href="#其他常用函数"></a> 其他常用函数</h4>
<ol>
<li>
<p>查看节点的 compatible 属性是否有包含指定的字符串</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_device_is_compatible</span><span class="params">(<span class="keyword">const</span> struct device_node *device, <span class="keyword">const</span> <span class="keyword">char</span> *compat)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>device：设备节点。</li>
<li>compat：要查看的字符串。</li>
<li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li>
</ul>
</li>
<li>
<p>获取地址相关属性</p>
<p>主要是“reg”或者“assigned-addresses”属性值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> __be32 *<span class="title">of_get_address</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index, u64 *size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>index：要读取的地址标号。</li>
<li>size：地址长度。</li>
<li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li>
<li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li>
</ul>
</li>
<li>
<p>将从设备树读取到的地址转换为物理地址</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">of_translate_address</span><span class="params">(struct device_node *dev, <span class="keyword">const</span> __be32 *in_addr)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>in_addr：要转换的地址。</li>
<li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li>
</ul>
</li>
<li>
<p>从设备树里面提取资源值</p>
<p>本质上是将 reg 属性值转换为 resource 结构体类型</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_address_to_resource</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index, struct resource *r)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev：设备节点。</li>
<li>index：地址资源标号。</li>
<li>r：得到的 resource 类型的资源值。</li>
<li>返回值： 0，成功；负值，失败。</li>
</ul>
</li>
<li>
<p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p>
<p>本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">of_iomap</span><span class="params">(struct device_node *np, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li>
<li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li>
</ul>
</li>
</ol>
<h3 id="gpio子系统"><a class="markdownIt-Anchor" href="#gpio子系统"></a> GPIO子系统</h3>
<h4 id="of函数"><a class="markdownIt-Anchor" href="#of函数"></a> of函数</h4>
<ol>
<li>
<p>获取设备树某个属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_gpio_named_count</span><span class="params">(struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>np：设备节点。</li>
<li>propname：要统计的 GPIO 属性。</li>
<li>返回值： 正值，统计到的 GPIO 数量；负值，失败。</li>
</ul>
</li>
<li>
<p>获取设备树<code>gpios</code>属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_gpio_count</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取 GPIO 编号</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_get_named_gpio</span><span class="params">(struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO 的编号，如果只有一个 GPIO 信息的话此参数为 0</li>
</ul>
</li>
</ol>
<h4 id="驱动层函数"><a class="markdownIt-Anchor" href="#驱动层函数"></a> 驱动层函数</h4>
<ol>
<li>
<p>申请GPIO</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_request</span><span class="params">(<span class="keyword">unsigned</span> gpio, <span class="keyword">const</span> <span class="keyword">char</span> *label)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>gpio：要申请的 gpio 标号，使用 <code>of_get_named_gpio</code> 函数返回值</li>
<li>label：给 gpio 设置个名字。</li>
<li>返回值： 0，申请成功；其他值，申请失败。</li>
</ul>
</li>
<li>
<p>释放GPIO</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpio_free</span><span class="params">(<span class="keyword">unsigned</span> gpio)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置方向</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_direction_input</span><span class="params">(<span class="keyword">unsigned</span> gpio)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_direction_output</span><span class="params">(<span class="keyword">unsigned</span> gpio, <span class="keyword">int</span> value)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值： 0，设置成功；负值，设置失败</li>
</ul>
</li>
<li>
<p>设置值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gpio_get_value __gpio_get_value</span></span><br><span class="line"><span class="keyword">int</span> __gpio_get_value(<span class="keyword">unsigned</span> gpio)</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值： 非负值，得到的 GPIO 值；负值，获取失败</li>
</ul>
</li>
<li>
<p>获取值</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gpio_set_value __gpio_set_value</span></span><br><span class="line"><span class="keyword">void</span> __gpio_set_value(<span class="keyword">unsigned</span> gpio, <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取 gpio 对应的中断号</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_to_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>gpio： 要获取的 GPIO 编号</li>
<li>返回值： GPIO 对应的中断号</li>
</ul>
</li>
</ol>
<h3 id="中断相关"><a class="markdownIt-Anchor" href="#中断相关"></a> 中断相关</h3>
<p>提取 interrupts 属性中的中断号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_of_parse_and_map</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>dev： 设备节点</li>
<li>index：索引号， interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息</li>
<li>返回值：中断号</li>
</ul>
<p>获取 gpio 对应的中断号（与上面的函数功能一样）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_to_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>gpio： 要获取的 GPIO 编号，由<code>gpio_request</code>申请而来</li>
<li>返回值： GPIO 对应的中断号</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2020/04/06/Linux%E9%A9%B1%E5%8A%A8%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/">http://nu-ll.github.io/2020/04/06/Linux驱动常用API整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A9%B1%E5%8A%A8API/">驱动API</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/28/ESP8266/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ESP8266</div></div></a></div><div class="next-post pull-right"><a href="/2020/03/28/Linux%E4%B8%8A%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"><img class="next-cover" data-lazy-src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux上常见服务搭建</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/spaceman.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">spaceman</div><div class="author-info__description">CtrlC CtrlV大师</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NU-LL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">白嫖一时爽，一直白嫖一直爽</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89"><span class="toc-text"> 并发与竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text"> 原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text"> 自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text"> 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-text"> 互斥体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-text"> 字符设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%8F"><span class="toc-text"> 常用宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80"><span class="toc-text"> 注册与注销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-text"> 设备节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-text"> 设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-text"> 用户空间与内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-text"> 地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text"> Linux常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text"> 内核定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text"> 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%8D%8A%E9%83%A8"><span class="toc-text"> 上半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7"><span class="toc-text"> 申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-text"> 释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text"> 中断处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD%E4%B8%8E%E7%A6%81%E6%AD%A2"><span class="toc-text"> 使能与禁止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-text"> 下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-text"> 软中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet"><span class="toc-text"> tasklet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text"> 工作队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text"> 阻塞与非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-text"> 等待队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%A4%B4"><span class="toc-text"> 等待队列头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E9%A1%B9"><span class="toc-text"> 等待队列项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-text"> 添加&#x2F;移除等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92"><span class="toc-text"> 等待唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6"><span class="toc-text"> 等待事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-text"> 轮询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-text"> select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-text"> poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-text"> epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84poll%E5%87%BD%E6%95%B0"><span class="toc-text"> 驱动中的poll函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%BF%A1%E5%8F%B7"><span class="toc-text"> 异步通知（信号）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8Fapi"><span class="toc-text"> 应用程序API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8Fapi"><span class="toc-text"> 驱动程序API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6api"><span class="toc-text"> 常用框架API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#platform"><span class="toc-text"> platform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#misc"><span class="toc-text"> MISC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input"><span class="toc-text"> INPUT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%8D%B8%E8%BD%BD"><span class="toc-text"> 初始化及卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E6%95%B0%E6%8D%AE"><span class="toc-text"> 上报数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%B8%E5%85%B3"><span class="toc-text"> 应用层相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8"><span class="toc-text"> 多点触摸</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#type-a"><span class="toc-text"> Type A</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#type-b"><span class="toc-text"> Type B</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#framebuffer"><span class="toc-text"> Framebuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rtc"><span class="toc-text"> RTC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iic"><span class="toc-text"> IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iic%E9%80%9A%E4%BF%A1"><span class="toc-text"> iic通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8"><span class="toc-text"> 内核驱动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-text"> 应用层直接访问</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi"><span class="toc-text"> SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spi%E9%80%9A%E4%BF%A1"><span class="toc-text"> spi通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-text"> 模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwm"><span class="toc-text"> PWM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text"> 设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-text"> 通用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text"> 查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="toc-text"> 提取属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text"> 其他常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text"> GPIO子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#of%E5%87%BD%E6%95%B0"><span class="toc-text"> of函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%B1%82%E5%87%BD%E6%95%B0"><span class="toc-text"> 驱动层函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3"><span class="toc-text"> 中断相关</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/12/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="conda常用命令">conda常用命令</a><time datetime="2021-04-12T08:47:06.096Z" title="发表于 2021-04-12 16:47:06">2021-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/02/lidar%E6%91%84%E5%83%8F%E5%A4%B4%E8%9E%8D%E5%90%88/" title="lidar摄像头融合">lidar摄像头融合</a><time datetime="2021-04-02T02:50:34.000Z" title="发表于 2021-04-02 10:50:34">2021-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/01/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="C++设计模式">C++设计模式</a><time datetime="2021-04-01T13:36:25.000Z" title="发表于 2021-04-01 21:36:25">2021-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/31/%E4%B9%90%E8%A7%86%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="乐视深度相机使用指南">乐视深度相机使用指南</a><time datetime="2021-03-31T04:19:14.000Z" title="发表于 2021-03-31 12:19:14">2021-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/12/%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE%E8%9E%8D%E5%90%88%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/" title="毫米波雷达融合相关论文">毫米波雷达融合相关论文</a><time datetime="2021-03-12T06:41:42.000Z" title="发表于 2021-03-12 14:41:42">2021-03-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By spaceman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> <iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tx&color=eee" frameborder="0" allowtransparency="false" align="middle" height="20"></iframe></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>