<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | spaceman</title><meta name="keywords" content="数据结构,算法"><meta name="author" content="spaceman"><meta name="copyright" content="spaceman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、基础排序 对于排序这个问题来说，最优的时间复杂度在O(N∗logN)O(N*logN)O(N∗logN)级别的 常用排序算法时间复杂度：    排序算法 平均时间复杂度 原地排序 空间复杂度 稳定性     冒泡排序 O(n2)O(n^2)O(n2)  O(1)O(1)O(1) √   选择排序 O(n2)O(n^2)O(n2)  O(1)O(1)O(1) ×   插入排序 O(n2)O(n^">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://nu-ll.github.io/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="spaceman">
<meta property="og:description" content="一、基础排序 对于排序这个问题来说，最优的时间复杂度在O(N∗logN)O(N*logN)O(N∗logN)级别的 常用排序算法时间复杂度：    排序算法 平均时间复杂度 原地排序 空间复杂度 稳定性     冒泡排序 O(n2)O(n^2)O(n2)  O(1)O(1)O(1) √   选择排序 O(n2)O(n^2)O(n2)  O(1)O(1)O(1) ×   插入排序 O(n2)O(n^">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg">
<meta property="article:published_time" content="2021-01-07T01:22:45.000Z">
<meta property="article:modified_time" content="2021-02-27T14:42:51.756Z">
<meta property="article:author" content="spaceman">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://nu-ll.github.io/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-27 22:42:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/spaceman.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">spaceman</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/todo/"><i class="fa-fw fas fa-list"></i><span> 清单</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-07T01:22:45.000Z" title="发表于 2021-01-07 09:22:45">2021-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-27T14:42:51.756Z" title="更新于 2021-02-27 22:42:51">2021-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>121分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、基础排序">一、基础排序</h2>
<p>对于排序这个问题来说，最优的时间复杂度在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>级别的</p>
<p>常用排序算法时间复杂度：</p>
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">原地排序</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><strong>插入排序</strong></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><strong>快速排序</strong></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><strong>归并排序</strong></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">×</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><strong>堆排序</strong></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>稳定排序：对于相等的元素，在排序后，这几个相等元素中原来靠前的元素依然靠前。即，相等元素的相对位置没有发生改变。</p>
<ul>
<li>可以通过自定义比较函数，让排序算法不存在稳定性的问题</li>
</ul>
<h3 id="0-冒泡排序">0.冒泡排序</h3>
<p>该算法重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>该算法每次遍历都将最大的元素放到了最后（默认从小到大排序）</p>
<p>步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/bubbleSort.b7d216a5.gif" alt="动图演示"></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">( T arr[] , <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[i<span class="number">-1</span>] &gt; arr[i] )&#123;</span><br><span class="line">                <span class="built_in">swap</span>( arr[i<span class="number">-1</span>] , arr[i] );</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优化, 每一趟Bubble Sort都将最大的元素放在了最后的位置</span></span><br><span class="line">        <span class="comment">// 所以下一次排序, 最后的元素可以不再考虑</span></span><br><span class="line">        n --;</span><br><span class="line">    &#125;<span class="keyword">while</span>(swapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort2</span><span class="params">( T arr[] , <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> newn; <span class="comment">// 使用newn进行优化</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        newn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[i<span class="number">-1</span>] &gt; arr[i] )&#123;</span><br><span class="line">                <span class="built_in">swap</span>( arr[i<span class="number">-1</span>] , arr[i] );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录最后一次的交换位置,在此之后的元素在下一轮扫描中均不考虑</span></span><br><span class="line">                newn = i;</span><br><span class="line">            &#125;</span><br><span class="line">        n = newn;</span><br><span class="line">    &#125;<span class="keyword">while</span>(newn &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-选择排序">1.选择排序</h3>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<p>步骤：</p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/selectionSort.44be35da.gif" alt="动图演示"></p>
<p>基本思路（从小到大）：</p>
<ol>
<li>找到未排序的整个序列中最小的元素</li>
<li>与未排序序列中的第一个元素进行交换</li>
<li>重复上述过程直至结束</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107112741185.png" alt="选择排序1"></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107113302167.png" alt="选择排序2"></p>
<ul>
<li>2之后最小的元素是3</li>
<li>将3与2号（0号开始）元素进行交换</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;<span class="comment">// arr：输入输出数组 n：数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minIndex = i;<span class="comment">// 当前最小值索引</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[minIndex] )</span><br><span class="line">                minIndex = j;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>( arr[i] , arr[minIndex] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>任何情况下，该算法的两层循环都必须全部执行完，所以效率<strong>较低</strong></li>
</ul>
<h4 id="改进">改进</h4>
<p>在每一轮中, 可以同时找到当前未处理元素的最大值和最小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> minIndex = left;</span><br><span class="line">        <span class="type">int</span> maxIndex = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在每一轮查找时, 要保证arr[minIndex] &lt;= arr[maxIndex]</span></span><br><span class="line">        <span class="keyword">if</span>(arr[minIndex] &gt; arr[maxIndex])</span><br><span class="line">            <span class="built_in">swap</span>(arr[minIndex], arr[maxIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left + <span class="number">1</span> ; i &lt; right; i ++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[minIndex])</span><br><span class="line">                minIndex = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])</span><br><span class="line">                maxIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(arr[left], arr[minIndex]);</span><br><span class="line">        <span class="built_in">swap</span>(arr[right], arr[maxIndex]);</span><br><span class="line"></span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-插入排序">2.插入排序</h3>
<p>步骤：</p>
<ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/insertionSort.be81c151.gif" alt="动图演示"></p>
<h4 id="基本实现">基本实现</h4>
<p>基本思路（从小到大）：将当前未排序元素放入前面已经排好序的元素中合适的位置（0号元素可以不考虑）</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107113846104.png" alt="插入排序1"></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107113910440.png" alt="插入排序2"></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107113927060.png" alt="插入排序3"></p>
<ol>
<li>3比前面元素8小，所以交换位置</li>
<li>3又比6小，交换位置</li>
<li>此时位置合适</li>
</ol>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;<span class="comment">// 0号元素不用考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        <span class="comment">// 写法1</span></span><br><span class="line"><span class="comment">//        for( int j = i ; j &gt; 0 ; j-- )</span></span><br><span class="line"><span class="comment">//            if( arr[j] &lt; arr[j-1] )</span></span><br><span class="line"><span class="comment">//                swap( arr[j] , arr[j-1] );</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写法2</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> j = i ; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>] ; j -- )</span><br><span class="line">            <span class="built_in">swap</span>( arr[j] , arr[j<span class="number">-1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内层循环可以提前终止，所以插入排序理论上来说比选择排序更快一些</li>
<li>但是该方法交换部分和比较操作来比更为费时（一次交换需要3次赋值），所以导致该算法比之前插入排序费时</li>
</ul>
<h4 id="优化">优化</h4>
<p>优化思路：将之前的多次交换操作变为一次赋值操作</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107124617708.png" alt="插入排序-优化1"></p>
<ul>
<li>先保存当前要排序的一个副本</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107125539606.png" alt="插入排序-优化2"></p>
<ul>
<li>比较当前副本和其位置之前的元素8，发现比8小，将8挪到当前3的位置上</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107130631577.png" alt="插入排序-优化3"></p>
<ul>
<li>假设将副本中的元素放到8的位置，此时需要和8的前一个元素6进行比较，发现比6小，将6移到8的位置上去</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107125015763.png" alt="插入排序-优化4"></p>
<ul>
<li>再将3放到原来6的位置上去，此时发现3比2大</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210107124227405.png" alt="插入排序-优化5"></p>
<ul>
<li>此时位置正确，放入3</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 寻找元素arr[i]合适的插入位置</span></span><br><span class="line">        T e = arr[i];<span class="comment">// 保存待排序的元素</span></span><br><span class="line">        <span class="type">int</span> j; <span class="comment">// j保存元素e应该插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; e; j--)</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];<span class="comment">// 将前一个元素向后挪动</span></span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时插入排序效率会比选择排序效率高（会提前终止内层循环，尤其是有重复数据或近乎有序的数据时）</li>
<li>对于一个<strong>近乎有序</strong>的数据来说，插入排序的效率要<strong>远远高于</strong>选择排序，此时时间复杂度接近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="3-希尔排序">3.希尔排序</h3>
<p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法</p>
<p>希尔排序是把序列按一定增量h来分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至 1 时，整个序列恰被分成一组，算法便终止。</p>
<p>步骤：</p>
<ol>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p>图例：</p>
<p>这里选择增量h=length/2，缩小增量继续以h= h/2的方式，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，{n/2,(n/2)/2…1}增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处示例使用希尔增量</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/562c11dfa9ec8a136327c52c9d49868fa0ec09fa6aee.jpg" alt="希尔排序"></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( h &lt; n/<span class="number">3</span> )</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( h &gt;= <span class="number">1</span> )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = h ; i &lt; n ; i ++ )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span></span><br><span class="line">            T e = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )</span><br><span class="line">                arr[j] = arr[j-h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该增量序列是最优的序列，此时时间复杂度可以达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="二、高级排序">二、高级排序</h2>
<p>该章中的算法时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h3 id="1-归并排序">1.归并排序</h3>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和<strong>选择排序</strong>一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为<strong>始终</strong>都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度。代价是需要额外的内存空间，由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/mergeSort.9541d116.gif" alt="动图演示——迭代"></p>
<h4 id="自顶向下——递归">自顶向下——递归</h4>
<p>实现：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E8%BF%87%E7%A8%8B.bmp" alt="归并过程"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="type">void</span> __merge(T arr[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="comment">//* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间</span></span><br><span class="line">    <span class="comment">//* 使用VS的请使用new的方式申请aux空间</span></span><br><span class="line">    <span class="comment">//* 使用new申请空间, 不要忘了在__merge函数的最后 delete 掉申请的空间:)</span></span><br><span class="line">    T aux[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//T *aux = new T[r-l+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = l ; i &lt;= r; i ++ )</span><br><span class="line">        aux[i-l] = arr[i];<span class="comment">// 拷贝一份副本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> k = l ; k &lt;= r; k ++ )&#123;<span class="comment">//k指向最终的目的地中的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; mid )&#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r )&#123;  <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( aux[i-l] &lt; aux[j-l] ) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[i-l]; i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[j-l]; j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete[] aux;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归使用归并排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __mergeSort(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, l, mid);<span class="comment">//递归排序左半部分</span></span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, r);<span class="comment">//递归排序右半部分</span></span><br><span class="line">    __merge(arr, l, mid, r);<span class="comment">//归并操作：真正的排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>该方法在有序列表中会远远慢于插入算法，但是通过以下优化在一定程度上缓解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __mergeSort(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="comment">// 优化2: 对于小规模数组, 使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        <span class="built_in">insertionSort</span>(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, l, mid);</span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">    <span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] &gt; arr[mid+<span class="number">1</span>] )</span><br><span class="line">        __merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="自底向上——迭代">自底向上——迭代</h4>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自底向上的归并排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort Bottom Up 无优化版本</span></span><br><span class="line"><span class="comment">//    for( int sz = 1; sz &lt; n ; sz += sz )// 每次归并的最小单位中的元素个数</span></span><br><span class="line"><span class="comment">//        for( int i = 0 ; i &lt; n - sz ; i += sz+sz )// 每次归并两个最小单位，其中i+sz&lt;n保证了后一个最小单位的存在，无论其多长</span></span><br><span class="line"><span class="comment">//            // 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并</span></span><br><span class="line"><span class="comment">//            __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );// 真正归并，min()是为了防止第二个最小单位过短</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort Bottom Up 优化</span></span><br><span class="line">    <span class="comment">// 对于小数组, 使用插入排序优化</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">16</span> )</span><br><span class="line">        <span class="built_in">insertionSort</span>(arr,i,<span class="built_in">min</span>(i+<span class="number">15</span>,n<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> sz = <span class="number">16</span>; sz &lt; n ; sz += sz )</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n - sz ; i += sz+sz )</span><br><span class="line">            <span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">            <span class="keyword">if</span>( arr[i+sz<span class="number">-1</span>] &gt; arr[i+sz] )</span><br><span class="line">                __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>,n<span class="number">-1</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环</span></span><br><span class="line">    <span class="comment">// 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据</span></span><br><span class="line">    <span class="comment">// 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该算法中未使用数组的索引特点，所以适合<strong>链表</strong>使用</li>
</ul>
<h4 id="性能区别">性能区别</h4>
<blockquote>
<p>自底向上（<strong>迭代</strong>）的归并排序，是比自顶向下（递归）的归并排序<strong>要快</strong>的</p>
</blockquote>
<p>上述两种对归并排序中主要存在两个可以优化的地方：</p>
<ul>
<li>使用插入排序对小数组进行处理。这个优化对两个算法的作用是相同的</li>
<li>判断两个序列是否需要真正的归并</li>
</ul>
<p>注意：在自顶向下的归并排序中，后一个优化可以发生在非常高的层次，也就是面对两个很大的数组，可以通过这步优化，使得不需要进一步处理两个大数组！但是在自底向上的归并排序中却不能跨过具有这种性质的大数组。由于这个原因，自底向上的归并排序的速度被拖慢了！</p>
<p>另外，虽然递归调用确实会有额外的开销，但是在现代计算机上，对于最新的C++编译器，对此都会有所优化</p>
<h3 id="2-快速排序">2.快速排序</h3>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法</p>
<p>步骤：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）（一般为第一个元素）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/quickSort.71c0f1c0.gif" alt="动图演示"></p>
<p>实现：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210108222153588.png" alt="分区(partition)操作"></p>
<ul>
<li>比较i处元素e和v的大小，并将e放到对应位置，之后i++，指向新的元素
<ul>
<li>如果e&gt;=v，i++（=随便放，默认在右边）</li>
<li>如果e&lt;v，swap(arr[j+1], arr[i])，j++</li>
</ul>
</li>
<li>swap(arr[l], arr[j])，此时v放到了合适的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] &lt; arr[p+1...r]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __partition(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    T v = arr[l];<span class="comment">// 标准 v</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使得arr[l+1...j] &lt; v &lt; arr[j+1...i)</span></span><br><span class="line">    <span class="type">int</span> j = l;<span class="comment">// 初始化j，此时&lt;v的部分为空</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = l + <span class="number">1</span> ; i &lt;= r ; i ++ )<span class="comment">// 初始化i，此时&gt;v的部分为空</span></span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;<span class="comment">// arr[i]&gt;v时，i++</span></span><br><span class="line">            j ++;</span><br><span class="line">            <span class="built_in">swap</span>( arr[j] , arr[i] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>( arr[l] , arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;<span class="comment">// 此时j为v对应的编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = __partition(arr, l, r);</span><br><span class="line">    __quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局限性与优化">局限性与优化</h4>
<p>局限性：</p>
<ol>
<li>在近乎有序的列表中会导致算法退化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>该方式会使算法按照v划分左右两块时极度不平衡而导致算法时间复杂度退化</li>
</ul>
</li>
<li>在有很多重复数据的列表中会导致算法退化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>该方式和上述类似，无论重复数据放左边还是右边均会导致两边极度不平衡</li>
</ul>
</li>
</ol>
<p>优化：</p>
<ol>
<li>
<p>采用<strong>随即快排</strong>：选取标定点v时采用随机的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> _quickSort(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        <span class="built_in">insertionSort</span>(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    <span class="built_in">swap</span>( arr[l] , arr[<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> p = _partition(arr, l, r);</span><br><span class="line">    _quickSort(arr, l, p<span class="number">-1</span> );</span><br><span class="line">    _quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>采用<strong>双路快排</strong>：两边同时进行分区操作，避免重复数据放到同一边</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210108231349286.png" alt="双路分区操作"></p>
<ul>
<li>i向后扫描到e&gt;=v时停止，j向前扫描到e&lt;=v时停止</li>
<li>交换i和j的元素</li>
<li>实质上左边时&lt;=v，右边是&gt;=v</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双路快速排序的partition</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]</span></span><br><span class="line"><span class="comment">// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> _partition(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    <span class="built_in">swap</span>( arr[l] , arr[<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>)+l] );</span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使得arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></span><br><span class="line">    <span class="type">int</span> i = l+<span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">        <span class="comment">// 注意这里不能是arr[i] &lt;= v</span></span><br><span class="line">        <span class="comment">// 否则=v的元素会全到左边</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= r &amp;&amp; arr[i] &lt; v )<span class="comment">// i&lt;=r防止越界</span></span><br><span class="line">            i ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里不能是arr[j] &gt;= v</span></span><br><span class="line">        <span class="keyword">while</span>( j &gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v )<span class="comment">// i&gt;=l+1防止越界</span></span><br><span class="line">            j --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( i &gt; j )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>( arr[i] , arr[j] );</span><br><span class="line">        i ++;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>( arr[l] , arr[j]);<span class="comment">// 此时j一定&lt;=v，而不能用i。i处可能会&gt;v</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;<span class="comment">// j处就是v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="三路快排-2">三路快排</h4>
<p>在上述双路快排的基础上，将<code>==v</code>的区域单独划分出来 ，形成3部分：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210112212337372.png" alt="三路快排"></p>
<ul>
<li>当e==v时，i++</li>
<li>e&lt;v时，swap(arr[lt+1], arr[i])，lt++，i++</li>
<li>e&gt;v时，swap(arr[gt-1], arr[i])，gt–，i由于此时交换的是新元素，所以不用改变</li>
<li>结束时，i应该和gt<strong>重合</strong>，指向&gt;v的第一个原始</li>
<li>最后交换l和lt即可：swap(arr[l], arr[lt])，注意此时lt指向的是==v的第一个元素，而非&lt;v的最后一个元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的三路快速排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort3Ways(T arr[], <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</span><br><span class="line">        <span class="built_in">insertionSort</span>(arr,l,r);</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 递归的退出条件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    <span class="built_in">swap</span>( arr[l], arr[<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>)+l ] );</span><br><span class="line"></span><br><span class="line">    T v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="type">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="type">int</span> i = l+<span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>( i &lt; gt )&#123;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( arr[i], arr[lt+<span class="number">1</span>]);</span><br><span class="line">            i ++;</span><br><span class="line">            lt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( arr[i] &gt; v )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( arr[i], arr[gt<span class="number">-1</span>]);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// arr[i] == v</span></span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>( arr[l] , arr[lt] );</span><br><span class="line"></span><br><span class="line">    __quickSort3Ways(arr, l, lt<span class="number">-1</span>);<span class="comment">//注意：上一步交换后 这里需要-1</span></span><br><span class="line">    __quickSort3Ways(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort3Ways</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3Ways( arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</li>
</ul>
<p>解题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort(nums.begin(), nums.end(), greater&lt;int&gt;());</span></span><br><span class="line">        <span class="comment">// return nums[k-1];</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        _partition(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[r-k+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[left, right]</span></span><br><span class="line">    <span class="type">void</span> _partition(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[<span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left]);</span><br><span class="line">        <span class="type">int</span> v = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> le = left;<span class="comment">//(left, le] &lt; v</span></span><br><span class="line">        <span class="type">int</span> gt = right+<span class="number">1</span>;<span class="comment">//[gt, right] &gt; v</span></span><br><span class="line">        <span class="type">int</span> i = le+<span class="number">1</span>;<span class="comment">//(le, i) == v</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i; i &lt; gt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                le++;</span><br><span class="line">                <span class="built_in">swap</span>(nums[le], nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                <span class="built_in">swap</span>(nums[gt], nums[i]);</span><br><span class="line">                i--;<span class="comment">//i此时不应该变化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[le]);</span><br><span class="line"></span><br><span class="line">        _partition(nums, left, le<span class="number">-1</span>);</span><br><span class="line">        _partition(nums, gt, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-分治算法">3.分治算法</h3>
<p>上述问题都是分治算法的典型例子（将原问题分割成同等结构的子问题，之后将子问题逐一解决后，原问题也就得到了解决）</p>
<ul>
<li>归并排序：关键在将子问题合并上</li>
<li>快速排序：关键在将原问题分解上</li>
</ul>
<p>这里会直接谈论从归并排序和快速排序上引申而来的一些问题</p>
<h4 id="逆序对">逆序对</h4>
<p>对这样的一个数组：8 6 2 3 1 5 7 4 ，可以从中抽出一对数组2 3，此时2&lt;3且2在前边，这样的叫做顺序对；相应的数组2 1称为逆序对。一个数组中逆序对的数量是衡量一个数组的有序程度。当一个数组顺序排列时逆序对位0，反之逆序排列时逆序对达到了最大</p>
<ul>
<li>暴力破解法：通过双重循环考察每个数据对。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>归并算法：在每次归并的比较过程中，前后两队其实是已经排好序的（假设从小到大），此时只要前一对中的元素i&lt;后一对的元素j，即可推断出i与j及其之后的所有元素均构成逆序对。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="取出数组中第n大的元素">取出数组中第n大的元素</h4>
<ul>
<li>快速排序然后定位：时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>在快速排序过程中，将标定点挪到合适的位置上时，该位置即为排好序后最终所处的位置，此时只要继续排序给出位置n所在的剩下那对即可。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="三、堆和堆排序">三、堆和堆排序</h2>
<ul>
<li>普通队列：先进先出；后进后出</li>
<li>优先队列：出队顺序和入队顺序无关；和优先级相关</li>
</ul>
<p>优先队列的实现方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">入队</th>
<th style="text-align:center">出队</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通数组</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">顺序数组</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">堆</td>
<td style="text-align:center">O(lgn)</td>
<td style="text-align:center">O(lgn)</td>
</tr>
</tbody>
</table>
<p>堆排序不占用额外的空间</p>
<h3 id="1-最大堆">1.最大堆</h3>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>最大堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>最小堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ol>
<p>满二叉树：一棵深度为k且有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个结点的二叉树</p>
<p><strong>完全的二叉树</strong>：如果对满二叉树的结点进行编号，约定编号从根结点起，自上而下，自左而右。则深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树</p>
<blockquote>
<p>通俗点说就是：</p>
<p>完全二叉树：除了最后一层，所有层的节点数达到最大，与此同时，最后一层的所有节点都在最左侧。</p>
<p>满二叉树：所有层的节点数达到最大。</p>
<p>平衡二叉树：每一个节点的左右子树的高度差不超过1</p>
<p>二分搜索树：每个节点的键值大于左孩子；每个节点的键值小于右孩子；且以左右孩子为根的子树仍为二分搜索树</p>
</blockquote>
<p>实现：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113105718460.png" alt="最大堆"></p>
<ul>
<li>根节点从1开始标记</li>
<li>父节点标号：parent(i) = i/2，计算机中需要取整</li>
<li>左子节点标号：left child(i) =2*i</li>
<li>右子节点标号：right child(i) = 2*i +1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;<span class="comment">//保存的数组</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//当前的容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MaxHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-添加元素">2.添加元素</h3>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113111005733.png" alt="插入"></p>
<ul>
<li>将新元素放到数组最后（放到最大堆的最后），此时不是最大堆，需要调整</li>
<li>比较新加入的节点与其父节点，如果父节点&lt;新节点，则交换位置</li>
<li>反复执行上一步，直至不能交换</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;<span class="comment">//保存的数组</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//当前的容量</span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//最大能够容纳的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="comment">//插入 尝试将k处元素向上移动</span></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：类似于插入排序，可以通过将待排序的值存到一个副本中，计算出待插入的位置后最终再交换位置来减小swap的使用次数</li>
</ul>
<h3 id="3-取出元素">3.取出元素</h3>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113115356259.png" alt="取出根节点元素"></p>
<ul>
<li>取出根节点元素，此时需要重新排列整个树位最大堆
<ul>
<li>根节点是优先级最高的节点</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113115611027.png" alt="重新生成最大堆"></p>
<ul>
<li>将最后一个元素放到取出元素的位置上</li>
<li>比较该元素与子节点的大小，找到子节点中的最大值，如果该值&gt;子节点，则互换
<ul>
<li>注意，完全二叉树如果有子节点则一定存在左子节点</li>
</ul>
</li>
<li>重复上述步骤直至不能互换</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//当前的容量</span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//最大能够容纳的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="comment">//取出元素 尝试将k处元素向下移动</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;<span class="comment">// 存在左子节点</span></span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] )<span class="comment">// 存在右子节点且右子节点较大</span></span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：类似于插入排序，可以通过将待排序的值存到一个副本中，计算出待插入的位置后最终再交换位置来减小swap的使用次数</li>
</ul>
<h3 id="4-基础堆排序和Heapify">4.基础堆排序和Heapify</h3>
<h4 id="基础堆排序">基础堆排序</h4>
<p>基于上述最大堆的数据结构，可以构建一个排序算法（直接通过添加、取出元素排序）：</p>
<p>MaxHeap class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) j ++;</span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MaxHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像最大堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count+<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">swap</span>( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        maxheap.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将n个元素逐个插入到一个空堆中，该过程时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="Heapify">Heapify</h4>
<p>Heapify操作：给定一个数组，将这个数组中的元素按照堆的方式进行排列，该过程称为Heapify</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113150707713.png" alt="Heapify"></p>
<ul>
<li>所有的叶子节点（蓝色）均为最大堆</li>
<li>在一棵完全二叉树来说，第一个非叶子节点的索引为所有元素个数/2</li>
<li>从后向前（编号）检查每个不是最大堆中的节点，执行<a href="#3.%E5%8F%96%E5%87%BA%E5%85%83%E7%B4%A0"><code>shiftDown</code></a>操作即可（和子节点进行比较）</li>
<li>整个过程后该数组就会成为一个最大堆</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) j ++;</span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(Item arr[], <span class="type">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )<span class="comment">// i从第一个非叶子节点开始</span></span><br><span class="line">            <span class="built_in">shiftDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort2, 借助我们的heapify过程创建堆</span></span><br><span class="line"><span class="comment">// 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(arr,n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Heapify直接从n/2开始，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，证明需要高数知识</li>
<li>该方法快于上述基础堆排序，但是仍然慢于快速排序和归并排序</li>
<li>更多的是用于动态数据的维护</li>
</ul>
<h3 id="5-原地堆排序">5.原地堆排序</h3>
<p>上述Heapity过程需要重新开辟一个相同的空间，而原地堆排序不需要，空间复杂度位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210113181132690.png" alt="原地堆排序"></p>
<ul>
<li>按照Heapify方法将数组构建成一个最大堆</li>
<li>此时第一个元素就是数组中最大元素的位置，需要将v和数组末尾元素w进行互换</li>
<li>互换后前半部分不是最大堆，需要再次进行<a href="#3.%E5%8F%96%E5%87%BA%E5%85%83%E7%B4%A0"><code>shiftDown</code></a>操作，构建最大堆</li>
<li>反复执行上述步骤直至排好序</li>
</ul>
<p>为便于数组操作，这里从0开始索引，如下规则需要改变：</p>
<ul>
<li>根节点从0开始标记（<a href="#1.%E6%9C%80%E5%A4%A7%E5%A0%86">原来版本</a>）</li>
<li>父节点标号：parent(i) = (i-1)/2，计算机中需要取整</li>
<li>左子节点标号：left child(i) =2*i+1</li>
<li>右子节点标号：right child(i) = 2*i +2</li>
<li>最后一个非叶子节点索引：(count-1)/2（<a href="#Heapify">原来版本</a>）</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的shiftDown过程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __shiftDown(T arr[], <span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[k] &gt;= arr[j] )<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>( arr[k] , arr[j] );</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line"><span class="comment">// 该优化思想和之前对插入排序进行优化的思路是一致的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __shiftDown2(T arr[], <span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">    T e = arr[k];</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n )&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( e &gt;= arr[j] ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[k] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此时堆是从0开始索引的</span></span><br><span class="line">    <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">    <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        __shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        <span class="built_in">swap</span>( arr[<span class="number">0</span>] , arr[i] );</span><br><span class="line">        __shiftDown2(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-索引堆">6.索引堆</h3>
<p>索引堆：将数组和索引分开存储，而真正构成堆的数据是由<strong>索引</strong>构成</p>
<p>索引堆也分为最大索引堆和最小索引堆，这里均采用最大索引堆</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115171134595.png" alt="索引堆——排序前"></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115171639980.png" alt="索引堆——排序后"></p>
<ul>
<li>每个圈内是索引号，圈外是二叉树节点编号（数组编号）</li>
<li>排序后data顺序不会改变，只改变索引号index</li>
<li>排序后，堆中元素index表示数组中的data值</li>
</ul>
<p>相较堆排序来说：<strong>比较data值，交换index值</strong></p>
<p>好处：仅仅只交换索引，不改变data。对于复杂结构的data来说效率较高</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大索引堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexMaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最大索引堆中的数据</span></span><br><span class="line">    <span class="type">int</span> *indexes;   <span class="comment">// 最大索引堆中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>( indexes[k] , indexes[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">IndexMaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="type">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IndexMaxHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="built_in">assert</span>( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最大索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="type">int</span> i )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">( <span class="type">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">1</span> ; j &lt;= count ; j ++ )</span><br><span class="line">            <span class="keyword">if</span>( indexes[j] == i )&#123;</span><br><span class="line">                <span class="built_in">shiftUp</span>(j);</span><br><span class="line">                <span class="built_in">shiftDown</span>(j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试索引堆中的索引数组index</span></span><br><span class="line">    <span class="comment">// 注意:这个测试在向堆中插入元素以后, 不进行extract操作有效</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">testIndexes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> *copyIndexes = <span class="keyword">new</span> <span class="type">int</span>[count+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            copyIndexes[i] = indexes[i];</span><br><span class="line"></span><br><span class="line">        copyIndexes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        std::<span class="built_in">sort</span>(copyIndexes, copyIndexes + count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在对索引堆中的索引进行排序后, 应该正好是1...count这count个索引</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt;= count ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( copyIndexes[i<span class="number">-1</span>] + <span class="number">1</span> != copyIndexes[i] )&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] copyIndexes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !res )&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用最大索引堆进行堆排序, 来验证我们的最大索引堆的正确性</span></span><br><span class="line"><span class="comment">// 最大索引堆的主要作用不是用于排序, 我们在这里使用排序只是为了验证我们的最大索引堆实现的正确性</span></span><br><span class="line"><span class="comment">// 在后续的图论中, 无论是最小生成树算法, 还是最短路径算法, 我们都需要使用索引堆进行优化:)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSortUsingIndexMaxHeap</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IndexMaxHeap&lt;T&gt; indexMaxHeap = <span class="built_in">IndexMaxHeap</span>&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">        indexMaxHeap.<span class="built_in">insert</span>( i , arr[i] );</span><br><span class="line">    <span class="built_in">assert</span>( indexMaxHeap.<span class="built_in">testIndexes</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        arr[i] = indexMaxHeap.<span class="built_in">extractMax</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述charge从，查找index中的元素时是通过遍历决定的，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>优化方法：再加一层rev数组</li>
</ul>
<h2 id="四、二分搜索树">四、二分搜索树</h2>
<h3 id="1-二分查找法">1.二分查找法</h3>
<p>对于<strong>有序数列</strong>（需要先排序），才能使用二分查找法，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115192948927.png" alt="二分查找法"></p>
<ul>
<li>判断中间数据v的值与待查找的值的关系：
<ul>
<li>v==待查找值：找到</li>
<li>否则划分为两部分</li>
</ul>
</li>
<li>再对应区域继续重复上述部分</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法,在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="type">int</span> n, T target)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r )&#123;</span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;</span></span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归的方式写二分查找法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __binarySearch2(T arr[], <span class="type">int</span> l, <span class="type">int</span> r, T target)&#123;</span><br><span class="line">    <span class="keyword">if</span>( l &gt; r )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int mid = (l+r)/2;</span></span><br><span class="line">    <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">    <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, l, mid<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> __binarySearch2(arr, mid+<span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归实现通常较容易实现</li>
<li>递归在性能上非略差</li>
</ul>
<h4 id="floor和ceil">floor和ceil</h4>
<p>查找的元素中如果有重复元素的话，上述二分查找法不能保证找到的索引是该重复元素中需要的索引</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115194324478.png" alt="floor和ceil"></p>
<ul>
<li>
<p>floor为待查找元素出现的第一个位置</p>
</li>
<li>
<p>ceil为最后一个</p>
</li>
<li>
<p>对于不存在的情况，返回结果比二分查找更好</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115194833866.png" alt="待查找元素42不存在"></p>
</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法, 在有序数组arr中, 查找target</span></span><br><span class="line"><span class="comment">// 如果找到target, 返回第一个target相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target, 返回比target小的最大值相应的索引, 如果这个最大值有多个, 返回最大索引</span></span><br><span class="line"><span class="comment">// 如果这个target比整个数组的最小元素值还要小, 则不存在这个target的floor值, 返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floor</span><span class="params">(T arr[], <span class="type">int</span> n, T target)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>( n &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// 寻找比target小的最大索引</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r )&#123;</span><br><span class="line">        <span class="comment">// 使用向上取整避免死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt;= target )<span class="comment">// 通过这里来找到target-1的位置</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>( l == r );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该索引+1就是target本身, 该索引+1即为返回值</span></span><br><span class="line">    <span class="keyword">if</span>( l + <span class="number">1</span> &lt; n &amp;&amp; arr[l+<span class="number">1</span>] == target )</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则, 该索引即为返回值</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法, 在有序数组arr中, 查找target</span></span><br><span class="line"><span class="comment">// 如果找到target, 返回最后一个target相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target, 返回比target大的最小值相应的索引, 如果这个最小值有多个, 返回最小的索引</span></span><br><span class="line"><span class="comment">// 如果这个target比整个数组的最大元素值还要大, 则不存在这个target的ceil值, 返回整个数组元素个数n</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ceil</span><span class="params">(T arr[], <span class="type">int</span> n, T target)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>( n &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// 寻找比target大的最小索引值</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r )&#123;</span><br><span class="line">        <span class="comment">// 使用普通的向下取整即可避免死循环</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &lt;= target )<span class="comment">// 通过这里来找到target+1的位置</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// arr[mid] &gt; target</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>( l == r );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该索引-1就是target本身, 该索引+1即为返回值</span></span><br><span class="line">    <span class="keyword">if</span>( r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[r<span class="number">-1</span>] == target )</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则, 该索引即为返回值</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-二分搜索树">2.二分搜索树</h3>
<p>优势：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">查找元素</th>
<th style="text-align:center">插入元素</th>
<th style="text-align:center">删除元素</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通数组</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">顺序数组</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">二分搜索树</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">O(logn)</td>
</tr>
</tbody>
</table>
<p>一般用于查找表/字典这种<strong>键值对</strong>的实现</p>
<p>需要满足：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210115203416004.png" alt="二分搜索树"></p>
<ul>
<li>是一颗二叉树</li>
<li>每个节点的键值大于左孩子（及其全部子节点），小于右孩子（及其全部子节点）</li>
<li>以左右孩子为根的子树仍为二分搜索树</li>
<li>圈中内容为<strong>键</strong></li>
<li>不像<a href="#1.%E6%9C%80%E5%A4%A7%E5%A0%86">最大堆</a>一样，二分搜索树不一定为完全二叉树，所以一般不用数组表示，而通过采用指针连接的node节点</li>
</ul>
<p>基本结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Key key, Value value)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Node *node)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *root; <span class="comment">// 根节点</span></span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 树中的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 默认构造一棵空二分搜索树</span></span><br><span class="line">    <span class="built_in">BST</span>()&#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数, 释放二分搜索树的所有空间</span></span><br><span class="line">    ~<span class="built_in">BST</span>()&#123;</span><br><span class="line">        <span class="built_in">destroy</span>( root );<span class="comment">// 这里用到了后序遍历，详见后文 遍历 章节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树的节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二分搜索树是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入-2">插入</h4>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125154623014.png" alt="插入元素——28"></p>
<ul>
<li>将待插入元素和根节点（41）进行比较，发现小于根节点</li>
<li>与左子节点（22）进行比较，发现大于该节点</li>
<li>与右子节点（33）进行比较，发现小于该节点</li>
<li>此时该位置为空，故最终成为33这个节点的左子节点</li>
</ul>
<blockquote>
<p>注意：当待插入节点在二分搜索树中已经存在时，通常来说会覆盖掉之前的节点的值（<strong>键相同，覆盖值</strong>）</p>
</blockquote>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node *node, Key key, Value value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> )&#123;<span class="comment">//递归终止条件1</span></span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key == node-&gt;key ) <span class="comment">// 已经存在，直接覆盖</span></span><br><span class="line">        node-&gt;value = value;<span class="comment">//递归终止条件2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">        node-&gt;left = <span class="built_in">insert</span>( node-&gt;left , key, value);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        node-&gt;right = <span class="built_in">insert</span>( node-&gt;right, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找-2">查找</h4>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125160322168.png" alt="查找元素——42"></p>
<ul>
<li>将待查找元素和根节点（41）进行比较，发现大于根节点</li>
<li>与右子节点（58）进行比较，发现小于该节点</li>
<li>与左子节点（50）进行比较，发现小于该节点</li>
<li>最终查找50的左子节点，发现刚好相等，查找成功</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> ) <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key == node-&gt;key ) <span class="comment">// 成功找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contain</span>( node-&gt;left , key );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contain</span>( node-&gt;right , key );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在以node为根的二分搜索树中查找key所对应的value, 递归算法</span></span><br><span class="line"><span class="comment">// 若value不存在, 则返回NULL</span></span><br><span class="line"><span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> ) <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key == node-&gt;key ) <span class="comment">// 成功找到</span></span><br><span class="line">        <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key &lt; node-&gt;key )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>( node-&gt;left , key );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>( node-&gt;right, key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历（深度优先）">遍历（深度优先）</h4>
<p>深度优先遍历，DFS（Depth First Search）：直接扫描到整个树的最深层，再依次回溯，来遍历整棵树。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。根据执行动作的时间不同分为以下几种方式：</p>
<ol>
<li>前序遍历：先访问<strong>当前</strong>节点，再依次递归访问左右子树</li>
<li>中序遍历：先递归访问左子树，再访问<strong>自身</strong>，再递归访问右子树
<ul>
<li>对于二分搜索树来说，中序遍历会将元素从小到大<strong>排序</strong>输出</li>
</ul>
</li>
<li>后续遍历：先递归访问左右子树，再访问<strong>自身</strong>节点
<ul>
<li>最典型的应用：释放二叉树</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：上述中的<code>访问</code>，可以理解为执行该节点对应的动作，如输出自身的值</p>
</blockquote>
<hr>
<p>一个便于理解的方法：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125162712403.png" alt="一种理解方法"></p>
<ul>
<li>每次遍历时（自身-&gt;左子树-&gt;自身-&gt;右子树-&gt;自身，共三次），一个节点都会扫描过三次，对应上图中的三个点</li>
<li>前序遍历是在第一次扫描时（对应第一个点），就执行对应的动作</li>
<li>中序遍历是在第二次扫描时（对应第二个点），就执行对应的动作</li>
<li>后序遍历是在第三次扫描时（对应最后一个点），就执行对应的动作</li>
</ul>
<p>前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行前序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行中序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(node-&gt;left);</span><br><span class="line">        cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">inOrder</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行后序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(node-&gt;right);</span><br><span class="line">        cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述析构函数就是利用到了后序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放以node为根的二分搜索树的所有节点</span></span><br><span class="line"><span class="comment">// 采用后续遍历的递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">destroy</span>( node-&gt;left );</span><br><span class="line">        <span class="built_in">destroy</span>( node-&gt;right );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历（广度优先）">遍历（广度优先）</h4>
<p>广度优先遍历，BFS（Breadth First Search）：从根节点开始，对每层的所有节点依次进行扫描。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>通常来说广度优先遍历需要借助FIFO队列来实现：</p>
<ol>
<li>将根节点入队</li>
<li>当队列不为空时，取出队列中的第一个元素并执行对应的动作（如打印）</li>
<li>将取出元素的左右子节点依次入队</li>
<li>重复上述2 3步骤，直到整棵树遍历结束</li>
</ol>
<hr>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125165440867.png" alt="广度优先遍历"></p>
<ul>
<li>取出根节点28的同时，将左右子节点16、30分别入队</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;Node *&gt; q;<span class="comment">//使用c++自带的队列queue</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *node = q.<span class="built_in">front</span>();<span class="comment">//取出队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; node-&gt;key &lt;&lt; endl;<span class="comment">//执行队首元素对应的动作</span></span><br><span class="line">        <span class="comment">//将node的左右子节点分别入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除-2">删除</h4>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h5 id="最小最大值">最小最大值</h5>
<p>在二分搜索树中：</p>
<ul>
<li>最小值：二分搜索树的最左子节点（一直找左节点，直到为空）</li>
<li>最大值：二分搜索树的最右子节点（一直找右节点，直到为空）</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125170639389.png" alt="删除最大值——58"></p>
<ul>
<li>找到最大值——58</li>
<li>删掉最大值后剩余部分节点直接挂载58下</li>
<li>最小值同理</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;<span class="comment">//递归终止条件：找到最小节点</span></span><br><span class="line"></span><br><span class="line">        Node* rightNode = node-&gt;right;<span class="comment">//最小节点的右节点不管存不存在都挂回到删掉的位置上</span></span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;left = <span class="built_in">removeMin</span>(node-&gt;left);<span class="comment">//递归查找，并挂回到删掉的位置上</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中的最大节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line"></span><br><span class="line">        Node* leftNode = node-&gt;left;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;right = <span class="built_in">removeMax</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="任意节点">任意节点</h5>
<p>通过上述可以看出：</p>
<ul>
<li>最小值所在节点只会有右子节点</li>
<li>最大值所在节点只会有左子节点</li>
</ul>
<p>从上述可以推断出：</p>
<ol>
<li>对于只存在一个子节点的节点，可以直接删除掉该节点，然后将子节点挂上来</li>
<li>对于存在两个子节点的节点，可以通过Hubbard Deletion方法来删除</li>
<li></li>
</ol>
<p>Hubbard Deletion方法：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125175835771.png" alt="Hubbard Deletion方法"></p>
<ol>
<li>找到要删除元素d（58）的<strong>右子树中的最小值</strong>（或者左子树的最大值，称为前驱节点），此时为节点s（59），称该节点为d的<strong>后继</strong>节点</li>
<li>将节点s换到节点d的位置上去
<ol>
<li>删除后继节点s（59）</li>
<li>将该节点s的右子节点指向节点d（58）的右子树（60）</li>
<li>将节点s的左子节点指向节点d（58）的左子树（50）</li>
<li>删除节点d（58）</li>
<li>将新节点s（59）挂在原来节点d的位置上</li>
</ol>
</li>
</ol>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key &lt; node-&gt;key )&#123;</span><br><span class="line">        node-&gt;left = <span class="built_in">remove</span>( node-&gt;left , key );</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key &gt; node-&gt;key )&#123;</span><br><span class="line">        node-&gt;right = <span class="built_in">remove</span>( node-&gt;right, key );</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key == node-&gt;key</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;left == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            Node *rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>( node-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            Node *leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">        <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">        Node *successor = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">minimum</span>(node-&gt;right));<span class="comment">//找到右节点中的最小节点并复制一份</span></span><br><span class="line">        count ++;<span class="comment">//removeMin中需要操作该变量</span></span><br><span class="line"></span><br><span class="line">        successor-&gt;right = <span class="built_in">removeMin</span>(node-&gt;right);<span class="comment">//删除右节点中的最小节点 并返回右子树的根节点复制给后继节点successor</span></span><br><span class="line">        successor-&gt;left = node-&gt;left;<span class="comment">//继承node节点的左子树节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> node;<span class="comment">//删除找到的节点</span></span><br><span class="line">        count --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> successor;<span class="comment">//新的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序性">顺序性</h4>
<p>二分搜索树具有一定的顺序性，不仅能够定位一个元素，而且还能用于处理一些和元素顺序相关的问题，具体包括：</p>
<ol>
<li>查询最小、最大元素（minimum、maximum）</li>
<li>查找前驱元素、后驱元素（predecessor、successor）</li>
<li>找到相应元素的floor、ceil（定义详见<a href="#floor%E5%92%8Cceil">floor和ceil</a>，与第2点不同的是，第3点中的元素可以不存在树中）</li>
<li>rank、select
<ul>
<li>rank：xx元素排名第几</li>
<li>select：排名第几的元素是谁</li>
</ul>
</li>
</ol>
<p>floor和ceil的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在以node为根的二叉搜索树中, 寻找key的floor值所处的节点, 递归算法</span></span><br><span class="line"><span class="function">Node* <span class="title">floor</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node的key值和要寻找的key值相等</span></span><br><span class="line">    <span class="comment">// 则node本身就是key的floor节点</span></span><br><span class="line">    <span class="keyword">if</span>( node-&gt;key == key )</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node的key值比要寻找的key值大</span></span><br><span class="line">    <span class="comment">// 则要寻找的key的floor节点一定在node的左子树中</span></span><br><span class="line">    <span class="keyword">if</span>( node-&gt;key &gt; key )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">floor</span>( node-&gt;left , key );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node-&gt;key &lt; key</span></span><br><span class="line">    <span class="comment">// 则node有可能是key的floor节点, 也有可能不是(存在比node-&gt;key大但是小于key的其余节点)</span></span><br><span class="line">    <span class="comment">// 需要尝试向node的右子树寻找一下</span></span><br><span class="line">    Node* tempNode = <span class="built_in">floor</span>( node-&gt;right , key );</span><br><span class="line">    <span class="keyword">if</span>( tempNode != <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> tempNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在以node为根的二叉搜索树中, 寻找key的ceil值所处的节点, 递归算法</span></span><br><span class="line"><span class="function">Node* <span class="title">ceil</span><span class="params">(Node* node, Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node的key值和要寻找的key值相等</span></span><br><span class="line">    <span class="comment">// 则node本身就是key的ceil节点</span></span><br><span class="line">    <span class="keyword">if</span>( node-&gt;key == key )</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node的key值比要寻找的key值小</span></span><br><span class="line">    <span class="comment">// 则要寻找的key的ceil节点一定在node的右子树中</span></span><br><span class="line">    <span class="keyword">if</span>( node-&gt;key &lt; key )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>( node-&gt;right , key );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node-&gt;key &gt; key</span></span><br><span class="line">    <span class="comment">// 则node有可能是key的ceil节点, 也有可能不是(存在比node-&gt;key小但是大于key的其余节点)</span></span><br><span class="line">    <span class="comment">// 需要尝试向node的左子树寻找一下</span></span><br><span class="line">    Node* tempNode = <span class="built_in">ceil</span>( node-&gt;left , key );</span><br><span class="line">    <span class="keyword">if</span>( tempNode != <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> tempNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局限性">局限性</h4>
<p>同样的数据可以对应不同的二分搜索树，所以在某些情况下可能会退化为链表，相应的操作会从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlongn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>退化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如下所以：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210125200955578.png" alt="局限性"></p>
<p>解决方法：</p>
<ol>
<li>打乱数据，使得不会出现上述极端情况</li>
<li>在不能打乱数据的情况下（如几乎有序的数据流等情况下），可以通过<code>平衡二叉树——红黑树</code>来实现
<ul>
<li>平衡二叉树中还包括诸如：2-3树、AVL树、Splay树</li>
<li>平衡二叉树和堆的结合：Treap</li>
<li>trie字典树：适合字典词频统计</li>
</ul>
</li>
</ol>
<h4 id="树形问题">树形问题</h4>
<p>由于树这种结构的定义具有天然的递归性，所以在求解时利用递归的方法也天然的具有这种树的性质，如：</p>
<ul>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<p>使用递归来求解的问题，最常见的就是<code>搜索问题</code></p>
<h2 id="五、并查集">五、并查集</h2>
<p>一种很不一样的树形结构：对于一组数据，主要支持两个操作：</p>
<ol>
<li>union(p,q)：求p和q的并集，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∪</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\cup q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></li>
<li>find§：查找元素p所在的组</li>
</ol>
<p>并查集可以回答下述问题：</p>
<ol>
<li>isConnected(p,q)：p和q是否在一块</li>
</ol>
<p>时间复杂度<strong>近乎</strong>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（通过优化后）</p>
<h3 id="Quick-Find结构">Quick Find结构</h3>
<p>基本数据表示：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210126180654268.png" alt="Quick Find结构"></p>
<ul>
<li>数组的索引用来表示元素（横线上方元素）</li>
<li>数组的每个元素表示对应元素所属的组（横线下方元素）</li>
</ul>
<p>特点：</p>
<ol>
<li>查找（find）元素所属的组特别快，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>并（union）操作时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UF1 &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *id;    <span class="comment">// 本质就是一个数组，其中的内容是组号</span></span><br><span class="line">        <span class="type">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            count = n;</span><br><span class="line">            id = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">            <span class="comment">// 初始化, 每一个id[i]指向自己, 没有合并的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">UnionFind</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">            <span class="keyword">return</span> id[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(1)复杂度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(n) 复杂度</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> pID = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="type">int</span> qID = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pID == qID) <span class="comment">// 元素已经在同一个集合中</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">                <span class="keyword">if</span> (id[i] == pID)</span><br><span class="line">                    id[i] = qID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Quick-Union结构">Quick Union结构</h3>
<p>将每个元素视为一个节点，如果两个元素为同一个组，则通过指针进行连接，如下所示：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210126183122651.png" alt="3和2在同一个组中，连接在一起"></p>
<p>通过上述方法将所有元素进行连接。而实际上并不需要通过指针进行连接，这里可以通过一个数组parent来表示这种关系：</p>
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<ul>
<li>上方为parent数组的序号，下方为元素</li>
<li>parent[i]：即元素值，表示i元素所指向的父亲元素的序号</li>
<li>初始化时每个元素都指向自己，即<code>parent[i] = i</code></li>
</ul>
<p>如下情况，该数组变为：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210128232104286.png" alt="某种情况"></p>
<ul>
<li>合并过程中，只需要将待合并的元素的根部进行连接即可</li>
<li>查找过程和树的高度相关，在绝大多数情况下树的高度远远小于整个数据个数</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UF2&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">        <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="type">int</span>* parent;</span><br><span class="line">        <span class="type">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">UnionFind</span>(<span class="type">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">UnionFind</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="union优化——元素大小">union优化——元素大小</h4>
<p>上述过程没有考虑到合并过程中时元素多的一组向元素少的一组合并还是反过来，可以通过在根节点处设置一个计数器来实现一个层数更低的树</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UF3&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="type">int</span>* sz;     <span class="comment">// sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line">        <span class="type">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">UnionFind</span>(<span class="type">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            sz = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                sz[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">UnionFind</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] sz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( sz[pRoot] &lt; sz[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;<span class="comment">//指向元素多的根</span></span><br><span class="line">                sz[qRoot] += sz[pRoot];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">                sz[pRoot] += sz[qRoot];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="union优化——元素层数">union优化——元素层数</h4>
<p>当出现如下所示是特殊情况时：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210128233546818.png" alt="按元素大小来处理时的特殊情况"></p>
<p>若按照元素大小来进行优化，此时当需要将4和2进行合并时，4所在的树8会合并到2所在的树7上去，此时整棵树的层数变为了4层；如果反之将树7挂到树8下，则层数为3。</p>
<p>由上可知基于元素大小并不一定可靠，而需要根据元素层数来进行判断，通常而言，在并查集中元素层数称为<code>rank</code>：</p>
<ul>
<li><code>rank[i]</code>：根节点为i的树的高度</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UF4&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span>* rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="type">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="type">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">UnionFind</span>(<span class="type">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">UnionFind</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">            <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">            <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;<span class="comment">//注意：此时不需要修改rank</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 需要维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="find优化——路径压缩">find优化——路径压缩</h4>
<p>在find依照节点依次向上寻找根节点时，需要遍历每个节点。如果在这个过程中对树进行一些变化：</p>
<ol>
<li>如果在向上寻找的过程中没有找到根节点的话就将当前节点向上挪动</li>
</ol>
<p>如下述过程中（find元素4）会将整棵树改为右侧的样子：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210128235118247.png" alt="find元素4"></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UF5&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">        <span class="comment">// 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line">        <span class="comment">// 这也是rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line">        <span class="type">int</span>* rank;</span><br><span class="line">        <span class="type">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">        <span class="type">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">UnionFind</span>(<span class="type">int</span> count)&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">            <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~<span class="built_in">UnionFind</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] parent;</span><br><span class="line">            <span class="keyword">delete</span>[] rank;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// path compression 1</span></span><br><span class="line">            <span class="keyword">while</span>( p != parent[p] )&#123;</span><br><span class="line">                parent[p] = parent[parent[p]];<span class="comment">//仅仅这一句即可 根节点指向自己，所以无需考虑根节点的情况</span></span><br><span class="line">                p = parent[p];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// path compression 2, 递归算法</span></span><br><span class="line"><span class="comment">//            if( p != parent[p] )</span></span><br><span class="line"><span class="comment">//                parent[p] = find( parent[p] );//将路径压缩到极致，压缩之后的树只需一步即可找到根节点</span></span><br><span class="line"><span class="comment">//            return parent[p];//此时parent[p]即为根节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">            <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">            <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">            <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">                parent[qRoot] = pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">                parent[pRoot] = qRoot;</span><br><span class="line">                rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 我维护rank的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、无权图">六、无权图</h2>
<h3 id="图的表示">图的表示</h3>
<p>实质是对边的描述，通常分为两种：</p>
<ol>
<li>邻接矩阵：适合表示<strong>稠密图</strong>（边相对节点较多）
<ul>
<li>优：自动解决平行边的问题</li>
<li>缺：遍历领边较慢</li>
</ul>
</li>
<li>邻接表：适合表示<strong>稀疏图</strong>（边相对节点较少）
<ul>
<li>优：遍历领边较快</li>
<li>缺：不能够自动解决平行边，寻找平行边耗时太高</li>
</ul>
</li>
</ol>
<h4 id="邻接矩阵（稠密）">邻接矩阵（稠密）</h4>
<p>使用一个2*2的矩阵来表示，图中有n个节点则一共有n行n列，设该矩阵位矩阵A，则中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 这两个节点是否相连</p>
<ul>
<li>对于无向图来说直接表示即可：</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210204225344007.png" alt="邻接矩阵（无向图）表示形式"></p>
<ul>
<li>对于有向图来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 节点到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 节点是否相连</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210204230315212.png" alt="邻接矩阵（有向图）表示形式"></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DenseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;       <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="type">bool</span> directed;  <span class="comment">// 是否为有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; g; <span class="comment">// 图的具体数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DenseGraph</span>( <span class="type">int</span> n , <span class="type">bool</span> directed )&#123;</span><br><span class="line">        <span class="built_in">assert</span>( n &gt;= <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;    <span class="comment">// 初始化没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n*n的布尔矩阵, 每一个g[i][j]均为false, 表示没有任和边</span></span><br><span class="line">        g = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DenseGraph</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 返回节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 返回边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中添加一个边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">hasEdge</span>( v , w ) )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        g[v][w] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( !directed )</span><br><span class="line">            g[w][v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证图中是否有从v到w的边</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="keyword">return</span> g[v][w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>if( hasEdge( v , w ) )</code>能够顺带处理了<strong>平行边</strong>的问题</li>
<li>能够用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的速度来判断 v、w 之间是否有边</li>
</ul>
<h5 id="遍历领边">遍历领边</h5>
<p>对于邻接矩阵来说，遍历领边需要花费较高的时间</p>
<p>实现（为了不暴露类中的图，只向用户提供一个接口，这里用迭代器实现）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图 - 邻接矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DenseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DenseGraph &amp;G;  <span class="comment">// 图G的引用</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">adjIterator</span>(DenseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph)&#123;</span><br><span class="line">            <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.n );</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index = <span class="number">-1</span>;   <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">adjIterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从当前index开始向后搜索, 直到找到一个g[v][index]为true</span></span><br><span class="line">            <span class="keyword">for</span>( index += <span class="number">1</span> ; index &lt; G.<span class="built_in">V</span>() ; index ++ )</span><br><span class="line">                <span class="keyword">if</span>( G.g[v][index] )</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            <span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.<span class="built_in">V</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表（稀疏）">邻接表（稀疏）</h4>
<p>对于每一行来说，只表达和该行对应的点连接的那个点的信息：</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210204230620902.png" alt="邻接表（无向图）"></p>
<ul>
<li>第0行：只有1一个元素，表示只和节点1相接</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210204230857098.png" alt="邻接表（有向图）"></p>
<ul>
<li>第0行：只连接1号节点，方向为0–&gt;1</li>
</ul>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏图 - 邻接表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;       <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="type">bool</span> directed;  <span class="comment">// 是否为有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;  <span class="comment">// 图的具体数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SparseGraph</span>( <span class="type">int</span> n , <span class="type">bool</span> directed )&#123;</span><br><span class="line">        <span class="built_in">assert</span>( n &gt;= <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;    <span class="comment">// 初始化没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n个空的vector, 表示每一个g[i]都为空, 即没有任和边</span></span><br><span class="line">        g = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SparseGraph</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 返回节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 返回边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中添加一个边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">( <span class="type">int</span> v, <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        g[v].<span class="built_in">push_back</span>(w);</span><br><span class="line">        <span class="keyword">if</span>( v != w &amp;&amp; !directed ) <span class="comment">// 排除自环边：自己指向自己</span></span><br><span class="line">            g[w].<span class="built_in">push_back</span>(v);</span><br><span class="line"></span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证图中是否有从v到w的边</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; g[v].<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( g[v][i] == w )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用链表来实现——删除元素是更加方便</li>
<li>这里不涉及删除操作，简单点就使用vector</li>
<li><code>addEdge</code>中由于时间问题暂时不处理<strong>平行边</strong>的问题
<ul>
<li>通常是通过整张图构建完毕后再一次性过滤平行边，来排除这个问题</li>
</ul>
</li>
<li>判断 v、w 之间是否 有边时最差能达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h5 id="遍历领边-2">遍历领边</h5>
<p>每行中就是领边，所以花费时间较少</p>
<p>实现（为了不暴露类中的图，只向用户提供一个接口，这里用迭代器实现）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏图 - 邻接表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SparseGraph &amp;G; <span class="comment">// 图G的引用</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">adjIterator</span>(SparseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">adjIterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( G.g[v].<span class="built_in">size</span>() )</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            <span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            index ++;</span><br><span class="line">            <span class="keyword">if</span>( index &lt; G.g[v].<span class="built_in">size</span>() )</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            <span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="遍历">遍历</h3>
<h4 id="深度优先遍历">深度优先遍历</h4>
<p>时间复杂度（与广度优先遍历一样）：</p>
<ul>
<li>稀疏图（邻接表）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，通常领边较少，可以认为为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>
<ul>
<li>V：节点个数</li>
<li>E：领边条数</li>
</ul>
</li>
<li>稠密图（邻接矩阵）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<hr>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210205002004415.png" alt="深度优先遍历"></p>
<ol>
<li>从<strong>节点0</strong>开始访问，在第一行中先访问<strong>节点1</strong>
<ol>
<li>节点1连通的只有节点0，且刚刚访问完毕了，退回上一层</li>
</ol>
</li>
<li>访问<strong>节点2</strong>
<ol>
<li>节点2连通的只有节点0，且刚刚访问完毕了，退回上一层</li>
</ol>
</li>
<li>访问<strong>节点5</strong>
<ol>
<li>访问节点0，遍历过，继续遍历</li>
<li>访问<strong>节点3</strong>
<ol>
<li>访问<strong>节点4</strong>
<ol>
<li>访问节点3，遍历过，继续遍历</li>
<li>访问节点5，遍历过，继续遍历</li>
<li>访问<strong>节点6</strong>
<ol>
<li>访问节点0，遍历过，继续遍历</li>
<li>访问节点4，遍历过，返回上一层</li>
</ol>
</li>
</ol>
</li>
<li>访问节点5，遍历过，返回上一层</li>
</ol>
</li>
<li>访问节点4，遍历过，返回上一层</li>
</ol>
</li>
<li>访问节点6，遍历过。</li>
<li>至此已经全部遍历完毕</li>
</ol>
<hr>
<h5 id="连通分量">连通分量</h5>
<p>典型应用：求图中的连通分量</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210205003021332.png" alt="3个连通分量"></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求无权图的联通分量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;<span class="comment">//邻接矩阵 或 连接邻接表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;       <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="type">bool</span> *visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="type">int</span> ccount;     <span class="comment">// 记录联通分量个数</span></span><br><span class="line">    <span class="type">int</span> *id;        <span class="comment">// 每个节点所对应的联通分量标记（并查集思想 Quick Find结构）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> v )</span></span>&#123;<span class="comment">//遍历一个连通分量，并置位每个被访问节点的visited</span></span><br><span class="line"></span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        id[v] = ccount;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;<span class="comment">//图class中的迭代器，遍历领边</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; i = adj.<span class="built_in">next</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 求出无权图的联通分量</span></span><br><span class="line">    <span class="built_in">Component</span>(Graph &amp;graph): <span class="built_in">G</span>(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];<span class="comment">//G.V()：图中节点个数</span></span><br><span class="line">        id = <span class="keyword">new</span> <span class="type">int</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        ccount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;<span class="comment">// 全部没有访问过</span></span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求图的联通分量</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">                ccount ++;<span class="comment">//dfs后一定含有一个连通分量</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Component</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的联通分量个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询点v和点w是否联通</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="寻路">寻路</h5>
<p>在遍历的过程中存储对应的路径（每个节点从哪里遍历过来的）即可，但是并不能保证是最短路径</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径查询</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Path</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;   <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="type">int</span> s;      <span class="comment">// 起始点</span></span><br><span class="line">    <span class="type">bool</span>* visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="type">int</span> * from;     <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> v )</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;<span class="comment">//遍历领边</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; i = adj.<span class="built_in">next</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>( !visited[i] )&#123;</span><br><span class="line">                from[i] = v;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 寻路算法, 寻找图graph从s点到其他点的路径</span></span><br><span class="line">    <span class="built_in">Path</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        <span class="built_in">assert</span>( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.<span class="built_in">V</span>() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="type">int</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻路算法</span></span><br><span class="line">        <span class="built_in">dfs</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Path</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点的路径, 存放在vec中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">path</span><span class="params">(<span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPath</span>(w) );</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        <span class="type">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>( s.<span class="built_in">top</span>() );</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPath</span>(w) );</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">path</span>( w , vec );</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>() ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.<span class="built_in">size</span>() - <span class="number">1</span> )</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历">广度优先遍历</h4>
<p>类似于树的广度遍历，这里也需要一个<strong>队列</strong>来临时存储</p>
<p>时间复杂度（与深度优先遍历一样）：</p>
<ul>
<li>稀疏图（邻接表）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，通常领边较少，可以认为为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>
<ul>
<li>V：节点个数</li>
<li>E：领边条数</li>
</ul>
</li>
<li>稠密图（邻接矩阵）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<hr>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210205151746327.png" alt="广度优先遍历"></p>
<ol>
<li>将初始节点0推入队列q中</li>
<li>将队列首部元素节点0取出，即遍历了<strong>节点0</strong>，将节点0的领边相连的节点加入队列，此时队列中有节点1、2、5、6</li>
<li>将队列首部元素节点1取出，即遍历了<strong>节点1</strong>，将节点1的领边相连的节点加入队列，发现节点0已经遍历，此时队列中有节点2、5、6</li>
<li>将队列首部元素节点2取出，即遍历了<strong>节点2</strong>，将节点2的领边相连的节点加入队列，发现节点0已经遍历，此时队列中有节点5、6</li>
<li>将队列首部元素节点5取出，即遍历了<strong>节点5</strong>，将节点5的领边相连的节点加入队列，发现节点0已经遍历，此时队列中有节点6、3、4</li>
<li>将队列首部元素节点6取出，即遍历了<strong>节点6</strong>，将节点6的领边相连的节点加入队列，发现节点0已经遍历且节点4<strong>已经在队列中</strong>，此时队列中有节点3、4</li>
<li>将队列首部元素节点3取出，即遍历了<strong>节点3</strong>，将节点3的领边相连的节点加入队列，发现节点5已经遍历且节点4<strong>已经在队列中</strong>，此时队列中有节点4</li>
<li>将队列首部元素节点4取出，即遍历了<strong>节点4</strong>，将节点4的领边相连的节点加入队列，发现节点3、5、6已经遍历，此时队列中<strong>为空</strong>，遍历结束</li>
</ol>
<p>特点：先遍历的节点距起始节点的<strong>距离</strong>一定是<strong>小于等于</strong>后遍历的节点的，所以广度优先遍历求出了<strong>无权图</strong>的<strong>最短路径</strong></p>
<h5 id="最短路径">最短路径</h5>
<p>注意：</p>
<ol>
<li>深度优先的结果有时候也是最短路径，具体还是需要看节点的添加方式，即最终的邻接表</li>
<li>当有多条最短路径时，下面实现的结果取决于遍历顺序（只能输出一条最短路径）</li>
</ol>
<p>通过上面的思路，有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找无权图的最短路径</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortestPath</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;       <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="type">int</span> s;          <span class="comment">// 起始点</span></span><br><span class="line">    <span class="type">bool</span> *visited;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">    <span class="type">int</span> *from;      <span class="comment">// 记录路径, from[i]表示查找的路径上i的上一个节点</span></span><br><span class="line">    <span class="type">int</span> *ord;       <span class="comment">// 记录路径中节点的次序。ord[i]表示i节点在路径中的次序。（或离起始点的最短距离）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 寻找无权图graph从s点到其他点的最短路径</span></span><br><span class="line">    <span class="built_in">ShortestPath</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        <span class="built_in">assert</span>( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; graph.<span class="built_in">V</span>() );</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="type">bool</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="type">int</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="type">int</span>[graph.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; graph.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无向图最短路径算法, 从s开始广度优先遍历整张图</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>( s );</span><br><span class="line">        visited[s] = <span class="literal">true</span>;</span><br><span class="line">        ord[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( !q.<span class="built_in">empty</span>() )&#123;<span class="comment">// 只要队列不为空 就一直广度遍历</span></span><br><span class="line">            <span class="type">int</span> v = q.<span class="built_in">front</span>();<span class="comment">//取出队列首节点</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;<span class="comment">//遍历队列首的领边对应的节点</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; i = adj.<span class="built_in">next</span>() )</span><br><span class="line">                <span class="keyword">if</span>( !visited[i] )&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);<span class="comment">// 新节点 加入到队列中</span></span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    from[i] = v;</span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ShortestPath</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">        <span class="keyword">delete</span> [] ord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点是否有路径</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询从s点到w点的路径, 存放在vec中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">path</span><span class="params">(<span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        <span class="type">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>( s.<span class="built_in">top</span>() );</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="built_in">path</span>(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>() ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.<span class="built_in">size</span>()<span class="number">-1</span> )</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="七、有权图">七、有权图</h2>
<p>有权图在每条边上都会有一组权重，对于</p>
<ul>
<li>邻接矩阵：将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 改为权值即可，表示从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 节点的权值</li>
<li>邻接表：之前每行只用一个值存储连接的节点信息，现在需要两个，即
<ol>
<li>相应的索引——即之前存储的值</li>
<li>对应的权值</li>
</ol>
</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210209151608476.png" alt="邻接表"></p>
<ul>
<li>代码中，<code>边</code>通过指针的形式存储</li>
</ul>
<hr>
<p>实现：</p>
<p>边的抽象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a,b;    <span class="comment">// 边的两个端点</span></span><br><span class="line">    Weight weight;  <span class="comment">// 边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> a, <span class="type">int</span> b, Weight weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空的构造函数, 所有的成员变量都取默认值</span></span><br><span class="line">    <span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">v</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a;&#125; <span class="comment">// 返回第一个顶点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">w</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> b;&#125; <span class="comment">// 返回第二个顶点</span></span><br><span class="line">    <span class="function">Weight <span class="title">wt</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> weight;&#125;    <span class="comment">// 返回权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定一个顶点, 返回另一个顶点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">other</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( x == a || x == b );</span><br><span class="line">        <span class="keyword">return</span> x == a ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出边的信息</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Edge &amp;e)&#123;</span><br><span class="line">        os&lt;&lt;e.a&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;e.b&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;e.weight;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的大小比较, 是对边的权值的大小比较</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Edge&lt;Weight&gt;&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Edge&lt;Weight&gt;&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt;= e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Edge&lt;Weight&gt;&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(Edge&lt;Weight&gt;&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt;= e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Edge&lt;Weight&gt;&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight == e.<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稠密图——邻接矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DenseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;       <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="type">bool</span> directed;  <span class="comment">// 是否为有向图</span></span><br><span class="line">    vector&lt;vector&lt;Edge&lt;Weight&gt; *&gt;&gt; g;   <span class="comment">// 图的具体数据（存放指针）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DenseGraph</span>( <span class="type">int</span> n , <span class="type">bool</span> directed)&#123;</span><br><span class="line">        <span class="built_in">assert</span>( n &gt;= <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n*n的矩阵, 每一个g[i][j]指向一个边的信息, 初始化为NULL</span></span><br><span class="line">        g = vector&lt;vector&lt;Edge&lt;Weight&gt; *&gt;&gt;(n, vector&lt;Edge&lt;Weight&gt; *&gt;(n, <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">DenseGraph</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++ )</span><br><span class="line">                <span class="keyword">if</span>( g[i][j] != <span class="literal">NULL</span> )</span><br><span class="line">                    <span class="keyword">delete</span> g[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 返回节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 返回边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中添加一个边, 权值为weight</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">( <span class="type">int</span> v, <span class="type">int</span> w , Weight weight )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果从v到w已经有边, 删除这条边</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">hasEdge</span>( v , w  ) )&#123;</span><br><span class="line">            <span class="keyword">delete</span>  g[v][w];<span class="comment">//删除之前的边</span></span><br><span class="line">            <span class="keyword">if</span>( v != w &amp;&amp; !directed )</span><br><span class="line">                <span class="keyword">delete</span> g[w][v];</span><br><span class="line">            m --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g[v][w] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(v, w, weight);</span><br><span class="line">        <span class="keyword">if</span>( v != w &amp;&amp; !directed )</span><br><span class="line">            g[w][v] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(w, v, weight);</span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证图中是否有从v到w的边</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="keyword">return</span> g[v][w] != <span class="literal">NULL</span>;<span class="comment">//判断是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图的信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++ )</span><br><span class="line">                <span class="keyword">if</span>( g[i][j] )</span><br><span class="line">                    cout&lt;&lt;g[i][j]-&gt;<span class="built_in">wt</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;NULL\t&quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有边</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DenseGraph &amp;G;  <span class="comment">// 图G的引用</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">adjIterator</span>(DenseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index = <span class="number">-1</span>;   <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">adjIterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的第一个边</span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt;* <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的下一个边</span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt;* <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 从当前index开始向后搜索, 直到找到一个g[v][index]为true</span></span><br><span class="line">            <span class="keyword">for</span>( index += <span class="number">1</span> ; index &lt; G.<span class="built_in">V</span>() ; index ++ )</span><br><span class="line">                <span class="keyword">if</span>( G.g[v][index] )</span><br><span class="line">                    <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            <span class="comment">// 若没有顶点和v相连接, 则返回NULL</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有边</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.<span class="built_in">V</span>();<span class="comment">//G.g[v].size() ?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>边通过一个二维指针数组来表示</li>
</ul>
<p>稀疏图 - 邻接表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;       <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="type">bool</span> directed;  <span class="comment">// 是否为有向图</span></span><br><span class="line">    vector&lt;vector&lt;Edge&lt;Weight&gt; *&gt; &gt; g;   <span class="comment">// 图的具体数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SparseGraph</span>( <span class="type">int</span> n , <span class="type">bool</span> directed)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;    <span class="comment">// 初始化没有任何边</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="comment">// g初始化为n个空的vector, 表示每一个g[i]都为空, 即没有任和边</span></span><br><span class="line">        g = vector&lt;vector&lt;Edge&lt;Weight&gt; *&gt; &gt;(n, vector&lt;Edge&lt;Weight&gt; *&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SparseGraph</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; g[i].<span class="built_in">size</span>() ; j ++ )</span><br><span class="line">                <span class="keyword">delete</span> g[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 返回节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 返回边的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向图中添加一个边, 权值为weight</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">( <span class="type">int</span> v, <span class="type">int</span> w , Weight weight)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意, 由于在邻接表的情况, 查找是否有重边需要遍历整个链表</span></span><br><span class="line">        <span class="comment">// 我们的程序允许重边的出现</span></span><br><span class="line"></span><br><span class="line">        g[v].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(v, w, weight));</span><br><span class="line">        <span class="keyword">if</span>( v != w &amp;&amp; !directed )</span><br><span class="line">            g[w].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(w, v, weight));</span><br><span class="line">        m ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证图中是否有从v到w的边</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">( <span class="type">int</span> v , <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n );</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n );</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; g[v].<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">            <span class="keyword">if</span>( g[v][i]-&gt;<span class="built_in">other</span>(v) == w )<span class="comment">// edge中的other:判断与v相接的另一个顶点是否为w</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图的信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;vertex &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; g[i].<span class="built_in">size</span>() ; j ++ )</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;( to:&quot;</span>&lt;&lt;g[i][j]-&gt;<span class="built_in">w</span>()&lt;&lt;<span class="string">&quot;,wt:&quot;</span>&lt;&lt;g[i][j]-&gt;<span class="built_in">wt</span>()&lt;&lt;<span class="string">&quot;)\t&quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有边</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">adjIterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SparseGraph &amp;G; <span class="comment">// 图G的引用</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">adjIterator</span>(SparseGraph &amp;graph, <span class="type">int</span> v): <span class="built_in">G</span>(graph)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">adjIterator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的第一个边</span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt;* <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( G.g[v].<span class="built_in">size</span>() )</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            <span class="comment">// 若没有顶点和v相连接, 则返回NULL</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回图G中与顶点v相连接的下一个边</span></span><br><span class="line">        <span class="function">Edge&lt;Weight&gt;* <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( index &lt; G.g[v].<span class="built_in">size</span>() )</span><br><span class="line">                <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树">最小生成树</h3>
<p>最小生成树（Minimum Span Tree，MST）：对于一个完全连通的带权图来说，需要找到一个这个图所属的生成树（生成树：一张图如果有v个节点，则使用v-1条边连接的这v个节点所形成的树），且这棵树上的所有边上的权值相加为最小</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210144437727.png" alt="生成树"></p>
<p>该问题通常针对<strong>带权无向图</strong>、<strong>连通图</strong></p>
<p>通常用切分定理来解决该问题，一般有两种算法：</p>
<ol>
<li>Prim算法</li>
<li>Kruskal算法</li>
</ol>
<h4 id="切分定理">切分定理</h4>
<p><strong>切分</strong>（Cut）：将图中的节点分为两部分，这样一分后，则说这个图形成了两个切分。</p>
<p><strong>横切边</strong>（ Crossing Edge）：如果一个边的两个端点，属于切分不同的两边，这个边称为横切边。</p>
<p><strong>切分定理</strong>：在一张图中给定<strong>任意</strong>切分，横切边中权值最小的边必然属于最小生成树。</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210145256174.png" alt="切分定理"></p>
<blockquote>
<p>注意：如果横切边有相等的边，根据下面的每一个算法的不同实现，使得结果会有所不同，且下述的每种算法都只能找到其中的一个最小生成树</p>
</blockquote>
<h5 id="Lazy-Prim算法">Lazy Prim算法</h5>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210145739306.png" alt="Lazy Prim算法"></p>
<ol>
<li>选定起始点0，与剩下节点做切分，分成两部分</li>
<li>使用[最小堆](# 1.最大堆)结构从堆中选出最短边
<ul>
<li>注意：有可能取出的最短边不是横切边，此情况需要排除，见步骤4</li>
</ul>
</li>
<li>将上述选出的最短边加入节点0的切分中来，重新形成切分与新的横切边</li>
<li>重新上述1-3步，直到取出的最短边的两个顶点均为节点0的切分内部的边时（不属于横切边），舍弃该边，重新寻找，直至算法完成。如下图为舍弃时的情况</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210154050622.png" alt="寻找时舍弃内部边"></p>
<ul>
<li>淡蓝色边：横切边</li>
<li>红色边：寻找到的边</li>
<li>上方三条灰色边：舍弃的边</li>
</ul>
<p>算法时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(ElogE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>E：整个图的所有边的数量</li>
</ul>
<hr>
<p>实现：</p>
<p>最小堆：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &gt; data[k] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &lt; data[j] ) j ++;</span><br><span class="line">            <span class="keyword">if</span>( data[k] &lt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>( data[k] , data[j] );</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最小堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    <span class="built_in">MinHeap</span>(Item arr[], <span class="type">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            <span class="built_in">shiftDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MinHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小堆中插入一个新的元素 item</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count+<span class="number">1</span>);</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小堆中取出堆顶元素, 即堆中所存储的最小数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">swap</span>( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>求解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Prim算法求图的最小生成树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyPrimMST</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                   <span class="comment">// 图的引用</span></span><br><span class="line">    MinHeap&lt;Edge&lt;Weight&gt;&gt; pq;   <span class="comment">// 最小堆, 算法辅助数据结构</span></span><br><span class="line">    <span class="type">bool</span> *marked;               <span class="comment">// 标记数组, 在算法运行过程中标记节点i是否被访问（切分区）</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;   <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    Weight mstWeight;           <span class="comment">// 最小生成树的累计总权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v（辅助函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( !marked[v] );</span><br><span class="line">        marked[v] = <span class="literal">true</span>;<span class="comment">// 标记，即代表访问过 或 切分到最小生成树节点区域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的所有未访问的边放入最小堆中</span></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )<span class="comment">//遍历图中所有边</span></span><br><span class="line">            <span class="keyword">if</span>( !marked[e-&gt;<span class="built_in">other</span>(v)] )<span class="comment">//e-&gt;other(v)：节点v相连的另一个节点 判断此节点是否已经访问过</span></span><br><span class="line">                pq.<span class="built_in">insert</span>(*e);<span class="comment">// 最小堆中插入该边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="built_in">LazyPrimMST</span>(Graph &amp;graph):<span class="built_in">G</span>(graph), <span class="built_in">pq</span>(MinHeap&lt;Edge&lt;Weight&gt;&gt;(graph.<span class="built_in">E</span>()))&#123;<span class="comment">//最小堆pq大小默认为整个图中边的数量</span></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">        mst.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lazy Prim</span></span><br><span class="line">        <span class="built_in">visit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !pq.<span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            <span class="comment">// 使用最小堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.<span class="built_in">extractMin</span>();</span><br><span class="line">            <span class="comment">// 如果这条边的两端都已经访问过了, 则扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>( marked[e.<span class="built_in">v</span>()] == marked[e.<span class="built_in">w</span>()] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 否则, 这条边则应该存在在最小生成树中（此时该边一定为横切边）</span></span><br><span class="line">            mst.<span class="built_in">push_back</span>( e );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问和这条边连接的还没有被访问过的节点（定为横切边）</span></span><br><span class="line">            <span class="keyword">if</span>( !marked[e.<span class="built_in">v</span>()] )</span><br><span class="line">                <span class="built_in">visit</span>( e.<span class="built_in">v</span>() );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">visit</span>( e.<span class="built_in">w</span>() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最小生成树的权值</span></span><br><span class="line">        mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; mst.<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">            mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">LazyPrimMST</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdges</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Prim算法">Prim算法</h5>
<p>该算法是Lazy Prim算法的优化版本</p>
<p>算法时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(ElogV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>E：整个图的所有边的数量</li>
<li>V：整个图的节点数量</li>
<li>由于整个遍历过程少了，节省的时间非常可观</li>
</ul>
<p>lazy prim算法缺点：</p>
<ol>
<li>所有边都需要经过最小堆，其中有些边随着切分的改变会变为不是横切边</li>
<li>虽然有很多横切边，但是通常只关注最短的那一条横切边</li>
</ol>
<p>优化思路：</p>
<ol>
<li>使用新的数据结构来维护横切边，存储每个节点相连的最短的横切边</li>
<li>在不断变化的切分中，只需要不断更新该数据机构即可</li>
</ol>
<p>满足上述两点的数据结构：[索引堆](# 6.索引堆)</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210174548357.png" alt="优化后的Prim算法"></p>
<ul>
<li>通过一个数组来保存最短临边</li>
<li>从节点0开始，其余节点2、4、6、7临边依次更新进数组，并选出最短临边0.16（节点7）</li>
<li>由0、7组成的切分继续扩充横切边
<ul>
<li>遍历节点7的临边，未在表中的直接加入，已在表中的判断是否最小值，表中仅仅保留最小值</li>
</ul>
</li>
<li>重复上述步骤直至所有节点全部更新完毕</li>
</ul>
<hr>
<p>实现：</p>
<p>最小索引堆：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexMinHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最小索引堆中的数据</span></span><br><span class="line">    <span class="type">int</span> *indexes;   <span class="comment">// 最小索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="type">int</span> *reverse;   <span class="comment">// 最小索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &gt; data[indexes[k]] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j]] &gt; data[indexes[j+<span class="number">1</span>]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &lt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">IndexMinHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="type">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="type">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IndexMinHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="built_in">assert</span>( index + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; index + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = index;</span><br><span class="line">        reverse[index] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素, 即索引堆中所存储的最小数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">( <span class="type">int</span> index )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse[index+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="type">int</span> index )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">contain</span>(index) );</span><br><span class="line">        <span class="keyword">return</span> data[index+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最小索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">( <span class="type">int</span> index , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">contain</span>(index) );</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">shiftUp</span>( reverse[index] );</span><br><span class="line">        <span class="built_in">shiftDown</span>( reverse[index] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>求解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用优化的Prim算法求图的最小生成树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimMST</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                     <span class="comment">// 图的引用</span></span><br><span class="line">    IndexMinHeap&lt;Weight&gt; ipq;     <span class="comment">// 最小索引堆, 算法辅助数据结构</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; edgeTo; <span class="comment">// 访问的点所对应的最短横切边, 算法辅助数据结构</span></span><br><span class="line">    <span class="type">bool</span>* marked;                 <span class="comment">// 标记数组, 在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;     <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    Weight mstWeight;             <span class="comment">// 最小生成树的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问节点v</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( !marked[v] );</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将和节点v相连接的未访问的另一端点, 和与之相连接的边, 放入最小堆中</span></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )&#123;<span class="comment">//遍历节点v的临边</span></span><br><span class="line">            <span class="type">int</span> w = e-&gt;<span class="built_in">other</span>(v);</span><br><span class="line">            <span class="comment">// 如果边的另一端点未被访问（即横切边）</span></span><br><span class="line">            <span class="keyword">if</span>( !marked[w] )&#123;</span><br><span class="line">                <span class="comment">// 如果从没有考虑过这个端点, 直接将这个端点和与之相连接的边加入索引堆</span></span><br><span class="line">                <span class="keyword">if</span>( !edgeTo[w] )&#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    ipq.<span class="built_in">insert</span>(w, e-&gt;<span class="built_in">wt</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果曾经考虑这个端点, 但现在的边比之前考虑的边更短, 则进行替换</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( e-&gt;<span class="built_in">wt</span>() &lt; edgeTo[w]-&gt;<span class="built_in">wt</span>() )&#123;</span><br><span class="line">                    edgeTo[w] = e;<span class="comment">// 存储最短横切边</span></span><br><span class="line">                    ipq.<span class="built_in">change</span>(w, e-&gt;<span class="built_in">wt</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 使用Prim算法求图的最小生成树</span></span><br><span class="line">    <span class="built_in">PrimMST</span>(Graph &amp;graph):<span class="built_in">G</span>(graph), <span class="built_in">ipq</span>(<span class="built_in">IndexMinHeap</span>&lt;<span class="type">double</span>&gt;(graph.<span class="built_in">V</span>()))&#123;</span><br><span class="line">        <span class="built_in">assert</span>( graph.<span class="built_in">E</span>() &gt;= <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            edgeTo.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mst.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prim</span></span><br><span class="line">        <span class="built_in">visit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !ipq.<span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            <span class="comment">// 使用最小索引堆找出已经访问的边中权值最小的边</span></span><br><span class="line">            <span class="comment">// 最小索引堆中存储的是点的索引, 通过点的索引找到相对应的边</span></span><br><span class="line">            <span class="type">int</span> v = ipq.<span class="built_in">extractMinIndex</span>();</span><br><span class="line">            <span class="built_in">assert</span>( edgeTo[v] );<span class="comment">//确保节点v的最小横切边存在</span></span><br><span class="line">            mst.<span class="built_in">push_back</span>( *edgeTo[v] );</span><br><span class="line">            <span class="built_in">visit</span>( v );</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//求解累计权值	</span></span><br><span class="line">        mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; mst.<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">            mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">PrimMST</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdges</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Kruskal算法">Kruskal算法</h5>
<p>依次找到图中的最短的边，只要这些边之间不构成一个环，则一定是最小生成树中相应的边</p>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210190051223.png" alt="Kruskal算法"></p>
<ol>
<li>将所有边从小到大进行排序</li>
<li>选取最小边进行判断，若不会形成环则为最小生成树的边
<ul>
<li>判断是否为环这个操作可以通过<a href="#%E4%BA%94%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>来实现</li>
</ul>
</li>
<li>重复上述1-2步，直至找到n-1条边，其中n为节点个数</li>
</ol>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(ElogE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，较上述两种算法<strong>耗时</strong>，但是实现较为<strong>简单</strong></p>
<ul>
<li>E：整个图的所有边的数量</li>
</ul>
<hr>
<p>实现：</p>
<p>并查集：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick Union + rank + path compression</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">    <span class="comment">// 在后续的代码中并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line">    <span class="comment">// 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line">    <span class="type">int</span>* rank;</span><br><span class="line">    <span class="type">int</span>* parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">    <span class="type">int</span> count;   <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> count)&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">UnionFind</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] parent;</span><br><span class="line">        <span class="keyword">delete</span>[] rank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path compression 1</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path compression 2, 递归算法</span></span><br><span class="line"><span class="comment">//            if( p != parent[p] )</span></span><br><span class="line"><span class="comment">//                parent[p] = find( parent[p] );</span></span><br><span class="line"><span class="comment">//            return parent[p];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">        <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 此时, 需要维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Kruskal算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KruskalMST</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; mst;   <span class="comment">// 最小生成树所包含的所有边</span></span><br><span class="line">    Weight mstWeight;           <span class="comment">// 最小生成树的权值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 使用Kruskal算法计算graph的最小生成树</span></span><br><span class="line">    <span class="built_in">KruskalMST</span>(Graph &amp;graph)&#123;</span><br><span class="line">        <span class="comment">// 将图中的所有边存放到一个最小堆中（并排序）</span></span><br><span class="line">        MinHeap&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">pq</span>( graph.<span class="built_in">E</span>() );</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; graph.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(graph,i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>( Edge&lt;Weight&gt; *e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )</span><br><span class="line">                <span class="keyword">if</span>( e-&gt;<span class="built_in">v</span>() &lt; e-&gt;<span class="built_in">w</span>() )<span class="comment">// 防止每条边被正向、反向遍历两边</span></span><br><span class="line">                    pq.<span class="built_in">insert</span>(*e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个并查集, 来查看已经访问的节点的联通情况</span></span><br><span class="line">        UnionFind uf = <span class="built_in">UnionFind</span>(graph.<span class="built_in">V</span>());</span><br><span class="line">        <span class="keyword">while</span>( !pq.<span class="built_in">isEmpty</span>() &amp;&amp; mst.<span class="built_in">size</span>() &lt; graph.<span class="built_in">V</span>() - <span class="number">1</span> )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从最小堆中依次从小到大取出所有的边</span></span><br><span class="line">            Edge&lt;Weight&gt; e = pq.<span class="built_in">extractMin</span>();</span><br><span class="line">            <span class="comment">// 如果该边的两个端点是联通的, 说明加入这条边将产生环, 扔掉这条边</span></span><br><span class="line">            <span class="keyword">if</span>( uf.<span class="built_in">isConnected</span>( e.<span class="built_in">v</span>() , e.<span class="built_in">w</span>() ) )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 否则, 将这条边添加进最小生成树, 同时标记边的两个端点联通</span></span><br><span class="line">            mst.<span class="built_in">push_back</span>( e );</span><br><span class="line">            uf.<span class="built_in">unionElements</span>( e.<span class="built_in">v</span>() , e.<span class="built_in">w</span>() );</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//求和</span></span><br><span class="line">        mstWeight = mst[<span class="number">0</span>].<span class="built_in">wt</span>();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; mst.<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">            mstWeight += mst[i].<span class="built_in">wt</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">KruskalMST</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的所有边</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;&gt; <span class="built_in">mstEdges</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树的权值</span></span><br><span class="line">    <span class="function">Weight <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vyssotsky算法</p>
<p>基本思想：将任意一条边逐渐地添加到生成树中，一旦形成环，删除环中权值最大的边</p>
<blockquote>
<p>该算法需要删除边、且需要在环上的最长边（需要探测环的存在且找到环中权值最大的边），对于这个操作暂时没有优秀的数据结构能够快速的处理该事，所以一般实现较为复杂</p>
</blockquote>
<h2 id="八、最短路径">八、最短路径</h2>
<p>对于无向图、有向图均成立</p>
<p>最短路径问题：求从一个节点到另一个节点耗费最小的路径</p>
<p>对于一个<strong>无权图</strong>，从某个一节点开始进行<a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">广度优先遍历</a>，结果其实就是求从一个节点到其他<strong>所有</strong>节点相应的<strong>最短路径</strong>，其实这形成了从起始节点开始到其他所有节点的一棵树，通常称之为<strong>最短路径树</strong>（Shortest Path Tree），求这棵树的过程通常称之为<strong>单源最短路径</strong>（Single Source Shortest Path）</p>
<p><strong>松弛(relaxation)</strong>：指对于图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 中每个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v ∈ V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> ，都设置一个属性 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dist[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> ，用来描述从源点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的最短路径上权值的上界。在开始进行一个最短路径算法时，只知道图中边和权值。随着算法的进行，逐渐得到各对顶点的最短路径的信息。算法会逐渐更新这些信息，每步都会检查是否可以找到一条路径比当前给定路径更短。这一过程通常称为松弛。</p>
<h3 id="dijkstra单源最短路径算法">dijkstra单源最短路径算法</h3>
<p>前提：图中不能有负权边</p>
<p>在最优的情况下时间复杂度为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(ElogV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>E：整个图的所有边的数量</li>
<li>V：整个图的节点数量</li>
</ul>
<hr>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210211300469.png" alt="dijkstra算法"></p>
<ul>
<li>选定初始点：节点0，标出节点0的所有临边</li>
<li>找到未访问节点中能够以最短路径访问的节点，即节点2
<ul>
<li>因为没有负权，且到其他节点的距离都&gt;2，所以不可能有比2更短的距离到节点2</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210212042068.png" alt="松弛操作"></p>
<ul>
<li>进行松弛操作：从节点2开始到其他节点有没有可能比 已经找到的、从原点到其他节点 路径更短的路线
<ul>
<li>由于0-2-1比之前的0-1路径短，所以在表中更新（即松弛过程）</li>
<li>由于0-2-3比之前的0-3路径短，所以在表中更新（即松弛过程）</li>
</ul>
</li>
<li>由于之前没有到过节点4，所以表中直接填</li>
<li>重复上述循环：找到此时未访问节点中能够以最短路径访问的节点，即节点1</li>
</ul>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210210212646250.png" alt="重复"></p>
<ul>
<li>进行松弛操作：从节点1开始到其他节点有没有可能比 已经找到的、从原点到其他节点 路径更短的路线
<ul>
<li>由于0-2-1-4比之前的0-2-4路径短，所以在表中更新（即松弛过程）</li>
</ul>
</li>
<li>重复上述循环：找到此时未访问节点中能够以最短路径访问的节点，即节点4</li>
<li>最后只剩下节点3，此时长度就为5，至此算法结束</li>
</ul>
<hr>
<p>实现：</p>
<p>最小索引堆：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexMinHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;     <span class="comment">// 最小索引堆中的数据</span></span><br><span class="line">    <span class="type">int</span> *indexes;   <span class="comment">// 最小索引堆中的索引, indexes[x] = i 表示索引i在x的位置</span></span><br><span class="line">    <span class="type">int</span> *reverse;   <span class="comment">// 最小索引堆中的反向索引, reverse[i] = x 表示索引i在x的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &gt; data[indexes[k]] )&#123;</span><br><span class="line">            <span class="built_in">swap</span>( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">( <span class="type">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j]] &gt; data[indexes[j+<span class="number">1</span>]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &lt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 构造一个空的索引堆, 可容纳capacity个元素</span></span><br><span class="line">    <span class="built_in">IndexMinHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="type">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="type">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IndexMinHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引堆中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个布尔值, 表示索引堆中是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向最小索引堆中插入一个新的元素, 新元素的索引为i, 元素为item</span></span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, Item item)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="built_in">assert</span>( index + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; index + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = index;</span><br><span class="line">        reverse[index] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素, 即索引堆中所存储的最小数据</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最小索引堆中取出堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extractMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中的堆顶元素的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">( <span class="type">int</span> index )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse[index+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小索引堆中索引为i的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="type">int</span> index )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">contain</span>(index) );</span><br><span class="line">        <span class="keyword">return</span> data[index+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最小索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">( <span class="type">int</span> index , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">contain</span>(index) );</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">shiftUp</span>( reverse[index] );</span><br><span class="line">        <span class="built_in">shiftDown</span>( reverse[index] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Dijkstra算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dijkstra</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                   <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="type">int</span> s;                      <span class="comment">// 起始点</span></span><br><span class="line">    Weight *distTo;             <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">    <span class="type">bool</span> *marked;               <span class="comment">// 标记数组, 在算法运行过程中标记节点i是否被访问</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; from; <span class="comment">// from[i]记录最短路径中, 到达i点的边是哪一条边</span></span><br><span class="line">                                <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 使用Dijkstra算法求最短路径</span></span><br><span class="line">    <span class="built_in">Dijkstra</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        <span class="built_in">assert</span>( s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.<span class="built_in">V</span>()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="type">bool</span>[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            distTo[i] = <span class="built_in">Weight</span>();<span class="comment">// 调用模板的默认构造函数</span></span><br><span class="line">            marked[i] = <span class="literal">false</span>;</span><br><span class="line">            from.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br><span class="line">        <span class="function">IndexMinHeap&lt;Weight&gt; <span class="title">ipq</span><span class="params">(G.V())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于其实点s进行初始化</span></span><br><span class="line">        distTo[s] = <span class="built_in">Weight</span>();<span class="comment">// 调用模板的默认构造函数</span></span><br><span class="line">        from[s] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(s, s, <span class="built_in">Weight</span>());</span><br><span class="line">        ipq.<span class="built_in">insert</span>(s, distTo[s] );</span><br><span class="line">        marked[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>( !ipq.<span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            <span class="type">int</span> v = ipq.<span class="built_in">extractMinIndex</span>();<span class="comment">//取出最小索引堆中距原点最近的点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// distTo[v]就是s到v的最短距离</span></span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对v的所有相邻节点进行更新（核心操作——松弛操作）</span></span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )&#123;<span class="comment">//对v邻边进行遍历</span></span><br><span class="line">                <span class="type">int</span> w = e-&gt;<span class="built_in">other</span>(v);<span class="comment">//找到邻边的另一个节点w</span></span><br><span class="line">                <span class="comment">// 如果从s点到w点的最短路径还没有找到</span></span><br><span class="line">                <span class="keyword">if</span>( !marked[w] )&#123;<span class="comment">//松弛操作</span></span><br><span class="line">                    <span class="comment">// 如果w点以前没有访问过,</span></span><br><span class="line">                    <span class="comment">// 或者访问过, 但是通过当前的v点到w点距离更短, 则进行更新</span></span><br><span class="line">                    <span class="keyword">if</span>( from[w] == <span class="literal">NULL</span> || distTo[v] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[w] )&#123;</span><br><span class="line">                        distTo[w] = distTo[v] + e-&gt;<span class="built_in">wt</span>();</span><br><span class="line">                        from[w] = e;</span><br><span class="line">                        <span class="keyword">if</span>( ipq.<span class="built_in">contain</span>(w) )<span class="comment">//维护最小索引堆</span></span><br><span class="line">                            ipq.<span class="built_in">change</span>(w, distTo[w] );<span class="comment">//如果包含该节点，则更新最小距离</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            ipq.<span class="built_in">insert</span>(w, distTo[w] );<span class="comment">//否则直接插入</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Dijkstra</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">        <span class="keyword">delete</span>[] marked;</span><br><span class="line">        <span class="keyword">delete</span> from[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s到w的最短路径, 将整个路径经过的边存放在vec中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shortestPath</span><span class="params">( <span class="type">int</span> w, vector&lt;Edge&lt;Weight&gt;&gt; &amp;vec )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        stack&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span>( e-&gt;<span class="built_in">v</span>() != <span class="keyword">this</span>-&gt;s )&#123;<span class="comment">//不是原点</span></span><br><span class="line">            s.<span class="built_in">push</span>(e);<span class="comment">//放入栈中</span></span><br><span class="line">            e = from[e-&gt;<span class="built_in">v</span>()];<span class="comment">//取出上一条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(e);<span class="comment">//存入最后一条边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">        <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">            e = s.<span class="built_in">top</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>( *e );</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line"></span><br><span class="line">        vector&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">shortestPath</span>(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>() ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;vec[i].<span class="built_in">v</span>()&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>( i == vec.<span class="built_in">size</span>()<span class="number">-1</span> )</span><br><span class="line">                cout&lt;&lt;vec[i].<span class="built_in">w</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford单源最短路径算法">Bellman-Ford单源最短路径算法</h3>
<p>dijkstra算法的缺点就是不能够处理负权边</p>
<p><strong>负权环</strong>：从某一点到该点的一个环，环上权重和为负数。</p>
<p>当一个图中出现负权环，则<strong>不存在</strong>最短路径或最短路径为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span></p>
<p>前提：图中不能有负权环，若图中有负权环，该算法虽然找不到最短路径，但是<strong>可以判断</strong>是否有负权环</p>
<p>基本思想：如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的V个顶点（一个图中假设有V个顶点），有V-1条边。否则，存在顶点经过了两次，既存在负权环</p>
<blockquote>
<p>注意：在无向图中，只要有一条负权边，即可认为有一个负权环</p>
</blockquote>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(EV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>E：整个图的所有边的数量</li>
<li>V：整个图的节点数量</li>
</ul>
<hr>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210211092813634.png" alt="松弛操作"></p>
<ol>
<li>找到初始节点0相邻的所有邻边，即可暂时找到和其他节点之间的一个路径，且暂时得到一个最短路径
<ul>
<li>上述操作可以视为对节点0相邻的所有节点进行了一次松弛操作，得到的结果是从原点开始经过一条边到其他节点的最短路径</li>
</ul>
</li>
<li>在进行一次松弛操作：</li>
</ol>
<p><img src="/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210211124834655.png" alt="第二次松弛操作"></p>
<ul>
<li>再次松弛操作后，能够找到从原点开始通过两条路径的最短路径</li>
</ul>
<p>综上：对所有的点进行V-1次松弛操作，理论上就找到了从源点到其他所有点的最短路径。如果还可以继续松弛，所说原图中有负权环。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用BellmanFord算法求最短路径</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BellmanFord</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;                   <span class="comment">// 图的引用</span></span><br><span class="line">    <span class="type">int</span> s;                      <span class="comment">// 起始点</span></span><br><span class="line">    Weight* distTo;             <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">    vector&lt;Edge&lt;Weight&gt;*&gt; from; <span class="comment">// from[i]记录最短路径中, 到达i点的边是哪一条边</span></span><br><span class="line">                                <span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line">    <span class="type">bool</span> hasNegativeCycle;      <span class="comment">// 标记图中是否有负权环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断图中是否有负权环（继续松弛操作）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectNegativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )</span><br><span class="line">                <span class="keyword">if</span>( from[e-&gt;<span class="built_in">v</span>()] &amp;&amp; distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[e-&gt;<span class="built_in">w</span>()] )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数, 使用BellmanFord算法求最短路径</span></span><br><span class="line">    <span class="built_in">BellmanFord</span>(Graph &amp;graph, <span class="type">int</span> s):<span class="built_in">G</span>(graph)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        distTo = <span class="keyword">new</span> Weight[G.<span class="built_in">V</span>()];</span><br><span class="line">        <span class="comment">// 初始化所有的节点s都不可达, 由from数组来表示</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )</span><br><span class="line">            from.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置distTo[s] = 0, 并且让from[s]不为NULL, 表示初始s节点可达且距离为0</span></span><br><span class="line">        distTo[s] = <span class="built_in">Weight</span>();</span><br><span class="line">        from[s] = <span class="keyword">new</span> <span class="built_in">Edge</span>&lt;Weight&gt;(s, s, <span class="built_in">Weight</span>()); <span class="comment">// 这里我们from[s]的内容是new出来的, 注意要在析构函数里delete掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bellman-Ford的过程</span></span><br><span class="line">        <span class="comment">// 进行V-1次循环, 每一次循环求出从起点到其余所有点, 最多使用pass步可到达的最短距离</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> pass = <span class="number">1</span> ; pass &lt; G.<span class="built_in">V</span>() ; pass ++ )&#123;</span><br><span class="line">            <span class="comment">// 每次循环中对所有的边进行一遍松弛操作</span></span><br><span class="line">            <span class="comment">// 遍历所有边的方式是先遍历所有的顶点, 然后遍历和所有顶点相邻的所有边</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.<span class="built_in">V</span>() ; i ++ )&#123;</span><br><span class="line">                <span class="comment">// 使用邻边迭代器遍历和所有顶点相邻的所有边</span></span><br><span class="line">                <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G,i)</span></span>;</span><br><span class="line">                <span class="keyword">for</span>( Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>() ; !adj.<span class="built_in">end</span>() ; e = adj.<span class="built_in">next</span>() )</span><br><span class="line">                    <span class="comment">// 对于每一个边首先判断e-&gt;v()可达</span></span><br><span class="line">                    <span class="comment">// 之后看如果e-&gt;w()以前没有到达过， 显然我们可以更新distTo[e-&gt;w()]</span></span><br><span class="line">                    <span class="comment">// 或者e-&gt;w()以前虽然到达过, 但是通过这个e我们可以获得一个更短的距离, 即可以进行一次松弛操作, 我们也可以更新distTo[e-&gt;w()]</span></span><br><span class="line">                    <span class="keyword">if</span>( from[e-&gt;<span class="built_in">v</span>()] &amp;&amp; (!from[e-&gt;<span class="built_in">w</span>()] || distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>() &lt; distTo[e-&gt;<span class="built_in">w</span>()]) )&#123;</span><br><span class="line">                        distTo[e-&gt;<span class="built_in">w</span>()] = distTo[e-&gt;<span class="built_in">v</span>()] + e-&gt;<span class="built_in">wt</span>();</span><br><span class="line">                        from[e-&gt;<span class="built_in">w</span>()] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasNegativeCycle = <span class="built_in">detectNegativeCycle</span>();<span class="comment">//继续松弛操作，即进行第V次循环，判断是否为负权环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BellmanFord</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] distTo;</span><br><span class="line">        <span class="keyword">delete</span> from[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中是否有负权环</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">negativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNegativeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathTo</span><span class="params">( <span class="type">int</span> w )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="keyword">return</span> from[w] != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s到w的最短路径, 将整个路径经过的边存放在vec中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shortestPath</span><span class="params">( <span class="type">int</span> w, vector&lt;Edge&lt;Weight&gt;&gt; &amp;vec )</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        stack&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt; *e = from[w];</span><br><span class="line">        <span class="keyword">while</span>( e-&gt;<span class="built_in">v</span>() != <span class="keyword">this</span>-&gt;s )&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(e);</span><br><span class="line">            e = from[e-&gt;<span class="built_in">v</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">        <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() )&#123;</span><br><span class="line">            e = s.<span class="built_in">top</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>( *e );</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPath</span><span class="params">(<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.<span class="built_in">V</span>() );</span><br><span class="line">        <span class="built_in">assert</span>( !hasNegativeCycle );</span><br><span class="line">        <span class="built_in">assert</span>( <span class="built_in">hasPathTo</span>(w) );</span><br><span class="line"></span><br><span class="line">        vector&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">shortestPath</span>(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>() ; i ++ )&#123;</span><br><span class="line">            cout&lt;&lt;vec[i].<span class="built_in">v</span>()&lt;&lt;<span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>( i == vec.<span class="built_in">size</span>()<span class="number">-1</span> )</span><br><span class="line">                cout&lt;&lt;vec[i].<span class="built_in">w</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思考：最长路径">思考：最长路径</h3>
<ul>
<li>最长路径问题不能有正权环</li>
<li>无权图的最长路径问题是指数级难度的</li>
<li>对于有权图，不能使用 Dijkstra求最长路径问题</li>
<li>可以使用 Bellman-Ford算法（将权重取负，然后求最短路径）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">spaceman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nu-ll.github.io/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://nu-ll.github.io/2021/01/07/数据结构与算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://NU-LL.github.io" target="_blank">spaceman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/12/Leetcode/"><img class="prev-cover" src="https://gitee.com/NU-LL/image-host/raw/master/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/05/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E4%B8%8E%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="https://gitee.com/NU-LL/image-host/raw/master/139-150515124111.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法套路与框架</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/spaceman.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">spaceman</div><div class="author-info__description">CtrlC CtrlV大师</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NU-LL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">白嫖一时爽，一直白嫖一直爽</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F"><span class="toc-text">一、基础排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">0.冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">1.选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-text">改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">2.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">3.希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F"><span class="toc-text">二、高级排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">1.归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-text">自顶向下——递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3"><span class="toc-text">自底向上——迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%8C%BA%E5%88%AB"><span class="toc-text">性能区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">2.快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">局限性与优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92-2"><span class="toc-text">三路快排</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">3.分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">逆序对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACn%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">取出数组中第n大的元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">三、堆和堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="toc-text">1.最大堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">2.添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%96%E5%87%BA%E5%85%83%E7%B4%A0"><span class="toc-text">3.取出元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E7%A1%80%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8CHeapify"><span class="toc-text">4.基础堆排序和Heapify</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">基础堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Heapify"><span class="toc-text">Heapify</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8E%9F%E5%9C%B0%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">5.原地堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E5%A0%86"><span class="toc-text">6.索引堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">四、二分搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-text">1.二分查找法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#floor%E5%92%8Cceil"><span class="toc-text">floor和ceil</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">2.二分搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-2"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-text">遍历（深度优先）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-text">遍历（广度优先）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">最小最大值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9"><span class="toc-text">任意节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="toc-text">顺序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E9%97%AE%E9%A2%98"><span class="toc-text">树形问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">五、并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-Find%E7%BB%93%E6%9E%84"><span class="toc-text">Quick Find结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-Union%E7%BB%93%E6%9E%84"><span class="toc-text">Quick Union结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#union%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F"><span class="toc-text">union优化——元素大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%85%83%E7%B4%A0%E5%B1%82%E6%95%B0"><span class="toc-text">union优化——元素层数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-text">find优化——路径压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%97%A0%E6%9D%83%E5%9B%BE"><span class="toc-text">六、无权图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">图的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E7%A8%A0%E5%AF%86%EF%BC%89"><span class="toc-text">邻接矩阵（稠密）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%A2%86%E8%BE%B9"><span class="toc-text">遍历领边</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%A8%80%E7%96%8F%EF%BC%89"><span class="toc-text">邻接表（稀疏）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%A2%86%E8%BE%B9-2"><span class="toc-text">遍历领边</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">连通分量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E8%B7%AF"><span class="toc-text">寻路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">最短路径</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%89%E6%9D%83%E5%9B%BE"><span class="toc-text">七、有权图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E5%88%86%E5%AE%9A%E7%90%86"><span class="toc-text">切分定理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Lazy-Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Lazy Prim算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">八、最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-text">dijkstra单源最短路径算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-text">Bellman-Ford单源最短路径算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9A%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84"><span class="toc-text">思考：最长路径</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/06/openwrt%E5%AE%89%E8%A3%85transmission/" title="openwrt安装transmission.md">openwrt安装transmission.md</a><time datetime="2022-10-06T15:37:29.000Z" title="发表于 2022-10-06 23:37:29">2022-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/14/Linux%20perl%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" title="Linux perl性能分析工具">Linux perl性能分析工具</a><time datetime="2022-08-14T09:17:28.000Z" title="发表于 2022-08-14 17:17:28">2022-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/05/C++%20%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/" title="C++ 虚函数、纯虚函数">C++ 虚函数、纯虚函数</a><time datetime="2022-08-04T16:05:23.000Z" title="发表于 2022-08-05 00:05:23">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/26/VEYE%E6%91%84%E5%83%8F%E5%A4%B4%E8%B0%83%E8%AF%95/" title="VEYE摄像头调试">VEYE摄像头调试</a><time datetime="2022-06-26T08:37:45.000Z" title="发表于 2022-06-26 16:37:45">2022-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/06/%E5%9F%BA%E4%BA%8EVSCode%E6%90%AD%E5%BB%BAESP-IDF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" title="基于VSCode搭建ESP-IDF开发环境">基于VSCode搭建ESP-IDF开发环境</a><time datetime="2022-06-06T06:27:54.000Z" title="发表于 2022-06-06 14:27:54">2022-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By spaceman</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> <iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tx&color=eee" frameborder="0" allowtransparency="false" align="middle" height="20"></iframe></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>