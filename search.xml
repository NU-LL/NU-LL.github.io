<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SVM（线性模型）数学推导</title>
      <link href="/2020/06/05/SVM/"/>
      <url>/2020/06/05/SVM/</url>
      
        <content type="html"><![CDATA[<h1 id="SVM（线性模型）数学推导"><a href="#SVM（线性模型）数学推导" class="headerlink" title="SVM（线性模型）数学推导"></a>SVM（线性模型）数学推导</h1><p>作者：<a href="https://github.com/zihuanqiu" target="_blank" rel="noopener">zihuanqiu</a></p><p>[TOC]</p><p><img src="//NU-LL.github.io/2020/06/05/SVM/1590504502746.png" alt="1590504502746"></p><p>学习路线：先线性二分类解释清楚，再加入核方法扩展至非线性二分类</p><h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><ol><li><p>训练样本集</p><p>$(\boldsymbol{x}_i,y_i)$，其中$\boldsymbol{x_i}$为$n$维列向量，表示$n$维特征；$y_i$为标签，当$y_i=+1$时为正样本，$y_i=-1$时为负样本。</p><p>则训练样本集为：$D=\left{ \left( \boldsymbol{x}_{\boldsymbol{1}},y_1 \right) ,\left( \boldsymbol{x}_2,y_2 \right) ,\cdots ,\left( \boldsymbol{x}_m,y_m \right) \right} , y\in \left{ -1,+1 \right} $</p></li></ol><ol start="2"><li><p>什么叫超平面</p><p>如上图，若在二维空间内（两个特征），若数据为线性可分，则可以用一条直线将正负样本区分开来（2分类问题）；若在三维空间则为一个平面；三维空间以上无法想象统称为超平面。</p><p>但上图中区分正负样本肯定又不止一种划分方法，何者为最优？最优者才叫做SVM的超平面。</p><p>最优的判断标准则是，若对数据样本加以扰动（可以理解为采样样本总有误差），那么SVM超平面具有最佳的鲁棒性。从几何上来看，在上图中，若将超平面左右平移，直至触碰到最近的样本，那么这个被界定的范围记为$d$，则SVM的超平面是有最大$d$的那个超平面。</p></li></ol><ol start="3"><li><p>什么叫支持向量</p><p>SVM超平面左右平移最先触碰到的为支持向量</p></li></ol><ol start="4"><li><p>超平面的方程<br>$$<br>\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=0<br>$$<br>其中：$\boldsymbol{w}$和$\boldsymbol{x}$都是$n\times 1$的列向量，$n$是特征维数。$b$为标量；$\boldsymbol{w}$还是超平面的法向量，$b$控制了超平面到原点的距离。确定了$\boldsymbol{w}$和$b$，超平面就被完全确定了。</p><p>那么在超平面上方数据$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b&gt;0 $；在超平面下方数据$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b&lt;0 $；</p></li></ol><ol start="5"><li><p>$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=0$与$\zeta\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+\zeta b=0$表示的是同一个超平面</p><blockquote><p>如：$4x+4y=0$ 和 $ x+y=0$是同一个平面，$4x+4y=4 $和$ x+y=1$也是同一个平面</p></blockquote></li></ol><ol start="6"><li><p>线性可分数据集的定义</p><p>在数据集$\left{ \left( \boldsymbol{x}_i,y_i \right) \right} _{i=1\sim m}$中，$\exists \left( \boldsymbol{w},b \right) $，使得对于$\forall i=1 \sim m$，有：<br>$$<br>\begin{cases}</p><pre><code>\text{若}y_i=+1, \text{则}\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}_{\boldsymbol{i}}+b&gt; 0\\\text{若}y_i=-1, \text{则}\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}_{\boldsymbol{i}}+b&lt; 0\\</code></pre><p>\end{cases}<br>$$<br>即正样本全部分到上方，负样本全部分到下方</p><p>等价于 $y_i(\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}_{\boldsymbol{i}}+b)&gt; 0$</p></li></ol><ol start="7"><li><p>点到平面距离公式</p><p>点$(x_0,y_0)$到平面$w_1x+w_2y+b=0$的距离表示为：<br>$$<br>d=\frac{\left| w_1x_0+w_2y_0+b \right|}{\sqrt{w_{1}^{2}+w_{2}^{2}}}<br>$$<br>则样本点到超平面的距离表示为：<br>$$<br>d=\frac{\left| \boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}_{\boldsymbol{i}}+b \right|}{\lVert \boldsymbol{w} \rVert}<br>$$</p></li><li><p>若假设支持向量过超平面的平行线为$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=1$和$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=-1$（如上图所示），那么可求得</p><p>支持向量到超平面的距离为:<br>$$<br>d=\frac{1}{\lVert \boldsymbol{w} \rVert}<br>$$<br>那么超平面左右平移被限制的范围（即两个异类支持向量到超平面的距离之和）为：<br>$$<br>\varUpsilon =\frac{2}{\lVert \boldsymbol{w} \rVert}<br>$$<br>$\varUpsilon$被称为SVM的“间隔”（margin）</p></li></ol><blockquote><p>为什么可以假设支持向量过超平面的平行线为$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=1$和$\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b=-1$呢？正如上面第5点所述，由于$\boldsymbol{W}$和$b$可以整体缩放倍数，超平面不变。那么总可以通过$\zeta \cdot \left( \boldsymbol{w},b \right) \rightarrow \left( \boldsymbol{w’},b’ \right) $，使$\left| \boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}+b \right|=1$。归一化的操作为我们带来便利</p></blockquote><h2 id="求解超平面转化为下列优化问题"><a href="#求解超平面转化为下列优化问题" class="headerlink" title="求解超平面转化为下列优化问题"></a>求解超平面转化为下列优化问题</h2><p>在限制条件 $y_i(w^Tx_i+b)\geqslant 1,i=1\sim m$ 下，最小化 $\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2$ 的问题</p><p>即：<br>$$<br>\begin{align}<br>&amp;\underset{\boldsymbol{w},b}{\min},,\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2<br>\<br>&amp;s.t.\quad y_i(\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}_{\boldsymbol{i}}+b)\geqslant 1,i=1\sim m<br>\end{align}<br>$$</p><blockquote><p>最大化$\varUpsilon =\frac{2}{\lVert \boldsymbol{w} \rVert}$等价于最小化$\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2$，而限制条件$y_i(w^Tx_i+b)\geqslant 1,i=1\sim m$表示求解超平面的前提条件是所有样本都被正确分类的情况下</p></blockquote><p>这样就把支持向量机的求解转化为凸优化问题中的二次规划问题</p><blockquote><p>二次规划（Quadratic Programming）</p><ol><li>目标函数（Objective Function）为二次项</li><li>限制条件为一次项</li></ol><p>要么无解，要么只有一个极值</p></blockquote><h1 id="SVM（非线性模型）数学推导"><a href="#SVM（非线性模型）数学推导" class="headerlink" title="SVM（非线性模型）数学推导"></a>SVM（非线性模型）数学推导</h1><p>若数据集非线性可分，那么线性SVM的优化问题会变得无解。通过加入正则项，可以使SVM应用于非线性可分的数据集。</p><h2 id="改写优化目标函数和限制条件"><a href="#改写优化目标函数和限制条件" class="headerlink" title="改写优化目标函数和限制条件"></a>改写优化目标函数和限制条件</h2><p>$$<br>\begin{align}<br>    &amp;\underset{\boldsymbol{w},b}{\min},,\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2+C\sum_{i=1}^m{\xi <em>i}\<br>    &amp;s.t.\quad \begin{cases}<br>    y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{i}}+b \right) \geqslant 1-\xi _i\<br>    \xi _i\geqslant 0\<br>\end{cases},i=1\sim m\<br>\end{align}<br>\tag{1} \label{eq:1}<br>$$</p><p>其中：$\xi_i$称为松弛变量（Slack  Variable），$\sum_{i=1}^m{\xi _i}$称为正则项</p><blockquote><p>若$\xi_i$足够大，则限制条件可以被轻易满足（即为限制条件加入了容忍度）。但$\xi_i$又不能太大，那么限制条件就失去了意义。因此在优化目标函数里需要添加$\xi_i$，并用一个超参数$C$来权衡最小化$\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2$与最小化$\sum_{i=1}^m{\xi _i}$之间的关系</p></blockquote><h2 id="低维到高维的映射"><a href="#低维到高维的映射" class="headerlink" title="低维到高维的映射"></a>低维到高维的映射</h2><p>改写优化目标函数和限制条件后的SVM可以应用于非线性可分的数据集中。但是这样的SVM仍然是在试图寻找一条直线将正负样本划分，在某些情况下这仍然不够好，例如：</p><img src="//NU-LL.github.io/2020/06/05/SVM/1590496039067.png" alt="1590496039067"><p>不同于其他机器学习算法，SVM试图通过高维映射，使低维空间的线性不可分问题变成高维空间中的线性可分问题，从而在高维空间中画出超平面对数据集进行划分。</p><p>我们定义高维映射$\varphi (\boldsymbol{x})$：<br>$$<br>\boldsymbol{x}\xrightarrow{\varphi }\varphi  \left( \boldsymbol{x} \right)<br>$$</p><blockquote><p>其中$\boldsymbol{x}$是低维向量，而$\varphi (\boldsymbol{x})$为高维向量</p></blockquote><p>那么SVM的优化条件变为：<br>$$<br>\begin{align}<br>&amp;\underset{\boldsymbol{w},b}{\min},,\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2 +C\sum_{i=1}^m{\xi _i}</p><p>\<br>&amp;s.t.\quad \begin{cases}<br>    y_i(\boldsymbol{w}^{\boldsymbol{T}}\varphi  (\boldsymbol{x}_{\boldsymbol{i}})+b) \geqslant 1-\xi _i\<br>    \xi _i\geqslant 0\<br>\end{cases},i=1\sim m<br>\end{align}<br>$$</p><blockquote><p>此时$\boldsymbol{w}$的维度也升高了，与$\varphi (\boldsymbol{x})$的维度相同</p></blockquote><p>例子：</p><p><img src="//NU-LL.github.io/2020/06/05/SVM/1590498357677.png" alt="1590498357677"></p><p>对于这么一个异或问题，我们有：<br>$$<br>\begin{align}<br>&amp;\boldsymbol{x}<em>{\boldsymbol{1}}=\left[ \begin{array}{c}<br>    0\<br>    0\<br>\end{array} \right] \in C_1,\quad \boldsymbol{x}</em>{\boldsymbol{2}}=\left[ \begin{array}{c}<br>    1\<br>    1\<br>\end{array} \right] \in C_1,\quad<br>\<br>&amp;\boldsymbol{x}<em>{\boldsymbol{3}}=\left[ \begin{array}{c}<br>    1\<br>    0\<br>\end{array} \right] \in C_2,\quad \boldsymbol{x}</em>{\boldsymbol{4}}=\left[ \begin{array}{c}<br>    0\<br>    1\<br>\end{array} \right] \in C_2<br>\end{align}<br>$$<br>定义映射关系：<br>$$<br>\boldsymbol{x}=\left[ \begin{array}{c}<br>    a\<br>    b\<br>\end{array} \right] \xrightarrow{\varphi }\varphi  \left( \boldsymbol{x} \right) =\left[ \begin{array}{c}<br>    a^2\<br>    b^2\<br>    a\<br>    \begin{array}{c}<br>    b\<br>    ab\<br>\end{array}\<br>\end{array} \right]<br>$$<br>则升维后的样本为</p><p>$$<br>\begin{align}<br>&amp;\varphi \left( \boldsymbol{x}<em>{\boldsymbol{1}} \right) =\left[ \begin{array}{c}<br>    \begin{array}{c}<br>    0\<br>    0\<br>\end{array}\<br>    \begin{array}{c}<br>    0\<br>    0\<br>    0\<br>\end{array}\<br>\end{array} \right] \in C_1,\quad \varphi \left( \boldsymbol{x}</em>{\boldsymbol{2}} \right) =\left[ \begin{array}{c}<br>    \begin{array}{c}<br>    1\<br>    1\<br>\end{array}\<br>    \begin{array}{c}<br>    1\<br>    1\<br>    1\<br>\end{array}\<br>\end{array} \right] \in C_1,\quad<br>\<br>&amp;\varphi \left( \boldsymbol{x}<em>{\boldsymbol{3}} \right) =\left[ \begin{array}{c}<br>    \begin{array}{c}<br>    1\<br>    0\<br>\end{array}\<br>    \begin{array}{c}<br>    1\<br>    0\<br>    0\<br>\end{array}\<br>\end{array} \right] \in C_2,\quad \varphi \left( \boldsymbol{x}</em>{\boldsymbol{4}} \right) =\left[ \begin{array}{c}<br>    \begin{array}{c}<br>    0\<br>    1\<br>\end{array}\<br>    \begin{array}{c}<br>    0\<br>    1\<br>    0\<br>\end{array}\<br>\end{array} \right] \in C_2<br>\end{align}<br>$$</p><p>求得$\boldsymbol{w}$为：<br>$$<br>\boldsymbol{w}=\left[ \begin{array}{c}<br>    \begin{array}{c}<br>    -1\<br>    -1\<br>\end{array}\<br>    \begin{array}{c}<br>    -1\<br>    -1\<br>    6\<br>\end{array}\<br>\end{array} \right] ,\quad b=1<br>$$<br>则<br>$$<br>\begin{align}<br>\widehat{y}<em>1&amp;=\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{1}}+b,,=,,1&gt;0\\widehat{y}<em>2&amp;=\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{2}}+b,,=,,3&gt;0\\widehat{y}<em>3&amp;=\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{3}}+b,,=,,-1&lt;0\\widehat{y}<em>4&amp;=\boldsymbol{w}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{4}}+b,,=,,-1&lt;0<br>\end{align}<br>$$<br>可见的确通过升维，在高维空间划分了超平面，实现了非线性可分数据的分类问题。</p><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>可以证明：若升的维度越高，则数据集越有可能在高维空间被线性划分。可以猜想，若$\varphi (\boldsymbol{x})$为无限维度，则必定可以在无限高维空间划分任意数据集。但这样，会使得$\boldsymbol{w}$也变为无限维度，使优化问题$\eqref{eq:1}$变得不可解（因为$\boldsymbol{w}$是代求参数）。</p><p><strong>定理：我们可以不知道无限维映射$\varphi (\boldsymbol{x})$的显式表达，我们只要知道一个核函数（Kernel Function）</strong><br>$$<br>K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right) ,,=,,\varphi \left( \boldsymbol{x}<em>{\boldsymbol{1}} \right) ^T\cdot \varphi \left( \boldsymbol{x}</em>{\boldsymbol{2}} \right)<br>$$<br><strong>则$\eqref{eq:1}$这个优化式仍然可解。</strong></p><p>常用核函数：</p><ol><li>高斯核<br>$$<br>K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right) ,,=,,e^{-\frac{\lVert x_1-x_2 \rVert ^2}{2\sigma ^2}}<br>$$</li></ol><ol start="2"><li>多项式核</li></ol><p>$$<br>K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right) ,,=,,\left( \boldsymbol{x}<em>{\boldsymbol{1}}^{\boldsymbol{T}}\boldsymbol{x}</em>{\boldsymbol{2}}+1 \right) ^d<br>$$</p><blockquote><p>我们知道核$K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right)$的表达式，且知道$K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right)$可以表示为$\varphi \left( \boldsymbol{x}<em>{\boldsymbol{1}} \right) ^T \varphi \left( \boldsymbol{x}</em>{\boldsymbol{2}} \right)$，并且$\varphi (\boldsymbol{x})$是无限维的（不需要知道$\varphi (\boldsymbol{x})$的显示表达）。</p></blockquote><blockquote><p>$K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right)$能写成$\varphi \left( \boldsymbol{x}<em>{\boldsymbol{1}} \right) ^T \varphi \left( \boldsymbol{x}</em>{\boldsymbol{2}} \right)$的充要条件为（Mercer’s Theorem）：</p><ol><li>$K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right) = K\left( \boldsymbol{x}<em>{\boldsymbol{2}},\boldsymbol{x}</em>{\boldsymbol{1}} \right)$（交换性）</li><li>$\forall C_i, ,, \boldsymbol{x_i}(i=1\sim N)$，有$\sum_{i=1}^N{\sum_{j=1}^N{C_iC_jK\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right) \geqslant 0}},,$成立（半正定性）</li></ol></blockquote><h2 id="原问题和对偶问题"><a href="#原问题和对偶问题" class="headerlink" title="原问题和对偶问题"></a>原问题和对偶问题</h2><p>现在我们要在只知道$K\left( \boldsymbol{x}<em>{\boldsymbol{1}},\boldsymbol{x}</em>{\boldsymbol{2}} \right)$不知道$\varphi (\boldsymbol{x})$的情况下，解优化问题$\eqref{eq:1}$，因此我们需要一些理论知识铺垫。</p><blockquote><p>这是优化理论的内容，用到就学一下吧</p></blockquote><p>原问题（Prime Problem）：</p><p>最小化：<br>$$<br>f(\boldsymbol{\omega})<br>$$<br>限制条件：<br>$$<br>g_i\left( \boldsymbol{\omega} \right) \leqslant 0  \left( i=1\sim K \right)<br>\<br>h_i\left( \boldsymbol{\omega} \right) =0  \left( i=1\sim M \right)<br>$$<br>则其对偶问题（Dual Problem）为：</p><p>最大化：<br>$$<br>\varTheta \left( \boldsymbol{\alpha} ,\boldsymbol{\beta}\right) ,,=,,\underset{for,,all,,\boldsymbol{\omega}}{inf}\left{ L\left( \boldsymbol{\omega} ,\boldsymbol{\alpha} ,\boldsymbol{\beta} \right) \right}<br>$$</p><p>限制条件：</p><p>$$<br>\boldsymbol{\alpha }\geqslant 0<br>$$</p><blockquote><p>其中$L\left( \boldsymbol{\omega} ,\boldsymbol{\alpha },\boldsymbol{\beta } \right) $为：<br>$$<br>\begin{align}<br>L\left( \boldsymbol{\omega} ,\boldsymbol{\alpha },\boldsymbol{\beta } \right) ,,&amp;=,,f\left( \boldsymbol{\omega} \right) +\sum_{i=1}^K{\alpha <em>ig_i\left( \boldsymbol{\omega} \right)}+\sum</em>{i=1}^M{\beta _ih_i\left( \boldsymbol{\boldsymbol{\omega}} \right)},,<br>\<br>&amp;=,,f\left( \boldsymbol{\omega} \right) +\boldsymbol{\alpha }^{\boldsymbol{T}}g\left( \boldsymbol{\omega} \right) +\boldsymbol{\beta }^{\boldsymbol{T}}h\left( \boldsymbol{\omega} \right)<br>\end{align}<br>$$</p></blockquote><blockquote><p>$\underset{for,,all,,\boldsymbol{\omega}}{inf}$的意思是，在所有$\boldsymbol{\omega}$取值上取得的最小值</p></blockquote><p> 原问题和对偶问题的关系：如果$\boldsymbol{\omega}^<em>$是原问题的解，而$\boldsymbol{\alpha}^</em>,\boldsymbol{\beta}^<em>$是对偶问题的解，则有：<br>$$<br>f\left( \boldsymbol{\omega} ^</em> \right) \geqslant \theta \left( \boldsymbol{\alpha} ^<em>,\boldsymbol{\beta} ^</em> \right)<br>$$</p><blockquote><p>proof:<br>$$<br>\begin{align}<br>\theta \left( \boldsymbol{\alpha }^<em>,\boldsymbol{\beta }^</em> \right) ,,&amp;=,,\underset{for,,all,,\omega}{inf}\left{ L\left( \boldsymbol{\omega },\boldsymbol{\alpha }^<em>,\boldsymbol{\beta }^</em> \right) \right} \leqslant L\left( \boldsymbol{\omega }^<em>,\boldsymbol{\alpha }^</em>,\boldsymbol{\beta }^* \right)<br>\<br> &amp;=,,f\left( \boldsymbol{\omega }^* \right) +\sum_{i=1}^K{\boldsymbol{\alpha }<em>{i}^{<em>}g_i\left( \boldsymbol{\omega }^</em> \right)}+\sum</em>{i=1}^M{\boldsymbol{\beta }_{i}^{<em>}h_i\left( \boldsymbol{\omega }^</em> \right)}\leqslant ,,f\left( \boldsymbol{\omega }^* \right)<br>\end{align}<br>$$<br>因为其中$\boldsymbol{\alpha^* }\geqslant 0$,  $g_i\left( \boldsymbol{\omega ^<em>} \right) \leqslant 0   $，$h_i\left( \boldsymbol{\omega^</em> } \right) =0$</p></blockquote><h2 id="强对偶定理"><a href="#强对偶定理" class="headerlink" title="强对偶定理"></a>强对偶定理</h2><p>若$f(\boldsymbol{\omega})$为凸函数，且$g(\boldsymbol{\omega}) = \boldsymbol{A\omega} + b$，$h(\boldsymbol{\omega}) = \boldsymbol{C\omega} + d$，则优化问题的原问题与对偶问题间距为0，即：<br>$$<br>f\left( \boldsymbol{\omega} ^* \right) = \theta \left( \boldsymbol{\alpha} ^<em>,\boldsymbol{\beta} ^</em> \right)<br>$$<br>再观察上面的proof过程，可以立即得出：</p><p>对 $\forall i=1 \sim K$，有$\boldsymbol{\alpha^<em>_i }=0$ 或者 $g_i\left( \boldsymbol{\omega ^</em>} \right) =0   $</p><p>以上称为<strong>KKT条件</strong></p><h2 id="将SVM原问题转化为对偶问题"><a href="#将SVM原问题转化为对偶问题" class="headerlink" title="将SVM原问题转化为对偶问题"></a>将SVM原问题转化为对偶问题</h2><p>核函数SVM优化目标可以改写为（为了使形式上靠近优化理论，将$\xi _i\geqslant 0\rightarrow \xi _i\leqslant 0$）</p><p>最小化：<br>$$<br>\underset{\boldsymbol{w},b}{\min},,\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2+C\sum_{i=1}^m{\xi <em>i}\rightarrow \underset{\boldsymbol{w},b}{\min},,\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2-C\sum</em>{i=1}^m{\xi _i}<br>$$</p><p>限制条件：<br>$$<br>\begin{align}<br>y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}<em>{\boldsymbol{i}}\text{)}+b \right) \geqslant 1-\xi _i,,&amp;\rightarrow ,,y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \geqslant 1+\xi <em>i,,<br>\<br>&amp;\rightarrow ,,1+\xi _i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \leqslant 0<br>\<br>\xi _i\geqslant 0&amp;\rightarrow \xi _i\leqslant 0<br>\end{align}<br>$$</p><table><thead><tr><th align="left">1. 原问题</th><th align="left">1.核函数SVM原问题</th></tr></thead><tbody><tr><td align="left">最小化：<br>$f(\boldsymbol{\omega})$</td><td align="left">最小化：<br>$\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2-C\sum_{i=1}^m{\xi _i}$</td></tr><tr><td align="left">限制条件：<br>$g_i\left( \boldsymbol{\omega} \right) \leqslant 0  \left( i=1\sim K \right) \h_i\left( \boldsymbol{\omega} \right) =0  \left( i=1\sim M \right)$</td><td align="left">限制条件：<br>$,1+\xi <em>i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \leqslant 0 \ \xi _i\leqslant 0$</td></tr></tbody></table><p>从限制条件可知，左边的不等式限制条件$g_i\left( \boldsymbol{\omega} \right) \leqslant 0$对应右边的$,1+\xi <em>i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \leqslant 0 $和$\xi _i\leqslant 0$；而没有等式限制条。</p><p>优化目标函数$f(\boldsymbol{\omega})$对应$\frac{1}{2}\lVert \boldsymbol{w} \rVert ^2+C\sum_{i=1}^m{\xi _i}$</p><p>左边只有一个变量$\boldsymbol{\omega}$，而右边对应有三个变量$\boldsymbol{\omega}，\xi _i， b$</p><p>因此可以推导出核函数SVM的对偶问题：</p><table><thead><tr><th><strong>2. 对偶问题</strong></th><th>2. 核函数SVM对偶问题</th></tr></thead><tbody><tr><td>最大化：<br>$\varTheta \left( \boldsymbol{\alpha} ,\boldsymbol{\beta}\right) ,=,\underset{for,,all,,\boldsymbol{\omega}}{inf}\left{ L\left( \boldsymbol{\omega} ,\boldsymbol{\alpha} ,\boldsymbol{\beta} \right) \right}$</td><td>最大化：<br>$$\begin{align}\varTheta \left( \boldsymbol{\alpha },\boldsymbol{\beta } \right) ,=,\underset{for,,all,\left( ,\boldsymbol{\omega },\xi <em>i,b \right)}{inf}\left{ \frac{1}{2}\lVert \boldsymbol{w} \rVert ^2-C\sum</em>{i=1}^m{\xi <em>i}+\sum</em>{i=1}^m{\alpha <em>i},\left( 1+\xi _i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \right) +\sum_{i=1}^m{\beta _i\xi _i} \right}\end{align}$$</td></tr><tr><td>限制条件：<br>$\alpha_i\geqslant 0 \quad    (i=1 \sim K)            $</td><td>限制条件：<br>$\alpha_i\geqslant 0 , \beta_i \geqslant 0     \quad(i=1 \sim m)            $</td></tr><tr><td>$L\left( \boldsymbol{\omega },\boldsymbol{\alpha },\boldsymbol{\beta } \right) ,,=,,f\left( \boldsymbol{\omega } \right) +\sum_{i=1}^K{\alpha <em>ig_i\left( \boldsymbol{\omega } \right)}+\sum</em>{i=1}^M{\beta _ih_i\left( \boldsymbol{\omega } \right)},,$</td><td></td></tr></tbody></table><blockquote><p>注意，由于SVM中的不等式限制条件有$\alpha_i$和$\beta_i$两个，因此实际上左边的$\alpha_i$对应右边的$\alpha_i$和$\beta_i$</p></blockquote><p>现在我们来求解下式的具体表达式<br>$$<br>\begin{align}<br>\varTheta \left( \boldsymbol{\alpha },\boldsymbol{\beta } \right) ,&amp;=\underset{for,,all,\left( ,\boldsymbol{\omega },\xi <em>i,b \right)}{inf}\left{ L\left( \boldsymbol{\omega },\boldsymbol{\xi },b \right) \right} ,<br>\<br>&amp;=\underset{for,,all,\left( ,\boldsymbol{\omega },\boldsymbol{\xi },b \right)}{inf}\left{ \frac{1}{2}\lVert \boldsymbol{w} \rVert ^2-C\sum</em>{i=1}^m{\xi <em>i}+\sum</em>{i=1}^m{\alpha <em>i},\left( 1+\xi _i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) \right) +\sum_{i=1}^m{\beta <em>i\xi _i} \right}<br>\end{align}<br>$$<br>$\underset{for,,all,\left( ,\boldsymbol{\omega },\xi _i,b \right)}{inf}$表示求关于$\left( ,\boldsymbol{\omega },\xi _i,b \right) $的最小值，即求$\frac{\partial}{\partial \boldsymbol{\omega }}L\left( \boldsymbol{\omega },\xi _i,b \right) $，$\frac{\partial}{\partial \xi _i}L\left( \boldsymbol{\omega },\xi _i,b \right) $，$\frac{\partial}{\partial b}L\left( \boldsymbol{\omega },\xi _i,b \right) $，并使他们等于零：<br>$$<br>\begin{align}<br>    &amp;\frac{\partial}{\partial \boldsymbol{\omega }}L\left( \boldsymbol{\omega },\xi _i,b \right) =0\rightarrow \boldsymbol{\omega }=\sum</em>{i=1}^m{\alpha <em>iy_i\varphi \left( x_i \right)}\<br>    &amp;\frac{\partial}{\partial \xi _i}L\left( \boldsymbol{\omega },\xi _i,b \right) =0\rightarrow \alpha _i+\beta _i=C\<br>    &amp;\frac{\partial}{\partial b}L\left( \boldsymbol{\omega },\xi _i,b \right) =0\rightarrow \sum</em>{i=1}^m{\alpha _iy_i=0}\<br>\end{align}<br>\tag2<br>\label{eq:2}<br>$$</p><blockquote><p>其中用到矩阵求导参考矩阵论，这里给出结果</p><p>若$f\left( \boldsymbol{\omega } \right) =\frac{1}{2}\lVert \boldsymbol{\omega } \rVert ^2$，则$\frac{\partial}{\partial \boldsymbol{\omega }}f\left( \boldsymbol{\omega } \right) =\boldsymbol{\omega }$</p><p>若$f\left( \boldsymbol{\omega } \right) =\boldsymbol{\omega }^{\text{T}}x$，则$\frac{\partial}{\partial \boldsymbol{\omega }}f\left( \boldsymbol{\omega } \right) =x$</p></blockquote><p>将$\eqref{eq:2}$带入$\varTheta \left( \boldsymbol{\alpha },\boldsymbol{\beta } \right) $，得到：<br>$$<br>\varTheta \left( \boldsymbol{\alpha }\right) =\sum_{i=1}^m{\alpha <em>i-\frac{1}{2}\sum</em>{i=1}^m{\sum_{j=1}^m{\alpha _i\alpha _jy_iy_j}}}K\left( x_i,x_j \right)<br>$$</p><blockquote><p>这时，通过把原问题转换为对偶问题，得到了核函数的表示形式！</p></blockquote><p>将$\eqref{eq:2}$带入限制条件$\alpha_i\geqslant 0 , \beta_i \geqslant 0 (i=1 \sim m)            $得到：<br>$$<br>0\leqslant \alpha <em>i\leqslant C<br>\<br>\sum</em>{i=1}^m{\alpha _iy_i=0}<br>$$</p><p>于是我们求得了核函数SVM的优化对偶问题</p><table><thead><tr><th>核函数SVM对偶问题</th></tr></thead><tbody><tr><td>最大化：$\varTheta \left( \boldsymbol{\alpha }\right) =\sum_{i=1}^m{\alpha <em>i-\frac{1}{2}\sum</em>{i=1}^m{\sum_{j=1}^m{\alpha _i\alpha _jy_iy_j}}}K\left( x_i,x_j \right)$</td></tr><tr><td>限制条件：$0\leqslant \alpha <em>i\leqslant C \quad\quad \sum</em>{i=1}^m{\alpha _iy_i=0}$</td></tr></tbody></table><p>于是只有一个参数待求解：$\boldsymbol{\alpha}$，通常可以使用SMO算法</p><p>在测试流程中，我们可以有如下判断：<br>$$<br>\begin{cases}<br>    \text{若}\boldsymbol{w}^{\boldsymbol{T}}\varphi \left( \boldsymbol{x}<em>{\text{i}} \right) +b&gt;0,\text{则}y</em>{\text{i}}=+1\<br>    \text{若}\boldsymbol{w}^{\boldsymbol{T}}\varphi \left( \boldsymbol{x}<em>{\text{i}} \right) +b&lt;0,\text{则}y</em>{\text{i}}=-1\<br>\end{cases}<br>$$<br>在$\eqref{eq:2}$中，我们知道有$\boldsymbol{\omega }=\sum_{i=1}^m{\alpha <em>iy_i\varphi \left( \boldsymbol{x_i} \right)}$，则：<br>$$<br>\begin{align}<br>\boldsymbol{w}^{\boldsymbol{T}}\varphi \left( \boldsymbol{x}</em>{\boldsymbol{i}} \right) &amp;=\sum_{j=1}^m{\left[ \alpha <em>iy_i\varphi \left( \boldsymbol{x}_j \right) \right] ^{\text{T}}}\varphi \left( \boldsymbol{x}</em>{\boldsymbol{i}} \right) \&amp;=\sum_{j=1}^m{\alpha <em>iy_i\varphi \left( \boldsymbol{x}</em>{\boldsymbol{j}} \right) ^{\text{T}}\varphi \left( \boldsymbol{x}<em>{\boldsymbol{i}} \right)}\&amp;=\sum</em>{j=1}^m{\alpha <em>iy_iK\left( \boldsymbol{x}</em>{\boldsymbol{i}},\boldsymbol{x}_{\boldsymbol{j}} \right)}<br>\end{align}<br>\tag{3}<br>\label{eq:3}<br>$$<br>只剩下$b$待求解。确定了$b$，则核函数SVM训练完成</p><p>$b$的求解需要用到KKT条件，</p><table><thead><tr><th><strong>3. KKT条件</strong></th><th>3. SVM的KKT条件</th></tr></thead><tbody><tr><td>$\forall i=1 \sim K$，<br>$\boldsymbol{\alpha^<em>_i }=0$ 或者 $g_i\left( \boldsymbol{\omega ^</em>} \right) =0   $</td><td>$\forall i=1 \sim  m$，<br>1. $\boldsymbol{\alpha_i }=0$ 或者 $,1+\xi <em>i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) = 0$<br>2. $\boldsymbol{\beta_i }=0$或者$\xi_i=0$</td></tr></tbody></table><p>取一个$0&lt;\boldsymbol{\alpha }<em>{\boldsymbol{i}}&lt;C\Rightarrow \boldsymbol{\beta }</em>{\boldsymbol{i}}=C-\boldsymbol{\alpha }<em>{\boldsymbol{i}}&gt;0$，此时有：<br>$$<br>\begin{align}<br>\boldsymbol{\beta }</em>{\boldsymbol{i}}\ne 0&amp;\Rightarrow \xi <em>i=0<br>\<br>\boldsymbol{\alpha }</em>{\boldsymbol{i}}\ne 0&amp;\Rightarrow 1+\xi <em>i-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}+b \right) =0<br>\<br>&amp;\Rightarrow 1-y_i\left( \boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}<em>{\boldsymbol{i}}\text{)}+b \right) =0<br>\end{align}<br>$$<br>带入$\eqref{eq:3}$，得到：<br>$$<br>\begin{align}<br>b&amp;=\frac{1}{y_i}-\boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}</em>{\boldsymbol{i}}\text{)}=\frac{1-y_i\boldsymbol{w}^{\boldsymbol{T}}\varphi \boldsymbol{(x}<em>{\boldsymbol{i}}\text{)}}{y_i}<br>\<br>&amp;=\frac{1-y_i\sum</em>{j=1}^m{\alpha <em>iy_iK\left( \boldsymbol{x}</em>{\boldsymbol{i}},\boldsymbol{x}_{\boldsymbol{j}} \right)}}{y_i}<br>\end{align}<br>$$</p><p>以上就是核函数SVM原问题转换为对偶问题，并用对偶问题训练SVM（求出$\boldsymbol{\alpha_i}$和$b$的过程）的推导过程</p><h2 id="核函数SVM算法总结"><a href="#核函数SVM算法总结" class="headerlink" title="核函数SVM算法总结"></a>核函数SVM算法总结</h2><p>SVM算法</p><ol><li><p>训练流程：</p><ul><li><p>输入${(\boldsymbol{x_i},y_i)}_{i=1 \sim m}$</p></li><li><p>解优化问题：</p><p>​    最大化：$\varTheta \left( \boldsymbol{\alpha }\right) =\sum_{i=1}^m{\alpha <em>i-\frac{1}{2}\sum</em>{i=1}^m{\sum_{j=1}^m{\alpha _i\alpha _jy_iy_j}}}K\left( x_i,x_j \right)$</p><p>​    限制条件：$0\leqslant \alpha <em>i\leqslant C, \quad\sum</em>{i=1}^m{\alpha _iy_i=0}$</p><p>​    求解$b$：找一个$0&lt;\boldsymbol{\alpha }<em>{\boldsymbol{i}}&lt;C$，可以算得$b=\frac{1-y_i\sum</em>{j=1}^m{\alpha <em>iy_iK\left( \boldsymbol{x}</em>{\boldsymbol{i}},\boldsymbol{x}_{\boldsymbol{j}} \right)}}{y_i}$</p></li></ul></li><li><p>测试流程</p><ul><li>输入测试样本$\boldsymbol{x}$<br>$$<br>\begin{cases}<pre><code>\text{若}\sum_{j=1}^m\alpha _iy_iK\left( \boldsymbol{x}_{\boldsymbol{i}},\boldsymbol{x}_{\boldsymbol{j}} \right) +b&gt;0,\text{则}y_{\text{i}}=+1\\\text{若}\sum_{j=1}^m\alpha _iy_iK\left( \boldsymbol{x}_{\boldsymbol{i}},\boldsymbol{x}_{\boldsymbol{j}} \right) +b&lt;0,\text{则}y_{\text{i}}=-1\\</code></pre>\end{cases}<br>$$</li></ul></li></ol><blockquote><p>通过转换为对偶问题，我们可以看到上面没有出现$\varphi (\boldsymbol{x})$，而待求解的参数只有$\boldsymbol{\alpha_i}$和$b$</p></blockquote><h1 id="SVM处理多分类问题"><a href="#SVM处理多分类问题" class="headerlink" title="SVM处理多分类问题"></a>SVM处理多分类问题</h1><p>上面都在说如何用SVM处理二分类问题，那么怎么样用SVM处理多分类问题呢？</p><p>我们有一下三种方法：</p><ol><li><p>改造优化的目标函数和限制条件，使之能处理多分类问题。</p><blockquote><p>这种方法通常效果一般，SVM专为二分类而生</p></blockquote></li><li><p>一类VS其他类</p><blockquote><p>例子：</p><p>若有$C_1 ,C_2 ,C_3$三类，则可以设计三个SVM</p><p>SVM1：$(C_1 ,C_2)VS(C_3)$</p><p>SVM2：$(C_1 ,C_3)VS(C_2)$</p><p>SVM3：$(C_2 ,C_3)VS(C_1)$</p><p>若$y_1=+1,y_2=+1,y_3=-1$，则 显然为第一类</p><p>若$y_1=+1,y_2=-1,y_3=-1$，在看看SVM1和SVM2的$\boldsymbol{w}^{\boldsymbol{T}}\varphi \left( \boldsymbol{x}_{\text{i}} \right) +b$哪一个负的比较多就判断为哪一个</p></blockquote></li><li><p>一类VS另一类</p><blockquote><p>例子：</p><p>若有$C_1 ,C_2 ,C_3$三类，则可以设计三个SVM</p><p>SVM1：$(C_1 )VS(C_2)$</p><p>SVM2：$(C_1 )VS(C_3)$</p><p>SVM3：$(C_2)VS(C_3)$</p><p>若$y_1=+1,y_2=+1,y_3=-1$，则 显然为第一类（$C_1$被投了两票，$C_3$被投了一票）</p></blockquote></li></ol><p>对于n分类问题：</p><p>用一类VS其他类我们需要用n个SVM；</p><p>用一类VS另一类我们需要用$\frac{n\left( n-1 \right)}{2}$个SVM。</p><p>根据经验，用一类VS另一类的效果最佳，但同时也是最复杂的。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266</title>
      <link href="/2020/05/16/ESP32/"/>
      <url>/2020/05/16/ESP32/</url>
      
        <content type="html"><![CDATA[<h3 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h3><p>ESP32-CAM：</p><ul><li><p>核心貌似是ESP-32S(ESP32-WROOM-32)模组</p></li><li><p>两个低功耗 Xtensa® 32-bit LX6 MCU，主频高达 240MHz， 运算能力高达 600 DMIPS，小端序</p></li><li><p>RAM：片内520 KB SRAM，片外<strong>8MB</strong> PSRAM</p><ul><li>RTC中8 KB SRAM（RTC慢速存储器），Deep-sleep模式下被协处理器访问</li><li>RTC中8 KB SRAM（RTC快速存储器），Deep-sleep模式下RTC启动时用于数据存储以及被主CPU访问</li><li>1kbit eFuse，其中256bit为系统专用（MAC 地址和芯片设置）其余 768bit保留给用户应用，包括Flash加密和芯片ID</li></ul></li><li><p>ROM：片内448 KB ROM（用于程序启动和内核功能调用），片外32Mbit SPI Flash（<strong>4MB</strong>）</p></li><li><p>支持UART、 SPI、 I2C、 PWM</p></li><li><p>TF卡最大支持4G</p></li><li><p>供电：4.75-5.25V</p></li><li><p><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-22712549685.72.3dfb56099J9SHD&id=615999358728" target="_blank" rel="noopener">购买链接</a></p></li><li><p>引脚定义：</p><p>  <img src="//NU-LL.github.io/2020/05/16/ESP32/269b17ad-f1e6-4295-a407-45300983906e.png" alt="引脚定义"></p></li></ul><p>Goouuu-ESP32：</p><ul><li>ESP32-WROOM-32模组（ESP32-D0WDQ6）</li><li>两个低功耗 Xtensa® 32-bit LX6 MCU，主频高达 240MHz， 运算能力高达 600 DMIPS，小端序</li><li><a href="https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-22712549685.15.3dfb56099J9SHD&id=547082402418" target="_blank" rel="noopener">购买链接</a></li></ul><p>软件配置：</p><ul><li>[IDF(IoT Development Framework)编程指南]((IoT Development Framework))</li><li>ESP-CAM：<a href="https://github.com/donny681/ESP32_CAMERA_QR" target="_blank" rel="noopener">ESP32_CAMERA_QR项目</a>，<a href="https://github.com/donny681/ESP32_CAMERA_QR/wiki" target="_blank" rel="noopener">该项目wiki文档</a></li></ul><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/get-started/windows-setup-scratch.html" target="_blank" rel="noopener">官方参考链接</a></p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>目前，ESP-IDF 仅适用于 <strong>Python 2.7</strong></p><p>附件：</p><ul><li><code>mconf-v4.6.0.0-idf-20190628-win32.zip</code>：mconf-idf</li><li><code>ninja-win.zip</code>：ninja</li><li><code>cmake-3.17.2-win64-x64.msi</code>：cmake安装包</li><li><code>xtensa-esp32-elf-gcc8_2_0-esp-2019r2-win32.zip</code>：编译工具链</li><li><code>pyelftools-0.26-py2.py3-none-any.whl</code>：pyelftools包</li></ul><p>步骤：</p><ol><li><p>下载安装<a href="https://cmake.org/download/" target="_blank" rel="noopener">Cmake</a>（安装时注意选上<code>Add CMake to the system PATH for all users</code>）</p></li><li><p>下载安装<a href="https://github.com/ninja-build/ninja/releases" target="_blank" rel="noopener">ninja</a>（手动加到系统环境变量，只支持64位windows，如需其他版本需自己编译）</p></li><li><p>下载安装<code>python2.7</code>并通过<code>pip install --user pyserial</code>安装<code>pyserial</code>包（可以通过Anaconda新建环境安装）</p></li><li><p>从 <a href="https://github.com/espressif/kconfig-frontends/releases/" target="_blank" rel="noopener">这里</a>下载配置工具<code>mconf-idf</code>（需要手动加到系统环境变量）</p></li><li><p>下载<a href="https://dl.espressif.com/dl/xtensa-esp32-elf-gcc8_2_0-esp-2019r2-win32.zip" target="_blank" rel="noopener">交叉编译工具链</a>，解压之后需要添加到系统环境变量，如<code>C:\Program Files\xtensa-esp32-elf\bin</code></p></li><li><p>下载安装<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git</a></p></li><li><p>下载<a href="https://github.com/espressif/esp-idf/releases" target="_blank" rel="noopener">ESP-IDF</a>（3.3.2为长期支持版，最新稳定版为4.0）</p></li><li><p>设置环境变量：</p><ol><li><code>IDF_PATH</code> 应设置为 ESP-IDF 根目录的路径</li><li><code>PATH</code> 应包括同一 <code>IDF_PATH</code> 目录下的 <code>tools</code> 目录路径（为了使用<code>idf.py</code> 工具，<code>%IDF_PATH%\tools</code>即可）</li></ol></li><li><p>根据<code>IDF_PATH/requirements.txt</code>文件安装Python软件包：</p><pre><code class="python"> # 注意查询所使用的Python版本（运行命令python --version），并根据查询结果将python替换为python2或python2.7等 python -m pip install --user -r $IDF_PATH/requirements.txt # 使用pip安装 # 也可以使用anaconda安装</code></pre><p> 安装内容：</p><pre><code class="txt"> click&gt;=5.0 pyserial&gt;=3.0 future&gt;=0.15.2 cryptography&gt;=2.1.4 pyparsing&gt;=2.0.3,&lt;2.4.0 pyelftools&gt;=0.22</code></pre><ul><li>其中<code>pyelftools</code>软件包在anaconda中没有，需要手动从<a href="https://pypi.org/project/pyelftools/#files" target="_blank" rel="noopener">这里</a>下载<code>.whl</code>文件，在<code>Anaconda Prompt</code>中通过命令<code>pip install E:\xxx\xxx.whl</code>安装<ul><li>也可以在conda官网<a href="https://anaconda.org/" target="_blank" rel="noopener">https://anaconda.org/</a>中搜索<code>pyelftools</code>软件包，并通过软件包对应命令进行安装（推荐）</li></ul></li></ul></li></ol><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>ESP-IDF 的<code>examples</code>目录下有一系列示例工程，可以复制到其他地方进行运行（推荐），也可以直接编译示例，无需进行复制。</p><p><strong>注意</strong>：ESP-IDF 编译系统不支持<strong>带有空格</strong>的路径</p><h3 id="一般注意事项"><a href="#一般注意事项" class="headerlink" title="一般注意事项"></a>一般注意事项</h3><h4 id="应用程序启动流程"><a href="#应用程序启动流程" class="headerlink" title="应用程序启动流程"></a>应用程序启动流程</h4><p>宏观上，该启动流程可以分为如下 3 个步骤：</p><ol><li>一级引导程序被固化在了 ESP32 内部的 ROM 中，它会从 Flash 的 <code>0x1000</code> 偏移地址处加载二级引导程序至 RAM(IRAM &amp; DRAM) 中</li><li>二级引导程序从 Flash 中加载分区表和主程序镜像至内存中，主程序中包含了 RAM 段和通过 Flash 高速缓存映射的只读段</li><li>主程序运行，这时第二个 CPU 和 RTOS 的调度器可以开始运行</li></ol><h4 id="应用程序内存布局方案"><a href="#应用程序内存布局方案" class="headerlink" title="应用程序内存布局方案"></a>应用程序内存布局方案</h4><p>ESP-IDF 应用程序的代码可以放在：</p><ul><li><p>IRAM（指令RAM）</p><p>  ESP-IDF 将内部 SRAM0 区域（在技术参考手册中有定义）的一部分分配为指令RAM。除了开始的 64kB 用作 PRO CPU 和 APP CPU 的高速缓存外，剩余内存区域（从 <code>0x40080000</code> 至 <code>0x400A0000</code> ）被用来存储应用程序中部分需要在RAM中运行的代码</p><p>  一些 ESP-IDF 的组件和 WiFi 协议栈的部分代码通过链接脚本文件被存放到了这块内存区域</p><p>  如果一些应用程序的代码需要放在 IRAM 中运行，可以使用 <code>IRAM_ATTR</code> 宏定义进行声明</p></li><li><p>IROM（代码从Flash中运行）</p><p>  如果一个函数没有被显式地声明放在 IRAM 或者 RTC 内存中，则将其置于 Flash 中</p></li><li><p>RTC快速内存</p><p>  从深度睡眠模式唤醒后必须要运行的代码要放在 RTC 内存中，更多信息请查阅官方文档 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a></p></li><li><p>DRAM（数据RAM）</p><p>  链接器将非常量静态数据和零初始化数据放入 <code>0x3FFB0000 — 0x3FFF0000</code> 这 256kB 的区域。注意，如果使用蓝牙堆栈，此区域会减少 64kB（通过将起始地址移至 <code>0x3FFC0000</code> ）。如果使用了内存跟踪的功能，该区域的长度还要减少 16kB 或者 32kB。放置静态数据后，留在此区域中的剩余空间都用作运行时堆。</p><p>  常量数据也可以放在 DRAM 中，需要使用 <code>DRAM_ATTR</code> 宏来声明。</p></li><li><p>DROM（数据存储在Flash中）</p><p>  默认情况下，链接器将常量数据放入一个 4MB 区域 (<code>0x3F400000 — 0x3F800000</code>) ，该区域用于通过 Flash MMU 和高速缓存来访问外部 Flash。一种特例情况是，字面量会被编译器嵌入到应用程序代码中。</p></li><li><p>RTC慢速内存</p><p>  从 RTC 内存运行的代码（例如深度睡眠模块的代码）使用的全局和静态变量必须要放在 RTC 慢速内存中。更多详细说明请查看官方文档 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-guides/deep-sleep-stub.html" target="_blank" rel="noopener">深度睡眠</a> 。</p><p>  宏 <code>RTC_NOINIT_ATTR</code> 用来声明将数据放入 RTC 慢速内存中，该数据在深度睡眠唤醒后将保持不变。</p></li></ul><h4 id="DMA能力要求"><a href="#DMA能力要求" class="headerlink" title="DMA能力要求"></a>DMA能力要求</h4><p>大多数的 DMA 控制器（比如 SPI，SDMMC 等）都要求发送/接收缓冲区放在 DRAM 中，并且按字对齐。建议将 DMA 缓冲区放在静态变量中而不是堆栈中。使用 <code>DMA_ATTR</code> 宏可以声明该全局/本地的静态变量具备 DMA 能力（推荐全局）</p><h3 id="构建系统（CMake）"><a href="#构建系统（CMake）" class="headerlink" title="构建系统（CMake）"></a>构建系统（CMake）</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><code>项目</code> 特指一个目录，其中包含了构建可执行应用程序所需的全部文件和配置，以及其他支持型文件，例如分区表、数据/文件系统分区和引导程序。</li><li><code>项目配置</code> 保存在项目根目录下名为 <code>sdkconfig</code> 的文件中，可以通过 <code>idf.py menuconfig</code> 进行修改，且一个项目只能包含一个项目配置。</li><li><code>应用程序</code> 是由 ESP-IDF 构建得到的可执行文件。一个项目通常会构建两个应用程序：项目应用程序（可执行的主文件，即用户自定义的固件）和引导程序（启动并初始化项目应用程序）。</li><li><code>组件</code> 是模块化且独立的代码，会被编译成静态库（.a 文件）并链接到应用程序。部分组件由 ESP-IDF 官方提供，其他组件则来源于其它开源项目。</li><li><code>目标</code> 特指运行构建后应用程序的硬件设备。ESP-IDF 当前仅支持 <code>ESP32</code> 这一个硬件目标。</li></ul><h4 id="idf-py使用"><a href="#idf-py使用" class="headerlink" title="idf.py使用"></a>idf.py使用</h4><p><code>idf.py</code> 命令行工具提供了一个前端，可以帮助您轻松管理项目的构建过程，它管理了以下工具：</p><ul><li><a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a>，配置待构建的系统</li><li>命令行构建工具（<a href="https://ninja-build.org/" target="_blank" rel="noopener">Ninja</a> 或 GNU Make）</li><li><a href="https://github.com/espressif/esptool/#readme" target="_blank" rel="noopener">esptool.py</a>，烧录 ESP32</li></ul><p><code>idf.py</code> 应运行在 ESP-IDF 的 <code>项目</code> 目录下，即包含 <code>CMakeLists.txt</code> 文件的目录</p><hr><p>常用的命令：</p><ul><li><p><code>idf.py menuconfig</code>：运行<code>menuconfig</code><strong>配置</strong>项目</p></li><li><p><code>idf.py build</code>：<strong>构建</strong>在当前目录下的项目，包括：</p><ul><li><p>根据需要创建 <code>build</code> 构建目录，用于保存输出文件，可以使用 <code>-B</code> 选项修改默认的构建目录</p></li><li><p>根据需要运行 <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> 配置命令，为主构建工具生成构建文件</p></li><li><p>运行主构建工具（<a href="https://ninja-build.org/" target="_blank" rel="noopener">Ninja</a> 或 GNU Make）。默认情况下，构建工具会被自动检测，可以使用 <code>-G</code> 选项显式地指定构建工具</p><p>如果自上次构建以来源文件或项目配置没有发生改变，则不会执行任何操作</p></li></ul></li><li><p><code>idf.py clean</code>：把输出文件从构建目录中删除，从而<strong>清理</strong>整个项目。下次构建时会强制“重新完整构建”这个项目。清理时，不会删除 CMake 配置输出及其他文件</p></li><li><p><code>idf.py fullclean</code> 会将整个 <code>build</code> 目录下的内容全部<strong>删除</strong>，包括所有 CMake 的配置输出文件。下次构建项目时，CMake 会从头开始配置项目。请注意，该命令会递归删除构建目录下的 <em>所有文件</em>，请谨慎使用。项目配置文件不会被删除</p></li><li><p><code>idf.py flash</code> 会在必要时<strong>自动构建</strong>项目，并将生成的二进制程序<strong>烧录</strong>进ESP32中。<code>-p</code> 和 <code>-b</code> 选项可分别设置串口的设备名和烧录时的波特率</p></li><li><p><code>idf.py monitor</code> 用于显示 ESP32 设备的串口输出。<code>-p</code> 选项可用于设置主机端串口的设备名，按下 <code>Ctrl-]</code> 可退出监视器。更多有关监视器的详情，请参阅官方 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-guides/tools/idf-monitor.html" target="_blank" rel="noopener">IDF 监视器</a></p></li></ul><p>多个 <code>idf.py</code> 命令可合并成一个</p><blockquote><p>环境变量 <code>ESPPORT</code> 和 <code>ESPBAUD</code> 可分别用作 <code>-p</code> 和 <code>-b</code> 选项的默认值。在命令行中，重新为这两个选项赋值，会覆盖其默认值</p></blockquote><hr><p>高级命令：</p><ul><li><code>idf.py app</code>，<code>idf.py bootloader</code>，<code>idf.py partition_table</code>：从项目中构建应用程序、引导程序或分区表</li><li><code>idf.py app-flash</code> 等匹配命令：将特定部分烧录至 ESP32</li><li><code>idf.py -p PORT erase_flash</code>：使用 esptool.py 擦除整个 Flash</li><li><code>idf.py size</code>：打印应用程序相关的大小信息，<code>idf.py size-components</code> 和 <code>idf.py size-files</code> 这两个命令分别用于打印每个组件或源文件的详细信息</li><li><code>idf.py reconfigure</code>：重新运行CMake（即便无需重新运行）。正常使用时，并不需要运行此命令，但当源码树中添加/删除文件后或更改 CMake cache 变量时，此命令会非常有用，例如，<code>idf.py -DNAME=&#39;VALUE&#39; reconfigure</code> 会将 CMake cache 中的变量 <code>NAME</code> 的值设置为 <code>VALUE</code></li></ul><p>同时调用多个 <code>idf.py</code> 命令时，命令的输入顺序并不重要，它们会按照正确的顺序依次执行，并保证每一条命令都生效（即先构建后烧录，先擦除后烧录等）</p><h4 id="CMakeLists文件"><a href="#CMakeLists文件" class="headerlink" title="CMakeLists文件"></a>CMakeLists文件</h4><h5 id="项目CMakeLists"><a href="#项目CMakeLists" class="headerlink" title="项目CMakeLists"></a>项目CMakeLists</h5><p>每个项目都有一个顶层 <code>CMakeLists.txt</code> 文件，包含整个项目的构建设置。默认情况下，项目 CMakeLists 文件会非常小：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.5)include($ENV{IDF_PATH}/tools/cmake/project.cmake)project(myProject)</code></pre><ul><li><code>cmake_minimum_required(VERSION 3.5)</code> 必须放在 CMakeLists.txt 文件的第一行，告诉 CMake 构建该项目所需要的最小版本号</li><li><code>include($ENV{IDF_PATH}/tools/cmake/project.cmake)</code> 导入 CMake 的其余功能来完成配置项目、检索组件等任务</li><li><code>project(myProject)</code> 创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 <code>myProject.elf</code> 和 <code>myProject.bin</code>。每个 CMakeLists 文件只能定义一个项目</li></ul><hr><p>默认变量（用户可以覆盖这些变量值以自定义构建行为（更多实现细节，请参阅 <a href="https://github.com/espressif/esp-idf/blob/v4.0.1//tools/cmake/project.cmake" target="_blank" rel="noopener">/tools/cmake/project.cmake</a> 文件））：</p><ul><li><code>COMPONENT_DIRS</code>：组件的搜索目录，默认为 <code>${IDF_PATH}/components</code>、<code>${PROJECT_PATH}/components</code> 和 <code>EXTRA_COMPONENT_DIRS</code></li><li><code>EXTRA_COMPONENT_DIRS</code>：搜索组件的其它可选目录列表</li><li><code>COMPONENTS</code>：要构建进项目中的组件名称列表，默认为 <code>COMPONENT_DIRS</code> 目录下检索到的所有组件。使用此变量可以“精简”项目以缩短构建时间。请注意，如果一个组件通过 <code>COMPONENT_REQUIRES</code> 指定了它依赖的另一个组件，则会自动将其添加到 <code>COMPONENTS</code> 中，所以 <code>COMPONENTS</code> 列表可能会非常短。</li><li><code>COMPONENT_REQUIRES_COMMON</code>：每个组件都需要的通用组件列表，这些通用组件会自动添加到每个组件的 <code>COMPONENT_PRIV_REQUIRES</code> 列表中以及项目的 <code>COMPONENTS</code> 列表中。默认情况下，此变量设置为 ESP-IDF 项目所需的最小核心“系统”组件集。通常您无需在项目中更改此变量</li></ul><p>以上变量中的路径可以是绝对路径，或者是相对于项目目录的相对路径</p><p>请使用 <a href="https://cmake.org/cmake/help/v3.5/command/set.html" target="_blank" rel="noopener">cmake 中的 set 命令</a> 来设置这些变量，即 <code>set(VARIABLE &quot;VALUE&quot;)</code>。请注意，<code>set()</code> 命令需放在 <code>include(...)</code> 之前，<code>cmake_minimum(...)</code> 之后</p><h5 id="组件CMakeLists"><a href="#组件CMakeLists" class="headerlink" title="组件CMakeLists"></a>组件CMakeLists</h5><p>每个组件目录都包含一个 <code>CMakeLists.txt</code> 文件，里面会定义一些变量以控制该组件的构建过程，以及其与整个项目的集成</p><p>每个组件还可以包含一个 <code>Kconfig</code> 文件，它用于定义 <code>menuconfig</code> 时展示的 组件配置 选项。某些组件可能还会包含 <code>Kconfig.projbuild</code> 和 <code>project_include.cmake</code> 特殊文件，它们用于 覆盖项目的部分设置</p><p>组件是 <code>COMPONENT_DIRS</code> 列表中包含 <code>CMakeLists.txt</code> 文件的任何目录</p><p>ESP-IDF 搜索待构建组件顺序（由<code>COMPONENT_DIRS</code> 指定）：</p><ol><li><p><code>${IDF_PATH}/components</code></p></li><li><p><code>${PROJECT_PATH}/components</code></p></li><li><p><code>EXTRA_COMPONENT_DIRS</code></p><p> 如果包含同名组件，则使用最后一个位置的组件</p></li></ol><p>最小组件 <code>CMakeLists.txt</code> 文件：</p><pre><code class="cmake">set(COMPONENT_SRCS &quot;foo.c&quot;)set(COMPONENT_ADD_INCLUDEDIRS &quot;include&quot;)register_component()</code></pre><ul><li><code>COMPONENT_SRCS</code>：用空格分隔的源文件列表（<code>*.c</code>，<code>*.cpp</code>，<code>*.cc</code>，<code>*.S</code>），里面所有的源文件都将会编译进组件库中</li><li><code>COMPONENT_ADD_INCLUDEDIRS</code>：用空格分隔的目录列表，里面的路径会被添加到所有需要该组件的组件（包括 main 组件）全局 include 搜索路径中。</li><li><code>register_component()</code>：使用上述设置的变量将组件添加到构建系统中，构建生成与组件同名的库，并最终被链接到应用程序中。如果因为使用了 <a href="https://cmake.org/cmake/help/v3.5/command/if.html" target="_blank" rel="noopener">CMake 中的 if 命令</a> 或类似命令而跳过了这一步，那么该组件将不会被添加到构建系统中</li></ul><p>有关更完整的 <code>CMakeLists.txt</code> 示例，请参阅 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-guides/build-system.html#component-cmakelists-example" target="_blank" rel="noopener">组件 CMakeLists 示例</a></p><hr><p>组件CMakeLists预设变量（不推荐修改）：</p><ul><li><code>COMPONENT_PATH</code>：组件目录，即包含 <code>CMakeLists.txt</code> 文件的绝对路径，它与 <code>CMAKE_CURRENT_SOURCE_DIR</code> 变量一样，路径中不能包含空格</li><li><code>COMPONENT_NAME</code>：组件名，与组件目录名相同</li><li><code>COMPONENT_TARGET</code>：库目标名，它由构建系统在内部为组件创建</li></ul><p>可以在组件 CMakeLists 中使用的项目 CMakeLists 预设变量：</p><ul><li><code>PROJECT_NAME</code>：项目名，在项目 CMakeLists.txt 文件中设置</li><li><code>PROJECT_PATH</code>：项目目录（包含项目 CMakeLists 文件）的绝对路径，与 <code>CMAKE_SOURCE_DIR</code> 变量相同</li><li><code>COMPONENTS</code>：此次构建中包含的所有组件的名称，具体格式为用分号隔开的 CMake 列表</li><li><code>CONFIG_*</code>：项目配置中的每个值在 cmake 中都对应一个以 <code>CONFIG_</code> 开头的变量。更多详细信息请参阅 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-reference/kconfig.html" target="_blank" rel="noopener">Kconfig</a></li><li><code>IDF_VER</code>：ESP-IDF 的 git 版本号，由 <code>git describe</code> 命令生成。</li><li><code>IDF_VERSION_MAJOR</code>, <code>IDF_VERSION_MINOR</code>, <code>IDF_VERSION_PATCH</code>: ESP-IDF 的组件版本，可用于条件表达式。注意这些信息的精确度不如 <code>IDF_VER</code> 变量，版本号 <code>v4.0-dev-*</code>， <code>v4.0-beta1</code>， <code>v4.0-rc1</code> 和 <code>v4.0</code> 对应的 <code>IDF_VERSION_*</code> 变量值是相同的，但是 <code>IDF_VER</code> 值不同</li><li><code>IDF_TARGET</code>：项目的硬件目标名称</li><li><code>PROJECT_VER</code>：项目版本号<ul><li>如果在项目 CMakeLists.txt 文件中设置了 <code>PROJECT_VER</code> 变量，则该变量值可以使用</li><li>或者，如果 <code>${PROJECT_PATH}/version.txt</code> 文件存在，其内容会用作 <code>PROJECT_VER</code> 的值</li><li>或者，如果项目位于某个 Git 仓库中，则使用 <code>git describe</code> 命令的输出作为 <code>PROJECT_VER</code> 的值</li><li>否则，<code>PROJECT_VER</code> 的值为空</li></ul></li></ul><p>如果修改以上变量，并不会影响其他组件的构建，但可能会使该组件变得<strong>难以构建或调试</strong></p><h4 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h4><p>每个组件的源文件都会使用以下路径中的头文件进行编译:</p><ul><li>当前组件的 <code>COMPONENT_ADD_INCLUDEDIRS</code> 和 <code>COMPONENT_PRIV_INCLUDEDIRS</code></li><li>当前组件的 <code>COMPONENT_REQUIRES</code> 和 <code>COMPONENT_PRIV_REQUIRES</code> 变量指定的其他组件（即当前组件的所有公共和私有依赖项）所设置的 <code>COMPONENT_ADD_INCLUDEDIRS</code></li><li>所有组件的 <code>COMPONENT_REQUIRES</code> 做递归操作，即该组件递归运算后的所有公共依赖项</li></ul><h5 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h5><ul><li><code>COMPONENT_REQUIRES</code> ：包含所有被当前组件的<strong>公共头文件</strong> #include 的头文件所在的组件。</li><li><code>COMPONENT_PRIV_REQUIRES</code>：包含被当前组件的<strong>源文件</strong> #include 的头文件所在的组件（除非已经被设置在了 <code>COMPONENT_PRIV_REQUIRES</code> 中），或者是当前组件正常工作必须要链接的组件</li><li><code>COMPONENT_REQUIRES</code>、<code>COMPONENT_PRIV_REQUIRES</code> 需要在调用 <code>register_component()</code> <strong>之前</strong>设置</li><li><code>COMPONENT_REQUIRES</code> 和 <code>COMPONENT_PRIV_REQUIRES</code> 的值不能依赖于任何配置选项（<code>CONFIG_xxx</code>），这是因为在配置加载之前，依赖关系就已经被展开。其它组件变量（比如 <code>COMPONENT_SRCS</code> 和 <code>COMPONENT_ADD_INCLUDEDIRS</code>）可以依赖配置选择</li><li>如果当前组件除了 <code>COMPONENT_REQUIRES_COMMON</code> 中设置的通用组件（比如 RTOS、libc 等）外，并不依赖其它组件，那么上述两个 <code>REQUIRES</code> 变量可以为空</li></ul><p>如果组件仅支持某些硬件目标（即依赖于特定的 <code>IDF_TARGET</code>），则可以调用 <code>require_idf_targets(NAMES...)</code>来声明这个需求</p><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><ul><li>默认情况下，每个组件都会包含在构建系统中</li><li>如果将<code>COMPONENTS</code>变量设置为项目直接使用的最小组件列表，那么构建系统会导入：<ul><li><code>COMPONENTS</code> 中明确提及的组件</li><li>这些组件的依赖项（以及递归运算后的组件）</li><li>每个组件都依赖的通用组件</li></ul></li><li>将 <code>COMPONENTS</code> 设置为所需组件的最小列表，可以显著减少项目的构建时间</li></ul><h5 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h5><ul><li>在 CMake 配置进程的早期阶段会运行 <code>expand_requirements.cmake</code> 脚本。该脚本会对所有组件的 CMakeLists.txt 文件进行局部的运算，得到一张组件依赖关系图（此图可能会有闭环）。此图用于在构建目录中生成 <code>component_depends.cmake</code> 文件</li><li>CMake 主进程会导入该文件，并以此来确定要包含到构建系统中的组件列表（内部使用的 <code>BUILD_COMPONENTS</code> 变量）。<code>BUILD_COMPONENTS</code> 变量已排好序，依赖组件会排在前面。由于组件依赖关系图中可能存在闭环，因此不能保证每个组件都满足该排序规则。如果给定相同的组件集和依赖关系，那么最终的排序结果应该是确定的</li><li>CMake 会将 <code>BUILD_COMPONENTS</code> 的值以 “Component names:” 的形式打印出来</li><li>然后执行构建系统中包含的每个组件的配置</li><li>每个组件都被正常包含在构建系统中，然后再次执行 CMakeLists.txt 文件，将组件库加入构建系统</li></ul><p><code>BUILD_COMPONENTS</code> 变量中组件的顺序决定了构建过程中的其它顺序：</p><ul><li>项目导入 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/api-guides/build-system.html#project-include-cmake" target="_blank" rel="noopener">project_include.cmake</a> 文件的顺序</li><li>生成用于编译（通过 <code>-I</code> 参数）的头文件路径列表的顺序。请注意，对于给定组件的源文件，仅需将该组件的依赖组件的头文件路径告知编译器</li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和GO的语法对比</title>
      <link href="/2020/05/09/C%E5%92%8CGO%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
      <url>/2020/05/09/C%E5%92%8CGO%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="C和GO的语法对比"><a href="#C和GO的语法对比" class="headerlink" title="C和GO的语法对比"></a>C和GO的语法对比</h3><p>具体转自<a href="https://www.amobbs.com/thread-5727957-1-1.html" target="_blank" rel="noopener">阿莫论坛</a>、<a href="https://mangogeek.com/archives/131.html" target="_blank" rel="noopener">备份地址</a></p><table><thead><tr><th align="center"></th><th>C</th><th>GO</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">变量声明</td><td>int a;</td><td>Var a Int</td><td align="center">C：变量类型+变量名字<br>Go：var+ 变量名字+变量类型</td></tr><tr><td align="center">变量声明 并初始化</td><td>int a=10;</td><td>Var a Int=10</td><td align="center">C：变量类型+变量名字=表达式<br>Go：var+变量名字+ 变量类型=表达式</td></tr><tr><td align="center">变量初始化时不指定类型</td><td>不支持</td><td>Var a=10</td><td align="center">变量类型由编译器来推导</td></tr><tr><td align="center">短变量声明并初始化</td><td>不支持</td><td>a:=10</td><td align="center">变量类型由编译器来推导</td></tr><tr><td align="center">多变量声明</td><td>不支持</td><td>name,age:=”pengwang”,18<br> var(<br>       name= “pengwang”<br>       age= 18<br>)</td><td align="center"></td></tr><tr><td align="center">字符</td><td>Chars=’a’</td><td>varsbyte=’a’</td><td align="center">char, byte等同于int8,占用1个字节</td></tr><tr><td align="center">字符串</td><td>CharsO=”123456”</td><td>var sstring= “123456”</td><td align="center">c中采用字符数组来表示字符串,没有特定的变量名称;go中用sting 变量类型,sting 底层也是byte数组</td></tr><tr><td align="center">rune</td><td>不支持</td><td>I 支持</td><td align="center">Go语言中rune等同于int32,占用4 个字节; go中采用rune主要为 了解决中文等字符,go编码是utf.8编码,-般占用3个字节; 在go中用rune的好处在于快速获取字符串,特别是utf-8 比如: s:= “你好12,如果想要快速分别得到s字符串中“你”和“好”, 在c中,一般是通过字节偏移来获取;在go中可以把string强制换</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow2入门与实践</title>
      <link href="/2020/05/03/TensorFlow2/"/>
      <url>/2020/05/03/TensorFlow2/</url>
      
        <content type="html"><![CDATA[<h1 id="TensorFlow2入门与实践"><a href="#TensorFlow2入门与实践" class="headerlink" title="TensorFlow2入门与实践"></a>TensorFlow2入门与实践</h1><h2 id="深度学习基础和-tf-keras"><a href="#深度学习基础和-tf-keras" class="headerlink" title="深度学习基础和 tf.keras"></a>深度学习基础和 tf.keras</h2><p>顺序模型：有一个输入和一个输出，他们之间的网络是顺序搭建的</p><p>Dense层：即y=ax+b</p><ul><li>输出维度<ul><li>None为输入数据的数量</li></ul></li><li>input_shape：输入维度</li></ul><pre><code class="python">import tensorflow as tfmodel = tf.keras.Sequential() # 顺序模型model.add(tf.keras.layers.Dense(1, input_shape=(1,)))# 向模型中添加添加层（Dense层）model.summary() # 查看模型Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense (Dense)                (None, 1)                 2         =================================================================Total params: 2Trainable params: 2Non-trainable params: 0_________________________________________________________________</code></pre>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266</title>
      <link href="/2020/04/28/ESP8266/"/>
      <url>/2020/04/28/ESP8266/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><a href="https://www.espressif.com/" target="_blank" rel="noopener">乐鑫官网</a>及<a href="https://www.espressif.com/zh-hans/support/download/all?keys=&field_type_tid[]=14" target="_blank" rel="noopener">乐鑫官网ESP8266资料</a></p><p>ESP8266模块<a href="https://www.ai-thinker.com/product/esp8266" target="_blank" rel="noopener">安信可官网</a></p><p>本人使用的NodeMcu相关信息：</p><ul><li><p><a href="https://github.com/nodemcu/nodemcu-devkit-v1.0" target="_blank" rel="noopener">开源地址</a>，主模块为ESP-12E（与ESP-12F一致，区别为ESP-12E为双层板，ESP-12F四层板，详见安信可的<a href="https://docs.ai-thinker.com/_media/esp8266/esp8266_module_list.png" target="_blank" rel="noopener">旧选型表</a>），32M<strong>Bit</strong>（25Q32，4MB）</p></li><li><p>NodeMcu官方<a href="https://github.com/nodemcu/nodemcu-flasher" target="_blank" rel="noopener">烧录器地址</a>，第三方基于wxPython制作带GUI的<a href="https://github.com/marcelstoer/nodemcu-pyflasher/releases" target="_blank" rel="noopener">烧录器</a></p></li><li><p>NodeMcu<a href="https://github.com/nodemcu/nodemcu-firmware" target="_blank" rel="noopener">官方固件</a>（可以使用lua脚本编程，该固件的<a href="https://nodemcu.readthedocs.io/en/master/" target="_blank" rel="noopener">参考文档</a>，以及第三方<a href="https://github.com/wangzexi/NodeMCU-Tutorial" target="_blank" rel="noopener">学习笔记</a>（github访问不了可以通过<a href="https://www.cnblogs.com/wangzexi/category/856856.html" target="_blank" rel="noopener">该博客链接</a>））</p></li><li><p>引脚图</p><p>  <img src="//NU-LL.github.io/2020/04/28/ESP8266/NODEMCU_DEVKIT_V1.0_PINMAP.png" alt="NODEMCU_DEVKIT_V1.0_PINMAP"></p></li></ul><p>CPU、存储和Flash：</p><p>更多详细信息请看<a href="https://www.espressif.com/sites/default/files/documentation/0a-esp8266ex_datasheet_cn.pdf" target="_blank" rel="noopener">datasheet</a></p><ul><li>CPU时钟最高可达16MHz<ul><li>外部晶振在24MHz~52MHz之间</li></ul></li><li>内置ROM和SRAM。芯片内无可编程存储器，用户程序必须由外部Flash存储</li><li>理论上外部Flash最大支持16MB（128Mbit）</li><li>支持TCP/IP完全遵循802.11 b/g/n WLAN MAC协议和Wi-Fi Direct标准</li></ul><p>使用方式：</p><ul><li>AT指令模式：当做从机，响应主机的AT指令来执行对应的命令</li><li>SDK编程模式：<a href="https://www.espressif.com/zh-hans/support/download/sdks-demos" target="_blank" rel="noopener">乐鑫官网提供的SDK</a>（开源在github上：<a href="https://github.com/espressif/ESP8266_RTOS_SDK/releases" target="_blank" rel="noopener">RTOS_SDK</a>，<a href="https://github.com/espressif/ESP8266_NONOS_SDK/releases" target="_blank" rel="noopener">NONOS_SDK</a>）<ul><li>bin：编译生成的BN文件，可直接下载到Fash中。</li><li>documents：SDK相关的文档或链接。</li><li>driver_lib：外设驱动的库文件，如：UART、I2C和GPIO等。</li><li>examples：可供用户二次开发的示例代码</li><li>include：SDK自带头文件，包含了用户可使用的相关API函数及其他宏定义，用户无需修改。</li><li>ld：链接时所需的脚本文件，若无特殊需求，用户无需修改。</li><li>lib：SDK提供的库文件。</li><li>toos：编译B|N文件所需的工具，用户无需修改</li></ul></li></ul><p>参考文档：</p><ul><li><a href="https://www.espressif.com/sites/default/files/documentation/2a-esp8266-sdk_getting_started_guide_cn.pdf" target="_blank" rel="noopener">ESP8266 SDK 入门指南</a></li><li><a href="https://www.espressif.com/sites/default/files/documentation/2c-esp8266_non_os_sdk_api_reference_cn.pdf" target="_blank" rel="noopener">ESP8266 Non-OS SDK API 参考手册</a></li><li>安信可提供的<a href="https://docs.ai-thinker.com/esp8266/docs" target="_blank" rel="noopener">文档资源汇总</a>（有上述两本手册足够了，包含安信可自家的模块规格书、应用文档、AT手册、SDK相关手册）</li></ul><p>开发工具：</p><ul><li>安信可提供的<a href="https://docs.ai-thinker.com/tools" target="_blank" rel="noopener">开发工具</a><ul><li><a href="https://docs.ai-thinker.com/ai_ide_install" target="_blank" rel="noopener">安装</a></li><li><a href="https://docs.ai-thinker.com/ai_ide_use" target="_blank" rel="noopener">使用</a></li><li><a href="https://docs.ai-thinker.com/esp_download" target="_blank" rel="noopener">烧录</a><ul><li>相关选项配置可以看<code>ESP8266 SDK 入门指南</code>下载固件 章节</li><li>一般默认为：外部晶振频率26M，SPI速度40M，SPI模式DOUT，FLSH大小32Mbit，不勾选SpiAutoSet、DoNotChgBin</li><li>SpiAutoSet：不建议勾选 SpiAutoSet，推荐⽤户根据实际情况对 Flash 进⾏⼿动配置。⽤户如果了勾选 SpiAutoSet，下载⼯具将会按照默认的 Flash map 下载， 16 Mbit和 32 Mbit 的 Flash map 会被设置为 512 Kbyte + 512 Kbyte</li><li>DoNotChgBin<ul><li>勾选：Flash 的运⾏频率、⽅式和布局会以⽤户编译时的配置选项为准（采用Makefile中的配置项，不采用自己设置的SPI速度、模式等配置）</li><li>不勾选：Flash 的运⾏频率、⽅式和布局会以下载⼯具最终的配置为准 </li></ul></li></ul></li></ul></li></ul><p>下载模式：</p><ul><li>GPI00=1、GPI02=1、GPI015=0 =&gt; 程序运行模式</li><li>GPI00=0、GPI02=1、GPI015=0 =&gt; 串口下载模式</li></ul><p>Flash布局信息：</p><ul><li><p>详细情况可以看<code>ESP8266 SDK 入门指南</code>Flash布局 章节</p></li><li><p>Non-FOTA：</p><p>  <img src="//NU-LL.github.io/2020/04/28/ESP8266/image-20200428162850334.png" alt="Non-FOTA"></p><ul><li><p>⽤户可以通过修改<code>ESP8266_NONOS_SDK/ld/eagle.app.v6.ld</code>⽂件来改变<code>eagle.irom0text.bin</code>的上限值，即修改⽂件中<code>irom0_0_seg</code>参数的<code>len</code>字段</p><pre><code>  MEMORY  {    dport0_0_seg :                        org = 0x3FF00000, len = 0x10    dram0_0_seg :                         org = 0x3FFE8000, len = 0x14000    iram1_0_seg :                         org = 0x40100000, len = 0x8000    irom0_0_seg :                         org = 0x40210000, len = 0x5C000  }</code></pre><ul><li>org的低5位为下载地址（0x10000=64kb），len为长度</li></ul></li><li><p>对于NodeMcu而言（4MB=32Mbit）：</p><ul><li>eagle.flash.bin：0x00000（64kb）</li><li>eagle.irom0text.bin：0x10000</li><li>blank.bin：0x3FB000（4kb）</li><li>esp_init_data_default.bin：0x3FC000（默认RF参数）</li><li>blank.bin：0x3FE000</li></ul></li></ul></li><li><p>FOTA：</p><p>  <img src="//NU-LL.github.io/2020/04/28/ESP8266/image-20200428162907834.png" alt="FOTA"></p><ul><li>RF_CAL 参数：⽤于系统⾃动保存校准后的 RF 参数</li><li>默认 RF 参数：将 esp_int_data_default.bin 下载⾄该区，⽤于保存默认的参数信息</li><li>系统参数：⽤于保存系统参数信息</li></ul></li></ul><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动常用API整理</title>
      <link href="/2020/04/06/Linux%E9%A9%B1%E5%8A%A8%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/06/Linux%E9%A9%B1%E5%8A%A8%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="并发与竞争"><a href="#并发与竞争" class="headerlink" title="并发与竞争"></a>并发与竞争</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>定义：</p><pre><code class="c">typedef struct {    int counter;} atomic_t;</code></pre><p>整形操作：</p><pre><code class="c">ATOMIC_INIT(int i);//定义时初始化int atomic_read(atomic_t *v);void atomic_set(atomic_t *v, int i)void atomic_add(int i, atomic_t *v)void atomic_sub(int i, atomic_t *v)void atomic_dec(atomic_t *v)//自减void atomic_inc(atomic_t *v)//自增int atomic_dec_return(atomic_t *v)//自减并返回vint atomic_inc_return(atomic_t *v)//自增并返回vint atomic_sub_and_test(int i, atomic_t *v)//(v-i)==0?1:0（返回真、假）int atomic_dec_and_test(atomic_t *v)//(v--)==0?1:0（返回真、假）int atomic_inc_and_test(atomic_t *v)//(v++)==0?1:0（返回真、假）int atomic_add_negative(int i, atomic_t *v)//(v+i)&lt;0?1:0（返回真、假）</code></pre><p>位操作（直接对内存操作）：</p><pre><code class="c">void set_bit(int nr, void *p)//将p地址的第nr位置 1void clear_bit(int nr,void *p)void change_bit(int nr, void *p)//翻转int test_bit(int nr, void *p)//获取int test_and_set_bit(int nr, void *p)//将p地址的第nr位置1，并返回nr位原来的值int test_and_clear_bit(int nr, void *p)//...清零...int test_and_change_bit(int nr, void *p)//...翻转...</code></pre><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>基本API</p><pre><code class="c">DEFINE_SPINLOCK(spinlock_t lock)//定义并初始化int spin_lock_init(spinlock_t *lock)//初始化void spin_lock(spinlock_t *lock)//加锁void spin_unlock(spinlock_t *lock)//解锁int spin_trylock(spinlock_t *lock)//尝试加锁int spin_is_locked(spinlock_t *lock)//检查是否加锁，是返回非 0，否返回 0</code></pre><p>中断相关：</p><p>一般在线程中使用 <code>spin_lock_irqsave</code>/<code>spin_unlock_irqrestore</code>，在中断中使用<code>spin_lock</code>/<code>spin_unlock</code>  </p><pre><code class="c">void spin_lock_irq(spinlock_t *lock)//禁止本地中断，并获取自旋锁void spin_unlock_irq(spinlock_t *lock)//激活本地中断，并释放自旋锁void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)//保存中断状态，禁止本地中断，并获取自旋锁void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)//恢复中断状态，并且激活本地中断，释放自旋锁</code></pre><p>中断下半部相关：</p><pre><code class="c">void spin_lock_bh(spinlock_t *lock)//关闭下半部，并获取自旋锁void spin_unlock_bh(spinlock_t *lock)//打开下半部，并释放自旋锁</code></pre><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><pre><code class="c">DEFINE_SEAMPHORE(name)//定义信号量 并设值为1void sema_init(struct semaphore *sem, int val)//初始化，并设值为valvoid down(struct semaphore *sem)//获取信号量（会导致休眠，不能在中断中使用，不能被信号打断）int down_interruptible(struct semaphore *sem)//获取信号量(会导致休眠，不能在中断中使用，可以被信号打断)int down_trylock(struct semaphore *sem)//尝试获取信号量(成功返回 0。否则返回非 0)void up(struct semaphore *sem)//释放信号量</code></pre><h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><p>会导致休眠，不能在中断中使用 <code>mutex</code>，中断中只能使用<code>自旋锁</code></p><pre><code class="c">DEFINE_MUTEX(name)//定义并初始化void mutex_init(mutex *lock)//初始化void mutex_lock(struct mutex *lock)//上锁，失败则休眠，不可以被信号打断int mutex_lock_interruptible(struct mutex *lock)//上锁，失败则休眠，可以被信号打断void mutex_unlock(struct mutex *lock)//解锁int mutex_trylock(struct mutex *lock)//尝试加锁，成功返回1，失败返回0int mutex_is_locked(struct mutex *lock)//判断是否加锁，是返回1，否返回0</code></pre><h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h3 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h3><pre><code class="c">module_init(xxx_init);module_exit(xxx_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;author&quot;);//printk#define KERN_EMERG KERN_SOH &quot;0&quot; /* 紧急事件，一般是内核崩溃 */#define KERN_ALERT KERN_SOH &quot;1&quot; /* 必须立即采取行动 */#define KERN_CRIT KERN_SOH &quot;2&quot; /* 临界条件，比如严重的软件或硬件错误*/#define KERN_ERR KERN_SOH &quot;3&quot; /* 错误状态，一般设备驱动程序中使用KERN_ERR 报告硬件错误 */#define KERN_WARNING KERN_SOH &quot;4&quot; /* 警告信息，不会对系统造成严重影响 */#define KERN_NOTICE KERN_SOH &quot;5&quot; /* 有必要进行提示的一些信息 */#define KERN_INFO KERN_SOH &quot;6&quot; /* 提示性的信息 */#define KERN_DEBUG KERN_SOH &quot;7&quot; /* 调试信息 */</code></pre><h3 id="注册与注销"><a href="#注册与注销" class="headerlink" title="注册与注销"></a>注册与注销</h3><p>老方法，不推荐：</p><pre><code class="c">//注册字符设备（浪费设备号）static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops);//注销字符设备static inline void unregister_chrdev(unsigned int major, const char *name);</code></pre><ul><li>name：设备名字，指向一串字符串</li></ul><p>新方法，推荐：</p><pre><code class="c">/*注册（方法一，自己确定设备号）*/int register_chrdev_region(dev_t from, unsigned count, const char *name);//详见设备号APIcdev.owner = THIS_MODULE;void cdev_init(struct cdev *cdev, const struct file_operations *fops);int cdev_add(struct cdev *p, dev_t dev, unsigned count);/*注册（方法二，系统分配设备号）*/int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);//详见设备号APIcdev.owner = THIS_MODULE;void cdev_init(struct cdev *cdev, const struct file_operations *fops);int cdev_add(struct cdev *p, dev_t dev, unsigned count);/*注销*/void cdev_del(struct cdev *p);void unregister_chrdev_region(dev_t from, unsigned count);</code></pre><h3 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h3><p>类相关：</p><pre><code class="c">class_create(owner, name)//创建类 owner一般为THIS_MODULEvoid class_destroy(struct class *cls);//卸载类</code></pre><p>设备相关：</p><pre><code class="c">struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);//创建设备 parent=NULL drvdata=NULLvoid device_destroy(struct class *class, dev_t devt)//卸载设备</code></pre><h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>相关宏：</p><pre><code class="c">MAJOR(dev)//dev_t -&gt; 主设备号MINOR(dev)//dev_t -&gt; 次设备号MKDEV(ma,mi)//主设备号+次设备号 -&gt; dev_t</code></pre><p>动态分配设备号：</p><p>系统分配设备号+自动注册设备号</p><pre><code class="c">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</code></pre><ul><li>dev：存放起始设备编号的指针，当注册成功，*dev就会等于分配到的起始设备编号，可以通过<code>MAJOR()</code>和<code>MINNOR()</code>宏来提取主次设备号</li><li>baseminor：次设备号基地址，也就是起始次设备号</li><li>count：要申请的数量，一般都是一个</li><li>name：字符设备名称</li><li>返回值小于0,表示注册失败</li></ul><p>注册设备号：</p><p>手动确定设备号+手动注册设备号</p><pre><code class="c">int register_chrdev_region(dev_t from, unsigned count, const char *name)</code></pre><ul><li>from：要申请的起始设备号，也就是<strong>给定的设备号</strong></li><li>count：要申请的数量，一般都是一个</li><li>name：设备名字</li><li>当返回值小于0,表示注册失败</li></ul><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>内核空间–&gt;用户空间</p><pre><code class="c">static inline long copy_to_user(void __user *to, const void *from, unsigned long n)</code></pre><ul><li>to：用户空间指针</li><li>from：内核空间指针</li><li>n：从内核空间向用户空间拷贝数据的字节数</li><li>成功返回0，失败返回失败数目</li></ul><p>用户空间–&gt;内核空间</p><pre><code class="c">static inline long copy_from_user(void *to, const void __user * from, unsigned long n)</code></pre><ul><li>to：内核空间指针</li><li>from：用户空间指针</li><li>n：从用户空间向内核空间拷贝数据的字节数</li><li>成功返回0，失败返回失败数目</li></ul><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><pre><code class="c">#define ioremap(cookie,size) __arm_ioremap((cookie), (size), MT_DEVICE)</code></pre><ul><li>phys_addr：要映射的物理起始地址。</li><li>size：要映射的内存空间大小。</li></ul><pre><code class="c">void iounmap (volatile void __iomem *addr)</code></pre><p>对映射后的内存进行读写操作的函数：</p><pre><code class="c">//读u8 readb(const volatile void __iomem *addr)u16 readw(const volatile void __iomem *addr)u32 readl(const volatile void __iomem *addr)//写void writeb(u8 value, volatile void __iomem *addr)void writew(u16 value, volatile void __iomem *addr)void writel(u32 value, volatile void __iomem *addr)</code></pre><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><pre><code class="bash">#查看设备号cat /proc/devices#创建设备节点mknod /dev/xxx c 主设备号 次设备号#查看设备树节点ls /proc/device-treels /sys/firmware/devicetree/base#查看platform相关ls /sys/bus/platform/devices # 设备ls /sys/bus/platform/drivers # 驱动#查看misc相关ls /sys/class/misc # 驱动#驱动相关depmodmodprobe xxx.koinsmod xxx.kolsmodrmmod xxx.ko</code></pre><h2 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h2><pre><code class="c">extern u64 __jiffy_data jiffies_64;extern unsigned long volatile __jiffy_data jiffies;</code></pre><p>相关变量：</p><ul><li><code>HZ</code>：宏，就是CONFIG_HZ，系统频率，通过menuconfig配置，默认100</li><li><code>jiffies</code>、<code>jiffies_64</code>：系统运行的<strong>节拍数</strong>，由宏<code>HZ</code>确定，默认10ms累加一次</li><li><code>jiffies/HZ</code>：系统运行时间（s）</li></ul><p>时间先后函数：</p><pre><code class="c">//unkown 通常为 jiffies，known 通常是需要对比的值time_after(unkown, known)//unkown 时间上超过 known 则返回真time_before(unkown, known)//unkown 时间上滞后 known 则返回真time_after_eq(unkown, known)//unkown 时间上超过或等于 known 则返回真time_before_eq(unkown, known)//unkown 时间上滞后或等于 known 则返回真</code></pre><p>时间转换函数：</p><pre><code class="c">int jiffies_to_msecs(const unsigned long j)//jiffies类型j --&gt; msint jiffies_to_usecs(const unsigned long j)//jiffies类型j --&gt; usu64 jiffies_to_nsecs(const unsigned long j)//jiffies类型j --&gt; nslong msecs_to_jiffies(const unsigned int m)//ms --&gt; jiffieslong usecs_to_jiffies(const unsigned int u)//us --&gt; jiffiesunsigned long nsecs_to_jiffies(u64 n)//ns --&gt; jiffies</code></pre><p>短延时函数：</p><pre><code class="c">void ndelay(unsigned long nsecs)void udelay(unsigned long usecs)void mdelay(unsigned long mseces)</code></pre><p>定时器类型：</p><pre><code class="c">struct timer_list {    struct list_head entry;    unsigned long expires; /* 定时器超时时间，单位是节拍数 */    struct tvec_base *base;    void (*function)(unsigned long); /* 定时处理函数 */    unsigned long data; /* 要传递给 function 函数的参数 */    int slack;};</code></pre><p>定时器函数：</p><pre><code class="c">void init_timer(struct timer_list *timer);//初始化void add_timer(struct timer_list *timer);//注册并使能int del_timer(struct timer_list * timer);//删除（需等待 定时处理函数 退出）int del_timer_sync(struct timer_list *timer);//删除（需等待其他处理器使用完定时器，中断上下文勿用）int mod_timer(struct timer_list *timer, unsigned long expires);//修改定时值（会使能定时器）</code></pre><ul><li>返回值： 0，定时器未被使能； 1，定时器已经使能</li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h3><h4 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h4><pre><code class="c">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)</code></pre><ul><li>irq：要申请中断的中断号。</li><li>handler：中断处理函数，当中断发生以后就会执行此中断处理函数。</li><li>flags：中断标志，可以在文件<code>include/linux/interrupt.h</code>里面查看所有的中断标志。</li></ul><blockquote><p>常用的中断标志：</p><table><thead><tr><th align="center">标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IRQF_SHARED</td><td align="center">多个设备共享一个中断线，共享的所有中断都必须指定此标志。 如果使用共享中断的话，request_irq函数的 dev 参数是唯一区分他们的标志</td></tr><tr><td align="center">IRQF_ONESHOT</td><td align="center">单次中断，中断执行一次就结束</td></tr><tr><td align="center">IRQF_TRIGGER_NONE</td><td align="center">无触发</td></tr><tr><td align="center">IRQF_TRIGGER_RISING</td><td align="center">上升沿触发</td></tr><tr><td align="center">IRQF_TRIGGER_FALLING</td><td align="center">下降沿触发</td></tr><tr><td align="center">IRQF_TRIGGER_HIGH</td><td align="center">高电平触发</td></tr><tr><td align="center">IRQF_TRIGGER_LOW</td><td align="center">低电平触发</td></tr></tbody></table></blockquote><ul><li>name：中断名字，设置以后可以在<code>/proc/interrupts</code>文件中看到对应的中断名字</li><li>dev： 如果将 flags 设置为 IRQF_SHARED 的话， dev 用来区分不同的中断，一般情况下将dev 设置为设备结构体， dev 会传递给中断处理函数 irq_handler_t 的第二个参数</li><li>返回值： 0 中断申请成功；其他负值：中断申请失败；-EBUSY：中断已经被申请了</li></ul><p>对于一种不太重要而又比较耗时的中断，可以使用以下函数进行申请：</p><pre><code class="c">int devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)</code></pre><ul><li>该函数会使得中断线程化（中断使用下半部虽然可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比较耗时的下半部与进程进行公平竞争）</li><li>带<code>devm_</code>前缀表明申请到的资源可以由系统自动释放，无需手动处理</li><li>注意：并不是所有的中断都可以被线程化。该函数有利有弊，具体是否使用需要根据实际情况来衡量（触摸中断一般会用）</li></ul><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><pre><code class="c">void free_irq(unsigned int irq, void *dev)</code></pre><ul><li>irq： 要释放的中断</li><li>dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉</li></ul><h4 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h4><p>格式：</p><pre><code class="c">irqreturn_t (*irq_handler_t) (int, void *)</code></pre><p>返回值：</p><p>一般为<code>return IRQ_RETVAL(IRQ_HANDLED)</code></p><pre><code class="c">enum irqreturn {    IRQ_NONE = (0 &lt;&lt; 0),    IRQ_HANDLED = (1 &lt;&lt; 0),    IRQ_WAKE_THREAD = (1 &lt;&lt; 1),};typedef enum irqreturn irqreturn_t;</code></pre><h4 id="使能与禁止"><a href="#使能与禁止" class="headerlink" title="使能与禁止"></a>使能与禁止</h4><pre><code class="c">void enable_irq(unsigned int irq)void disable_irq(unsigned int irq)//需等待 正在执行的中断处理函数执行完void disable_irq_nosync(unsigned int irq)//无需等待 正在执行的中断处理函数执行完//不推荐local_irq_disable()//关闭全局中断local_irq_enable()//使能全局中断//推荐local_irq_save(flags)//保存中断标志到flags并 关闭全局中断local_irq_restore(flags)//根据flags设置中断标志并 使能全局中断</code></pre><h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><p>推荐使用<code>tasklet</code>实现</p><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>定义：</p><pre><code class="c">struct softirq_action{    void (*action)(struct softirq_action *);};</code></pre><p>系统定义的10个软中断：</p><p>多核处理器中，各个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断，但是所执行的软中断服务函数却是相同的：</p><pre><code class="c">enum{    HI_SOFTIRQ=0,//高优先级软中断    TIMER_SOFTIRQ,//定时器软中断    NET_TX_SOFTIRQ,//网络数据发送软中断    NET_RX_SOFTIRQ,//网络数据接收软中断    BLOCK_SOFTIRQ,    BLOCK_IOPOLL_SOFTIRQ,    TASKLET_SOFTIRQ,//tasklet 软中断    SCHED_SOFTIRQ,//调度软中断    HRTIMER_SOFTIRQ,//高精度定时器软中断    RCU_SOFTIRQ,//RCU 软中断    NR_SOFTIRQS};static struct softirq_action softirq_vec[NR_SOFTIRQS];</code></pre><p>注册软中断：</p><p>软中断必须在编译的时候静态注册。Linux内核默认会在软中断初始化函数<code>softirq_init</code>中打开<code>TASKLET_SOFTIRQ</code>和<code>HI_SOFTIRQ</code>软中断</p><pre><code class="c">void open_softirq(int nr, void (*action)(struct softirq_action *))</code></pre><ul><li>nr：要开启的软中断，在上述<code>enum</code>中选择一个</li><li>action：软中断对应的处理函数</li></ul><p>触发软中断：</p><pre><code class="c">void raise_softirq(unsigned int nr)</code></pre><h4 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h4><p>定义：</p><pre><code class="c">struct tasklet_struct{    struct tasklet_struct *next; /* 下一个 tasklet */    unsigned long state; /* tasklet 状态 */    atomic_t count; /* 计数器，记录对 tasklet 的引用数 */    void (*func)(unsigned long); /* tasklet 执行的函数，用户定义，相当于中断处理函数 */    unsigned long data; /* 函数 func 的参数 */};</code></pre><p>初始化：</p><pre><code class="c">void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);//初始化DECLARE_TASKLET(name, func, data)//宏，定义并初始化</code></pre><ul><li>func：tasklet 的处理函数</li><li>data：要传递给 func 函数的参数</li></ul><p>调度函数：</p><p>一般在中断的上半部中调用</p><pre><code class="c">void tasklet_schedule(struct tasklet_struct *t)</code></pre><ul><li>t：要调度的 tasklet，也就是 <code>DECLARE_TASKLET</code> 宏里面的 <code>name</code></li></ul><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列在进程上下文执行，即，将要推后的工作交给一个内核线程去执行，因此工作队列允许<strong>睡眠</strong>或<strong>重新调度</strong>。</p><p>如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet</p><p>定义：</p><p>工作–&gt;工作队列–&gt;工作者线程</p><pre><code class="c">//工作（重点关注）：struct work_struct {    atomic_long_t data;    struct list_head entry;    work_func_t func; /* 工作队列处理函数 */};//工作队列：struct workqueue_struct {    struct list_head pwqs;    struct list_head list;    struct mutex mutex;    int work_color;    int flush_color;    atomic_t nr_pwqs_to_flush;    struct wq_flusher *first_flusher;    struct list_head flusher_queue;    struct list_head flusher_overflow;    struct list_head maydays;    struct worker *rescuer;    int nr_drainers;    int saved_max_active;    struct workqueue_attrs *unbound_attrs;    struct pool_workqueue *dfl_pwq;    char name[WQ_NAME_LEN];    struct rcu_head rcu;    unsigned int flags ____cacheline_aligned;    struct pool_workqueue __percpu *cpu_pwqs;    struct pool_workqueue __rcu *numa_pwq_tbl[];};//工作者线程struct worker {    union {        struct list_head entry;        struct hlist_node hentry;    };    struct work_struct *current_work;    work_func_t current_func;    struct pool_workqueue *current_pwq;    bool desc_valid;    struct list_head scheduled;    struct task_struct *task;    struct worker_pool *pool;    struct list_head node;    unsigned long last_active;    unsigned int flags;    int id;    char desc[WORKER_DESC_LEN];    struct workqueue_struct *rescue_wq;};</code></pre><p>初始化：</p><pre><code class="c">#define INIT_WORK(_work, _func)//初始化，需要自己创建work_struct#define DECLARE_WORK(n, f)//创建和初始化，无需自己创建work_struct</code></pre><p>调度：</p><p>一般在中断的上半部中调用</p><pre><code class="c">bool schedule_work(struct work_struct *work)</code></pre><ul><li>work： 要调度的工作</li><li>返回值： 0 成功，其他值 失败</li></ul><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞：访问资源时，如果资源不可用，将会<strong>挂起线程</strong>，直到资源可用再唤醒。open函数中大部分flag均为阻塞访问</p><p>非阻塞：访问资源时，如果资源不可用，将会<strong>直接返回错误码</strong>。open函数中flag参数<code>O_NONBLOCK</code>为非阻塞访问</p><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>一般用于在<strong>中断</strong>中唤醒<strong>阻塞</strong>操作而引起的线程挂起</p><h4 id="等待队列头"><a href="#等待队列头" class="headerlink" title="等待队列头"></a>等待队列头</h4><p>等待队列的头部</p><p>定义：</p><pre><code class="c">struct __wait_queue_head {    spinlock_t lock;    struct list_head task_list;};typedef struct __wait_queue_head wait_queue_head_t;</code></pre><p>初始化：</p><pre><code class="c">void init_waitqueue_head(wait_queue_head_t *q)//仅初始化DECLARE_WAIT_QUEUE_HEAD//宏，定义+初始化</code></pre><h4 id="等待队列项"><a href="#等待队列项" class="headerlink" title="等待队列项"></a>等待队列项</h4><p>每个访问设备的进程都需要创建一个队列项，当设备不可用的时候需要将这些进程对应的等待队列项添加到等待队列里面</p><p>定义：</p><pre><code class="c">struct __wait_queue {    unsigned int flags;    void *private;    wait_queue_func_t func;    struct list_head task_list;};typedef struct __wait_queue wait_queue_t;</code></pre><p>初始化：</p><pre><code class="c">DECLARE_WAITQUEUE(name, tsk)//宏，定义并初始化</code></pre><ul><li>name：等待队列项的名字</li><li>tsk：这个等待队列项属于哪个任务(进程)，一般设置为<code>current</code>（全局变量，表示当前进程）</li></ul><h4 id="添加-移除等待队列"><a href="#添加-移除等待队列" class="headerlink" title="添加/移除等待队列"></a>添加/移除等待队列</h4><p>当设备不可用的时候需要将该进程对应的等待队列项添加到等待队列里面</p><pre><code class="c">void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)//添加void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)//删除</code></pre><ul><li>q： 等待队列项要加入的等待队列头</li><li>wait：要加入/删除的等待队列项</li></ul><h4 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程</p><pre><code class="c">void wake_up(wait_queue_head_t *q)//唤醒队列中的所有进程（包括TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE状态）void wake_up_interruptible(wait_queue_head_t *q)//唤醒队列中的所有进程（仅唤醒TASK_INTERRUPTIBLE状态进程）</code></pre><h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><p>当事件满足以后能够自动唤醒等待队列中的进程</p><pre><code class="c">wait_event(wq, condition)//若condition为真，则唤醒等待队列，否则一直阻塞。（会将进程设置为TASK_UNINTERRUPTIBLE状态）wait_event_timeout(wq, condition, timeout)//与wait_event类似，timeout为超时时间，单位为jiffies。返回0：超时时间到，且condition为假；返回1：condition为真wait_event_interruptible(wq, condition)//与wait_event类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断wait_event_interruptible_timeout(wq, condition, timeout)//与wait_event_timeout类似，此函数会将进程设置为TASK_INTERRUPTIBLE，即可以被信号打断</code></pre><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>一般用于<strong>非阻塞</strong>操作</p><p><code>poll</code>、 <code>epoll</code> 和 <code>select</code> 用于处理轮询。应用程序通过 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。当应用程序调用 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 函数的时候设备驱动程序中的 <code>poll</code> 函数就会执行</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>单线程中 select 函数能够监视的文件描述符数量一般最大为1024，可以修改该数量但会降低效率</p><pre><code class="c">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</code></pre><ul><li>nfds： 要操作的文件描述符个数</li><li>readfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>读</u>变化，所指定集合中有一个文件可以<u>读取</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>读</u>变化</li><li>writefds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>写</u>变化，所指定集合中有一个文件可以<u>写入</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>写</u>变化</li><li>exceptfds：指向描述符集合，fd_set类型。用于监视指定描述符集的<u>异常</u>变化，所指定集合中有一个文件<u>异常</u>，则返回大于 0 的值，否则根据 timeout 参数来判断是否超时。设置为 NULL，表示不关心任何文件的<u>异常</u>变化</li></ul><blockquote><p>fd_set变量定义相关宏：</p><pre><code class="c">void FD_ZERO(fd_set *set)//将 fd_set 变量的所有位都清零void FD_SET(int fd, fd_set *set)//将 fd_set 变量的某个位置 1（向 fd_set 添加一个文件描述符）， fd：要加入的文件描述符void FD_CLR(int fd, fd_set *set)//将 fd_set 变量的某个位清零（向 fd_set 删除一个文件描述符）， fd：要删除的文件描述符int FD_ISSET(int fd, fd_set *set)//测试 fd_set 的某个位是否置 1（判断某个文件是否可以进行操作）， fd：要判断的文件描述符</code></pre></blockquote><ul><li><p>timeout：超时时间，设为 NULL 表示无限期等待。timeval结构体类型</p><pre><code class="c">  struct timeval {   long tv_sec; /* 秒 */   long tv_usec; /* 微秒 */  };</code></pre></li><li><p>返回值： 0，超时发生，没有任何文件描述符可以进行操作； -1，发生错误；其他值，可以进行操作的文件描述符个数</p></li></ul><blockquote><p>select使用示例：</p><pre><code class="c">void main(void){    int ret, fd; /* 要监视的文件描述符 */    fd_set readfds; /* 读操作文件描述符集 */    struct timeval timeout; /* 超时结构体 */    fd = open(&quot;dev_xxx&quot;, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */    FD_ZERO(&amp;readfds); /* 清除 readfds */    FD_SET(fd, &amp;readfds); /* 将 fd 添加到 readfds 里面 */    /* 构造超时时间 */    timeout.tv_sec = 0;    timeout.tv_usec = 500000; /* 500ms */    ret = select(fd + 1, &amp;readfds, NULL, NULL, &amp;timeout);    switch (ret) {        case 0: /* 超时 */            ......            break;        case -1: /* 错误 */            ......            break;        default: /* 可以读取数据 */            if(FD_ISSET(fd, &amp;readfds)) { /* 判断是否为 fd 文件描述符 */                /* 使用 read 函数读取数据 */            }            break;    }}</code></pre></blockquote><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>本质上和 select 没有太大的差别，但是 poll 函数没有最大文件描述符限制</p><pre><code class="c">int poll(struct pollfd *fds, nfds_t nfds, int timeout)</code></pre><ul><li><p>fds： 要监视的文件描述符集合以及要监视的事件，为结构体<code>pollfd</code>数组类型，<code>pollfd</code>类型定义：</p><pre><code class="c">  struct pollfd {      int fd; /* 文件描述符 */      short events; /* 请求的事件 */      short revents; /* 返回的事件 */  };</code></pre><ul><li><p>fd：要监视的文件描述符，如果 fd 无效则 events 监视事件也无效，并且 revents 返回 0</p></li><li><p>events：要监视的事件，类型如下：</p><pre><code class="c">  POLLIN 有数据可以读取  POLLPRI 有紧急的数据需要读取  POLLOUT 可以写数据  POLLERR 指定的文件描述符发生错误  POLLHUP 指定的文件描述符挂起  POLLNVAL 无效的请求  POLLRDNORM 等同于POLLIN</code></pre></li><li><p>revents：返回参数，由 Linux 内核设置具体的返回事件</p></li></ul></li><li><p>nfds：poll 函数要监视的文件描述符数量</p></li><li><p>timeout：超时时间，单位为 ms</p></li><li><p>返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，即发生事件或错误的文件描述符数量； 0，超时； -1，发生错误，并设置相应的错误码</p></li></ul><blockquote><p>poll使用示例：</p><pre><code class="c">void main(void){    int ret;    int fd; /* 要监视的文件描述符 */    struct pollfd fds;    fd = open(filename, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */    /* 构造结构体 */    fds.fd = fd;    fds.events = POLLIN; /* 监视数据是否可以读取 */    ret = poll(&amp;fds, 1, 500); /* 轮询文件是否可操作，超时 500ms */    if (ret) { /* 数据有效 */        ......        /* 读取数据 */        ......    } else if (ret == 0) { /* 超时 */        ......    } else if (ret &lt; 0) { /* 错误 */        ......    }}</code></pre></blockquote><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>selcet 和 poll 函数会随着所监听的 fd 数量的增加，而导致效率的降低，且遍历所有的描述符比较浪费时间。epoll 专为处理大并发而准备，一般用于网络编程中。  其相关函数如下：</p><p>创建 epoll 句柄：</p><pre><code class="c">int epoll_create(int size)</code></pre><ul><li>size：Linux2.6.8 后此参数已无意义，大于 0 即可</li><li>返回值： epoll 句柄，如果为-1 的话表示创建失败</li></ul><p>向 epoll 句柄中添加要监视的文件描述符以及监视的事件：</p><pre><code class="c">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></pre><ul><li><p>epfd：epoll 句柄（即epoll_create的返回值）</p></li><li><p>op：对 epfd 的操作，可以设置为：</p><pre><code class="c">  EPOLL_CTL_ADD 向epfd添加文件参数fd表示的描述符  EPOLL_CTL_MOD 修改参数fd的event事件  EPOLL_CTL_DEL 从epfd中删除fd描述符</code></pre></li><li><p>fd：要监视的文件描述符</p></li><li><p>event：要监视的事件类型，epoll_event结构体指针类型：</p><pre><code class="c">  struct epoll_event {      uint32_t events; /* epoll 事件 */      epoll_data_t data; /* 用户数据 */  };</code></pre><ul><li><p>events：要监视的事件：</p><pre><code class="c">  EPOLLIN 有数据可以读取  EPOLLPRI 有紧急的数据需要读取  EPOLLOUT 可以写数据  EPOLLERR 指定的文件描述符发生错误  EPOLLHUP 指定的文件描述符挂起  EPOLLET 设置epoll为边沿触发（默认为水平触发）  EPOLLONESHOT 一次性监视（当监视完成以后需要再次监视某个fd，就需要将fd重新添加到epoll里面）</code></pre></li></ul></li><li><p>返回值： 0，成功； -1，失败，并设置相应的错误码</p></li></ul><p>等待事件发生：</p><pre><code class="c">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></pre><ul><li>epfd：epoll 句柄</li><li>events：指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调用者可以根据 events 判断发生了哪些事件</li><li>maxevents：events 数组大小（必须大于 0）</li><li>timeout：超时时间，单位为 ms</li><li>返回值： 0，超时； -1，错误；其他值，准备就绪的文件描述符数量</li></ul><h4 id="驱动中的poll函数"><a href="#驱动中的poll函数" class="headerlink" title="驱动中的poll函数"></a>驱动中的poll函数</h4><p>函数原型：</p><pre><code class="c">unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait)</code></pre><ul><li><p>filp： 要打开的设备文件(文件描述符)</p></li><li><p>wait： 结构体 poll_table_struct 类型指针， 由应用程序传递进来的。一般将此参数传递给<br>  poll_wait 函数</p></li><li><p>返回值：向应用程序返回设备或者资源状态，可以返回的资源状态如下：</p><pre><code class="c">  POLLIN 有数据可以读取  POLLPRI 有紧急的数据需要读取  POLLOUT 可以写数据  POLLERR 指定的文件描述符发生错误  POLLHUP 指定的文件描述符挂起  POLLNVAL 无效的请求  POLLRDNORM 等同于POLLIN，普通数据可读</code></pre></li></ul><p>添加到poll_table：</p><p>非阻塞函数，不会引起阻塞，只是将应用程序添加到 poll_table 中</p><pre><code class="c">void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)</code></pre><ul><li>wait_address：要添加到 poll_table 中的等待队列头</li><li>p：poll_table，就是file_operations 中 poll 函数的 wait 参数</li></ul><blockquote><p>驱动通用模板：</p><pre><code class="c">struct xxxx_dev {    ......    struct wait_queue_head_t r_wait; /* 等待队列头 */};unsigned int xxx_poll(struct file *filp, struct poll_table_struct *wait){    unsigned int mask = 0;    struct xxxx_dev *dev = (struct xxxx_dev *)filp-&gt;private_data;    poll_wait(filp, &amp;dev-&gt;r_wait, wait);    if(......) { /* 相关条件满足 */        mask = POLLIN | POLLRDNORM; /* 返回 PLLIN */    }    return mask;}</code></pre></blockquote><h2 id="异步通知（信号）"><a href="#异步通知（信号）" class="headerlink" title="异步通知（信号）"></a>异步通知（信号）</h2><p>Linux中的信号宏：</p><pre><code class="c">#define SIGHUP         1 /* 终端挂起或控制进程终止 */#define SIGINT         2 /* 终端中断(Ctrl+C 组合键) */#define SIGQUIT     3 /* 终端退出(Ctrl+\组合键) */#define SIGILL         4 /* 非法指令 */#define SIGTRAP     5 /* debug 使用，有断点指令产生 */#define SIGABRT     6 /* 由 abort(3)发出的退出指令 */#define SIGIOT         6 /* IOT 指令 */#define SIGBUS         7 /* 总线错误 */#define SIGFPE         8 /* 浮点运算错误 */#define SIGKILL     9 /* 杀死、终止进程 */#define SIGUSR1     10 /* 用户自定义信号 1 */#define SIGSEGV     11 /* 段违例(无效的内存段) */#define SIGUSR2     12 /* 用户自定义信号 2 */#define SIGPIPE     13 /* 向非读管道写入数据 */#define SIGALRM     14 /* 闹钟 */#define SIGTERM     15 /* 软件终止 */#define SIGSTKFLT     16 /* 栈异常 */#define SIGCHLD     17 /* 子进程结束 */#define SIGCONT     18 /* 进程继续 */#define SIGSTOP     19 /* 停止进程的执行，只是暂停 */#define SIGTSTP     20 /* 停止进程的运行(Ctrl+Z 组合键) */#define SIGTTIN     21 /* 后台进程需要从终端读取数据 */#define SIGTTOU     22 /* 后台进程需要向终端写数据 */#define SIGURG         23 /* 有&quot;紧急&quot;数据 */#define SIGXCPU     24 /* 超过 CPU 资源限制 */#define SIGXFSZ     25 /* 文件大小超额 */#define SIGVTALRM     26 /* 虚拟时钟信号 */#define SIGPROF     27 /* 时钟信号描述 */#define SIGWINCH     28 /* 窗口大小改变 */#define SIGIO         29 /* 可以进行输入/输出操作 */#define SIGPOLL     SIGIO/* #define SIGLOS 29 */#define SIGPWR         30 /* 断点重启 */#define SIGSYS         31 /* 非法的系统调用 */#define SIGUNUSED     31 /* 未使用信号 */</code></pre><p>上述信号中，除了 <code>SIGKILL</code>(9)和 <code>SIGSTOP</code>(19)这两个信号不能被忽略外，其他的信号都可以忽略</p><h3 id="应用程序API"><a href="#应用程序API" class="headerlink" title="应用程序API"></a>应用程序API</h3><p>指定信号的处理函数：</p><pre><code class="c">sighandler_t signal(int signum, sighandler_t handler)</code></pre><ul><li><p>signum：要设置处理函数的信号</p></li><li><p>handler： 信号的处理函数，函数原型：</p><pre><code class="c">  typedef void (*sighandler_t)(int)</code></pre></li><li><p>返回值： 设置成功返回信号的前一个处理函数，设置失败返回 SIG_ERR</p></li></ul><blockquote><p>应用程序的一般模板：</p><pre><code class="c">fd = open(filename, O_RDWR);if (fd &lt; 0) {    printf(&quot;Can&#39;t open file %s\r\n&quot;, filename);    return -1;}/* 设置信号 SIGIO 的处理函数 */signal(SIGIO, sigio_signal_func);fcntl(fd, F_SETOWN, getpid()); /* 将当前进程的进程号告诉给内核 */flags = fcntl(fd, F_GETFD); /* 获取当前的进程状态 */fcntl(fd, F_SETFL, flags | FASYNC);/* 设置进程状态为 FASYNC 启用异步通知功能（此时会调用驱动中的fasync函数） */while(1) {    sleep(2);}close(fd);return 0;</code></pre></blockquote><h3 id="驱动程序API"><a href="#驱动程序API" class="headerlink" title="驱动程序API"></a>驱动程序API</h3><p>异步相关结构体：</p><pre><code class="c">struct fasync_struct {    spinlock_t fa_lock;    int magic;    int fa_fd;    struct fasync_struct *fa_next;    struct file *fa_file;    struct rcu_head fa_rcu;};</code></pre><p>向应用程序发送中断信号：</p><pre><code class="c">void kill_fasync(struct fasync_struct **fp, int sig, int band)</code></pre><ul><li>fp：要操作的 fasync_struct 结构体</li><li>sig： 要发送的信号</li><li>band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT</li><li>返回值： 无</li></ul><p>file_operations操作集中异步接口函数：</p><p>应用程序通过<code>fcntl(fd, F_SETFL, flags | FASYNC)</code>改变fasync标记的时候，该函数就会执行</p><pre><code class="c">int (*fasync) (int fd, struct file *filp, int on)</code></pre><p>初始化 fasync_struct 结构体：</p><pre><code class="c">int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)</code></pre><ul><li>前三个参数与<code>fasync</code>函数中参数一致</li><li>fapp：要初始化的 fasync_struct 结构体指针变量</li></ul><blockquote><p>驱动一般模板：</p><pre><code class="c">struct xxx_dev {    ......    struct fasync_struct *async_queue; /* 异步相关结构体 */};static int xxx_fasync(int fd, struct file *filp, int on){    struct xxx_dev *dev = (xxx_dev)filp-&gt;private_data;    if (fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue) &lt; 0)//直接调用该函数即可，不用干其他事        return -EIO;    return 0;}static struct file_operations xxx_ops = {    ......    .fasync = xxx_fasync,    .release = xxx_release,    ......};static int xxx_release(struct inode *inode, struct file *filp){    return xxx_fasync(-1, filp, 0); /* 删除异步通知 */}</code></pre></blockquote><h2 id="常用框架API"><a href="#常用框架API" class="headerlink" title="常用框架API"></a>常用框架API</h2><h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>platform设备相关：</p><pre><code class="c">void platform_device_unregister(struct platform_device *pdev)//卸载platform设备int platform_device_register(struct platform_device *pdev)//注册platform设备</code></pre><p>platform驱动相关：</p><pre><code class="c">void platform_driver_unregister(struct platform_driver *drv)//卸载platform驱动int platform_driver_register (struct platform_driver *driver)//注册platform驱动</code></pre><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>MISC 驱动也叫做杂项驱动，当某些外设无法进行分类的时候就可以使用 MISC 驱动。 MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动</p><p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。MISC 设备会自动创建 cdev</p><pre><code class="c">int misc_register(struct miscdevice * misc)//注册MISC驱动int misc_deregister(struct miscdevice *misc)//销毁MISC驱动</code></pre><h3 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h3><h4 id="初始化及卸载"><a href="#初始化及卸载" class="headerlink" title="初始化及卸载"></a>初始化及卸载</h4><p>申请及释放：</p><pre><code class="c">struct input_dev *input_allocate_device(void)//申请input_devvoid input_free_device(struct input_dev *dev)//释放input_dev</code></pre><p>注册及注销：</p><pre><code class="c">int input_register_device(struct input_dev *dev)//注册void input_unregister_device(struct input_dev *dev)//注销</code></pre><p>修改input_dev：</p><pre><code class="c">struct input_dev *inputdev;inputdev = input_allocate_device(); /* 申请 input_dev */inputdev-&gt;name = &quot;test_inputdev&quot;; /* 设置 input_dev 名字 *//*********第一种设置事件和事件值的方法***********/__set_bit(EV_KEY, inputdev-&gt;evbit); /* 设置产生按键事件 */__set_bit(EV_REP, inputdev-&gt;evbit); /* 重复事件 */__set_bit(KEY_0, inputdev-&gt;keybit); /*设置产生哪些按键值 *//************************************************//*********第二种设置事件和事件值的方法***********/keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);/************************************************//*********第三种设置事件和事件值的方法***********/keyinputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);/************************************************//* 注册 input_dev */input_register_device(inputdev);</code></pre><h4 id="上报数据"><a href="#上报数据" class="headerlink" title="上报数据"></a>上报数据</h4><p>上报指定的事件以对应值：</p><pre><code class="c">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)</code></pre><ul><li>dev：需要上报的 input_dev</li><li>type：上报的事件类型，比如 EV_KEY</li><li>code：事件码，即注册的按键值，比如 KEY_0、 KEY_1 等等</li><li>value：事件值，比如 1 表示按键按下， 0 表示按键松开</li></ul><p>专用上报函数（本质是调用input_event）：</p><pre><code class="c">void input_report_key(struct input_dev *dev, unsigned int code, int value)//上报按键void input_report_rel(struct input_dev *dev, unsigned int code, int value)void input_report_abs(struct input_dev *dev, unsigned int code, int value)void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)void input_report_switch(struct input_dev *dev, unsigned int code, int value)void input_mt_sync(struct input_dev *dev)</code></pre><p>同步事件：</p><pre><code class="c">void input_sync(struct input_dev *dev)</code></pre><h4 id="应用层相关"><a href="#应用层相关" class="headerlink" title="应用层相关"></a>应用层相关</h4><p>应用层通过获得 <code>input_event</code> 结构体来获取input子系统发送的输入事件</p><pre><code class="c">struct input_event {    struct timeval time;    __u16 type;    __u16 code;    __s32 value;};</code></pre><ul><li><p>time：时间，即此事件发生的时间，timeval 结构体类型：</p><pre><code class="c">  typedef long __kernel_long_t;  typedef __kernel_long_t __kernel_time_t;  typedef __kernel_long_t __kernel_suseconds_t;  struct timeval {      __kernel_time_t tv_sec; /* 秒 */      __kernel_suseconds_t tv_usec; /* 微秒 */  };</code></pre></li><li><p>type： 事件类型，比如 EV_KEY 表示此次事件为按键事件</p></li><li><p>code： 事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如： KEY_0、KEY_1等</p></li><li><p>value：值，比如 EV_KEY 事件中 value 就是按键值，为 1 表示按键按下，为 0 的话表示按键没有被按下</p></li></ul><p>应用层读取方式：</p><pre><code class="c">static struct input_event inputevent;int err = 0;err = read(fd, &amp;inputevent, sizeof(inputevent));if (err &gt; 0) { /* 读取数据成功 */    switch (inputevent.type) {        case EV_KEY:            if (inputevent.code &lt; BTN_MISC) { /* 键盘键值 */                printf(&quot;key %d %s\r\n&quot;, inputevent.code, inputevent.value ? &quot;press&quot; : &quot;release&quot;);            } else {                printf(&quot;button %d %s\r\n&quot;, inputevent.code, inputevent.value ? &quot;press&quot; : &quot;release&quot;);            }            break;            /* 其他类型的事件，自行处理 */        case EV_REL:            break;        case EV_ABS:            break;        case EV_MSC:            break;        case EV_SW:            break;    }} else {    printf(&quot;读取数据失败\r\n&quot;);}</code></pre><h4 id="多点触摸"><a href="#多点触摸" class="headerlink" title="多点触摸"></a>多点触摸</h4><ul><li>linux内核中讲解多点电容触摸屏协议文档路径：<code>Documentation/input/multitouch-protocol.txt</code></li><li>老版本（2.x 版本）的 linux内核不支持多点电容触摸(Multi-touch，简称 MT)</li></ul><p>MT 协议分为两种类型：</p><ul><li>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)</li><li>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息，一般的多点电容触摸屏 IC 都有此能力</li></ul><h5 id="Type-A"><a href="#Type-A" class="headerlink" title="Type A"></a>Type A</h5><p>步骤（时序）如下：</p><pre><code class="c">ABS_MT_POSITION_X x[0]//上报第一个点的x坐标 input_report_abs()ABS_MT_POSITION_Y y[0]//上报第一个点的y坐标SYN_MT_REPORT// input_mt_sync()ABS_MT_POSITION_X x[1]//上报第二个点的x坐标 input_report_abs()ABS_MT_POSITION_Y y[1]//上报第二个点的y坐标SYN_MT_REPORT// input_mt_sync()SYN_REPORT// input_sync() 该轮数据发送完毕</code></pre><p>例子：drivers/input/touchscreen/st1232.c</p><h5 id="Type-B"><a href="#Type-B" class="headerlink" title="Type B"></a>Type B</h5><p>步骤（时序）如下：</p><pre><code class="c">ABS_MT_SLOT 0// input_mt_slot()ABS_MT_TRACKING_ID 45// input_mt_report_slot_state()ABS_MT_POSITION_X x[0]//上报第一个点的x坐标 input_report_abs()ABS_MT_POSITION_Y y[0]//上报第一个点的y坐标ABS_MT_SLOT 1// input_mt_slot()ABS_MT_TRACKING_ID 46// input_mt_report_slot_state()ABS_MT_POSITION_X x[1]//上报第二个点的x坐标 input_report_abs()ABS_MT_POSITION_Y y[1]//上报第二个点的y坐标SYN_REPORT// input_sync() 该轮数据发送完毕</code></pre><p>例子：drivers/input/touchscreen/ili210x.c</p><p>相关函数：</p><p>初始化 MT 的输入 slots（初始化时使用）：</p><pre><code class="c">int input_mt_init_slots(struct input_dev *dev, unsigned int num_slots, unsigned int flags)</code></pre><ul><li><p>dev： MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev</p></li><li><p>num_slots：设备要使用的 SLOT 数量，也就是触摸点的数量</p></li><li><p>flags： 其他一些 flags 信息</p><pre><code class="c">  #define INPUT_MT_POINTER 0x0001 /* pointer device, e.g. trackpad */  #define INPUT_MT_DIRECT 0x0002 /* direct device, e.g. touchscreen */  #define INPUT_MT_DROP_UNUSED0x0004 /* drop contacts not seen in frame */  #define INPUT_MT_TRACK 0x0008 /* use in-kernel tracking */  #define INPUT_MT_SEMI_MT 0x0010 /* semi-mt device, finger count handled manually */</code></pre></li><li><p>返回值： 0，成功；负值，失败</p></li></ul><p>产生 ABS_MT_SLOT 事件：</p><pre><code class="c">static inline void input_mt_slot(struct input_dev *dev, int slot)</code></pre><ul><li>dev： MT 设备对应的 input_dev</li><li>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点</li></ul><p>产生ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件：</p><pre><code class="c">void input_mt_report_slot_state(struct input_dev *dev, unsigned int tool_type, bool active)</code></pre><ul><li>dev： MT 设备对应的 input_dev</li><li>tool_type：上报触摸工具类型（即ABS_MT_TOOL_TYPE事件），目前的协议支持MT_TOOL_FINGER(手指)、 MT_TOOL_PEN(笔)和 MT_TOOL_PALM(手掌)</li><li>active：true，连续触摸，添加一个新的触摸点，linux 内核自动分配一个 ABS_MT_TRACKING_ID；false，触摸点抬起，移除一个触摸点，ABS_MT_TRACKING_ID由内核设为-1</li></ul><p>上传真实的触摸点数量：</p><pre><code class="c">void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)</code></pre><ul><li>dev： MT 设备对应的 input_dev</li><li>use_count：true，有效的触摸点数量（上报数量就是当前数模点数量）； false，追踪到的触摸点数量多于当前上报的数量（使用 BTN_TOOL_TAP     事件通知用户空间当前追踪到的触摸点总数量）</li><li>举个例子：硬件能够追踪5个触摸点，无论是否有触摸，硬件都会有5个值输出，此时use_count就是false，即无论触摸的数量为多少，追踪到的（硬件输出的5个值）总比上报的（真实触摸数量）多</li></ul><p>例子：</p><pre><code class="c">static irqreturn_t ft5x06_handler(int irq, void *dev_id){    ......    /* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */    ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);    /* 上报每一个触摸点坐标 */    for (i = 0; i &lt; MAX_SUPPORT_POINTS; i++) {        u8 *buf = &amp;rdbuf[i * tplen + offset];        /* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：         * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件         * bit5:4  保留         * bit3:0  X轴触摸点的11~8位。         */        type = buf[0] &gt;&gt; 6;     /* 获取触摸类型 */        if (type == TOUCH_EVENT_RESERVED)            continue;        /* 我们所使用的触摸屏和FT5X06是反过来的 */        x = ((buf[2] &lt;&lt; 8) | buf[3]) &amp; 0x0fff;        y = ((buf[0] &lt;&lt; 8) | buf[1]) &amp; 0x0fff;        /* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：         * bit7:4  Touch ID  触摸ID，表示是哪个触摸点         * bit3:0  Y轴触摸点的11~8位。         */        id = (buf[2] &gt;&gt; 4) &amp; 0x0f;        down = type != TOUCH_EVENT_UP;//是否按下 1：按下 0：松开        input_mt_slot(multidata-&gt;input, id);        input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);        if (!down)            continue;        input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);        input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);    }    input_mt_report_pointer_emulation(multidata-&gt;input, true);    input_sync(multidata-&gt;input);    ......}</code></pre><h3 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h3><p>fb_info结构体：</p><pre><code class="c">struct fb_info *framebuffer_alloc(size_t size, struct device *dev)void framebuffer_release(struct fb_info *info)</code></pre><ul><li>size：分配完framebuffer结构体后附加的额外空间（一般用于存放用户私有数据）</li><li>dev：最终会绑定到fb_info-&gt;device上，可以设为NULL</li></ul><p>注册与卸载：</p><pre><code class="c">int register_framebuffer(struct fb_info *fb_info)int unregister_framebuffer(struct fb_info *fb_info)</code></pre><p>显存分配与释放：</p><pre><code class="c">static inline void *dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *dma_addr, gfp_t gfp)static inline void dma_free_writecombine(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_addr)</code></pre><h3 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h3><p>申请并注册rtc_device：</p><pre><code class="c">struct rtc_device *rtc_device_register(const char *name, struct device *dev, const struct rtc_class_ops *ops, struct module *owner)</code></pre><ul><li>name：设备名字</li><li>dev： 设备</li><li>ops： RTC 底层驱动函数集</li><li>owner：驱动模块拥有者</li></ul><p>注销rtc_device：</p><pre><code class="c">void rtc_device_unregister(struct rtc_device *rtc)</code></pre><h3 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h3><p>适配器注册和注销：</p><p>一般不会用到，SOC厂商会写好这部分代码</p><pre><code class="c">//注册int i2c_add_adapter(struct i2c_adapter *adapter)/* 使用动态总线号 */int i2c_add_numbered_adapter(struct i2c_adapter *adap)/* 使用静态总线号 *///注销void i2c_del_adapter(struct i2c_adapter * adap)</code></pre><p>i2c驱动注册与注销：</p><pre><code class="c">#define i2c_add_driver(driver) i2c_register_driver(THIS_MODULE, driver)void i2c_del_driver(struct i2c_driver *driver)</code></pre><h4 id="iic通信"><a href="#iic通信" class="headerlink" title="iic通信"></a>iic通信</h4><h5 id="内核驱动"><a href="#内核驱动" class="headerlink" title="内核驱动"></a>内核驱动</h5><p>内核文档：<code>Documentation\i2c\i2c-protocol</code>、<code>Documentation\i2c\smbus-protocol</code></p><p>其中smbus-protocol是i2c-protocol的一个子集，官方更加推荐使用后者的smbus-protoco中的函数</p><p>收发函数：</p><pre><code class="c">//S Addr Rd [A] [Data] NA S Addr Wr [A] Data [A] Pint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)</code></pre><ul><li><p>adap： 所使用的 I2C 适配器， i2c_client 会保存其对应的 i2c_adapter</p></li><li><p>msgs： I2C 要发送的一个或多个消息</p><pre><code class="c">  struct i2c_msg {      __u16 addr; /* 从机地址 */      __u16 flags; /* 标志 */      #define I2C_M_TEN 0x0010      #define I2C_M_RD 0x0001      #define I2C_M_STOP 0x8000      #define I2C_M_NOSTART 0x4000      #define I2C_M_REV_DIR_ADDR 0x2000      #define I2C_M_IGNORE_NAK 0x1000      #define I2C_M_NO_RD_ACK 0x0800      #define I2C_M_RECV_LEN 0x0400      __u16 len; /* 消息(本 msg)长度 */      __u8 *buf; /* 消息数据 */  };</code></pre></li><li><p>num： 消息数量，即 msgs 的数量</p></li><li><p>返回值： 负值，失败，其他非负值，发送的 msgs 数量</p></li></ul><p>发送函数（最终调用i2c_transfer）：</p><pre><code class="c">//S Addr Wr [A] Data [A] Data [A] ... [A] Data [A] Pint i2c_master_send(const struct i2c_client *client, const char *buf, int count)</code></pre><ul><li>client： I2C 设备对应的 i2c_client</li><li>buf：要发送的数据</li><li>count： 要发送的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li><li>返回值： 负值，失败，其他非负值，发送的字节数</li></ul><p>接收函数（最终调用i2c_transfer）：</p><pre><code class="c">//S Addr Rd [A] [Data] A [Data] A ... A [Data] NA Pint i2c_master_recv(const struct i2c_client *client, char *buf, int count)</code></pre><ul><li>client： I2C 设备对应的 i2c_client</li><li>buf：要接收的数据</li><li>count： 要接收的数据字节数，必须小于 64KB（i2c_msg 的 len 成员变量是一个 u16(无符号 16 位)类型的数据）</li><li>返回值： 负值，失败，其他非负值，发送的字节数</li></ul><p>smbus-protoco中的函数：</p><pre><code class="c">i2c_smbus_read_byte()//S Addr Rd [A] [Data] NA Pi2c_smbus_write_byte()//S Addr Wr [A] Data [A] Pi2c_smbus_read_byte_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] NA Pi2c_smbus_read_word_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA Pi2c_smbus_write_byte_data()//S Addr Wr [A] Comm [A] Data [A] Pi2c_smbus_write_word_data()//S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] Pi2c_smbus_read_block_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA Pi2c_smbus_write_block_data()//S Addr Wr [A] Comm [A] Count [A] Data [A] Data [A] ... [A] Data [A] Pi2c_smbus_read_i2c_block_data()//S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] A [Data] A ... A [Data] NA Pi2c_smbus_write_i2c_block_data()//S Addr Wr [A] Comm [A] Data [A] Data [A] ... [A] Data [A] P</code></pre><h5 id="应用层直接访问"><a href="#应用层直接访问" class="headerlink" title="应用层直接访问"></a>应用层直接访问</h5><p>内核文档：<code>Documentation\i2c\dev-interface</code></p><p>通常，I2C设备由设备驱动来控制，但是通过/dev接口也可以提供用户空间直接访问适配器上的设备。前提是需要加载I2C-DEV内核模块</p><p>在应用层，<a href="https://i2c.wiki.kernel.org/index.php/I2C_Tools" target="_blank" rel="noopener">i2c-tools工具包</a>帮你写好了接口，<a href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/" target="_blank" rel="noopener">下载链接</a>，<a href="http://jdelvare.nerim.net/mirror/i2c-tools/" target="_blank" rel="noopener">镜像仓库</a>，只需要包含该库的头文件<code>include\linux\i2c-dev.h</code>即可直接控制iic（最新版本的4.1没有发现该文件）。其本质是调用的内核自带的驱动模块I2C-DEV。该模块位于<code>\drivers\i2c\i2c-dev.c</code>，通过宏<code>CONFIG_I2C_CHARDEV</code>配置，内核menuconfig路径为<code>Device Drivers-&gt; I2C support</code>，一般默认为通过模块加载</p><p>i2c-tools工具包的本质是通过调用<code>ioctl</code>打开实现各种功能：</p><pre><code class="c">//include\linux\i2c-dev.h部分源码static inline __s32 i2c_smbus_access(int file, char read_write, __u8 command, int size, union i2c_smbus_data *data){    struct i2c_smbus_ioctl_data args;    args.read_write = read_write;    args.command = command;    args.size = size;    args.data = data;    return ioctl(file,I2C_SMBUS,&amp;args);//本质就是调用ioctl}static inline __s32 i2c_smbus_write_quick(int file, __u8 value){    return i2c_smbus_access(file,value,0,I2C_SMBUS_QUICK,NULL);}</code></pre><p>上述部分源码中file就是需要访问的iic控制器，如：<code>/dev/i2c-0</code>，与自己写的驱动程序类似</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre><code class="c">/* 设备结构体 */struct xxx_dev {    ......        void *private_data; /* 私有数据，一般会设置为 i2c_client */};/** @description : 读取 I2C 设备多个寄存器数据* @param – dev : I2C 设备* @param – reg : 要读取的寄存器首地址* @param – val : 读取到的数据* @param – len : 要读取的数据长度* @return : 操作结果*/static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val, int len){    int ret;    struct i2c_msg msg[2];    struct i2c_client *client = (struct i2c_client *)dev-&gt;private_data;    /* msg[0]，第一条写消息，发送要读取的寄存器首地址 */    msg[0].addr = client-&gt;addr; /* I2C 器件地址 */    msg[0].flags = 0; /* 标记为发送数据 */    msg[0].buf = &amp;reg; /* 读取的首地址 */    msg[0].len = 1; /* reg 长度 */    /* msg[1]，第二条读消息，读取寄存器数据 */    msg[1].addr = client-&gt;addr; /* I2C 器件地址 */    msg[1].flags = I2C_M_RD; /* 标记为读取数据 */    msg[1].buf = val; /* 读取数据缓冲区 */    msg[1].len = len; /* 要读取的数据长度 */    ret = i2c_transfer(client-&gt;adapter, msg, 2);    if(ret == 2) {        ret = 0;    } else {        ret = -EREMOTEIO;    }    return ret;}/** @description : 向 I2C 设备多个寄存器写入数据* @param – dev : 要写入的设备结构体* @param – reg : 要写入的寄存器首地址* @param – val : 要写入的数据缓冲区* @param – len : 要写入的数据长度* @return : 操作结果*/static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len){    u8 b[256];    struct i2c_msg msg;    struct i2c_client *client = (struct i2c_client *)        dev-&gt;private_data;    b[0] = reg; /* 寄存器首地址 */    memcpy(&amp;b[1],buf,len); /* 将要发送的数据拷贝到数组 b 里面 */    msg.addr = client-&gt;addr; /* I2C 器件地址 */    msg.flags = 0; /* 标记为写数据 */    msg.buf = b; /* 要发送的数据缓冲区 */    msg.len = len + 1; /* 要发送的数据长度 */    return i2c_transfer(client-&gt;adapter, &amp;msg, 1);}</code></pre><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>spi_master注册和注销：</p><p>一般不会用到，SOC厂商会写好这部分代码</p><pre><code class="c">//注册struct spi_master *spi_alloc_master(struct device *dev,unsigned size)//申请int spi_register_master(struct spi_master *master)//注册 spi_bitbang_start//注销void spi_master_put(struct spi_master *master)//释放void spi_unregister_master(struct spi_master *master)//注销 spi_bitbang_stop</code></pre><p>spi驱动注册与注销：</p><pre><code class="c">int spi_register_driver(struct spi_driver *sdrv);void spi_unregister_driver(struct spi_driver *sdrv)</code></pre><p>相关结构体：</p><pre><code class="c">/*-----------------------spi_message-----------------------*/struct spi_message {    struct list_head    transfers;    struct spi_device   *spi;    unsigned        is_dma_mapped:1;    /* REVISIT:  we might want a flag affecting the behavior of the     * last transfer ... allowing things like &quot;read 16 bit length L&quot;     * immediately followed by &quot;read L bytes&quot;.  Basically imposing     * a specific message scheduling algorithm.     *     * Some controller drivers (message-at-a-time queue processing)     * could provide that as their default scheduling algorithm.  But     * others (with multi-message pipelines) could need a flag to     * tell them about such special cases.     */    /* completion is reported through a callback */    void            (*complete)(void *context);/*异步传输完成后，会调用该函数*/    void            *context;    unsigned        frame_length;    unsigned        actual_length;    int         status;    /* for optional use by whatever driver currently owns the     * spi_message ...  between calls to spi_async and then later     * complete(), that&#39;s the spi_master controller driver.     */    struct list_head    queue;    void            *state;};/*-----------------------spi_transfer-----------------------*/struct spi_transfer {    /* it&#39;s ok if tx_buf == rx_buf (right?)     * for MicroWire, one buffer must be null     * buffers must work with dma_*map_single() calls, unless     *   spi_message.is_dma_mapped reports a pre-existing mapping     */    const void  *tx_buf;/* 要发送的数据 */    void        *rx_buf;/* 保存接收到的数据 */    unsigned    len;/* 进行传输的数据长度 */    dma_addr_t  tx_dma;    dma_addr_t  rx_dma;    struct sg_table tx_sg;    struct sg_table rx_sg;    unsigned    cs_change:1;    unsigned    tx_nbits:3;    unsigned    rx_nbits:3;#define SPI_NBITS_SINGLE    0x01 /* 1bit transfer */#define SPI_NBITS_DUAL      0x02 /* 2bits transfer */#define SPI_NBITS_QUAD      0x04 /* 4bits transfer */    u8      bits_per_word;    u16     delay_usecs;    u32     speed_hz;    struct list_head transfer_list;};</code></pre><h4 id="spi通信"><a href="#spi通信" class="headerlink" title="spi通信"></a>spi通信</h4><p>初始化：</p><pre><code class="c">int spi_setup(struct spi_device *spi)//初始化时钟和SPI模式void spi_message_init(struct spi_message *m)void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)//将spi_transfer添加到spi_message队列中</code></pre><p>同步传输（阻塞，会等待SPI数据传输完成）</p><pre><code class="c">int spi_sync(struct spi_device *spi, struct spi_message *message)</code></pre><p>异步传输（不会阻塞，不会等到SPI数据传输完成）</p><p>异步传输需要设置 spi_message 中的<code>complete</code>成员变量，当 SPI 异步传输完成以后<code>complete</code>函数就会被调用</p><pre><code class="c">int spi_async(struct spi_device *spi, struct spi_message *message)</code></pre><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre><code class="c">/* SPI 多字节发送 */static int spi_send(struct spi_device *spi, u8 *buf, int len){    int ret;    struct spi_message m;    struct spi_transfer t = {        .tx_buf = buf,        .len = len,    };    spi_message_init(&amp;m); /* 初始化 spi_message */    spi_message_add_tail(t, &amp;m);/* 将 spi_transfer 添加到 spi_message 队列 */    ret = spi_sync(spi, &amp;m); /* 同步传输 */    return ret;}/* SPI 多字节接收 */static int spi_receive(struct spi_device *spi, u8 *buf, int len){    int ret;    struct spi_message m;    struct spi_transfer t = {        .rx_buf = buf,        .len = len,    };    spi_message_init(&amp;m); /* 初始化 spi_message */    spi_message_add_tail(t, &amp;m);/* 将 spi_transfer 添加到 spi_message 队列 */    ret = spi_sync(spi, &amp;m); /* 同步传输 */    return ret;}</code></pre><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p>设备树绑定内核参考文档：<code>Documentation/devicetree/bindings/pwm/imx-pwm.txt</code></p><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li><p>通过名字查找</p><pre><code class="c"> struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>name：要查找的节点名字（不是table和name属性）。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li></ul></li><li><p>通过device_type 属性查找</p><pre><code class="c"> struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li></ul></li><li><p>根据 device_type 和 compatible查找</p><pre><code class="c"> struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li><li>compatible： 要查找的节点所对应的 compatible 属性列表。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败  </li></ul></li><li><p>通过 of_device_id 匹配表来查找</p><pre><code class="c"> struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li><li>match： 找到的匹配的 of_device_id。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败</li></ul></li><li><p>通过路径查找</p><pre><code class="c"> inline struct device_node *of_find_node_by_path(const char *path)</code></pre><ul><li>path：带有全路径的节点名，可以使用节点的别名。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败</li></ul></li><li><p>查找指定节点的父节点</p><pre><code class="c"> struct device_node *of_get_parent(const struct device_node *node)</code></pre><ul><li>node：要查找的父节点的节点。</li><li>返回值： 找到的父节点。</li></ul></li><li><p>查找指定节点的子节点</p><pre><code class="c"> struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)</code></pre><ul><li>node：父节点。</li><li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li><li>返回值： 找到的下一个子节点。</li></ul></li></ol><h4 id="提取属性"><a href="#提取属性" class="headerlink" title="提取属性"></a>提取属性</h4><ol><li><p>查找节点中的指定属性</p><pre><code class="c"> property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></pre><ul><li>np：设备节点。</li><li>name： 属性名字。</li><li>lenp：属性值的字节数，一般为NULL</li><li>返回值： 找到的属性。</li></ul></li><li><p>获取属性中元素的数量</p><pre><code class="c"> int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></pre><ul><li>np：设备节点。</li><li>proname： 需要统计元素数量的属性名字。</li><li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li><li>返回值： 得到的属性元素数量。</li></ul></li><li><p>从属性中获取指定标号的 u32 类型数据值</p><pre><code class="c"> int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>index：要读取的值标号。</li><li>out_value：读取到的值</li><li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p><pre><code class="c"> int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz) int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz) int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz) int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li><li>sz： 要读取的数组元素数量。</li><li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取只有一个整形值的属性</p><pre><code class="c"> int of_property_read_u8(const struct device_node *np,const char *propname, u8 *out_value) int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value) int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value) int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_value：读取到的数组值。</li><li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取属性中字符串值</p><pre><code class="c"> int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_string：读取到的字符串值。</li><li>返回值： 0，读取成功，负值，读取失败。</li></ul></li><li><p>获取#address-cells 属性值</p><pre><code class="c"> int of_n_addr_cells(struct device_node *np)</code></pre><ul><li>np：设备节点。</li><li>返回值： 获取到的#address-cells 属性值。</li></ul></li><li><p>获取#size-cells 属性值</p><pre><code class="c"> int of_n_size_cells(struct device_node *np)</code></pre><ul><li>np：设备节点。</li><li>返回值： 获取到的#size-cells 属性值。</li></ul></li></ol><h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><ol><li><p>查看节点的 compatible 属性是否有包含指定的字符串</p><pre><code class="c"> int of_device_is_compatible(const struct device_node *device, const char *compat)</code></pre><ul><li>device：设备节点。</li><li>compat：要查看的字符串。</li><li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li></ul></li><li><p>获取地址相关属性</p><p> 主要是“reg”或者“assigned-addresses”属性值</p><pre><code class="c"> const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags)</code></pre><ul><li>dev：设备节点。</li><li>index：要读取的地址标号。</li><li>size：地址长度。</li><li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li><li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li></ul></li><li><p>将从设备树读取到的地址转换为物理地址</p><pre><code class="c"> u64 of_translate_address(struct device_node *dev, const __be32 *in_addr)</code></pre><ul><li>dev：设备节点。</li><li>in_addr：要转换的地址。</li><li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li></ul></li><li><p>从设备树里面提取资源值</p><p> 本质上是将 reg 属性值转换为 resource 结构体类型</p><pre><code class="c"> int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</code></pre><ul><li>dev：设备节点。</li><li>index：地址资源标号。</li><li>r：得到的 resource 类型的资源值。</li><li>返回值： 0，成功；负值，失败。</li></ul></li><li><p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p><p> 本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p><pre><code class="c"> void __iomem *of_iomap(struct device_node *np, int index)</code></pre><ul><li>np：设备节点。</li><li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li><li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li></ul></li></ol><h3 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h3><h4 id="of函数"><a href="#of函数" class="headerlink" title="of函数"></a>of函数</h4><ol><li><p>获取设备树某个属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p><pre><code class="c"> int of_gpio_named_count(struct device_node *np, const char *propname)</code></pre><ul><li>np：设备节点。</li><li>propname：要统计的 GPIO 属性。</li><li>返回值： 正值，统计到的 GPIO 数量；负值，失败。</li></ul></li><li><p>获取设备树<code>gpios</code>属性中定义 GPIO 的个数（空的 GPIO 信息（即值为0）也会被统计到）</p><pre><code class="c"> int of_gpio_count(struct device_node *np)</code></pre></li><li><p>获取 GPIO 编号</p><pre><code class="c"> int of_get_named_gpio(struct device_node *np, const char *propname, int index)</code></pre><ul><li>index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO 的编号，如果只有一个 GPIO 信息的话此参数为 0</li></ul></li></ol><h4 id="驱动层函数"><a href="#驱动层函数" class="headerlink" title="驱动层函数"></a>驱动层函数</h4><ol><li><p>申请GPIO</p><pre><code class="c"> int gpio_request(unsigned gpio, const char *label)</code></pre><ul><li>gpio：要申请的 gpio 标号，使用 <code>of_get_named_gpio</code> 函数返回值</li><li>label：给 gpio 设置个名字。</li><li>返回值： 0，申请成功；其他值，申请失败。</li></ul></li><li><p>释放GPIO</p><pre><code class="c"> void gpio_free(unsigned gpio)</code></pre></li><li><p>设置方向</p><pre><code class="c"> int gpio_direction_input(unsigned gpio) int gpio_direction_output(unsigned gpio, int value)</code></pre><ul><li>返回值： 0，设置成功；负值，设置失败</li></ul></li><li><p>设置值</p><pre><code class="c"> #define gpio_get_value __gpio_get_value int __gpio_get_value(unsigned gpio)</code></pre><ul><li>返回值： 非负值，得到的 GPIO 值；负值，获取失败</li></ul></li><li><p>获取值</p><pre><code class="c"> #define gpio_set_value __gpio_set_value void __gpio_set_value(unsigned gpio, int value)</code></pre></li><li><p>获取 gpio 对应的中断号</p><pre><code class="c"> int gpio_to_irq(unsigned int gpio)</code></pre><ul><li>gpio： 要获取的 GPIO 编号</li><li>返回值： GPIO 对应的中断号</li></ul></li></ol><h3 id="中断相关"><a href="#中断相关" class="headerlink" title="中断相关"></a>中断相关</h3><p>提取 interrupts 属性中的中断号</p><pre><code class="c">unsigned int irq_of_parse_and_map(struct device_node *dev, int index)</code></pre><ul><li>dev： 设备节点</li><li>index：索引号， interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息</li><li>返回值：中断号</li></ul><p>获取 gpio 对应的中断号（与上面的函数功能一样）</p><pre><code class="c">int gpio_to_irq(unsigned int gpio)</code></pre><ul><li>gpio： 要获取的 GPIO 编号，由<code>gpio_request</code>申请而来</li><li>返回值： GPIO 对应的中断号</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上常见服务搭建</title>
      <link href="/2020/03/28/Linux%E4%B8%8A%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/28/Linux%E4%B8%8A%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux上常见服务搭建"><a href="#Linux上常见服务搭建" class="headerlink" title="Linux上常见服务搭建"></a>Linux上常见服务搭建</h1><h2 id="TFTP服务"><a href="#TFTP服务" class="headerlink" title="TFTP服务"></a>TFTP服务</h2><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p>tftp是Linux上常见的远程文件传输服务，其搭建方式如下（Ubuntu 18.04下实验成功）：</p><ol><li><p>搭建tftp服务器（tftp-server）：</p><pre><code class="bash"> sudo apt-get install tftp-hpa tftpd-hpa sudo apt-get install xinetd</code></pre></li><li><p>创建tftp共享文件夹并赋予其权限：</p><pre><code class="bash"> mkdir /tftpboot chmod 777 /tftpboot</code></pre></li><li><p>配置tftp服务器：</p><p> 创建并打开<code>/etc/xinetd.d/tftp</code>文件，输入以下内容：</p><pre><code class="bash"> service tftp { socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s /tftpboot # tftp的共享文件夹 disable = no per_source = 11 cps = 100 2 flags = IPv4 }</code></pre><p> 打开<code>/etc/default/tftpd-hpa</code>文件，将其修改为如下所示内容： </p><pre><code class="bash"> # /etc/default/tftpd-hpa TFTP_USERNAME=&quot;tftp&quot; TFTP_DIRECTORY=&quot;/tftpboot&quot; # tftp的共享文件夹 TFTP_ADDRESS=&quot;:69&quot; TFTP_OPTIONS=&quot;-l -c -s&quot;</code></pre></li><li><p>重启相关服务：</p><pre><code class="bash"> sudo /etc/init.d/xinetd restart sudo service tftpd-hpa restart</code></pre></li></ol><h3 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h3><ol><li><p>在共享目录下创建文件</p><pre><code class="bash"> echo &quot;hello tftp service&quot; &gt;&gt; /tftpboot/a.txt</code></pre></li><li><p>进入本地tftp服务器</p><pre><code class="bash"> null@ubuntu:~$ tftp localhost tftp&gt; get a.txt tftp&gt; q</code></pre></li><li><p>如果在当前目录下看到刚刚创建在<code>/tftpboot</code>下的文件，则表示搭建成功</p></li></ol><h2 id="NFS服务"><a href="#NFS服务" class="headerlink" title="NFS服务"></a>NFS服务</h2><ol><li><p>安装服务：</p><pre><code class="bash"> sudo apt-get install nfs-kernel-server rpcbind</code></pre></li><li><p>修改配置文件<code>/etc/exports</code>，填入以下内容：</p><pre><code class="bash"> #nfs文件夹绝对路径 文件名(相关权限) /home/null/NFS_Share *(rw,sync,no_root_squash)</code></pre></li><li><p>重启NFS服务：</p><pre><code class="bash"> sudo /etc/init.d/nfs-kernel-server restart</code></pre></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在一些Linux驱动开发过程中，需要利用uboot通过nfs加载相关的文件或文件系统，但是往往会发生各种异常，其中低版本uboot和高版本deepin或者ubuntu搭配进行开发时尤其严重，根本原因是：</p><p>linux内核默认启动nfs，使用协议为2，即使在配置时，选择支持了更高级别的版本，但是未修改默认使用版本，依然会默认使用协议为2。而高版本的deepin或者ubuntu17之后nfs就默认支持3和4，因此需要deepin或者ubuntu支持协议2，或者内核启动nfs挂载，默认使用3以及以上版本挂载nfs。</p><p>方法如下：</p><ol><li><p>修改ubuntu配置文件<code>/etc/default/nfs-kernel-server</code>，在配置文件尾部加上：<code>RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</code>，使nfs支持协议2。之后重启NFS服务即可</p><pre><code class="bash"> #重启nfs服务 sudo /etc/init.d/nfs-kernel-server restart</code></pre></li><li><p>修改Linux内核启动参数（内核支持更高等级的nfs协议），添加参数<code>proto=tcp,nolock,nfsvers=3,</code> ，如：</p><pre><code class="bash"> tftp 80800000 zImage console=ttymxc0,115200 root=/dev/nfs nfsvers=3 rw nfsroot=192.168.1.100:/home/null/NFS_Share ip=192.168.1.106:192.168.1.100:192.168.1.1:255.255.255.0::eth0:off</code></pre></li></ol><p>注意：iptables用于设置，维护和检查Linux内核中IPv4包过滤规则的表，在意外情况下可以通过如下命令清除所有规则（如果有安装iptables）：</p><pre><code class="bash">sudo iptables -F</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes</title>
      <link href="/2020/03/15/kubernetes/"/>
      <url>/2020/03/15/kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><p>kubernetes前身Borg系统架构：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200305135111543.png" alt="Borg系统架构"></p><ul><li>BorgMaster：主要负责请求的分发，整个集群的大脑<ul><li>多个，避免单节点故障，一般高可用集群的最好保持<strong>3个以上</strong>，一般为奇数，即3,5,7,9等</li><li>link shared：分发</li></ul></li><li>Borglet：真正执行的节点</li><li>scheduler：调度器，会将数据写入Paxos（数据库）</li><li>borgcfg、command-line tools、web browsers：通过 一些配置文件、命令行、浏览器 对这个集群进行调度管理</li></ul><p>kubernetes架构：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200305221943103.png" alt="kubernetes架构"></p><ul><li>kubectl、web UI：命令行管理工具、网页</li><li>etcd：GO语言的开源项目，键值对数据库，起持久化作用，储存k8s集群中的所有重要信息<ul><li>etcd的官方将它定位成一个<strong>可信赖</strong>的<strong>分布式键值存储服务</strong>，它能够为整个分布式集群存储些关键数据，协助分布式集群的正常运转，有以下两个版本：</li><li>v2：会将所有数据写入内存中</li><li>v3：会引入本地化 卷的持久化操作，关机后数据不会丢失（k8s 1.11之前没有该版本）</li></ul></li><li>Master（上边大框）：领导者<ul><li>scheduler：调度器，调度任务至不同的node中，会将任务交给api server</li><li>api server：负责将请求写入etcd，一切服务、访问的入口</li><li>replication controller：重置器，维护副本数目或者期望值</li></ul></li><li>node（下面小框）：执行者<ul><li>kubelet：根CRI（C：container容器 R：Runtime运行环境 I：interface接口 ，即docker在这里的表现形式）有关。kubelet会跟docker进行交互，操作docker创建对应的容器，维持pod生命周期</li><li>kube_proxy：实现pod与pod之间的访问，包括负载均衡。默认操作防火墙（firewall）实现pod的映射。新版本中支持IPVS。</li><li>docker或其他虚拟化引擎</li></ul></li></ul><p>ETCD内部架构图：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200305223042011.png" alt="image-20200305223042011"></p><ul><li>Raft：所有读写信息都在这里</li><li>WAL：预写日志<ul><li>Entry：日志完整备份</li><li>Snapshot：日志临时备份</li></ul></li><li>Store：Raft会将数据以及日志写入磁盘中进行持久化设置</li></ul><p>相关插件：</p><ul><li>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</li><li>DASHBOARD：给K8s集群提供一个B/S结构访问体系</li><li>INGRESS CONTROLLER：官方只能实现四层代理, INGRESS可以实现七层代理</li><li>FEDERATION：提供一个可以跨集群中心多K8S统一管理功能</li><li>PROMETHEUS：提供K8s集群的监控能力</li><li>ELK：提供K8s集群日志統一分析接入平台</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Pod概念"><a href="#Pod概念" class="headerlink" title="Pod概念"></a>Pod概念</h3><p>只要pod运行，pod中的pause容器就一定会被启动，且该pod中的其他容器会共用pause容器中的网络栈和存储资源</p><ul><li>共用网络栈：其他容器中没有独立的ip地址，有的只有pause容器中的或该pod的地址，即其他容器均可通过localhost访问对方，同时也表示同一个pod中容器之间的<strong>端口不能冲突</strong>（一样）</li><li>共用存储资源：同一个pod中既共享网络又共享储存</li></ul><p>分类：</p><ul><li>自主式Pod：不是控制器管理的pod，一旦死亡就结束</li><li>控制器管理的Pod</li></ul><p>pod控制器类型：</p><ul><li>RC（ReplicationController） &amp; RS（ReplicaSet） &amp; Deployment：<ul><li>ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。在新版本的 Kubernetes中建议使用 ReplicaSet来取代 ReplicationController</li><li>ReplicaSet跟 Replication Controller没有本质的不同，只是名字不一样，并且ReplicaSet<strong>支持集合式的selector</strong></li><li>虽然 ReplicaSet可以独立使用，但一般还是建议使用 Deployment来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题(比如 ReplicaSet不支持<strong>rolling-update</strong>但Deployment<strong>支持</strong>，Deployment是通过创建ReplicaSet来创建新的容器进而达到滚动更新的目的，且更新或者回滚时之前创建的ReplicaSet会被停用（而非删除）)</li></ul></li><li>HPA（HorizontalPodAutoScale）：<ul><li>Horizontal Pod Autoscaling仅适用于 Deployment和 ReplicaSet（HPA是基于RS定义的），在v1版本中仅支持根据Pod的CPU利用率扩所容，在 v1 alpha版本中，支持根据内存和用户自定义的 metric扩缩容，即能够实现水平自动扩容</li></ul></li><li>StatefullSet<ul><li>StatefullSet是为了解决<u>有状态服务</u>（无状态服务：没有状态需要实时保留，或拿出来一段时间后放回去仍能够正常工作。反之为有状态服务）的问题(对应 Deployments和 ReplicaSets是为无状态服务而设计)，其应用场景包括：<ul><li>稳定的持久化存储，即Pod死亡后重新调，还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后其 PodName和 HostName不变，基于 Headless Service<br>  (即没有 Cluster IP的 Service)来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行(即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是 Running和 Ready状态)，基于 init containers来实现</li><li>有序收缩，有序删除(即从N-1到0)</li></ul></li></ul></li><li>DaemonSet<ul><li>DaemonSet确保全部（或者一些（通过在Node上打污点（不被调度的Node），将不会在打污点的Node上运行该Pod副本））Node上运行<strong>一个</strong>Pod的副本。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除 DaemonSet将会删除它创建的所有Pod。DaemonSet的一些典型用法:<ul><li>运行集群存储 daemon，例如在每个Node上运行 glusterd、ceph</li><li>在每个Nde上运行日志收集 daemon，例如 fluent、 logstash</li><li>在每个Node上运行监控 daemon，例如 Prometheus Node Exporter</li></ul></li></ul></li><li>Job、Cronjob<ul><li>Job负责批处理任务，即仅执行一次的任务，它<strong>保证</strong>批处理任务的一个或多个Pod<strong>成功结束</strong>。</li><li>Cron Job管理基于时间的Job，即：<ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul></li></ul></li></ul><p>服务发现：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200306230923154.png" alt="图解"></p><ul><li>客户端想访问一组pod，这组pod会被service<strong>通过label</strong>选择到，同时service会有自己的ip+端口。所以客户端能够通过service的ip+端口访问从而间接访问service对应的pod，且该处有一个RR（轮询，负载均衡）算法存在<ul><li>一组pod：这些pod均具有相关性，即同一个RS、RC控制器创建或者是拥有同一组标签（本质是<strong>通过标签label</strong>）</li></ul></li></ul><h3 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h3><p>Kubernetes的网络模型假定了所有Pod都在一个可以<strong>直接连通</strong>的<strong>扁平</strong>（所有的pod均可以通过对方的ip”直接到达”(底层有相关的转化机制，详见后文Flannel)）的网络空间中，这在GCE( Google Compute Engine)里面是现成的网络模型，Kubernetes假定这个网络已经存在。而在私有云里搭建 Kubernetes集群，就不能假定这个网络已经存在了。我们需要自己实现这个网络假设，将不同节点上的 Docker容器之间的互相访问先打通，然后运行 Kubernetes</p><p>三种方式：</p><ul><li>同一个Pod内的多个容器之间：lo（localhost，由pause容器的网络栈构成）<ul><li>根本原因：同一个Pod共享同一个网络命名空间，共享同一个 Linux协议栈</li></ul></li><li>各Pod之间的通讯：Overlay Network（全覆盖网络）<ul><li>Pod1与Pod2不在同一台主机,Pod的地址是与 docker0在同一个网段的,但 docker0网段与宿主机网卡是两个完全不同的IP网段,并且不同Node之间的通信只能通过宿主机的物理网卡进行.将Pod的IP和所在Node的IP关联起来,通过这个关联让Pod可以互相访问（Flannel插件的原理，详解下文）</li><li>Pod1与Pod2在同一台机器,由 Docker0网桥直接转发请求至Pod2,不需要经过 Flannel</li></ul></li><li>Pod与 Service之间的通讯：各节点的 Iptables规则（最新版本中利用LVS机制）</li><li>Pod到外网：Pod向外网发送请求,查找路由表,转发数据包到宿主机的网卡,宿主网卡完成路由选择后, iptables执行 Masquerade转换,把源IP更改为宿主网卡的IP,然后向外网服务器发送请求</li><li>外网访问Pod：借助Service的Nodeport方式进行映射</li></ul><hr><p><strong>Flannel</strong>是CoreOS团队针对 Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的<strong>不同节点主机</strong>创建的 Docker容器都具有<strong>全集群唯一</strong>的虚拟IP地址。而且它还能在这些IP地址之间建立一个<strong>覆盖网络</strong>(Overla Network)，通过这个覆盖网络，将数据包原封不动地传递到目标容器内</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200306234642257.png" alt="Flannel框架说明"></p><ul><li>所有流量访问Backend的pod上，经过自己的网关处理后将相关请求分配至对应的Web appx服务上。这里的Backend与Web appx的相互之间的访问需要跨主机或者在同主机内部通信<ul><li>服务器service上一般会安装一个守护进程Flanneld，该进程会监听一个端口，该端口是用于后期转发接收数据包的服务端口，同时会开启网桥Flannel0</li><li>网桥Flannel0会收集Docker0转发出来的数据包</li><li>Docker0会分配自己的ip到对应的pod上</li></ul></li><li>同一台主机的不同pod访问：<ul><li>由于均处在同一网桥下，所以数据包都从Docker0的网桥走（在主机内部已经完成了数据包的转换）</li></ul></li><li>跨主机不同pod访问（Web app2 –&gt; Backend）：<ul><li>设置源、目标地址：10.1.15.2/24–&gt;10.1.20.3/24</li><li>由于不是同一个网段，所以会发往网关Docker0，Docker0会将数据包传给Flannel0中，Flannel0同样会将数据包传给Flanneld</li><li>Flanneld会从etcd中获取一堆路由表记录，并根据该表判断路由到那一台机器。然后会根据数据报文按照右侧图例进行封装（图中mac层后outerIp中目标地址为192.168.66.12，这里图中错了，注意）</li><li>数据包会被下面一台service中的Flanneld截获，并拆封该数据包，同时将数据包往Flannel0中发送，Flannel0又会转发给Docker0</li><li>Docker0会再次解封数据包，并将真正的数据发送给Backend</li></ul></li></ul><p>ETCD和Flannel之间的关联：</p><ul><li>存储管理 Flannel可分配的IP地址段资源</li><li>监控ETCD中每个Pod的实际地址，并在内存中建立维护Pod节点路由表</li></ul><hr><p>K8s中的三层网络关系：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200307001616147.png" alt="三层网络示例图"></p><ul><li>真实的物理网络只有：节点网络，其余网络均为虚拟化网络</li><li>所有Pod均在扁平化网络Pod网络中通信</li><li>访问Service需要在Service网络中访问，service会通过 LVS/iptables 在后台访问其他pod</li></ul><h2 id="Kubernetes集群安装"><a href="#Kubernetes集群安装" class="headerlink" title="Kubernetes集群安装"></a>Kubernetes集群安装</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>基本情况：私有镜像Harbor（192.168.66.100）、主节点k8s-master01（192.168.66.10）、从节点k8s-node01（192.168.66.20）、k8s-node02（192.168.66.21）以及软路由Router（192.168.66.1）</p><ul><li>采用k8s官方提供的安装工具kubeadm构建</li><li>Router采用koolshare构建</li><li>节点及私有镜像均采用CentOS7</li></ul><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><h4 id="软路由koolshare搭建"><a href="#软路由koolshare搭建" class="headerlink" title="软路由koolshare搭建"></a>软路由koolshare搭建</h4><p>VMware创建软路由koolshare：Windows10 x64（在PE中进行软路由的写入），固件类型为BIOS，2核心，暂时4G RAM后期再修改，网络类型为仅主机模式，磁盘类型为IDE，20G单个文件</p><p>步骤：</p><ul><li>将CD/DVD选项填入老毛桃的image（iso文件）位置，再开启虚拟机，选择进入Windows10 64位PE</li><li>进入虚拟机后，换掉光盘，换成koolshare的iso镜像文件</li><li>进入PE中我的电脑，打开DVD驱动器，看到<code>IMG写盘工具.exe</code>，右键，管理员方式运行，确定后选择对应的20G的物理硬盘，并将<code>映像档</code>设为DVD驱动器中的openwrt-koolshare镜像文件</li><li>点击开始，写入软路由koolshare</li><li>写入完毕后，将VMware中的CD/DVD中的设备状态栏中<code>启用时连接</code>选项关闭</li><li>关闭Windows10 PE</li><li>再次调整虚拟机资源：1G RAM，1核心，添加网卡并设为NAT模式<ul><li>之前的网卡为仅主机网络，用于和其他的k8s节点连接</li><li>添加的NAT网卡用于连接物理机，用于上网</li><li>在koolshare上安装ssr插件，进行科学上网</li></ul></li><li>再次开启虚拟机，会进入koolshare的系统</li><li>假设安装节点网络为192.168.66.0/24网段，其中master端口为192.168.66.10/24，node1为192.168.66.20/24，node2为192.168.66.21/24</li><li>修改网络并安装ssr插件：<ul><li>Windows控制面板中找到<code>网络连接</code>，选中仅主机网络对应的网卡（可以通过VMware中的虚拟网络编辑器查看），将对应网卡中IPv4协议中的<code>自动获得IP地址</code>改为<code>使用下面的IP地址</code>，并设置为192.168.1.240，子网掩码：255.255.255.0。点击<code>高级</code>，在<code>IP地址</code>栏中添加一个地址：192.168.66.240，子网掩码：255.255.255.0（一张网卡，两个地址，为了之后koolshare更改ip准备）</li><li>Windows物理机中可以打开网页：192.168.1.1的koolshare后台，密码为koolshare</li><li>找到网络-&gt;接口，删除DHCPv6的WAN6<ul><li>编辑内网网卡 LAN：点击<code>物理设置</code>，关闭桥接</li><li>编辑外网网卡 WAN：点击<code>物理设置</code>，没有桥接，正常，无需操作</li><li>编辑<code>IPv4</code>地址为：192.168.66.1（此后koolshare后台地址变为了该地址）</li></ul></li><li>重进后台，找到网络-&gt;诊断，尝试ping百度，测试网络</li><li>点击<code>酷软</code>，安装离线插件<code>koolss_2.2.2.tar.gz</code>（安装ssr插件）</li><li>配置上述插件的SS/SSR节点信息并保存</li></ul></li></ul><hr><h4 id="节点及k8s搭建"><a href="#节点及k8s搭建" class="headerlink" title="节点及k8s搭建"></a>节点及k8s搭建</h4><p>VMware创建3台centos7机器，分配100G磁盘并存储为单个文件（提高读写IO），4核心，并分别命令为主节点k8s-master01、从节点k8s-node01（4G RAM）、k8s-node02（4G RAM）</p><p>网络配置：</p><pre><code class="bash">vi /etc/sysconfig/network-scripts/ifcfg-ens33#修改一下参数：BOOOTRPOTO=static#添加地址IPADDR=192.168.66.20 #修改成对应的ipNETMASK=255.255.255.0GATEWAY=192.168.66.2 # 可以提前用ip route list看下网关地址DNS1=192.168.66.2DNS2=114.114.114.114#重启网络service network restart#ip link set eth0 upi          # 开启网卡#ip link set eth0 down         # 关闭网卡</code></pre><p>环境配置步骤：</p><pre><code class="bash">#设置系统主机名以及Host文件的相互解析hostnamectl set-hostname k8s-master01#修改host文件 大环境中建议通过DNS来解析vi /etc/hosts#添加下述代码192.168.66.10 k8s-master01192.168.66.20 k8s-node01192.168.66.21 k8s-node02scp /etc/hosts root@k8s-node01:/etc/hosts#将host拷贝至其他机器中scp /etc/hosts root@k8s-node02:/etc/hosts#将host拷贝至其他机器中#修改yum源为阿里源mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupcurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum makecache#安装依赖yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git#设置防火墙为 Iptables 并设置空规则systemctl stop firewall &amp;&amp; systemctl disable firewallyum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save#关闭SELINUXswapoff -a &amp;&amp; sed -i &#39;/ swap / s/^\(.*\)$/#\1/g&#39; /etc/fstab # 关闭swap分区（虚拟内存），再将虚拟内存永久关闭，防止k8s检测到虚拟内存并将容器放到虚拟内存中运行，从而降低工作效率setenforce 0 &amp;&amp; sed -i &#39;s/^SELINUX=.*/SELINUX=disabled/&#39; /etc/selinux/config # 关闭SELinux#调整内核参数，对于k8scat &gt; kubernetes.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1 # 必备参数 开启网桥模式net.bridge.bridge-nf-call-ip6tables=1 # 必备参数 开启网桥模式net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 # 禁止使用swap空间，只有当系统 OOM 时才允许使用它vm.overcommit_memory=1 # 不检查物理内存是否够用vm.panic_on_oom=0 # 开启OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1 # 必备参数 关闭IPv6net.netfilter.nf_conntrack_max=2310720EOFcp kubernetes.conf /etc/sysctl.d/kubernetes.confsysctl -p /etc/sysctl.d/kubernetes.conf # 刷新立马生效后，如提示文件不存在是因为当前内核环境下该文件没有，可以不用管#调整系统时区timedatectl set-timezone Asia/Shanghai #设置系统时区为 中国/上海timedatectl set-local-rtc 0 #将当前的UTC时间写入硬件时钟systemctl restart rsyslog #重启依赖于系统时间的服务systemctl restart crond#关闭系统不需要的服务systemctl stop postfix &amp;&amp; systemctl disable postfix # 邮件服务#设置rsyslogd 和 systemd journald （centos7中有两套日志方案，这里保留systemd journald关闭rsyslogd）mkdir /var/log/journal # 持久化保存日志的目录mkdir /etc/systemd/journald.conf.dcat &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;EOF[Journal]# 持久化保存到磁盘Storage=persistent# 压缩历史日志Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000# 最大占用空间 10GSystemMaxUse=10G# 单日志文件最大 200MSystemMaxFileSize=200M# 日志保存时间 2 周MaxRetentionSec=2week# 不将日志转发到 syslogForwardToSyslog=noEOFsystemctl restart systemd-journald#升级系统内核到4.44（Centos7.×系统自带的3.10.×内核存在一些Bugs，导致运行的 Docker、 Kubernetes不稳定）rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm # 安装完成后检查/boot/grub2/grub.cfg中对应内核 menuentry 中是否包含 initrd16配置，如果没有，再安装一次！yum --enablerepo=elrepo-kernel install -y kernel-lt# 设置开机从新内核启动grub2-set-default &#39;CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)&#39;#重启reboot#再次检测内核uname -r</code></pre><p>部署安装k8s：</p><pre><code class="bash">#kube-proxy开启ipvs的前置条件modprobe br_netfilter #加载模块cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOFchmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 #赋予权限并执行，查看是否引导成功#安装dockeryum install -y yum-utils device-mapper-persistent-data lvm2 #docker依赖yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #阿里云docker ce镜像仓库yum update -y &amp;&amp; yum install -y docker-ce-18.09.9#更新后重启，利用uname -r查看，发现又回到了之前的内核版本，需要重新选择内核，这里直接先切换，再重启grub2-set-default &#39;CentOS Linux (4.4.216-1.el7.elrepo.x86_64) 7 (Core)&#39; &amp;&amp; reboot #中间点版本号可能不同，通过uname -r来查看systemctl start docker &amp;&amp; systemctl enable docker #启动docker并设为自启mkdir /etc/docker # 创建/etc/docker目录#配置 daemoncat &gt; /etc/docker/daemon.json &lt;&lt;EOF{  &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],  &quot;log-driver&quot;:&quot;json-file&quot;,  &quot;log-opts&quot;:{    &quot;max-size&quot;:&quot;100m&quot;  }}EOFmkdir -p /etc/systemd/system/docker.service.d#重启 docker服务systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker</code></pre><p>上述过程后，所有节点的基本环境差不多搭建完成，还需要最后做一点工作：</p><p>首先初始化master节点：</p><pre><code class="bash">#安装 Kubeadm （主从配置）cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttp://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1 #初始化工具 命令行工具 容器接口工具systemctl enable kubelet.service #开机自启kubelet#初始化主节点（这一步只需要主节点执行即可）（kubeadm会从GCE（谷歌云服务器）上拉取镜像，可以直接通过软路由科学上网下载，也可以利用打包好的镜像直接导入（见下文））#显示init-defaults文件并打印到 kubeadm-config.yaml 中，获得默认的初始化模板kubeadm config print init-defaults &gt; kubeadm-config.yaml vim kubeadm-config.yaml # 编辑默认的初始化模板，并修改如下参数：localAPIEndpoint:    dvertiseAddress: 192.168.66.10 # 当前服务器节点地址kubernetesVersion: v1.15.1 # 修改为当前k8s版本networking:  podSubnet: &quot;10.244.0.0/16&quot; # 添加pod网段，修改到该网段（Flannel插件的默认网段）  serviceSubnet: 10.96.0.0/12#再在最后添加如下字段：---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationfeatureGates:  SupportIPVSProxyMode: truemode: ipvs # 将默认调度的方式改为ipvskubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | tee kubeadm-init.log # 指定初始化文件，并自动颁发证书（1.13后的k8s才用该功能，可以让其他子节点自动颁发证书），最后将所有信息都写入到kubeadm-init.log中（该步骤会下载镜像（可以通过再开一个shell输入docker images查看镜像下载情况），如果直接采用现成的打包好的镜像这一步会很快，具体方法详见下文）#加入主节点以及其余工作节点vim kubeadm-init.log #这一步可以通过找到安装日志kubeadm-init.log中的命令，执行即可（下面三个命令均为该文件中的）mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config#至此 kubectl 已经能够正常使用</code></pre><ul><li><p>初始化主节点中，若使用现有的镜像文件：</p><pre><code class="bash">  #解压压缩文件  tar -zxvf kubeadm-basic.images.tar.gz</code></pre></li><li><p>编写shell脚本load-image.sh一起倒入全部镜像：</p><pre><code class="bash">  #!/bin/bash  ls /root/kubeadm-basic.images &gt; /tmp/image-list.txt  cd /root/kubeadm-basic.images  for i in $( cat /tmp/image-list.txt )  do      docker load -i $i  done  rm -rf /tmp/image-list.txt</code></pre></li><li><p>执行脚本</p><pre><code class="bash">  chmod a+x load-image.sh  ./load-image.sh</code></pre></li><li><p>传给另外两台节点</p><pre><code class="bash">  #传给node01的家目录下  scp -r kubeadm-basic.images load-image.sh root@k8s-node01:/root/  #传给node02的家目录下  scp -r kubeadm-basic.images load-image.sh root@k8s-node02:/root/  #另外两台子节点分别执行脚本，导入image  ./load-image.sh</code></pre></li></ul><p>然后需要给master节点中的k8s网络装上Flannel网络插件，实现网络扁平化：</p><pre><code class="bash">kubectl get node # 查看节点信息 可以发现目前节点还是NotReady状态（还没有Flannel插件构建网络）#备份下重要配置文件mkdir -p install-k8s/coremv kubeadm-init.log kubeadm-config.yaml install-k8s/core # init日志和k8s初始化时的配置文件#子节点加入：从master节点的安装信息最后面可以获取到子节点加入的命令，在子节点上执行即可#部署网络（安装flannel插件，master节点）mkdir -p install-k8s/plugin/flannelcd install-k8s/plugin/flannelkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml # 通过网络部署#若不能通过上述命令，也可以直接打开网页另存为kube-flannel.yml或以下命令wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml &amp;&amp; kubectl create -f kube-flannel.yml # 根据.yml文件创建flannelkubectl get pod -n kube-system -w # 查看插件安装结果（获取kube-system命名空间的信息，不加-n参数默认是default空间，-w为watch，会一直监视）会发现一个NAME带flannel的组件（本文中为kube-flannel-ds-amd64-lkxfd，仅供参考）kubectl get node # 查看节点情况 等flannel组件初始化成功后，master节点应该是Ready状态#再次备份cd ~mv install-k8s/ /usr/local/rm -rf *</code></pre><p>其他节点的加入：</p><pre><code class="bash">#kubeadm-init.log文件中的最后几行会保存其他节点加入该网络的信息vim kubeadm-init.log # 最后移动到了/usr/local/install-k8s/core/kubeadm-init.log#本文中为以下加入命令，仅供参考：kubeadm join 192.168.199.10:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:46156bf0422bbca50c2588200c87c9d8d609b9eb5ac5d91c66a129703a0503f6</code></pre><ul><li><p>注意：默认<code>kubeadm join</code>命令默认的令牌<code>token</code>有效期为<u>24小时</u>，master节点可以通过如下命令对令牌进行操作（<a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/" target="_blank" rel="noopener">参考链接</a>）：</p><pre><code class="bash">  #创建一个引导令牌  kubeadm token create [token]  #参数：--ttl duration 默认值：24h0m0s 令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 &#39;0&#39;，令牌将永远不过期。  #删除指定的引导令牌  kubeadm token delete [token-value] ...  #列出所有的引导令牌  kubeadm token list</code></pre></li><li><p>node节点加入格式（<a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/" target="_blank" rel="noopener">参考链接</a>）：</p><pre><code class="bash">  kubeadm join 192.168.199.10:6443 --token 令牌 --discovery-token-ca-cert-hash sha256:46156bf0422bbca50c2588200c87c9d8d609b9eb5ac5d91c66a129703a0503f6（该值在master初始化时确定）</code></pre></li></ul><blockquote><p>安装过程中遇到的坑：<u>node节点安装好后一直加入不了master节点中的网络</u>，只输出以下信息：</p><pre><code class="bash">[preflight] Running pre-flight checks</code></pre><p>通过如下方法查询可能出现的问题：</p><pre><code class="bash">#在master节点上查看k8s网络上各个pod情况kubectl get pod -n kube-system</code></pre><p>发现两个coredns pod均不是Running状态，均为CrashLoopBackOff，大致找到问题所在，通过日志查看详细情况：</p><pre><code class="bash">kubectl logs coredns-5c98db65d4-ksqvt -n kube-system#输出如下E0318 09:27:20.034010       1 reflector.go:134] github.com/coredns/coredns/plugin/kubernetes/controller.go:322: Failed to list *v1.Namespace: Get https://10.96.0.1:443/api/v1/namespaces?limit=500&amp;resourceVersion=0: dial tcp 10.96.0.1:443: connect: no route to hostE0318 09:27:20.034010       1 reflector.go:134] github.com/coredns/coredns/plugin/kubernetes/controller.go:322: Failed to list *v1.Namespace: Get https://10.96.0.1:443/api/v1/namespaces?limit=500&amp;resourceVersion=0: dial tcp 10.96.0.1:443: connect: no route to hostlog: exiting because of error: log: cannot create log: open /tmp/coredns.coredns-5c98db65d4-ksqvt.unknownuser.log.ERROR.20200318-092720.1: no such file or directory</code></pre><p>发现是<code>k8s coredns connect: no route to host</code>问题，在github上查到<a href="https://github.com/kubernetes/minikube/issues/4350" target="_blank" rel="noopener">相关链接</a>发现是<strong>iptables没有刷新</strong>的问题，遂在<a href="https://github.com/kubernetes/kubeadm/issues/193" target="_blank" rel="noopener">该问题</a>下找打了答案：</p><pre><code class="bash">systemctl stop kubelet &amp;&amp; systemctl stop dockeriptables --flushiptables -tnat --flushsystemctl start kubelet &amp;&amp; systemctl start docker</code></pre><p>之后coredns pod一切正常node节点能够链接到master节点上。</p></blockquote><hr><h4 id="私有仓库Harbor搭建"><a href="#私有仓库Harbor搭建" class="headerlink" title="私有仓库Harbor搭建"></a>私有仓库Harbor搭建</h4><p>VMware创建私有镜像Harbor：2核心，2G RAM，100G单个文件。安装CentOS7，基本安装和上文中的节点类似这里不再叙述，值得一提的是该系统中Docker需要安装完毕IP配置为192.168.66.100且内核需要升级到4.4。</p><p>修改所有节点及私有仓库Harbor的docker配置文件：</p><pre><code class="bash">vim /etc/docker/daemon.json{  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: {    &quot;max-size&quot;: &quot;100m&quot;  }, # 注意这个逗号  &quot;insecure-registries&quot;: [&quot;https://hub.null.com&quot;] # 添加该行}#重启dockersystemctl restart docker</code></pre><ul><li><code>insecure-registries</code>：默认docker仓库是一个https的访问，需要一个https的证书，这里会在局域网内部制作一个假的证书，该证书对整个k8s集群来说会认为是一个危险的证书，需要通过该参数来将该域名对应的证书加到白名单中</li></ul><p>安装Harbor：</p><p>从<a href="https://github.com/vmware/harbor/releases" target="_blank" rel="noopener">Harbor的官方地址</a>下载压缩包，这里采用<code>harbor-offline-installer-v1.2.0.tgz</code></p><pre><code class="bash">#下载docker-composecurl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod a+x /usr/local/bin/docker-compose#安装Harbortar -zxvf harbor-offline-installer-v1.2.0.tgzmv harbor /usr/local/cd /usr/local/harborvim harbor.cfg # 编辑配置文件，具体参数如下hostname = hub.null.com # 修改为自己的域名，后面均需要该域名ui_url_protocol = httpsdb_password = root123max_job_workers = 3customize_crt = onssl_cert = /data/cert/server.crt # 需要创建该目录ssl_cert_key = /data/cert/server.keyharbor_admin_password = Harbor12345 # 进入后台的密码mkdir -p /data/certcd !$ # 进入刚刚创建的目录/data/cert#创建证书openssl genrsa -des3 -out server.key 2048 # 生成私钥（需要输入密码） 1234openssl req -new -key server.key -out server.csr # 根据该私钥创建证书（需要输入地点邮箱及域名，最后不需要修改密码和公司名字）cp server.key server.key.org # 备份私钥openssl rsa -in server.key.org -out server.key # 转换证书（主要是退掉密码，使私钥中不包含密码，不然docker中ngnix启动时会报错）openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt # 用该证书去签名并生成新的证书chmod a+x * # 将证书赋予可执行权限cd - # 回到刚刚的目录，即/usr/local/harbor./install.sh # 执行安装脚本</code></pre><ul><li><code>harbor.cfg</code>中的相关参数：<ul><li>hostname： 目标的主机名或者完全限定域名</li><li>ui_url_protocol： http或https。 默认为http</li><li>db_password： 用于db_auth的MySQL数据库的根密码。 更改此密码进行任何生产用途</li><li>max_job_workers： （默认值为3） 作业服务中的复制工作人员的最大数量。 对于每个映像复制作业，<br>  工作人员将存储库的所有标签同步到远程目标。 增加此数字允许系统中更多的并发复制作业。 但是， 由于每个工<br>  作人员都会消耗一定数量的网络/CPU/IO资源， 请根据主机的硬件资源， 仔细选择该属性的值</li><li>customize_crt： （on或off。 默认为on） 当此属性打开时， prepare脚本将为注册表的令牌的生成/验证创<br>  建私钥和根证书</li><li>ssl_cert： SSL证书的路径， 仅当协议设置为https时才应用</li><li>ssl_cert_key： SSL密钥的路径， 仅当协议设置为https时才应用</li><li>secretkey_path： 用于在复制策略中加密或解密远程注册表的密码的密钥路径  </li></ul></li></ul><p>收尾，修改各个节点的host</p><pre><code class="bash">echo &quot;192.168.66.100 hub.null.com&quot; &gt;&gt; /etc/hostscat /etc/hosts</code></pre><p>另外，如果需要Windows实体机访问虚拟机中的内容，需要修改Windows实体机中的host文件，host具体路径在：<code>C:\Windows\System32\drivers\etc\HOST</code>，到最后追加如下内容：</p><pre><code class="bash">192.168.66.100 hub.null.com</code></pre><p>打开Windows实体机中浏览器，进入网址hub.null.com即可进入harbor的后台（默认密码为admin，密码为Harbor12345）</p><h2 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h2><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><h4 id="k8s中的资源"><a href="#k8s中的资源" class="headerlink" title="k8s中的资源"></a>k8s中的资源</h4><p>K8s中所有的内容都抽象为资源，资源实例化之后，叫做对象</p><p>名称空间级别：尽在此名称空间下生效，如kube-system名称空间</p><ul><li>工作负载型资源（workload）：Pod、 ReplicaSet、 Deployment、 StatefulSet、 DaemonSet、Job、 CronJob（ Replication Controller在v1.11版本被废弃）</li><li>服务发现及负载均衡型资源（ ServiceDiscovery LoadBalance）：Service、 Ingress……</li><li>配置与存储型资源：Volume（存储卷）、CSI（容器存储接口，可以扩展各种各样的第三方存储卷）</li><li>特殊类型的存储卷：ConfigMap（当配置中心来使用的资源类型）、 Secret（保存敏感数据）、 DownwardAPI（把外部环境中的信息输出给容器）</li></ul><p>集群级别：Namespace、Node、Role、 ClusterRole、 RoleBinding、 ClusterRoleBinding</p><p>元数据级别：HPA、 PodTemplate、 LimitRange</p><h4 id="常用检测命令"><a href="#常用检测命令" class="headerlink" title="常用检测命令"></a>常用检测命令</h4><p>清理工作：</p><pre><code class="bash">#删除default命名空间下的所有podkubectl get podkubectl delete pod --all#删除对应服务kubectl get svckubectl delete svc 服务NAME#</code></pre><p>检测：</p><pre><code class="bash">#获取pod状态#-w：watch，一直监视#-o wide：显示ip等详细信息kubectl get pod#查看pod的详细信息kubectl describe pod pod的NAME#进入pod内部的容器#-c：指定那个容器，可以从yaml文件中获取，如果只有一个容器可以省略该参数 #-it -- 待运行命令：交互并打开一个tty并执行相应的命令#kubectl exec mypod -it -- /bin/shkubectl exec pod的NAME -c 指定容器名字 -it -- 待运行命令#查看pod对应的logkubectl log pod的NAME</code></pre><h4 id="资源清单yaml格式"><a href="#资源清单yaml格式" class="headerlink" title="资源清单yaml格式"></a>资源清单yaml格式</h4><p>在k8s中，一般使用yaml格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般称为资源清单</p><blockquote><p>yaml语法：</p><p>是一个可读性高，用来表达数据序列的格式。YAML的意思其实是：仍是一种标记语言，但为了强调这种语言以数居做为中心，而不是以标记语言为重点</p><p>规则：</p><ul><li>缩进时不允许使用Tab键，只允许使用空格</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>#标识注释，从这个宇符一直到行尾，都会被解释器忽略</li></ul><p>支持的数据结构：</p><ul><li><p>对象：键值对的集合，又称为映射（ mapping）/哈希（ hashes）/字典（ dictionary）</p><pre><code class="yaml">  name: Steve  age: 18  #Yaml也允许另一种写法,将所有键值对写成一个行内对象  hash: {name: Steve, age: 18}</code></pre></li><li><p>数组：一组按次序排列的值，又称为序列（ sequence）/列表（list）</p><pre><code class="yaml">  #一组连词线开头的行,构成一个数组  animal  - Cat  - Dog  #也可以采用行内表示法  animal: [Cat, Dog]</code></pre></li><li><p>复合结构：对象和数组可以结合使用，形成复合结构</p><pre><code class="yaml">  languages:  - Ruby  - Perl  - Python  websites:  YAML: yaml.org  Ruby: ruby-lang.org  Python: python.org  Perl: use.perl.org</code></pre></li><li><p>纯量（ scalars）：单个的、不可再分的值（字符串、布尔值、整数、浮点数、Null、时间、日期）</p><pre><code class="yaml">  # 数值直接以字面量的形式表示  number: 12.30  # 布尔值用true和 false表示  isSet: true  # null用 ~ 表示  parent: ~  # 时间采用ISO8601格式  iso8601: 2001-12-14t21:59:43.10-05:00  # 日期采用复合iso8601格式的年、月、日表示  date: 1976-07-31  # YAML允许使用两个感叹号,强制转换数据类型  e: !!str 123  f: !!str true</code></pre><ul><li><p>字符串相关说明：</p><pre><code class="yaml">  # 字符串默认不使用引号表示  str: 这是一行字符串  # 如果字符串之中包含空格或特殊字符,需要放在引号之中  str: &#39;内容: 字符串&#39;  # 单引号和双引号都可以使用,双引号不会对特殊字符转义  s1: &#39;内容\n字符串&#39;  s2: &quot;内容\n字符串&quot;  # 单引号之中如果还有单引号,必须连续使用两个单引号转义  str: &#39;labor&#39;&#39;s day&#39;  # 字符串可以写成多行,从第二行开始,必须有一个缩进,换行符会被转为 空格  str: 这是一段    多行    字符串  # 多行字符串可以使用|保留换行符,也可以使用&gt;折叠换行  this: |  Foo  Bar  that: &gt;  Foo  Bar  # +表示保留文字块末尾的换行,-表示删除字符串末尾的换行  s1: |    Foo  s2: |+    Foo  s3: |-    Foo</code></pre></li></ul></li></ul></blockquote><h4 id="常用字段解释说明"><a href="#常用字段解释说明" class="headerlink" title="常用字段解释说明"></a>常用字段解释说明</h4><p>必须存在的属性：</p><table><thead><tr><th align="center">参数名</th><th align="center">字段类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">version</td><td align="center">String</td><td align="center">指的是K8S APl的版本,目前基本上是v1,可以用<code>kubectl api-versions</code>命令查询</td></tr><tr><td align="center">kind</td><td align="center">String</td><td align="center">指的是yaml文件定义的资源类型和角色,比如:Pod</td></tr><tr><td align="center">metadata</td><td align="center">Object</td><td align="center">元数据对象,固定值就写metadata</td></tr><tr><td align="center">metadata.name</td><td align="center">String</td><td align="center">元数据对象的名字,这里由我们编写,比如命名Pod的名字</td></tr><tr><td align="center">metadata.namespace</td><td align="center">String</td><td align="center">元数据对象的命名空间,由我们自身定义(默认为default空间)</td></tr><tr><td align="center">Spec</td><td align="center">Object</td><td align="center">详细定义对象,固定值就写Spec</td></tr><tr><td align="center">spec.containers[]</td><td align="center">list</td><td align="center">Spec对象的容器列表定义,是个列表</td></tr><tr><td align="center">spec.containers[].name</td><td align="center">String</td><td align="center">定义容器的名字(可以不填，由系统随机)</td></tr><tr><td align="center">spec.containers[].image</td><td align="center">String</td><td align="center">定义要用到的镜像名称</td></tr></tbody></table><p>主要对象（可以不填）：</p><table><thead><tr><th align="center">参数名</th><th align="center">字段类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">spec.containers[].name</td><td align="center">String</td><td align="center">定义容器的名字(可以不填，由系统随机)</td></tr><tr><td align="center">spec.containers[].imagePullPollcy</td><td align="center">String</td><td align="center">定义镜像拉取策略,有 Always、 Never、IfNotPresent三个值可选(1) Always:意思是每次都尝试重新(从远程)拉取镜像(2) Never:表示仅使用本地镜像(3) IfNotPresent:如果本地有镜像就使用本地镜像,没有就拉取在线镜像.(默认是 Always)</td></tr><tr><td align="center">spec.containers[].command[]</td><td align="center">list</td><td align="center">指定容器启动命令,因为是数组可以指定多个,不指定则使用镜像打包时使用的启动命令</td></tr><tr><td align="center">spec.containers[].args[]</td><td align="center">list</td><td align="center">指定容器启动命令参数,因为是数组可以指定多个</td></tr><tr><td align="center">spec.containers[].workingDir</td><td align="center">String</td><td align="center">指定容器运行时所处的工作目录</td></tr><tr><td align="center">spec.containers[].volumeMounts[]</td><td align="center">List</td><td align="center">指定容器内部的存储卷配置</td></tr><tr><td align="center">spec containers[].volumeMounts[].name</td><td align="center">String</td><td align="center">指可以被容器挂载的存储卷的名称</td></tr><tr><td align="center">spec.containers[].volumeMounts[].mountPath</td><td align="center">String</td><td align="center">指定可以被容器挂载的存储卷的路径</td></tr><tr><td align="center">spec.containers[].volumeMounts[].readOnly</td><td align="center">String</td><td align="center">设置存储卷路径的读写模式,ture或者false默认为读写模式</td></tr><tr><td align="center">spec.containers[].ports[]</td><td align="center">List</td><td align="center">指定容器需要用到的端口列表</td></tr><tr><td align="center">spec.containets[].ports[].name</td><td align="center">String</td><td align="center">指定端口名称</td></tr><tr><td align="center">spec.containers[].ports[].containerPort</td><td align="center">String</td><td align="center">指定容器需要监听的端口号</td></tr><tr><td align="center">spec.containers[].ports[].hostPort</td><td align="center">String</td><td align="center">指定容器所在主机需要监听的端口号,默认跟上面 containerPort相同,注意设置了 hostPort,同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同,这样会冲突)</td></tr><tr><td align="center">spec.containers[].ports[].protocol</td><td align="center">String</td><td align="center">指定端口协议,支持TCP和UDP,默认值为TCP</td></tr><tr><td align="center">spec.containers[].env[]</td><td align="center">List</td><td align="center">指定容器运行前需设置的环境变量列表</td></tr><tr><td align="center">spec.containersl].env[].name</td><td align="center">String</td><td align="center">指定环境变量名称</td></tr><tr><td align="center">spec.containers[].env[].value</td><td align="center">String</td><td align="center">指定环境变量值</td></tr><tr><td align="center">spec.containers[].resources</td><td align="center">Object</td><td align="center">指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr><tr><td align="center">spec.containers[].resources.limits</td><td align="center">Object</td><td align="center">指定设置容器运行时资源的运行上限</td></tr><tr><td align="center">spec.containers[].resources.limits.cpu</td><td align="center">String</td><td align="center">指定CPU的限制，单位为core数，将用于<code>docker run --cpu-shares</code>参数（这里前面文章Pod资源限制有讲过)</td></tr><tr><td align="center">spec.containers[].resources.limits.memory</td><td align="center">String</td><td align="center">指定MEM内存的限制，单位为MIB、GiB</td></tr><tr><td align="center">spec.containers[].resources.requests</td><td align="center">Object</td><td align="center">指定容器启动和调度时的限制设置</td></tr><tr><td align="center">spec.containers[].resources.requests.cpu</td><td align="center">String</td><td align="center">CPU请求，单位为core数，容器启动时初始化可用数量</td></tr><tr><td align="center">spec.containers[].resources.requests.memory</td><td align="center">String</td><td align="center">内存请求，单位为MIB、GiB，容器启动的初始化可用数量</td></tr></tbody></table><p>额外的参数项：</p><table><thead><tr><th align="center">参数名</th><th align="center">字段类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">spec.restartPolicy</td><td align="center">String</td><td align="center">定义Pod的重启策略,可选值为 Always、 OnFailure,默认值为 Always. 1Always:pod一旦终止运行,则无论容器是如何终止的, kubelet服务都将重启它。2.OnFailure:只有pod以非零退出码终止时, kubelet会重启该容器。如果容器正常结束(退出码为0),则 kubelet将不会重启它 3. Never:pod终止后, kubeletMast将退出码报告给,不会重启该 Pod.</td></tr><tr><td align="center">spec.nodeSelector</td><td align="center">Object</td><td align="center">定义node的Label过滤标签,以key:value格式指定</td></tr><tr><td align="center">spec.imagePullSecrets</td><td align="center">Object</td><td align="center">定义pull镜像时secret使用名称,以 name:secretkey格式指定</td></tr><tr><td align="center">spec.hostNetwork</td><td align="center">Boolean</td><td align="center">定义是否使用主机网络模式,默认值为fase.设置true表示使用宿主机网络,不使用docker网桥,同时设置了true将无法在同一台宿主机上启动第二个副本。</td></tr></tbody></table><p>其他具体的可以通过如下命令查询：</p><pre><code class="bash">kubectl explain &lt;资源类型&gt;# eg:# kubectl explain pod# kubectl explain pod.apiVersion# kubectl explain rs</code></pre><p>最简单的模板：</p><pre><code class="yaml">apiVersion: v1kind: Pod # 这里名字需谨慎，必须为Pod 不能小写metadata:  name: mpapp-pod  namespace: default  labels:    app: mpapp    version: v1spec:  containers:  - name: app    image: xxxx:v1</code></pre><ul><li><p>编写后如果有错误，可以尝试从以下方面着手解决：</p><pre><code class="bash">  #查看pod内部信息  kubectl describe pod pod名字  # 查看对应报错容器日志（通过-c指定多个容器中的一个，若pod中只有一个容器则无需指定）  kubectl log pod名字 -c 容器名字</code></pre></li></ul><h3 id="容器生命周期"><a href="#容器生命周期" class="headerlink" title="容器生命周期"></a>容器生命周期</h3><p>pod的基本的生命周期如下所示：</p><p><img src="//NU-LL.github.io/2020/03/15/kubernetes/image-20200321225715567.png" alt="pod生命周期"></p><ul><li>kubectl先kubeapi发送调度指令，kubeapi会调度kubelet，整个调度过程中间由etcd在中间完成，包括存储及其他功能。</li><li>kubelet会操作CRI去完成容器的初始化</li><li>初始化过程中会先启动pause的基础容器，负责网络以及存储资源的共享</li><li>pause负责多个（或者0个）Init C（compose）的初始化<ul><li>Init C如果非正常退出（退出码为非0），会根据重启策略判断是否重新执行</li><li>这些Init C不是并行的</li></ul></li><li>Init C初始化完成后，会进入Main C（compose）中运行<ul><li>Main C在刚运行的时候，可以启动START脚本/命令，同样，在结束的时候也可以执行STOP脚本/命令</li><li>Main C的执行过程中会有readiness和Liveness的参与<ul><li>readiness可以根据配置在Main C开始执行的一定时间后启动，负责就绪检测，如果检测成功后Pod的状态会变成Running或Ready</li><li>Liveness可以根据配置在Main C开始执行的一定时间后启动，会伴随着Main C的整个生命周期，负责检测Main C中的进程，如果发现有不正常的现象，会根据重启策略执行诸如重启、删除pod等命令</li></ul></li></ul></li></ul><h4 id="Init-C"><a href="#Init-C" class="headerlink" title="Init C"></a>Init C</h4><p>Pod能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个先于应用容器启动的Init容器。Init容器与普通的容器非常像，除了如下两点：</p><ul><li>Init容器总是运行到成功完成为止</li><li>每个Init容器都必须在下一个Init容器启动之前成功完成</li></ul><p>如果Pod的Init容器失败， Kubernetes会不断地重启该Pod，直到Init容器成功为止。然而，如果Pod对应的 restartPolicy（重启策略）为 Never，它不会重新启动</p><p>因为Init容器具有与应用程序容器分离的单独镜像，所以它们具有如下优势：</p><ul><li>它们（Init容器）可以包含并运行实用工具，但是出于安全考虑，是不建议在应用程序容器镜像中包含这些实用工具的</li><li>它们（Init容器）可以包含使用工具和定制化代码来安装，但是不能出现在应用程序镜像中。例如，创建镜像没必要FROM另一个镜像，只需要在安装过程中使用类似sed、awk、 python或dig这样的工具</li><li>应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</li><li>Init容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret的权限，而应用程序容器则不能</li><li>它们（Init容器）必须在应用程序容器启动之前运行完成，而应用程序容器是并行运行的，所以Init容器能够提供了一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。</li></ul><p>Init C模板：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: myapp-pod # pod名字  labels:    app: myapp # pod标签spec:  containers: # pod中的容器  - name: myapp-container    image: busybox    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;] # 镜像启动时执行的命令，用于取代cmd的命令  initContainers: # Init C  - name: init-myservice # Init容器名字    image: busybox    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]  - name: init-mydb # Init容器名字    image: busybox    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#39;]</code></pre><p>想要上诉代码成功的通过Init C，需要有以下两个服务被创建：</p><pre><code class="yaml">kind: ServiceapiVersion: v1metadata:  name: myservicespec:  ports:    - protocol: TCP      port: 86      targetPort: 9376---kind: ServiceapiVersion: v1metadata:  name: mydbspec:  ports:    - protocol: TCP      port: 80      targetPort: 9377</code></pre><p>特殊说明：</p><ul><li>在Pod启动过程中，Init容器会按顺序在<strong>网络</strong>和<strong>数据卷</strong>初始化（这两个都是在pause中完成的）之后启动。每个容器必须在下一个容器启动之前成功退出</li><li>如果由于运行时或失败退出，将导致容器启动失败，它会根据Pod的 restartPolicy指定的策略进行重试。如果Pod的 restartPolicy设置为 Always，Init容器失败时会使用RestartPolicy策略（即重新初始化）</li><li>在所有的Init容器没有成功之前，Pod将不会变成 Ready状态。Init容器的端口将不会在Service中进行聚集。正在初始化中的Pod处于 Pending状态，但应该会将 Initializing状态设置为true</li><li>如果<strong>Pod重启</strong>，所有Init容器必须<strong>重新执行</strong></li><li>pod启动后，如果对Init容器spec的修改，范围会被限制在容器 image字段，修改其他字段都不会生效。更改Init容器的 Image字段，等价于重启该Pod</li><li>Init容器具有应用容器的所有字段，除了 readinessProbe字段（就绪检测）。因为Init容器无法定义不同于完成（ completion）的就绪（ readiness）之外的其他状态。</li><li>在Pod中的每个app和Init容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误</li><li>Init C中端口可以冲突</li></ul><h4 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h4><p>探针是由 kubelet对容器执行的定期诊断。要执行诊断， kubelet调用由容器实现的 Handler。Handler有三种类型的处理程序：</p><ul><li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功。</li><li>TCPSocketAction：对指定端口上的容器的IP地址进行TCP检查。如果端口打开，则诊断被认为是成功的。</li><li>HTTPGetAction：对指定的端口和路径上的容器的IP地址执行 Http Get请求。如果响应的状态码大于等于200且小于400，则诊断被认为是成功的</li></ul><p>每次探测都将获得以下三种结果之一</p><ul><li>成功：容器通过了诊断</li><li>失败：容器未通过诊断</li><li>未知：诊断失败，因此不会采取任何行动</li></ul><p>探测方法：</p><ul><li>livenessProbe：存活探测，指示容器是否正在运行。如果存活探测失败，则 kubelet会杀死容器（Main C），并且容器将受到其重启策略的影响。如果容器不提供存活探针，则默认状态为 Success</li><li>readinessProbe：就绪探测，指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与Pod匹配的所有 Service的端点中删除该Pod的IP地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success</li></ul><hr><p>例子1（readinessprobe-httpget）：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: readiness-httpget-pod  namespace: defaultspec:  containers:  - name: readiness-httpget-container    image: wangyanglinux/myapp:v1    imagePullPolicy: IfNotPresent # 镜像下载策略：如果有就不下载    readlinessProbe: # 就绪检测      httpGet: # 检测方案：gttpget方案        port: 80 # 端口        path: /index.html # 检测路径      initialDelaySeconds: 1 # 检测延时：容器启动后1s才开始检测      periodSeconds: 3 # 重试时间：3s</code></pre><p>例子2（livenessProbe-exec）：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: liveness-exec-pod  namespace: defaultspec:  containers:  - name: liveness-exec-container    image: null.com/library/busybox    imagePullPolicy: IfNotPresent    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/live; sleep 60; rm -rf /tmp/live; sleep 3600&quot;]    livenessProbe: # 存活检测      exec: # 检测方案：ExecAction方式        command: [&quot;test&quot;,&quot;-e&quot;,&quot;/tmp/live&quot;] # 运行的检测命令，返回值为0则正常      initialDelaySeconds: 1 # 检测延时：容器启动后1s才开始检测      periodSeconds: 3 # 重试时间：3s</code></pre><p>例子3（livenessProbe-httpget）：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: null.com/library/busybox:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    livenessProbe: # 存活检测      httpGet: # 检测方案：gttpget方案        port: http # 端口        path: /index.html # 检测路径      initialDelaySeconds: 1 # 检测延时：容器启动后1s才开始检测      periodSeconds: 3 # 重试时间：3s      timeoutSeconds: 10 # 最大超时时间</code></pre><p>例子4（livenessProbe-tcp）：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: probe-tcpspec:  containers:  - name: nginx    image: null.com/library/myapp:v1    livenessProbe: # 存活检测      tcpSocket: # 检测方案：TCPSocketAction方案        port: 8080 # 端口      initialDelaySeconds: 5 # 检测延时：容器启动后5s才开始检测      timeoutSeconds: 1 #最大超时时间      periodSeconds: 3 # 重试时间：3s</code></pre><h4 id="start、stop、相位"><a href="#start、stop、相位" class="headerlink" title="start、stop、相位"></a>start、stop、相位</h4><p>启动退出动作模板：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: lifecycle-demospec:  containers:  - name: lifecycle-demo-container    image: null.com/library/myapp:v1    lifecycle:      postStart: # start动作        exec:          command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo Hello from the poststart handler &gt; /usr/share/message&quot;]      postStop: # stop动作        exec:          command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo Hello from the poststop handler &gt; /usr/share/message&quot;]</code></pre><p>Pod的 status字段是一个 Podstatus对象， PodStatus中有一个 phase（<strong>相位</strong>）字段。该字段是Pod在其生命周期中的简单宏观概述。该阶段并不是对容器或Pod的综合汇总，也不是为了作为综合状态机。Pod相位的数量和含义是严格指定的。除了下面列举的状态外，不应该再假定Pod有其他的phase值：</p><ul><li>挂起（ Pending）：Pod已被 Kubernetes系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度Pod的时间和通过网络下载镜像的时间，这可能需要花点时间</li><li>运行中（ Running）：该Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态</li><li>成功（ Succeeded）：Pod中的所有容器都被<u>成功终止</u>（每个pod的退出码为0，即正常退出），并且不会再重启</li><li>失败（ Failed）：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止</li><li>未知（ Unknown）：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败</li></ul><h2 id="资源控制器"><a href="#资源控制器" class="headerlink" title="资源控制器"></a>资源控制器</h2><p>相关模板及帮助文档均可通过以下命令查询：</p><pre><code class="bash">kubectl explain &lt;资源类型&gt;# eg:# kubectl explain rs</code></pre><p>Pod 的分类：</p><ul><li>自主式 Pod：Pod 退出了，此类型的 Pod 不会被创建</li><li>控制器管理的 Pod：在控制器的生命周期里，始终要维持 Pod 的副本数目</li></ul><p>控制器：Kubernetes中内建了很多 controller（控制器），这些相当于一个状态机，用来控制Pod的具体状态和行为</p><p>控制器类型：</p><ul><li>ReplicationController和ReplicaSet</li><li>Deployment</li><li>DaemonSet</li><li>StateFulSet</li><li>Job/CronJob</li><li>Horizontal Pod Autoscaling</li></ul><h3 id="ReplicationController和ReplicaSet"><a href="#ReplicationController和ReplicaSet" class="headerlink" title="ReplicationController和ReplicaSet"></a>ReplicationController和ReplicaSet</h3><p>ReplicationController(RC)用来<strong>确保容器应用的副本数</strong>始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收；</p><p>在新版本的Kubernetes中建议使用ReplicaSet 来取代 ReplicationController。ReplicaSet跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet<u>支持集合式的selector</u>（通过标签控制）</p><p>模板：</p><pre><code class="yaml">apiVersion: extensions/v1beta1kind: ReplicaSetmetadata:  name: frontendspec:  replicas: 3  selector: # 这里确定RC控制的目标pod的标签    matchLabels:      tier: frontend  template: # 这里可以理解为嵌套了一个pod，其后在pod中的一些特性（如 init C等）这里均能够正常使用    metadata:      labels:        tier: frontend    spec:      containers:      - name: php-redis        image: gcr.io/google_samples/gb-frontend:v3        env:        - name: GET_HOSTS_FROM          value: dns        ports:        - containerPort: 80</code></pre><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment为Pod和Replicaset提供了一个声明式定义(declarative)方法，用来<strong>替代</strong>以前的<strong>ReplicationController</strong>来方便的管理应用。典型的应用场景包括；</p><blockquote><p>命令式编程：侧重于如何实现程序，就像我们刚接触编程的时候那样，我们需要把程序的实现过程按照逻辑结果一步步写下来</p><p>声明式编程：侧重于定义想要什么，然后告诉计算机/引擎，让他帮你去实现</p></blockquote><ul><li>通过定义Deployment来创建Pod和Replicaset（Deployment会创建ReplicaSet进而创建Pod）</li><li>滚动升级和回滚应用（会保留之前版本的ReplicaSet）</li><li>扩容和缩容</li><li>暂停和继续Deployment</li></ul><p>模板：</p><pre><code class="yaml">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-deploymentspec:  replicas: 3  template: # 这里可以理解为嵌套了一个pod，其后在pod中的一些特性（如 init C等）这里均能够正常使用    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.7.9        ports:        - containerPort: 80</code></pre><p>相关示例：</p><p>yaml文件为上述模板</p><pre><code class="bash">kubectl create -f nginx-deployment.yaml --record ##--record：记录命令，可以方便查看每次revision的变化kubectl get deploymentkubectl get rskubectl get pod -o wide#扩容kubectl scale deployment nginx-deployment(deployment名字) --replicas=10（扩容数量）kubectl get rs#会发现rs不会变，即模板信息不会变，即数目变化不会导致回滚#更新镜像kubectl get deploy -o wide # 查案版本信息kubectl set image deployment/nginx-deployment(deployment名字) nginx=nginx:1.9.1（容器名称=容器名称:升级后的版本号）kubectl get rs#rs改变，能够进行回滚操作#回滚（仅限回到上一次，再次回滚会又回来）kubectl get deploy -o wide # 查案版本信息kubectl rollout undo deployment/nginx-deployment(deployment名字)kubectl rollout undo deployment/nginx-deployment --to-revision=2 # 使用--to-revision参数退回到指定某个历史版本</code></pre><h4 id="细节知识"><a href="#细节知识" class="headerlink" title="细节知识"></a>细节知识</h4><p>Rollover</p><p>假如您创建了一个有5个<code>niginx:1.7.9</code> replica的 Deployment，但是当还只有3个<code>nginx:1.7.9</code>的 replica 创建出来的时候就开始更新含有5个 <code>nginx:1.9.1</code> replica 的 Deployment。在这种情况下，Deployment 会立即杀掉已创建的3个<code>nginx:1.7.9</code>的Pod，并开始创建<code>nginx:1.9.1</code>的 Pod。不会等到所有的5个<code>nginx:1.7.9</code>的Pod都创建完成后才开始改变航道</p><p>回退相关命令（接上述 相关示例 ）</p><pre><code class="bash">kubectl set image deployment/nginx-deployment nginx=nginx:1.91 # 更新镜像kubectl rollout status deployments/nginx-deployment # 查看当前更新状态（更新成功返回0）kubectl get podskubectl rollout history deployment/nginx-deployment # 查看历史版本（创建时加上--record这里会显示详细信息）kubectl rollout undo deployment/nginx-deployment # 回滚（仅限回到上一次，再次回滚会又回来）kubectl rollout undo deployment/nginx-deployment --to-revision=2 # 使用--to-revision参数退回到指定某个历史版本kubectl rollout pause deployment/nginx-deployment # 暂停deployment的更新kubectl rollout resume deployment/nginx-deployment # 恢复更新</code></pre><p>可以通过设置<code>.spec.revisonHistoryLimit</code>项来指定 deployment 最多保留多少 revision 历史记录。默认的会保留所有的 revision；如果将该项设置为0，Deployment 将不允许回退</p><h3 id="Daemonset"><a href="#Daemonset" class="headerlink" title="Daemonset"></a>Daemonset</h3><p>DaemonSet 确保<strong>全部（或者一些）</strong>Node上运行<strong>一个</strong>Pod的副本。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收。删除DaemonSet将会删除它创建的所有Pod。使用Daemonset的一些典型用法：</p><ul><li>运行集群存储daemon，例如在每个Node 上运行glusterd、ceph</li><li>在每个Node 上运行日志收集daemon，例如fluentd、logstash</li><li>在每个Node 上运行监控daemon，例如Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理，或Ganglia gmond</li></ul><p>实例：</p><pre><code class="yaml">apiVersion: apps/v1kind: DaemonSetmetadata:  name: deamonset-example # 必须和下面的matchLabels匹配成功，否则会不停创建  labels:    app: daemonsetspec:  selector: # 必须和上面的labels匹配成功，否则会不停创建    matchLabels:      name: deamonset-example  template: # pod模板    metadata:      labels:        name: deamonset-example    spec:      containers:      - name: daemonset-example        image: wangyanglinux/myapp:v1</code></pre><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job负责<strong>批处理任务</strong>，即仅执行一次的任务，它<strong>保证</strong>批处理任务的一个或多个Pod成功结束</p><h4 id="Job-Spec"><a href="#Job-Spec" class="headerlink" title="Job Spec"></a>Job Spec</h4><p><code>.spec.completions</code>标志Job结束需要成功运行的Pod个数，默认为1<br><code>.spec.parallelism</code>标志并行运行的Pod的个数，默认为1<br><code>.spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试</p><p>例子：</p><pre><code class="yaml">apiversion: batch/v1kind: Jobmetadata:  name: pispec:  template: # pod模板    metadata:      name: pi    spec:      containers: # pod中的容器      - name: pi        image: perl # 该镜像较大且国内下载慢        command: [&quot;perl&quot;， &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] # 运行该命令，计算pi后的2000位      restartPolicy: Never # 永不重启，这里仅支持Never和OnFailure</code></pre><p>命令：</p><pre><code class="bash">kubectl create -f xxxx.yamlkubectl get pod -o wide # 查看创建情况kubectl get job # 查看job控制器kubectl log # 查看日志，有pi后2000位输出</code></pre><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>CronJob管理<strong>基于时间</strong>的Job（与Deployment类似，本质是在特定的时间循环创建Job），即:</p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>使用前提条件：当前使用的Kubernetes集群版本&gt;= 1.8 (对CronJob)。</p><p>典型的用法如下所示：</p><ul><li>在给定的时间点调度Job运行</li><li>创建周期性运行的Job，例如：数据库备份、发送邮件</li></ul><h4 id="CronJob-Spec"><a href="#CronJob-Spec" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h4><p><code>.spec.schedule</code>:调度，必需字段，指定任务运行周期，格式同Cron<br><code>.spec.jobTemplate</code>:Job模板，必需字段，指定需要运行的任务，格式同Job<br><code>.spec.startingDeadlineSeconds</code>:启动Job的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的Job将被认为是失败的。如果没有指定，则没有期限<br><code>.spec.concurrencyPolicy</code>:并发策略，该字段也是可选的。它指定了如何处理被CronJob创建的Job的并发执行。只允许指定下面策略中的一种：</p><ul><li><p><code>Allow</code>(默认）：允许并发运行Job</p></li><li><p><code>Forbid</code>:禁止并发运行，如果前一个还没有完成，则直接跳过下一个</p></li><li><p><code>Replace</code>:取消当前正在运行的Job，用一个新的来替换</p><p>  注意，当前策略只能应用于同一个CronJob创建的Job。如果存在多个CronJob，它们创建的Job之间总是允许并发运行。</p></li></ul><p><code>.spec.suspend</code>:挂起，该字段也是可选的。如果设置为true，后续所有执行都会被挂起。它对已经开始执行的Job不起作用。默认值为false。<br><code>.spec.successfulJobsHistoryLimit</code>和<code>.spec.failedJobsHistoryLimit</code>:历史限制，是可选的字段。它们指定了可以保留多少完成和失败的Job。默认情况下，它们分别设置为3和1。设置限制的值为0，相关类型的Job完成后将不会被保留。</p><p>例子：</p><pre><code class="yaml"> apiversion: batch/v1beta1 kind: CronJob metadata:   name: hello spec:   schedule: &quot;*/1 * * * *&quot; # 分 时 日 月 周 （这里是每分钟）   jobTemplate:     spec:       template:         spec:           containers:           - name: hello             image: busybox             args:             - /bin/sh             - -C             - date; echo Hello from the Kubernetes cluster           restartPolicy: OnFailure #无失败则无重启</code></pre><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ol><li>创建Job操作应该是幂等的</li><li>成功与否并不太好去判断（但是Job可以判断）</li></ol><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>StatefulSet作为Controller 为Pod提供唯一的标识。 它可以保证部署和scale的顺序。StatefulSet是为了解决<strong>有状态服务</strong>的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括：</p><ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service (即没有Cluster IP的Service)来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行(即从0到N-1,在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态)，基于init containers来实现</li><li>有序收缩,有序删除(即从N-1到0)</li></ul><h3 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h3><p>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整？这就有赖于Horizontal Pod Autoscaling了，顾名思义，使Pod<strong>水平自动缩放</strong></p><p>HPA（Horizontal Pod Autoscaling）可以理解为是一个控制器的附属品，在选定其他控制器后再来确定是否需要HPA来管理选定的其他控制器。HPA可以根据K8s的一些资源指标（如CPU使用情况等）来对Pod进行水平缩放</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析与展示</title>
      <link href="/2020/03/10/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA/"/>
      <url>/2020/03/10/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Python数据分析与展示"><a href="#Python数据分析与展示" class="headerlink" title="Python数据分析与展示"></a>Python数据分析与展示</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Ipython"><a href="#Ipython" class="headerlink" title="Ipython"></a>Ipython</h3><p>Ipython是一个功能强大的交互式shell，适合进行交互式数据可视化和GUI相关应用</p><p>想要汉化可以参考这个github上的<a href="https://github.com/kingmo888/Spyder_Simplified_Chinese" target="_blank" rel="noopener">汉化链接</a></p><p><code>?</code>：变量名后跟<code>?</code>如：<code>a?</code>来获取变量相关的类型、值以及相关的描述信息。对于函数增加<code>?</code>能够获得函数的源代码</p><p><code>%run+python文件</code>命令：用于执行py文件，同时会生成一个新的空的命名空间（即，该程序内部需要包含足够的import变量）</p><p>其他相关的魔术命令：</p><table><thead><tr><th align="center">常用命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%magic</td><td align="center">显示所有魔术命令</td></tr><tr><td align="center">%hist</td><td align="center">IPython命令的输入历史</td></tr><tr><td align="center">%pdb</td><td align="center">异常发生后自动进入调试器</td></tr><tr><td align="center">%reset</td><td align="center">删除当前命名空间中的全部变量或名称</td></tr><tr><td align="center">%who</td><td align="center">显示lpython当前命名空间中已经定义的变量</td></tr><tr><td align="center">%time statement</td><td align="center">给出代码的执行时间，statement表示一段代码</td></tr><tr><td align="center">%timeit statement</td><td align="center">多次执行代码，计算综合平均执行时间</td></tr></tbody></table><p><a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="NumPy库"><a href="#NumPy库" class="headerlink" title="NumPy库"></a>NumPy库</h2><p>NumPy是一个开源的 Python科学计算基础库。</p><ul><li>一个强大的N维数组对象 ndarray</li><li>广播功能函数</li><li>整合C/C++/Fortran代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><p>NumPy是 SciPy、 Pandas等数据处理或科学计算库的基础。</p><p>引入：<code>import numpy as np</code></p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="数据的维度"><a href="#数据的维度" class="headerlink" title="数据的维度"></a>数据的维度</h4><p>维度：一组数据的组织形式</p><p>一维数据：一维数据由对等关系的有序或无序数据构成，采用线性方式组织。如：列表、数组（和列表一样，均表示一组数据的有序结构，与列表的区别如下）、集合等概念（对应python中的列表（有序）和集合（无序））</p><ul><li>列表：列表项的数据类型可以不同</li><li>数组：数据类型必须相同</li></ul><p>二维数据：二维数据由多个—维数据构成，是一维数据的组合式。如：表格（对应python中的列表）</p><p>多维数据：多维数据由一维或二维数据在新维度上扩展形成。（对应python中的多维列表）</p><p>高维数据：高维数据仅利用最基本的二元关系展示数据间的复杂结构（可以理解为由键值对将数据组织起来形成的数据方式）。如：json（对应python中的字典或数据表示格式（JSON、XML、YAML））</p><h4 id="数组对象：ndarray"><a href="#数组对象：ndarray" class="headerlink" title="数组对象：ndarray"></a>数组对象：ndarray</h4><p>ndarray是一个多维数组对象，由两部分构成：</p><ul><li>实际的数据</li><li>描逃这些数据的元数据（数据维度、数据类型等）</li></ul><p>ndarray数组<strong>一般</strong>要求所有元素类型相同（<strong>同质</strong>），数组下标从0开始。</p><p>ndarray在程序中的别名是：array</p><pre><code class="python"># 生成一个 ndarray数组a = np.array([[0,1,2,3,4],[9,8,7,6,5]])</code></pre><p>基本概念：</p><ul><li>轴（axis）：保存数据的维度</li><li>秩（rank）：轴的数量（即有多少个维度）</li></ul><p>基本属性：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.ndim</td><td align="center">秩，即轴的数量或维度的数量</td></tr><tr><td align="center">.shape</td><td align="center">ndarray对象的尺度，对于矩阵，n行m列</td></tr><tr><td align="center">.size</td><td align="center">ndarray对象元素的个数，相当于.shape中n*m的值</td></tr><tr><td align="center">.dtype</td><td align="center">ndarray对象的元素类型</td></tr><tr><td align="center">.itemsize</td><td align="center">ndarray对象中每个元素的大小，以字节为单位</td></tr></tbody></table><p>元素类型：</p><table><thead><tr><th align="center">数据类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">布尔类型，True或False</td></tr><tr><td align="center">intc</td><td align="center">与C语言中的int类型一致，一般是int32或int64</td></tr><tr><td align="center">intp</td><td align="center">用于索引的整数，与C语言中ssize_t一致，int32或int64</td></tr><tr><td align="center">int8</td><td align="center">字节长度的整数，取值：[-128，127]</td></tr><tr><td align="center">int16</td><td align="center">16位长度的整数，取值：[-32768，32767]</td></tr><tr><td align="center">int32</td><td align="center">32位长度的整数，取值：[-2^31^，2^31^-1]</td></tr><tr><td align="center">int64</td><td align="center">64位长度的整数，取值：[-2^63^，2^63^-1]</td></tr><tr><td align="center">uint8</td><td align="center">8位无符号整数，取值：[0，255]</td></tr><tr><td align="center">uint16</td><td align="center">16位无符号整数，取值：[0,65535]</td></tr><tr><td align="center">uint32</td><td align="center">32位无符号整数，取值：[0，2^32^-1]</td></tr><tr><td align="center">uint64</td><td align="center">64位无符号整数，取值：[0，2^64^-1]</td></tr><tr><td align="center">float16</td><td align="center">16位半精度浮点数：1位符号位，5位指数，10位尾数</td></tr><tr><td align="center">float32</td><td align="center">32位半精度浮点数：1位符号位，8位指数，23位尾数</td></tr><tr><td align="center">float64</td><td align="center">64位半精度浮点数：1位符号位，11位指数，52位尾数</td></tr><tr><td align="center">complex64</td><td align="center">复数类型，实部和虚部都是32位浮点数</td></tr><tr><td align="center">complex128</td><td align="center">复数类型，实部和虚部都是64位浮点数</td></tr></tbody></table><p>ndarray数组可以由<strong>非同质</strong>对象构成。非同质 ndarray元素为<strong>对象类型</strong>。非同质 ndarray对象无法有效发挥 NumPy优势，尽量避免使用。（当元素的类型并不相同或每一个元素的维度数据并不相同的时候，会将每个元素认为一个对象，将该对象认为同质的数据类型）</p><pre><code class="python">#同质&gt;&gt;&gt; a = np.array([[0,1,2,3,4],[9,8,7,6,5]])&gt;&gt;&gt; a.shape(2, 5)&gt;&gt;&gt; a.dtypedtype(&#39;int32&#39;)&gt;&gt;&gt; aarray([[0, 1, 2, 3, 4],       [9, 8, 7, 6, 5]])&gt;&gt;&gt; a.itemsize4&gt;&gt;&gt; a.size10#非同质&gt;&gt;&gt; a = np.array([[0,1,2,3,4],[9,8,7,6]])&gt;&gt;&gt; a.shape(2,)&gt;&gt;&gt; a.dtypedtype(&#39;O&#39;)&gt;&gt;&gt; aarray([list([0, 1, 2, 3, 4]), list([9, 8, 7, 6])], dtype=object)&gt;&gt;&gt; a.itemsize8&gt;&gt;&gt; a.size2</code></pre><h4 id="创建和变换"><a href="#创建和变换" class="headerlink" title="创建和变换"></a>创建和变换</h4><p>创建方法：</p><ul><li><p>从 Python中的列表、元组等类型创建 ndarray数组。</p><pre><code class="python">x = np.array(list/tuple)x = np.array(list/tuple, dtype=np.float32)#指定类型</code></pre><ul><li>当np. array()不指定 dtype时， NumPy将根据数据情况关联一个 dtype类型</li><li>只要元组和列表包含的数据个数和类型相同，就可以混合使用</li></ul></li><li><p>使用 NumPy中函数创建 ndarray数组，如：arange, ones, zeros等。</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">np.arange(n)</td><td align="center">类似range()函数，返回ndarray类型，元素从0到n-1，<strong>整数</strong>类型</td></tr><tr><td align="center">np.ones(shape)</td><td align="center">根据shape生成一个 全1数组，shape是元组类型，浮点数类型</td></tr><tr><td align="center">np.zeros(shape)</td><td align="center">根据shape生成一 个 全0数组，shape是元组类型，浮点数类型</td></tr><tr><td align="center">np.full(shape,val)</td><td align="center">根据shape生成一个数组， 每个元素值都是val，类型为val的类型</td></tr><tr><td align="center">np.eye(n)</td><td align="center">创建一个 正方的n*n单位矩阵，对角线为1，其余为0，浮点数类型</td></tr><tr><td align="center">np.ones_like(a)</td><td align="center">根据数组a的形状生成一个全1数组</td></tr><tr><td align="center">np.zeros_like(a)</td><td align="center">根据数组a的形状生成一个全0数组</td></tr><tr><td align="center">np.full_like(a,val)</td><td align="center">根据数组a的形状生成一个数组，每个元素值都是val</td></tr><tr><td align="center">np.linspace()</td><td align="center">根据起止数据等间距地填充数据，形成数组，浮点数类型</td></tr><tr><td align="center">np.coucatenate()</td><td align="center">将两个或多个数组合井成一个新的数组</td></tr></tbody></table><p>例子：</p><pre><code class="python">&gt;&gt;&gt; np.array(10)array(10)&gt;&gt;&gt; np.ones((3,6))array([[1., 1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1., 1.]])&gt;&gt;&gt; np.zeros((3,6), dtype=np.int32)array([[0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0],       [0, 0, 0, 0, 0, 0]])&gt;&gt;&gt; np.eye(5)array([[1., 0., 0., 0., 0.],       [0., 1., 0., 0., 0.],       [0., 0., 1., 0., 0.],       [0., 0., 0., 1., 0.],       [0., 0., 0., 0., 1.]])&gt;&gt;&gt; np.ones((2,3,4))array([[[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]],       [[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]]])&gt;&gt;&gt; x = np.ones((2,3,4))&gt;&gt;&gt; x.shape(2, 3, 4)&gt;&gt;&gt; np.linspace(1,10,4) #起始1 末尾10 4个元素array([ 1.,  4.,  7., 10.])&gt;&gt;&gt; np.linspace(1,10,4,endpoint=False) #最后一个元素10是否为4个元素中的一个array([1.  , 3.25, 5.5 , 7.75])&gt;&gt;&gt; a = np.linspace(1,10,4)&gt;&gt;&gt; b = np.linspace(1,10,4,endpoint=False)&gt;&gt;&gt; np.concatenate((a,b))array([ 1.  ,  4.  ,  7.  , 10.  ,  1.  ,  3.25,  5.5 ,  7.75])</code></pre></li><li><p>从字节流（ raw bytes）中创建 ndarray数组。</p></li><li><p>从文件中读取特定格式，创建 ndarray数组。</p></li></ul><p>变换：</p><p>维度变换</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.reshape(shape)</td><td align="center">不改变数组元素,返回一个 shape形状的数组,原数组不变</td></tr><tr><td align="center">.resize(shape)</td><td align="center">与.reshape()功能一致,但修改返回的数组时会改变原数组</td></tr><tr><td align="center">.swapaxes(ax1,ax2)</td><td align="center">将数组n个维度中两个维度进行调换</td></tr><tr><td align="center">.flatten()</td><td align="center">对数组进行降维,返回折叠后的一维数组,原数组不变</td></tr></tbody></table><p>类型变换</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.astype(new_type)</td><td align="center">改变数据中元素的类型,原数组不变</td></tr><tr><td align="center">.tolist()</td><td align="center">将ndarray数组转化为list</td></tr></tbody></table><h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><p>索引：获取数组中特定位置元素的过程</p><p>切片：获取数组元素子集的过程</p><p>一维数组的索引和切片：与 Python的列表类似</p><pre><code class="python">&gt;&gt;&gt; a = np.array([9,8,7,6,5])&gt;&gt;&gt; a[2]7&gt;&gt;&gt; a[1:4:2] #[1,4)号元素，不包含4，步长为2array([8, 6])</code></pre><p>多维数组的索引和切片：</p><pre><code class="python"># 索引&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))&gt;&gt;&gt; aarray([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]])&gt;&gt;&gt; a[1,2,3]23&gt;&gt;&gt; a[0,1,2]6&gt;&gt;&gt; a[-1,-2,-3]17# 切片&gt;&gt;&gt; a[:,1,-3] # 每个维度的切片方法与一位数组相同array([ 5, 17])&gt;&gt;&gt; a[:,1:3,:]array([[[ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[16, 17, 18, 19],        [20, 21, 22, 23]]])&gt;&gt;&gt; a[:,:,::2]array([[[ 0,  2],        [ 4,  6],        [ 8, 10]],       [[12, 14],        [16, 18],        [20, 22]]])</code></pre><h4 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h4><p>数组与标量（一个数据）之间的运算等价于数组中的每一个元素都与这个标量进行运算</p><p>例子：</p><pre><code class="python">&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))&gt;&gt;&gt; aarray([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]])&gt;&gt;&gt; a.mean()11.5&gt;&gt;&gt; a/a.mean()array([[[0.        , 0.08695652, 0.17391304, 0.26086957],        [0.34782609, 0.43478261, 0.52173913, 0.60869565],        [0.69565217, 0.7826087 , 0.86956522, 0.95652174]],       [[1.04347826, 1.13043478, 1.2173913 , 1.30434783],        [1.39130435, 1.47826087, 1.56521739, 1.65217391],        [1.73913043, 1.82608696, 1.91304348, 2.        ]]])</code></pre><p>相关函数（均为对数组中的<strong>各个元素</strong>进行操作，且均为新生成的数组，<strong>不改变</strong>原始数组）：</p><p>一元函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">np.abs(x)、np.fabs(x)</td><td align="center">计算数组各元素的绝对值</td></tr><tr><td align="center">np.sqrt()</td><td align="center">计算数组各元素的平方根</td></tr><tr><td align="center">np.square(x)</td><td align="center">计算数组各元素的平方</td></tr><tr><td align="center">np.log(x)、np.log10(x)、np.log2(x)</td><td align="center">计算数组各元素的自然对数、10底对数和2底对数</td></tr><tr><td align="center">np.ceil(x)、np.floor(x)</td><td align="center">计算数组各元素的 ceiling值（向上取整）或floor值（向下取整）</td></tr><tr><td align="center">np.rint(x)</td><td align="center">计算数组各元素的四舍五入值</td></tr><tr><td align="center">np.modf(x)</td><td align="center">将数组各元素的小数和整数部分以两个独立数组形式返回</td></tr><tr><td align="center">np. cos(x)、np.cosh(x)、np.sin(x)、np.sinh(x)、np.tan(x)、np.tanh(x)</td><td align="center">计算数组各元素的普通型和双曲型三角函数</td></tr><tr><td align="center">np.exp(x)</td><td align="center">计算数组各元素的指数值</td></tr><tr><td align="center">np.sign(x)</td><td align="center">计算数组各元素的符号值,1(+),0,-1(-)</td></tr></tbody></table><p>二元函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">+、-、<em>、/、*</em></td><td align="center">两个数组各元素进行对应运算</td></tr><tr><td align="center">np.maximum(x,y)、np.fmax()、np. minimum(x,y)、np.fmin()</td><td align="center">元素级的最大值/最小值计算</td></tr><tr><td align="center">np.mod(x,y)</td><td align="center">元素级的模运算</td></tr><tr><td align="center">np. copysign(x,y)</td><td align="center">将数组y中各元素值的符号赋值给数组x对应元素</td></tr><tr><td align="center">&gt;、&lt;、&gt;=、&lt;=、==、!=</td><td align="center">算术比较,产生布尔型数组</td></tr></tbody></table><h3 id="数据存取与函数"><a href="#数据存取与函数" class="headerlink" title="数据存取与函数"></a>数据存取与函数</h3><h4 id="CSV文件存取"><a href="#CSV文件存取" class="headerlink" title="CSV文件存取"></a>CSV文件存取</h4><p>CSV（ Comma-Separated value，逗号分隔值）是—种常见的文件格式，用来存储批量数据。（CSV文件只能用来保存一维二维数组）</p><p>将数据写入csv文件：</p><pre><code class="python">np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimeter=None)</code></pre><ul><li>frame：文件、字符串或产生器，可以是.gz或.bz2的压缩文件。</li><li>array：存入文件的数组。</li><li>fmt：写人文件的格式，例如：%d、%.2f、%.18e。</li><li>delimiter：分割字符串，默认是空格（csv文件中是逗号<code>,</code>）</li></ul><p>读取csv文件中的数据：</p><pre><code class="python">np.loadtxt(frame, dtype=np.float, delimeter=None, unpack=False)</code></pre><ul><li>frame：文件、字符串或产生器，可以是.gz或.bz2的压缩文件。</li><li>dtype：数据类型，可选。</li><li>delimiter：分割字符串，默认是空格（csv文件中是逗号<code>,</code>）</li><li>unpack：如果True，读入属性将分别写入不同变量</li></ul><h4 id="多维数据的存取"><a href="#多维数据的存取" class="headerlink" title="多维数据的存取"></a>多维数据的存取</h4><p>存储：</p><pre><code class="python">a.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></pre><ul><li>frame：文件、字符串</li><li>sep：数据分割字符串，如果是空串，写入文件为二进制。</li><li>format：写人数据的格式</li></ul><p>注意：将数组写入文件后，其中的<strong>维度信息会丢失</strong>，可以利用reshape方法：<code>np.fromfile().reshape()</code>在读取的时候还原维度信息，但是需要之前数组的维度信息</p><p>读取：</p><pre><code class="python">a.fromfile(frame, dtype=float, count=-1, sep=&#39;&#39;)</code></pre><ul><li>frame：文件、字符串</li><li>dtype：读取的数据类型。</li><li>count：读入元素个数，-1表示读入整个文件。</li><li>sep：数据分割字符串，如果是空串，写入文件为二进制。</li></ul><blockquote><p>例子：</p><pre><code class="python">&gt;&gt;&gt; a = np.arange(100).reshape(5, 10, 2)&gt;&gt;&gt; a.tofile(&quot;b.dat&quot;, format=&#39;%d&#39;)&gt;&gt;&gt; c = np.fromfile(&quot;b.dat&quot;, dtype=np.int).reshape(5, 10, 2)</code></pre></blockquote><p>注意：该方法需要读取时知道存入文件时数组的维度和元素类型，a.tofile()和 np.fromfile()需要配合使用。为解决上述维度丢失的情况，可以通过元数据文件来存储额外信息</p><h4 id="Numpy便捷文件存储"><a href="#Numpy便捷文件存储" class="headerlink" title="Numpy便捷文件存储"></a>Numpy便捷文件存储</h4><p>该方法可以解决上述方法的维度丢失情况</p><p>存储：</p><pre><code class="python">np.save(fname, array)np.savez(fname, array)</code></pre><ul><li>frame：文件名，以.npy为扩展名，压缩扩展名为.npz<ul><li>save方法存为.npy文件，savez方法存为压缩文件.npz</li></ul></li><li>array：数组变量</li></ul><p>读取：</p><pre><code class="python">a.load(fname)</code></pre><ul><li>frame：文件名，以.npy为扩展名，压缩扩展名为.npz</li></ul><h4 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h4><p>python中提供random库可以使用随机数，但是只能生成一般的随机数，Numpy中提供random字库提供numpy中的随机数，基本格式为<code>np.random.*</code>，<code>*</code>为random库中提供的函数，具体有：</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">rand(d0,d1,…,dn)</td><td align="center">根据d0-dn（视为shape信息）创建随机数数组，浮点数，[0,1)， 均匀分布</td></tr><tr><td align="center">randn(d0,d1,…,dn)</td><td align="center">根据d0-dn（即视为shape信息）创建随机数数组，标准正态分布</td></tr><tr><td align="center">randint(low[,high,shape])</td><td align="center">根据shape创建随机整数或整数数组，范围是[low, high)</td></tr><tr><td align="center">seed(s)</td><td align="center">随机数种子，s是给定的种子值</td></tr><tr><td align="center">shuffle(a)</td><td align="center">根据数组a的第1轴（最外层维度的元素）进行随排列，会改变数组a</td></tr><tr><td align="center">permutation(a)</td><td align="center">根据数组a的第1轴（最外层维度的元素）产生一个新的乱序数组，不改变数组a</td></tr><tr><td align="center">choice(a[,size, replace,p])</td><td align="center">从一维数组a中以概率p抽取元素，形成size形状新数组，replace表示是否可以重用元素，默认为 False</td></tr><tr><td align="center">uniform(low,high,size)</td><td align="center">产生具有均匀分布的数组，low起始值，high结束值，size形状</td></tr><tr><td align="center">normal(locc, scale,size)</td><td align="center">产生具有正态分布的数组，loc均值，scale标准差，size形状</td></tr><tr><td align="center">poisson(lam,size)</td><td align="center">产生具有泊松分布的数组，lam随机事件发生率，size形状</td></tr></tbody></table><p>例子：</p><pre><code class="python">&gt;&gt;&gt; a = np.random.randint(100, 200, (3,4))&gt;&gt;&gt; aarray([[121, 114, 100, 112],       [155, 183, 137, 177],       [131, 189, 158, 101]])&gt;&gt;&gt; np.random.shuffle(a)&gt;&gt;&gt; aarray([[155, 183, 137, 177],       [121, 114, 100, 112],       [131, 189, 158, 101]])&gt;&gt;&gt; np.random.shuffle(a)&gt;&gt;&gt; aarray([[131, 189, 158, 101],       [155, 183, 137, 177],       [121, 114, 100, 112]])</code></pre><h4 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h4><p>基本格式为<code>np.*</code>，<code>*</code>为random库中提供的函数，具体有：</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">sum(a, axis=None)</td><td align="center">根据给定轴axis计算数组a相关元素之和，axis整数或元组</td></tr><tr><td align="center">mean(a, axis=None)</td><td align="center">根据给定轴axis计算数组a相关元素的期望，axis整数或元组</td></tr><tr><td align="center">average(a,axis=None, weights=None)</td><td align="center">根据给定轴axis计算数组a相关元素的加权平均值，weights为每个元素的权重</td></tr><tr><td align="center">std(a, axis=None)</td><td align="center">根据给定轴axis计算数组a相关元素的标准差</td></tr><tr><td align="center">var(a, axis=None)</td><td align="center">根据给定轴axis计算数组a相关元素的方差</td></tr><tr><td align="center">min(a) max(a)</td><td align="center">计算数组a中元素的最小值、最大值</td></tr><tr><td align="center">argmin(a) argmax(a)</td><td align="center">计算数组a中元素最小值、最大值的降一维后下标</td></tr><tr><td align="center">unravel_index(index, shape)</td><td align="center">根据shape将一维下标index转换成多维下标</td></tr><tr><td align="center">ptp(a)</td><td align="center">计算数组a中元素最大值与最小值的差</td></tr><tr><td align="center">median(a)</td><td align="center">计算数组a中元素的中位数(中值)</td></tr></tbody></table><ul><li>axis=None即所有轴</li></ul><p>例子1：</p><pre><code class="python">&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)&gt;&gt;&gt; aarray([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])&gt;&gt;&gt; np.sum(a)105&gt;&gt;&gt; np.mean(a, axis=1)array([ 2.,  7., 12.])&gt;&gt;&gt; np.mean(a, axis=0)array([5., 6., 7., 8., 9.])&gt;&gt;&gt; np.average(a, axis=0, weights=[10, 5, 1])array([2.1875, 3.1875, 4.1875, 5.1875, 6.1875])# 4.1875=(2*10+7*5+1*12)/(10+5+1)</code></pre><p>例子2：</p><pre><code class="python">&gt;&gt;&gt; b = np.arange(15,0,-1).reshape(3, 5)&gt;&gt;&gt; barray([[15, 14, 13, 12, 11],       [10,  9,  8,  7,  6],       [ 5,  4,  3,  2,  1]])&gt;&gt;&gt; np.argmax(b) # 扁平化后的下标0&gt;&gt;&gt; np.unravel_index(np.argmax(b), b.shape) # 重塑成多维下标(0, 0)&gt;&gt;&gt; np.ptp(b)14</code></pre><h4 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数"></a>梯度函数</h4><p>梯度：连续值之间的变化率，即斜率。具体来说，XY坐标轴连续三个X坐标对应的Y轴值：a,b,c，其中，b的梯度是：<code>(c-a)/2</code></p><p>numpy中梯度函数只有一个：</p><pre><code class="python">np.gradient(f)</code></pre><ul><li>计算数组f中元素的梯度，当f为多维时，返回每个维度梯度</li></ul><p>例子：</p><pre><code class="python">#一维数组&gt;&gt;&gt; a = np.random.randint(0, 20, (5))&gt;&gt;&gt; aarray([ 6, 11, 18,  2,  6])&gt;&gt;&gt; np.gradient(a)#第二个返回值6=(18-6)/2 最后一个返回值4=(6-2)/1array([ 5. ,  6. , -4.5, -6. ,  4. ])#二维数组&gt;&gt;&gt; a = np.random.randint(0, 50, (3, 5))&gt;&gt;&gt; aarray([[42,  5,  0, 21, 16],       [ 7, 40, 17, 31, 18],       [41, 22,  1,  2, 14]])&gt;&gt;&gt; np.gradient(a)#二维数组中的任何一个元素的梯度存在两个方向[array([[-35. ,  35. ,  17. ,  10. ,   2. ],# 最外层维度的梯度       [ -0.5,   8.5,   0.5,  -9.5,  -1. ],       [ 34. , -18. , -16. , -29. ,  -4. ]]), array([[-37. , -21. ,   8. ,   8. ,  -5. ],# 最第二层维度的梯度       [ 33. ,   5. ,  -4.5,   0.5, -13. ],       [-19. , -20. , -10. ,   6.5,  12. ]])]</code></pre><ul><li>若一个n维数组，经过gradient求梯度后会生成n个数组，每个数组代表原始的n维数组中一个元素在第n维度的梯度值</li></ul><h3 id="图像手绘效果"><a href="#图像手绘效果" class="headerlink" title="图像手绘效果"></a>图像手绘效果</h3><pre><code class="python">from PIL import Imageimport numpy as npa = np.asarray(Image.open(&#39;D:/pycodes/beijing.jpg&#39;).convert(&#39;L&#39;)).astype(&#39;float&#39;)depth = 10 # (0-100)grad = np.gradient(a) # 取图像灰度的梯度值grad_x, grad_y = grad # 分别取横纵图像梯度值grad_x = grad_x*depth/100.grad_y = grad_y*depth/100.A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x/Auni_y = grad_y/Auni_z = 1./Avec_el = np.pi/2.2 # 光源的俯视角度,弧度值vec_az = np.pi/4. # 光源的方位角度,弧度值dx = np.cos(vec_el)*np.cos(vec_az) # 光源对x轴的影响dy = np.cos(vec_el)*np.sin(vec_az) # 光源对y轴的影响dz = np.sin(vec_el) # 光源对z轴的影响b = 255*(dx*uni_x + dy*uni_y + dz*uni_z) # 光源归一化b = b.clip(0, 255)im = Image.fromarray(b.astype(&quot;uint8&quot;)) # 重构图像im.save(&#39;D:/pycodes/beijingHD.jpg&#39;)</code></pre><h2 id="Matplotlib库"><a href="#Matplotlib库" class="headerlink" title="Matplotlib库"></a>Matplotlib库</h2><p>Matplotlib是Python优秀的数据可视化第三方库，由各种可视化类构成，内部结构复杂。</p><p><code>matplotlib.pyplot</code>是绘制各类可视化图形的命令子库，相当于快捷方式。所以基本上只会对该子库进行操作</p><p>引入：<code>import matplotlib.pyplot as plt</code></p><h3 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h3><h4 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h4><p>基本绘图函数</p><pre><code class="python">plt.plot(x, y, format_string, **kwargs)</code></pre><ul><li><p>x：X轴数据，列表或数组，可选。</p></li><li><p>y：Y轴数据，列表或数组。</p></li><li><p>format_string：控制曲线的格式字符串，可选。由颜色字符、风格字符和标记字符组成</p><ul><li><p>常用颜色字符：</p><table><thead><tr><th align="center">颜色字符</th><th align="center">说明</th><th align="center">颜色字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">‘b’</td><td align="center">蓝色</td><td align="center">‘m’</td><td align="center">洋红色 magenta</td></tr><tr><td align="center">‘g’</td><td align="center">绿色</td><td align="center">‘y’</td><td align="center">黄色</td></tr><tr><td align="center">‘r’</td><td align="center">红色</td><td align="center">‘k’</td><td align="center">黑色</td></tr><tr><td align="center">‘c’</td><td align="center">青绿色 cyan</td><td align="center">‘w’</td><td align="center">白色</td></tr><tr><td align="center">‘#008000’</td><td align="center">RGB某颜色</td><td align="center">‘0.8’</td><td align="center">灰度值字符串</td></tr></tbody></table></li><li><p>风格字符：</p><table><thead><tr><th align="center">风格字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">‘-‘</td><td align="center">实线</td></tr><tr><td align="center">‘–’</td><td align="center">破折线</td></tr><tr><td align="center">‘-.’</td><td align="center">点划线</td></tr><tr><td align="center">‘:’</td><td align="center">虚线</td></tr><tr><td align="center">‘’（空）或者’ ‘（空格）</td><td align="center">无线条</td></tr></tbody></table></li><li><p>常用标记字符：</p><table><thead><tr><th align="center">标记字符</th><th align="center">说明</th><th align="center">标记字符</th><th align="center">说明</th><th align="center">标记字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">‘.’</td><td align="center">点标记</td><td align="center">‘1’</td><td align="center">下花三角标记</td><td align="center">‘h’</td><td align="center">竖六边形标记</td></tr><tr><td align="center">‘,’</td><td align="center">像素标记（极小点）</td><td align="center">‘2’</td><td align="center">上花三角标记</td><td align="center">‘H’</td><td align="center">横六边形标记</td></tr><tr><td align="center">‘o’</td><td align="center">实心圈标记</td><td align="center">‘3’</td><td align="center">左花三角标记</td><td align="center">‘+’</td><td align="center">十字标记</td></tr><tr><td align="center">‘v’</td><td align="center">倒三角标记</td><td align="center">‘4’</td><td align="center">右花三角标记</td><td align="center">‘x’</td><td align="center">x标记</td></tr><tr><td align="center">‘^’</td><td align="center">上三角标记</td><td align="center">‘s’</td><td align="center">实心方角标记</td><td align="center">‘D’</td><td align="center">菱形标记</td></tr><tr><td align="center">‘&gt;’</td><td align="center">右三角标记</td><td align="center">‘p’</td><td align="center">实心五角标记</td><td align="center">‘d’</td><td align="center">瘦菱形标记</td></tr><tr><td align="center">‘&lt;’</td><td align="center">左三角标记</td><td align="center">‘*’</td><td align="center">星形标记</td><td align="center">‘|’</td><td align="center">垂直线标记</td></tr></tbody></table></li></ul></li><li><p>kwargs：第二组或更多（x,y,format_string）</p><ul><li>当绘制多条曲线时，各条曲线的不能省略</li><li>color：控制颜色， color=’green’</li><li>linestyle：线条风格， linestyle=’dashed’</li><li>marker：标记风格， marker=’o’</li><li>markerfacecolor：标记颜色， markerfacecolor=’blue’</li><li>markersize：标记尺寸， markersize=20</li></ul></li></ul><h4 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h4><p>pyplot默认不支持中文显示，可以通过以下两种方式设置：</p><p>一、使用rcParams属性改变pyplot全局字体</p><pre><code class="python">import matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39; # &#39;SimHei&#39;黑体，只需要支持中文即可plt.plot([3, 1, 4, 5, 2])plt.ylabel(&quot;纵轴（值）&quot;)plt.savefig(&#39;test&#39;, dpi=600) # 保存图像plt.show()</code></pre><ul><li><p>rcParams常用属性说明：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">‘font.family’</td><td align="center">用于显示字体的名字</td></tr><tr><td align="center">‘font.style’</td><td align="center">字体风格，正常’normal’或斜体’italic’</td></tr><tr><td align="center">‘font.size’</td><td align="center">字体大小，整数字号或者’large’、’x-small’</td></tr></tbody></table></li><li><p>常用中文字体：</p><ul><li>‘SimHei’：中文黑体</li><li>‘Kaiti’：中文楷体</li><li>‘LiSu’：中文隶书</li><li>‘FangSong’：中文仿宋</li><li>‘YouYuan’：中文幼圆</li><li>‘STSong’：华文宋体</li></ul></li></ul><p>二、在有中文输出的地方,增加一个属性: fontproperties</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npa = np.arange(0.0, 5.0, 0.02)plt.xlabel(&#39;横轴，时间&#39;, fontproperties=&#39;SimHei&#39;, fontsize=20)plt.ylabel(&#39;纵轴，振幅&#39;, fontproperties=&#39;SimHei&#39;, fontsize=20)plt.plot(a, np.cos(2*np.pi*a), &#39;r--&#39;)plt.savefig(&#39;test&#39;, dpi=600) # 保存图像plt.show()</code></pre><h4 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h4><p>常用函数：</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">plt.xlabel()</td><td align="center">对X轴增加文本标签</td></tr><tr><td align="center">plt.ylabel()</td><td align="center">对Y轴增加文本标签</td></tr><tr><td align="center">plt.title()</td><td align="center">对图形整体增加文本标签，放于整个图像的正上方</td></tr><tr><td align="center">plt.text()</td><td align="center">在任意位置增加文本</td></tr><tr><td align="center">plt.annotate()</td><td align="center">在图形中增加带箭头的注解</td></tr></tbody></table><p>其中annotate函数有：</p><pre><code class="python">plt.annotate(s, xy=arrow_crd, xytext=text_crd, arrowprops=dict)</code></pre><ul><li>s：带注解字符串</li><li>xy：箭头所在位置</li><li>xytext：文本显示位置</li><li>arrowprops：字典类型，包含箭头显示的一些属性</li></ul><p>例子：</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npa = np.arange(0.0, 5.0, 0.02)plt.plot(a, np.cos(2*np.pi*a), &#39;r--&#39;)plt.xlabel(&#39;横轴，时间&#39;, fontproperties=&#39;SimHei&#39;, fontsize=15, color=&#39;green&#39;)plt.ylabel(&#39;纵轴，振幅&#39;, fontproperties=&#39;SimHei&#39;, fontsize=15)plt.title(r&#39;正弦波实例 $y=cos(2\pi x)$&#39;, fontproperties=&#39;SimHei&#39;, fontsize=25) # $$中为latex语法plt.text(2, 1, r&#39;$\mu=100$&#39;, fontsize=15) # 在(2,1)处显示文本plt.annotate(r&#39;$\mu=100$&#39;, xy=(2,1), xytext=(3,1.5), arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.1, width=2)) # 箭头在(2,1)，文本在(3,1.5)，黑色箭头，箭头宽度为2，从箭头的起始到结束，按照0.1的比例将箭头缩进plt.axis([-1, 6, -2, 2]) # 横轴由-1到6，纵轴由-2到2plt.grid(True) # 加入网格plt.show()</code></pre><h4 id="子绘图区域"><a href="#子绘图区域" class="headerlink" title="子绘图区域"></a>子绘图区域</h4><p>如果在一个绘图区域中，希望分成几个子绘图区域来绘制图像，可以通过使用subplot函数：</p><pre><code class="python">plt.subplot(nrows, ncols, plot_number)</code></pre><ul><li>该函数将绘图区域划分成了横纵数量为nrows，纵轴数量为ncols的子区域</li><li>plot_number为在划分后的区域中，当前选中的那块区域（区域编号为从左到右，从上倒下，从1开始）</li><li>中间点逗号可以省略</li></ul><p>对于绘制较为复杂的子区域（不能由行列来划分，有些子区域占据多行或多列），需要通过以下函数来进行操作：</p><pre><code class="python">plt.subplot2grid(GridSpec, CurSpec, colspan=l, rowspan=l)</code></pre><p>理念：设定网格,选中网格,确定选中行列区域数量,编号从0开始.</p><p>例子：</p><p>绘制以下区域图形：</p><p><img src="//NU-LL.github.io/2020/03/10/Python数据分析与展示/image-20200321000425186.png" alt="待绘制区域图形"></p><pre><code class="python">#ax1：plt.subplot2grid((3,3), (0,0), colspan=3) # 将总区域划分成3*3的大小，选定(0,0)这个区域，并且列延伸colspan=3个单位（即选定长度加上旁边的长度）#ax2：plt.subplot2grid((3,3), (1,0), colspan=2) # 将总区域划分成3*3的大小，选定(1,0)这个区域，并且列延伸colspan=2个单位（即选定长度加上旁边的一个长度）#ax3：plt.subplot2grid((3,3), (1,2), rowspan=2) # 将总区域划分成3*3的大小，选定(1,2)这个区域，并且行延伸rowspan=2个单位（即选定长度加上旁边的长度）#ax4：plt.subplot2grid((3,3), (2,0)) # 将总区域划分成3*3的大小，选定(2,0)这个区域#ax5：plt.subplot2grid((3,3), (2,1)) # 将总区域划分成3*3的大小，选定(2,1)这个区域</code></pre><p>通过<strong>GridSpec类</strong>能够简化上述流程：</p><pre><code class="python">import matplotlib.gridspec as gridspecgs = gridspec.GridSpec(3,3) # 在该区域中划分为3*3的网格ax1 = plt.subplot(gs[0, :]) # 横向第0列，纵向所有列ax2 = plt.subplot(gs[1, :-1])ax3 = plt.subplot(gs[1:, -1])ax4 = plt.subplot(gs[2, 0])ax5 = plt.subplot(gs[2, 1])</code></pre><h3 id="基础绘图函数"><a href="#基础绘图函数" class="headerlink" title="基础绘图函数"></a>基础绘图函数</h3><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">plt.plot(x.y,fmt,…)</td><td align="center">绘制一个坐标图(直角/极坐标)</td></tr><tr><td align="center">plt.boxplot(data,notch,position)</td><td align="center">绘制一个箱形图</td></tr><tr><td align="center">plt.bar(left,height,width,bottom)</td><td align="center">绘制一个条形图</td></tr><tr><td align="center">plt.barh(width,bottom,left,height)</td><td align="center">绘制一个横向条形图</td></tr><tr><td align="center">plt.polar(theta,r)</td><td align="center">绘制极坐标图</td></tr><tr><td align="center">plt.pie(data, explode)</td><td align="center">绘制饼图</td></tr><tr><td align="center">plt.psd(x,NFFT=256,pad_to,Fs)</td><td align="center">绘制功率谱密度图</td></tr><tr><td align="center">plt.specgram(x,NFFT=256,pad_to,F)</td><td align="center">绘制谱图</td></tr><tr><td align="center">plt.cohere(x,y,NFFT=256,Fs)</td><td align="center">绘制X-Y的相关性函数</td></tr><tr><td align="center">plt.scatter(x,y)</td><td align="center">绘制散点图,其中,x和y长度相同</td></tr><tr><td align="center">plt.step(x,y,where)</td><td align="center">绘制步阶图</td></tr><tr><td align="center">plt.hist(x,bins,normed)</td><td align="center">绘制直方图</td></tr><tr><td align="center">plt.contour(X,Y,Z,N)</td><td align="center">绘制等值图</td></tr><tr><td align="center">plt.vlines()</td><td align="center">绘制垂直图</td></tr><tr><td align="center">plt.stem(x,y,linefmt,markerfmt)</td><td align="center">绘制柴火图</td></tr><tr><td align="center">plt.plot_date()</td><td align="center">绘制数据日期</td></tr></tbody></table><h2 id="Pandas库"><a href="#Pandas库" class="headerlink" title="Pandas库"></a>Pandas库</h2><p> Pandas是Python第三方库,提供高性能易用数据类型和分析工具，引用如下：</p><pre><code class="python">import pandas as pd</code></pre><p> Pandas基于NumPy实现,常与 NumPy和Matplotlib一同使用</p><p> Pandas主要提供两个数据类型：Series（一维），DataFrame（二维）</p><h3 id="Series类型"><a href="#Series类型" class="headerlink" title="Series类型"></a>Series类型</h3><p> Series类型由一组数据及与之相关的数据索引组成。其索引由pandas自动构建或由用户自定义生成：</p><ul><li><p>自动构建：</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; a = pd.Series([9,8,7,6])  &gt;&gt;&gt; a  0    9 # 左侧为pandas自动追加的索引，右侧为数据  1    8  2    7  3    6  dtype: int64 # NumPy中的数据类型</code></pre></li><li><p>用户自定义索引：</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; b = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) # 若为第二个参数，index=可以省略  &gt;&gt;&gt; b  a    9  b    8  c    7  d    6  dtype: int64</code></pre></li></ul><p>Series类型可以由以下类型创建：</p><ul><li><p>Python列表</p></li><li><p>标量值</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; s = pd.Series(25, index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) # 此时index=不能省略  &gt;&gt;&gt; s  a    25  b    25  c    25  dtype: int64</code></pre></li><li><p>Python字典</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; d = pd.Series({&#39;a&#39;:9,&#39;b&#39;:8,&#39;c&#39;:7})  &gt;&gt;&gt; d  a    9  b    8  c    7  dtype: int64  &gt;&gt;&gt; e = pd.Series({&#39;a&#39;:9,&#39;b&#39;:8,&#39;c&#39;:7}, index=[&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;]) # index从字典中进行选择操作  &gt;&gt;&gt; e  c    7.0  a    9.0  b    8.0  d    NaN  dtype: float64</code></pre></li><li><p>ndarray</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; import numpy as np  &gt;&gt;&gt; n = pd.Series(np.arange(5))  &gt;&gt;&gt; n  0    0  1    1  2    2  3    3  4    4  dtype: int32  &gt;&gt;&gt; m = pd.Series(np.arange(5),index=np.arange(9,4,-1))  &gt;&gt;&gt; m  9    0  8    1  7    2  6    3  5    4  dtype: int32</code></pre></li><li><p>其他函数（range()等函数）</p></li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>Series类型包括index和values两部分（Series类型的操作类似ndarray类型、Python字典类型），可以通过<code>.index</code>和<code>.values</code>分别获得索引和数据</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; b = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; b.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; b.valuesarray([9, 8, 7, 6], dtype=int64) # numpy中的array类型</code></pre><p>获得索引值和值的操作：</p><pre><code class="python">&gt;&gt;&gt; b[&#39;b&#39;] # 自定义索引8&gt;&gt;&gt; b[1] # 自动索引8&gt;&gt;&gt; b[[&#39;c&#39;,&#39;d&#39;,0]] # 报错&gt;&gt;&gt; b[[&#39;c&#39;,&#39;d&#39;,&#39;a&#39;]] # 两套索引并存，但不能混用c    7d    6a    9dtype: int64</code></pre><p>Series类型的操作类似ndarray类型：</p><ul><li><p>索引方法相同，采用[]</p></li><li><p>NumPy中运算和操作可用于Series类型</p></li><li><p>可以通过自定义索引的列表进行切片</p></li><li><p>可以通过自动索引进行切片，如果存在自定义索引， 则一同被切片</p><pre><code class="python">  &gt;&gt;&gt; b[1] # 索引出来的是值  8  &gt;&gt;&gt; b[:3] # 切片出来的任是Series  a    9  b    8  c    7  dtype: int64  &gt;&gt;&gt; b[b&gt;b.median()] # b.median()=7.5  a    9  b    8  dtype: int64  &gt;&gt;&gt; np.exp(b)  a    8103.083928  b    2980.957987  c    1096.633158  d     403.428793  dtype: float64</code></pre><ul><li>对Series类型的切片及相关运算都会返回<strong>Series类型</strong></li><li>如果只选择Series类型中的一个值，此时返回的是一个<strong>值</strong></li></ul></li></ul><p>Series类型的操作类似Python字典类型</p><ul><li><p>通过自定义索引访问</p></li><li><p>保留字<code>in</code>操作（只判断<strong>自定义索引</strong>）</p><pre><code class="python">  &gt;&gt;&gt; &#39;c&#39; in b # 判断&#39;c&#39;是否为自定义索引  True  &gt;&gt;&gt; 0 in b  False</code></pre></li><li><p>使用<code>.get()</code>方法</p><pre><code class="python">  &gt;&gt;&gt; b.get(&#39;f&#39;,100) # 从b中提取索引&#39;f&#39;对应的值，不存在则返回100，否则返回&#39;f&#39;对应的值  100</code></pre></li></ul><p>对齐操作：Series类型在运算中会自动对齐不同索引的数据（Series+Series时，索引值相同的值进行计算，不同的值不进行计算）</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; a = pd.Series([1,2,3], index=[&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])&gt;&gt;&gt; b = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; a+ba    NaNb    NaNc    8.0d    8.0e    NaNdtype: float64</code></pre><p>Series对象和索引都可以有一个名字，存储在属性<code>.name</code>中</p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; b = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; b.name&gt;&gt;&gt; b.name=&#39;Series对象&#39;&gt;&gt;&gt; b.index.name=&#39;索引列&#39;&gt;&gt;&gt; b索引列a    9b    8c    7d    6Name: Series对象, dtype: int64</code></pre><p>Series对象可以随时修改并<strong>即刻生效</strong></p><h3 id="Dataframe类型"><a href="#Dataframe类型" class="headerlink" title="Dataframe类型"></a>Dataframe类型</h3><p>Dataframe类型由共用相同索引的一组列组成（表格），是二维带“标签”数组：</p><p><img src="//NU-LL.github.io/2020/03/10/Python数据分析与展示/image-20200508175734518.png" alt="Dataframe类型示意图"></p><ul><li>是一个表格型的数据类型，每列值类型可以不同或相同</li><li>既有行索引（index）、也有列索引（column）<ul><li>axis=0（0轴）为行，即index</li><li>axis=1（1轴）为列，即column</li></ul></li><li>常用于表达二维数据，但可以表达多维数据</li></ul><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><ul><li><p>二维 ndarray对象</p><pre><code class="python">  &gt;&gt;&gt; import pandas as pd  &gt;&gt;&gt; import numpy as np  &gt;&gt;&gt; pd.DataFrame(np.arange(10).reshape(2,5)) # 10个元素 2*5的大小     0  1  2  3  4 #← 自动列索引  0  0  1  2  3  4  1  5  6  7  8  9  #↑ 自动行索引</code></pre></li><li><p>一维 ndarray、列表、字典、元组或 Series构成的字典</p><ul><li><p>Series构成的字典：</p><pre><code class="python">  &gt;&gt;&gt; dt = {&#39;one&#39;:pd.Series([1,2,3], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]),  ... &#39;two&#39;:pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])}  &gt;&gt;&gt; pd.DataFrame(dt)     one  two  a  1.0    9  b  2.0    8  c  3.0    7  d  NaN    6</code></pre><p>  可通过<code>index</code>指定行索引，<code>columns</code>指定列索引：</p><pre><code class="python">  &gt;&gt;&gt; pd.DataFrame(dt, index=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], columns=[&#39;two&#39;,&#39;three&#39;])     two three  b    8   NaN  c    7   NaN  d    6   NaN</code></pre></li><li><p>列表类型的字典：</p><pre><code class="python">  &gt;&gt;&gt; dl = {&#39;one&#39;:[1,2,3,4], &#39;two&#39;:[9,8,7,6]}  &gt;&gt;&gt; pd.DataFrame(dl, index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])     one  two  a    1    9  b    2    8  c    3    7  d    4    6</code></pre></li></ul></li><li><p>Series类型</p></li><li><p>其他的 Dataframe类型</p></li></ul><p>可以通过<code>.index</code>、<code>.columns</code>和<code>.values</code>分别获得行索引、列索引和表中的数据</p><pre><code class="python">&gt;&gt;&gt; dl = {&#39;one&#39;:[1,2,3,4], &#39;two&#39;:[9,8,7,6]}&gt;&gt;&gt; d = pd.DataFrame(dl, index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; d.index # 获得行索引Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; d.columns # 获得列索引Index([&#39;one&#39;, &#39;two&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; d.values # 获得表中的数据array([[1, 9],       [2, 8],       [3, 7],       [4, 6]], dtype=int64)</code></pre><p>获得Dataframe中的元素：</p><pre><code class="python">&gt;&gt;&gt; d[&#39;one&#39;] # 列索引标记 获得一列数据（Series类型）a    1b    2c    3d    4Name: one, dtype: int64&gt;&gt;&gt; d.iloc[1] # 查找第二行（Series类型）one    2two    8Name: b, dtype: int64&gt;&gt;&gt; d[&#39;one&#39;][&#39;b&#39;] # 精确查找2</code></pre><ul><li>在pandas的1.0.0版本开始，移除了<code>Series.ix</code>和<code>DataFrame.ix</code>方法，用loc方法或者iloc方法进行替换。<a href="https://www.jianshu.com/p/d6a9845a0a34" target="_blank" rel="noopener">loc、iloc使用</a></li></ul><h3 id="数据类型操作"><a href="#数据类型操作" class="headerlink" title="数据类型操作"></a>数据类型操作</h3><h4 id="Index对象"><a href="#Index对象" class="headerlink" title="Index对象"></a>Index对象</h4><p>Series和 Dataframe的索引是<code>Index</code>类型，Index对象是<strong>不可修改</strong>类型，其常用方法如下：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.append(idx)</code></td><td align="center">连接另一个Index对象，产生新的Index对象</td></tr><tr><td align="center"><code>.diff(idx)</code></td><td align="center">计算差集，产生新的Index对象</td></tr><tr><td align="center"><code>.intersection(idx)</code></td><td align="center">计算交集</td></tr><tr><td align="center"><code>.union(idx)</code></td><td align="center">计算并集</td></tr><tr><td align="center"><code>.delete(loc)</code></td><td align="center">删除loc位置处的元素</td></tr><tr><td align="center"><code>.insert(loc,e)</code></td><td align="center">在loc位置增加一个元素e</td></tr></tbody></table><h4 id="重新索引（增加或重排）"><a href="#重新索引（增加或重排）" class="headerlink" title="重新索引（增加或重排）"></a>重新索引（增加或重排）</h4><p><code>.reindex(index=None, columnS=None,...)</code>能够改变或重排 Series和 Dataframe索引</p><ul><li>index, columns：新的行列自定义索引</li><li>fill_value：重新索引中，用于填充缺失位置的值</li><li>method：填充方法，ffill当前值向前填充，bfill向后填充</li><li>limit：最大填充量</li><li>copy：默认True，生成新的对象， False时，新旧相等不复制</li></ul><pre><code class="python">&gt;&gt;&gt; dt = {&#39;one&#39;:pd.Series([1,2,3], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]),... &#39;two&#39;:pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])}&gt;&gt;&gt; d= pd.DataFrame(dt)&gt;&gt;&gt; d   one  twoa  1.0    9b  2.0    8c  3.0    7d  NaN    6&gt;&gt;&gt; d.reindex(index=[&#39;d&#39;,&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]) # 重排行   one  twod  NaN    6c  3.0    7b  2.0    8a  1.0    9&gt;&gt;&gt; d.reindex(columns=[&#39;two&#39;,&#39;one&#39;]) # 重排列   two  onea    9  1.0b    8  2.0c    7  3.0d    6  NaN&gt;&gt;&gt; newc = d.columns.insert(2, &#39;three&#39;) # 列中新增一列&gt;&gt;&gt; d.reindex(columns=newc, fill_value=200)   one  two  threea  1.0    9    200b  2.0    8    200c  3.0    7    200d  NaN    6    200</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>.drop()</code>能够删除 Series和 DataFrame指定行或列索引，会生成新的DataFrame对象</p><ul><li>默认<code>axis=0</code>，即默认对行进行操作。如需对列操作，需指定<code>axis=1</code></li></ul><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; a = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; aa    9b    8c    7d    6dtype: int64&gt;&gt;&gt; a.drop([&#39;b&#39;,&#39;c&#39;])a    9d    6dtype: int64</code></pre><h3 id="数学类型运算"><a href="#数学类型运算" class="headerlink" title="数学类型运算"></a>数学类型运算</h3><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ul><li><p>算术运算根据行列索引，补齐后运算，运算默认产生浮点数</p></li><li><p>补齐时缺项填充NaN（空值）</p></li><li><p>二维和一维、一维和零维间为广播运算</p><ul><li><p>广播运算：两个数组进行运算，一个是Series数组（即一维数组），另一个是DataFrame数组（多维数组）：</p><pre><code class="python">  &gt;&gt;&gt; a = pd.DataFrame(np.arange(20).reshape(4,5))  &gt;&gt;&gt; a      0   1   2   3   4  0   0   1   2   3   4  1   5   6   7   8   9  2  10  11  12  13  14  3  15  16  17  18  19  &gt;&gt;&gt; b = pd.Series(np.arange(4))  &gt;&gt;&gt; b  0    0  1    1  2    2  3    3  dtype: int32  &gt;&gt;&gt; b-10  0   -10  1    -9  2    -8  3    -7  dtype: int32  &gt;&gt;&gt; a-b        0     1     2     3   4  0   0.0   0.0   0.0   0.0 NaN  1   5.0   5.0   5.0   5.0 NaN  2  10.0  10.0  10.0  10.0 NaN  3  15.0  15.0  15.0  15.0 NaN</code></pre><ul><li><p>一维和零维的运算：一维上每个值加上零维的数据</p></li><li><p>不同维度间为广播运算，一维Series默认在轴1参与运算</p><ul><li>一维数组看成是一行，分别与多维数组的每一行进行运算</li></ul></li><li><p>可以通过<code>axis=0</code>指定到0轴上，即列上：</p><pre><code class="python">  &gt;&gt;&gt; a.sub(b,axis=0)      0   1   2   3   4  0   0   1   2   3   4  1   4   5   6   7   8  2   8   9  10  11  12  3  12  13  14  15  16</code></pre></li></ul></li></ul></li><li><p>采用+-*/符号进行的二元运算产生新的对象</p><ul><li><p><code>.add(d,**argws)</code>：类型间加法运算，可选参数</p><ul><li>fill_value：用于填充缺失位置的值</li></ul></li><li><p><code>.sub(d,**argws)</code>：类型间减法运算，可选参数</p></li><li><p><code>.mul(d,**argws)</code>：类型间乘法运算，可选参数</p></li><li><p><code>.div(d,**argws)</code>：类型间除法运算，可选参数</p><pre><code class="python">&gt;&gt;&gt; a = pd.DataFrame(np.arange(12).reshape(3,4))&gt;&gt;&gt; a 0  1   2   30  0  1   2   31  4  5   6   72  8  9  10  11&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5))&gt;&gt;&gt; b  0   1   2   3   40   0   1   2   3   41   5   6   7   8   92  10  11  12  13  143  15  16  17  18  19&gt;&gt;&gt; a+b    0     1     2     3   40   0.0   2.0   4.0   6.0 NaN1   9.0  11.0  13.0  15.0 NaN2  18.0  20.0  22.0  24.0 NaN3   NaN   NaN   NaN   NaN NaN&gt;&gt;&gt; a.mul(b,fill_value=0)    0     1      2      3    40   0.0   1.0    4.0    9.0  0.01  20.0  30.0   42.0   56.0  0.02  80.0  99.0  120.0  143.0  0.03   0.0   0.0    0.0    0.0  0.0</code></pre></li></ul></li></ul><h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><ul><li><p>比较运算只能比较<strong>相同</strong>索引的元素，<strong>不进行补齐</strong></p></li><li><p>二维和一维、—维和零维间为广播运算</p></li><li><p>用&gt;、&lt;、&gt;=、&lt;=、==、!=等符号进行的二元运算产生布尔对象</p><pre><code class="python">  &gt;&gt;&gt; a = pd.DataFrame(np.arange(12).reshape(3,4))  &gt;&gt;&gt; a     0  1   2   3  0  0  1   2   3  1  4  5   6   7  2  8  9  10  11  &gt;&gt;&gt; b = pd.DataFrame(np.arange(12,0,-1).reshape(3,4))  &gt;&gt;&gt; b      0   1   2  3  0  12  11  10  9  1   8   7   6  5  2   4   3   2  1  &gt;&gt;&gt; a&gt;b         0      1      2      3  0  False  False  False  False  1  False  False  False   True  2   True   True   True   True  &gt;&gt;&gt; a==b         0      1      2      3  0  False  False  False  False  1  False  False   True  False  2  False  False  False  False</code></pre></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>.sort_index(axis=0, ascending=True)</code>方法在指定轴上根据<strong>索引</strong>进行排序，默认升序</p><ul><li>axis：排序的轴，默认0轴，即行</li><li>ascending：是否递增排序，默认True</li></ul><pre><code class="python">&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;d&#39;])&gt;&gt;&gt; b    0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9b  10  11  12  13  14d  15  16  17  18  19&gt;&gt;&gt; b.sort_index()    0   1   2   3   4a   5   6   7   8   9b  10  11  12  13  14c   0   1   2   3   4d  15  16  17  18  19&gt;&gt;&gt; b.sort_index(ascending=False)    0   1   2   3   4d  15  16  17  18  19c   0   1   2   3   4b  10  11  12  13  14a   5   6   7   8   9</code></pre><p><code>.sort_values()</code>方法在指定轴上根据<strong>数值</strong>进行排序，默认升序</p><ul><li><code>Series.sort_values(axis=0, ascending=True)</code><ul><li>axis：排序的轴，默认0轴，即行</li><li>ascending：是否递增排序，默认True</li></ul></li><li><code>DataFrame.sort_values(by, axis=0, ascending=True)</code><ul><li>by：axis轴上的某个索引或索引列表</li></ul></li></ul><pre><code class="python">&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&#39;c&#39;,&#39;a&#39;,&#39;d&#39;,&#39;b&#39;])&gt;&gt;&gt; b    0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9d  10  11  12  13  14b  15  16  17  18  19&gt;&gt;&gt; b.sort_values(2,ascending=False) # 第三列 降序排序    0   1   2   3   4b  15  16  17  18  19d  10  11  12  13  14a   5   6   7   8   9c   0   1   2   3   4&gt;&gt;&gt; b.sort_values(&#39;a&#39;,axis=1,ascending=False) # &#39;a&#39;这一行 降序排序    4   3   2   1   0c   4   3   2   1   0a   9   8   7   6   5d  14  13  12  11  10b  19  18  17  16  15</code></pre><ul><li>NaN统一放到排序未尾（无论ascending为何值）</li></ul><h3 id="基本统计分析"><a href="#基本统计分析" class="headerlink" title="基本统计分析"></a>基本统计分析</h3><p>适用于 Series和 DataFrame类型：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.sum()</code></td><td align="center">计算数据的总和,按0轴计算,下同</td></tr><tr><td align="center"><code>.count()</code></td><td align="center">非NaN值的数量</td></tr><tr><td align="center"><code>.mean()</code> <code>.median()</code></td><td align="center">计算数据的算术平均值、算术中位数</td></tr><tr><td align="center"><code>.var()</code> <code>.std()</code></td><td align="center">计算数据的方差、标准差</td></tr><tr><td align="center"><code>.min()</code> <code>.max()</code></td><td align="center">计算数据的最小值、最大值</td></tr></tbody></table><p>适用于 Series类型：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.argmin()</code> <code>.argmax()</code></td><td align="center">计算数据最大值、最小值所在位置的索引位置(自动索引)</td></tr><tr><td align="center"><code>.idxmin()</code> <code>.idxmax()</code></td><td align="center">计算数据最大值、最小值所在位置的索引(自定义索引)</td></tr></tbody></table><p>统计汇总（适用于 Series和 DataFrame类型）：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.describe()</code></td><td align="center">针对0轴(各列)的统计汇总</td></tr></tbody></table><p>对于Series类型：</p><pre><code class="python">&gt;&gt;&gt; a = pd.Series([9,8,7,6], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])&gt;&gt;&gt; aa    9b    8c    7d    6dtype: int64&gt;&gt;&gt; a.describe()count    4.000000mean     7.500000std      1.290994min      6.00000025%      6.75000050%      7.50000075%      8.250000max      9.000000dtype: float64&gt;&gt;&gt; type(a.describe()) # 类型，任是Series类型&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt; a.describe()[&#39;max&#39;]9.0</code></pre><p>对于DataFrame类型：</p><pre><code class="python">&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&#39;c&#39;,&#39;a&#39;,&#39;d&#39;,&#39;b&#39;])&gt;&gt;&gt; b    0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9d  10  11  12  13  14b  15  16  17  18  19&gt;&gt;&gt; b.describe()               0          1          2          3          4count   4.000000   4.000000   4.000000   4.000000   4.000000mean    7.500000   8.500000   9.500000  10.500000  11.500000std     6.454972   6.454972   6.454972   6.454972   6.454972min     0.000000   1.000000   2.000000   3.000000   4.00000025%     3.750000   4.750000   5.750000   6.750000   7.75000050%     7.500000   8.500000   9.500000  10.500000  11.50000075%    11.250000  12.250000  13.250000  14.250000  15.250000max    15.000000  16.000000  17.000000  18.000000  19.000000&gt;&gt;&gt; type(b.describe()) # 类型，任是Series类型&lt;class &#39;pandas.core.series.Series&#39;&gt;&gt;&gt;&gt; b.describe().iloc[7] # 获取最后一行内容（Series类型）0    15.01    16.02    17.03    18.04    19.0Name: max, dtype: float64&gt;&gt;&gt; b.describe()[2] # 获取第三列内容（Series类型）count     4.000000mean      9.500000std       6.454972min       2.00000025%       5.75000050%       9.50000075%      13.250000max      17.000000Name: 2, dtype: float64</code></pre><h3 id="累计统计信息"><a href="#累计统计信息" class="headerlink" title="累计统计信息"></a>累计统计信息</h3><p>适用于 Series和 DataFrame类型：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.cumsum()</code></td><td align="center">依次给出前1、2、…、n个数的和</td></tr><tr><td align="center"><code>.cumprod()</code></td><td align="center">依次给出前1、2、…、n个数的积</td></tr><tr><td align="center"><code>.cummax()</code></td><td align="center">依次给出前1、2、…、n个数的最大值</td></tr><tr><td align="center"><code>.cummin()</code></td><td align="center">依次给出前1、2、…、n个数的最小值</td></tr></tbody></table><ul><li>默认为列，如需改为行，需添加参数<code>axis=1</code></li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&#39;c&#39;,&#39;a&#39;,&#39;d&#39;,&#39;b&#39;])&gt;&gt;&gt; b    0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9d  10  11  12  13  14b  15  16  17  18  19&gt;&gt;&gt; b.cumsum()    0   1   2   3   4c   0   1   2   3   4a   5   7   9  11  13d  15  18  21  24  27b  30  34  38  42  46</code></pre><p>适用 Series和 DataFrame类型，滚动计算（窗囗计算）：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.rolling(w).sum()</code></td><td align="center">依次计算相邻w个元素的和</td></tr><tr><td align="center"><code>.rolling(w).mean()</code></td><td align="center">依次计算相邻w个元素的算术平均值</td></tr><tr><td align="center"><code>.rolling(w).var()</code></td><td align="center">依次计算相邻w个元素的方差</td></tr><tr><td align="center"><code>.rolling(w).std()</code></td><td align="center">依次计算相邻w个元素的标准差</td></tr><tr><td align="center"><code>.rolling(w).min() .max()</code></td><td align="center">依次计算相邻w个元素的最小值和最大值</td></tr></tbody></table><p>例子：</p><pre><code class="python">&gt;&gt;&gt; b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&#39;c&#39;,&#39;a&#39;,&#39;d&#39;,&#39;b&#39;])&gt;&gt;&gt; b    0   1   2   3   4c   0   1   2   3   4a   5   6   7   8   9d  10  11  12  13  14b  15  16  17  18  19&gt;&gt;&gt; b.rolling(2).sum() # 列方向上，每两个单位求一次和      0     1     2     3     4c   NaN   NaN   NaN   NaN   NaNa   5.0   7.0   9.0  11.0  13.0d  15.0  17.0  19.0  21.0  23.0b  25.0  27.0  29.0  31.0  33.0&gt;&gt;&gt; b.rolling(3).sum()      0     1     2     3     4c   NaN   NaN   NaN   NaN   NaNa   NaN   NaN   NaN   NaN   NaNd  15.0  18.0  21.0  24.0  27.0b  30.0  33.0  36.0  39.0  42.0</code></pre><h3 id="相关分析"><a href="#相关分析" class="headerlink" title="相关分析"></a>相关分析</h3><p>适用 Series和 DataFrame类型：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>.cov()</code></td><td align="center">计算协方差矩阵</td></tr><tr><td align="center"><code>.corr()</code></td><td align="center">计算相关系数矩阵，Pearson、 Spearman、 Kendall等系数</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; hprice = pd.Series([3.04,22.93,12.75,22.6,12.33],index=[&#39;2008&#39;,&#39;2009&#39;,&#39;2010&#39;,&#39;2011&#39;,&#39;2012&#39;])&gt;&gt;&gt; m2 = pd.Series([8.18,18.38,9.13,7.82,6.69],index=[&#39;2008&#39;,&#39;2009&#39;,&#39;2010&#39;,&#39;2011&#39;,&#39;2012&#39;])&gt;&gt;&gt; hprice.corr(m2)0.5239439145220387</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫</title>
      <link href="/2020/02/18/python%E7%88%AC%E8%99%AB/"/>
      <url>/2020/02/18/python%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="定向网络数据爬取和网页解析"><a href="#定向网络数据爬取和网页解析" class="headerlink" title="定向网络数据爬取和网页解析"></a>定向网络数据爬取和网页解析</h2><p>request库：<a href="http://www.python-request.org" target="_blank" rel="noopener">http://www.python-request.org</a></p><p>requests库官方文档中文版：<a href="http://cn.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="noopener">http://cn.python-requests.org/zh_CN/latest/index.html</a><br>BeautifulSoup库官方文档中文版：<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://beautifulsoup.readthedocs.io/zh_CN/latest/</a><br>PEP8——Python代码规范：<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p><p>简单入门：</p><pre><code class="python">&gt;&gt;&gt; import request&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)#访问百度&gt;&gt;&gt; r.status_code#获取状态码200&gt;&gt;&gt; r.encoding=&#39;utf-8&#39;#更改编码&gt;&gt;&gt; r.text#打印网页内容&#39;&lt;!DOCTYPE html&gt;\r\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(\&#39;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=\&#39;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ \&#39;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;\&#39;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;\r\n&#39;</code></pre><p>常用的7个方法：</p><pre><code class="python">requests.request()#构造一个请求,支撑以下各方法的基础方法requests.get()#获取HTML网页的主要方法,对应于HTTP的GET requests.head()#获取HTML网页头信息的方法,对应于HTTP的HEAD requests.post()#向HTML网页提交POST请求的方法,对应于HTTP的POST requests.put()#向HTML网页提交PUT请求的方法,对应于HTTP的PUT requests.patch()#向HTML网页提交局部修改请求,对应于HTTP的PATCH requests.delete()#向HTML页面提交删除请求,对应于HTTP的DELETE</code></pre><ul><li>实际上底层都是使用了<code>request</code>方法来封装</li></ul><p>爬虫的尺寸：</p><ul><li>Requests库：小规模，数据量小，爬取速度不敏感（爬取网页 玩转网页）</li><li>Scrapy库：中规模，数据规模较大，爬取速度敏感（爬取网站 爬取系列网站）</li><li>定制开发：大规模，搜索引擎，爬取速度关键（爬取全网）</li></ul><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre><code class="python">r = request.get(url)#完整版r = request.get(url, params=None, **kwargs)</code></pre><ul><li>get方法构造一个向服务器请求资源的Request对象（由request库内部生成）</li><li>r：返回一个包含服务器资源的Response对象（包括从服务器返回的所有资源）</li><li>url：拟获取页面的url链接</li><li>params:url中的额外参数,字典或字节流格式,可选</li><li>**kwargs:12个控制访问的参数</li></ul><p>Response对象常用属性：</p><ul><li><code>r.status_code</code>：HTTP请求的返回状态,200表示<strong>连接成功</strong>,404表示失败（其余各种数均为失败）</li><li><code>r.text</code>：HTTP响应内容的字符串形式,即,url应的页面内容</li><li><code>r.encoding</code>：从 HTTP header中猜测的响应内容编码方式（如果HTTP header中不存在，则默认为<strong>ISO-8859-1</strong>）</li><li><code>r.apparent_encoding</code>：从内容中分析出的响应内容编码方式(备选编码方式)</li><li><code>r.content</code>：HTTP响应内容的二进制形式（保存图片可能会用到）</li></ul><h3 id="通用代码框架"><a href="#通用代码框架" class="headerlink" title="通用代码框架"></a>通用代码框架</h3><p>request库的相关异常：</p><ul><li><code>requests.ConnectionError</code>：网络连接错误异常,如DNS查询失败、拒绝连接等</li><li><code>requests.HTTPError</code>：HTTP错误异常</li><li><code>requests.URLRequired</code>：URL缺失异常</li><li><code>requests.TooManyRedirects</code>：超过最大重定向次数,产生重定向异常</li><li><code>requests.ConnectTimeout</code>：连接远程服务器超时异常（仅仅指与远程服务器连接的时间）</li><li><code>requests.Timeout</code>：请求URL超时,产生超时异常（发出请求到获得内容的整个过程的时间）</li></ul><p>产生异常函数：</p><pre><code class="python">r.raise_for_status()#如果不是200,产生异常requests.HTTPError</code></pre><p>通用代码框架：</p><pre><code class="python">import requestsdef getHTMLText(url):    try:        r = requests.get(url, timeout=30)        r.raise_for_status()#如果状态不是200,引发理 PError异常        r.encoding = r.apparent_encoding        return r. text    except:        return &quot;产生异常&quot;if __name__ == &quot;__main__&quot;:    url = &quot;http://www.baidu.com&quot;    print(getHTMLText(url))</code></pre><h3 id="HTTP协议及request库方法"><a href="#HTTP协议及request库方法" class="headerlink" title="HTTP协议及request库方法"></a>HTTP协议及request库方法</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP, Hypertext Transfer Protocol,超文本传输协议，基于”请求与响应”模式的、无状态的应用层协议，采用URL作为定位网络资源的标识。URL是通过HTTP协议存取资源的Internet路径,一个URL对应一个数据资源。</p><p>URL格式：<code>http://host[:port][path]</code></p><ul><li>host:合法的 Internet主机域名或IP地址</li><li>port:端口号,缺省端囗为80</li><li>path:请求资源的路径</li></ul><p>HTTP协议对资源的操作：</p><ul><li><code>GET</code>：请求获取URL位置的资源</li><li><code>HEAD</code>：请求获取URL位置资源的响应消息报告,即获得该资源的头部信息</li><li><code>POST</code>：请求向URL位置的资源后附加新的数据</li><li><code>PUT</code>：请求向URL位置存储一个资源,覆盖原URL位置的资源</li><li><code>PATCH</code>：请求局部更新URL位置的资原,即改变该处资原的部分内容（节省网络带宽）</li><li><code>DELETE</code>：请求删除URL位置存储的资源</li></ul><p>注：上述方法和request库中的方法是一一对应的</p><h4 id="request库方法"><a href="#request库方法" class="headerlink" title="request库方法"></a>request库方法</h4><p>由于网络安全的限制，一般只会使用到get，对于某些特别大的url链接只用head即可</p><p><strong>request方法</strong>：所有方法的基础方法</p><pre><code class="python">requests.request(method, url, **kwargs)</code></pre><ul><li><p>method:请求方式,对应其他get/put/post等7种方法</p><pre><code class="python">  requests.request(&#39;GET&#39;, url, **kwargs)  requests.request(&#39;HEAD&#39;, url, **kwargs)  requests.request(&#39;POST&#39;, url, **kwargs)  requests.request(&#39;PUT&#39;, url, **kwargs)  requests.request(&#39;PATCH&#39;, url, **kwargs)  requests.request(&#39;delete&#39;, url, **kwargs)  requests.request(&#39;OPTIONS&#39;, url, **kwargs)</code></pre></li><li><p>url:拟获取页面的url链接</p></li><li><p>**kwargs:控制访问的参数,共13个</p><ul><li><p>params:字典或字节序列,作为参数增加到url中</p><pre><code class="python">  &gt;&gt;&gt; kv = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;}  &gt;&gt;&gt; r = requests.request(&#39;GET&#39;,&#39;http://python123.io/ws&#39;,params = kv)  &gt;&gt;&gt; print(r.url)  https://python123.io/ws?key1=value1&amp;key2=value2  &gt;&gt;&gt; print(r.request.url)#发过去的链接  https://python123.io/ws?key1=value1&amp;key2=value2</code></pre></li><li><p>data:字典、字节序列或文件对象,作为 Request的内容</p><pre><code class="python">  &gt;&gt;&gt; kv = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;}  &gt;&gt;&gt; r = requests.request(&#39;POST&#39;,&#39;http://python123.io/ws&#39;,data = kv)  &gt;&gt;&gt; body = &#39;主体内容&#39;  &gt;&gt;&gt; r = requests.request(&#39;POST&#39;,&#39;http://python123.io/ws&#39;,data = body)</code></pre></li><li><p>json:JSON格式的数据,作为 Request的内容</p><pre><code class="python">  &gt;&gt;&gt; kv = {&#39;key1&#39;:&#39;value1&#39;}  &gt;&gt;&gt; r = requests.request(&#39;POST&#39;,&#39;http://python123.io/ws&#39;,json = kv)#赋值到服务器的json域上</code></pre></li><li><p>headers:字典,HTTP定制头</p><pre><code class="python">  &gt;&gt;&gt; hd = {&#39;user-agent&#39;:&#39;Chrome/10&#39;}  &gt;&gt;&gt; r = requests.request(&#39;POST&#39;,&#39;http://python123.io/ws&#39;,headers = hd)</code></pre></li><li><p>cookies:字典或 Cookiejar, Request中的 cookie</p></li><li><p>auth:元组,支持HTTP认证功能</p></li><li><p>files:字典类型,传输文件</p><pre><code class="python">  &gt;&gt;&gt; fs = {&#39;file&#39;:open(&#39;data.xls&#39;,&#39;rb&#39;)}  &gt;&gt;&gt; r = requests.request(&#39;POST&#39;,&#39;http://python123.io/ws&#39;,files = fs)</code></pre></li><li><p>timeout:设定超时时间,秒为单位（如果请求内容没有返回回来，会产生一个超时的异常）</p><pre><code class="python">  &gt;&gt;&gt; r = requests.request(&#39;GET&#39;,&#39;http://www.baidu.com&#39;,timeout = 10)</code></pre></li><li><p>proxies:字典类型,设定访问代理服务器,可以增加登录认证</p><pre><code class="python">  &gt;&gt;&gt; pxs = {&#39;http&#39;:&#39;http://user:pass@10.10.10.1:1234&#39;,&#39;https&#39;:&#39;https://10.10.10.1:4321&#39;}#增加http和https的代理，防止对爬虫的逆追踪  &gt;&gt;&gt; r = requests.request(&#39;GET&#39;,&#39;http://www.baidu.com&#39;,proxies = pxs)</code></pre></li><li><p>allow_redirects:True/ False,默认为True,重定向开关</p></li><li><p>stream:True/ False,默认为True,获取内容立即下载开关</p></li><li><p>verify:True/ False,默认为True,认证SSL证书开关</p></li><li><p>cert:本地SSL证书路径</p></li></ul></li></ul><p><strong>get方法</strong>：获取网页</p><pre><code class="python">requests.get(url, params=None, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>params:url中的额外参数,字典或字节流格式,可选</li><li>**kwargs:12个控制访问的参数(request方法中除了params的12个访问参数)</li></ul><p><strong>head方法</strong>：用很少的流量获得资源的概要信息</p><pre><code class="python">requests.head(url, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>**kwargs:13个控制访问的参数(与request方法中一样)</li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; r = requests.head(&#39;http://httpbin.org/get&#39;)&gt;&gt;&gt; r.headers#展示头部信息{&#39;Date&#39;: &#39;Wed, 19 Feb 2020 04:58:13 GMT&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Content-Length&#39;: &#39;305&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Server&#39;: &#39;gunicorn/19.9.0&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;, &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;}&gt;&gt;&gt; r.text#展示全部内容&#39;&#39;</code></pre><p><strong>post方法</strong>：向服务器提交新增数据。向 URL POST一个<strong>字典</strong>会自动编码为<strong>form</strong>(表单)，向 URL POST一个<strong>字符串</strong>会自动编码为<strong>data</strong></p><pre><code class="python">requests.post(url, data=None, json=None, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>data:字典、字节序列或文件, Request的内容</li><li>json:JSON格式的数据, Request的内容</li><li>**kwargs:剩下11个控制访问的参数(与request方法中一样)</li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; payload = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;}&gt;&gt;&gt; r = requests.post(&#39;http://httpbin.org/post&#39;,data = payload)&gt;&gt;&gt; print(r.text){  ...  &quot;form&quot;: {    &quot;key1&quot;: &quot;value1&quot;,    &quot;key2&quot;: &quot;value2&quot;  },  ...}&gt;&gt;&gt; r = requests.post(&#39;http://httpbin.org/post&#39;,data = &#39;ABC&#39;)&gt;&gt;&gt; print(r.text){  ...  &quot;data&quot;: &quot;ABC&quot;,  ...  &quot;form&quot;: {},  ...}</code></pre><p><strong>put方法</strong>：与post方法类似，只不过会覆盖原有数据</p><pre><code class="python">requests.put(url, data=None, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>data:字典、字节序列或文件, Request的内容</li><li>**kwargs:剩下12个控制访问的参数(与request方法中一样)</li></ul><p><strong>patch方法</strong>：向HTML网页提交局部修改请求,对应于HTTP的PATCH，能够节省网络带宽</p><pre><code class="python">requests.patch(url, data=None, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>data:字典、字节序列或文件, Request的内容</li><li>**kwargs:剩下12个控制访问的参数(与request方法中一样)</li></ul><p><strong>delete方法</strong>：</p><pre><code class="python">requests.patch(url, **kwargs)</code></pre><ul><li>url：拟获取页面的url链接</li><li>**kwargs:13个控制访问的参数(与request方法中一样)</li></ul><h3 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h3><p>一些网站对网络爬虫的限制：</p><ul><li>来源审查:判断 User-Agent进行限制<ul><li>检查来访HTTP协议头的User-Agent域或,只响应浏览器或友好爬虫的访问</li></ul></li><li>发布公告: Robots协议，Robots exclusion standard 网络爬虫排除标准<ul><li>告知所有爬虫，网站的爬取策略，要求爬虫遵守.</li></ul></li></ul><p>Robots协议：</p><ul><li>作用:网站告知网络爬虫哪些页面可以抓取,哪些不行</li><li>形式:在网站根目录下的 robots.txt文件中写明了那些目录能够爬取，那些不能</li></ul><p>例子（京东Robots协议<a href="https://www.jd.com/robots.txt" target="_blank" rel="noopener">https://www.jd.com/robots.txt</a>）：</p><pre><code class="python">User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /</code></pre><ul><li><code>User-agent: *</code> ：对于任何的爬虫来源，都应该遵守如下规则</li><li><code>Disallow</code>：不允许访问的目录和文件</li><li><code>EtaoSpider</code>、<code>HuihuiSpider</code>、<code>GwdangSpider</code>、<code>WochachaSpider</code>：对这四类爬虫禁止爬取</li></ul><p>其他例子：</p><ul><li>百度：<a href="http://www.baudu.com/robots.txt" target="_blank" rel="noopener">http://www.baudu.com/robots.txt</a></li><li>新浪：<a href="http://www.sina.com.cn/robots.txt" target="_blank" rel="noopener">http://www.sina.com.cn/robots.txt</a></li><li>QQ：<a href="http://www.qq.com/robots.txt" target="_blank" rel="noopener">http://www.qq.com/robots.txt</a></li><li>QQ新闻：<a href="http://news.qq.com/robots.txt" target="_blank" rel="noopener">http://news.qq.com/robots.txt</a></li></ul><h4 id="遵守方式"><a href="#遵守方式" class="headerlink" title="遵守方式"></a>遵守方式</h4><p>要求网络爬虫能够自动或人工识别 robots.txt,再进行内容爬取</p><p>Robots协议是建议但非约束性,网络爬虫可以不遵守,但存在法律风险.</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>亚马逊商品获取：</p><pre><code class="python">import requestsurl = &quot;https://www.amazon.cn/gp/product/B01M8L5Z3Y&quot;try:    kv = {&#39;user-agent&#39;:&#39;Mozilla/5.0&#39;}    r = requests.get(url, headers=kv)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(r.text[1000:2000])except:    print(&quot;爬取失败&quot;)</code></pre><p>360、百度的搜索：</p><pre><code class="python">import requestsurl = &quot;http://www.baidu.com/s&quot;#百度#url = &quot;http://www.so.com/s&quot;#360keyword = &quot;python&quot;try:    kv = {&#39;wd&#39;:keyword}#百度    #kv = {&#39;q&#39;:keyword}#360    r = requests.get(url, params=kv)    print(r.request.url)    r.raise_for_status()    print(len(r.text))except:    print(&quot;爬取失败&quot;)</code></pre><p>网络图片的爬取和存储：</p><pre><code class="python">import requestsimport osurl = &quot;http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg&quot;root = &quot;D://pics//&quot;path = root+url.split(&#39;/&#39;)[-1]try:    if not os.path.exists(root):        os.mkdir(root)    if not os.path.exists(path):        r = requests.get(url)        with open(path,&#39;wb&#39;) as f:            f.write(r.content)            f.close()            print(&quot;文件保存成功&quot;)    else:        print(&quot;文件已存在&quot;)except:    print(&quot;爬取失败&quot;)</code></pre><h2 id="网络爬虫与信息提取"><a href="#网络爬虫与信息提取" class="headerlink" title="网络爬虫与信息提取"></a>网络爬虫与信息提取</h2><p>BeautifulSoup库：能够解析HTML和XML</p><p>BeautifulSoup库官方文档中文版：<a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://beautifulsoup.readthedocs.io/zh_CN/latest/</a></p><h3 id="BeautifulSoup库的基本元素"><a href="#BeautifulSoup库的基本元素" class="headerlink" title="BeautifulSoup库的基本元素"></a>BeautifulSoup库的基本元素</h3><p>HTML/XML文档 &lt;==&gt; 标签树 &lt;==&gt; BeautifulSoup类，即BeautifulSoup类对应一个 HTMLIXML文档的全部内容.</p><pre><code class="python">#常用形式：from bs4 import BeautifulSoupsoup = BeautifulSoup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;,&quot;html.parser&quot;)#方式一soup2 = BeautifulSoup(open(&quot;D://demo.html&quot;),&quot;html.parser&quot;)#方式二</code></pre><p>BeautifulSoup库的解析器：</p><ul><li>bs4的HTML解析器：<code>BeautifulSoup( mk, &#39;html.parser&#39;)</code>，需要安装bs4库</li><li>lxml的HTML解析器：<code>BeautifulSoup(mk,&#39;lxml&#39;)</code>，需要安装lxml：<br>  <code>pip install Ixml</code></li><li>lxml的XML解析器：<code>BeautifulSoup(mk, ‘xml’)</code>，需要安装lxml：<code>pip install lxml</code></li><li>htmI5lib的解析器：<code>BeautifulSoup(mk, &#39;html5lib&#39;)</code>，需要安装html5lib：<code>pip install html5lib</code></li></ul><p>BeautifulSoup类的基本元素：</p><ul><li><code>Tag</code>：标签,最基本的信息组织单元,分别用&lt;&gt;和&lt;/&gt;标明开头和结尾</li><li><code>Name</code>：标签的名字,<p>…</p>的名字是’p’,格式:<tag>.name</tag></li><li><code>Attributes</code>：标签的属性,<strong>字典</strong>形式组织,格式:<tag>.attrs<ul><li>无论标签有没有属性，总能获得一个attrs，无属性就是空</li></ul></tag></li><li><code>NavigableString</code>：标签内非属性字符串,&lt;&gt;…&lt;/&gt;中字符串,格式:<tag>.string </tag></li><li><code>Comment</code>：标签内字符串的注释部分,一种特殊的Comment类型</li></ul><p><img src="//NU-LL.github.io/2020/02/18/python爬虫/image-20200220123236026.png" alt="图解"></p><p>例子：</p><p>对于如下demo网页<a href="https://python123.io/ws/demo.html" target="_blank" rel="noopener">https://python123.io/ws/demo.html</a>，其内容为：</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;    &lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to        professional by tracking the following courses:        &lt;a href=&quot;http://www.icourse163.org/course/BIT-268001&quot; class=&quot;py1&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a            href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; class=&quot;py2&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>使用方法：</p><pre><code class="python">&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; from bs4 import BeautifulSoup#从bs4库中导入BeautifulSoup类&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)#demo即为上述页面的一个变量#也可以通过soup = BeautifulSoup(open(&quot;demo.html&quot;),&quot;html.parser&quot;)，从本地文件获取&gt;&gt;&gt; soup.title#查看title&lt;title&gt;This is a python demo page&lt;/title&gt;&gt;&gt;&gt; tag = soup.a#获得a标签（只能获取第一个）&gt;&gt;&gt; tag#标签&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;&gt;&gt;&gt; type(tag)&lt;class &#39;bs4.element.Tag&#39;&gt;&gt;&gt;&gt; tag.attrs#标签属性 字典类型{&#39;href&#39;: &#39;http://www.icourse163.org/course/BIT-268001&#39;, &#39;class&#39;: [&#39;py1&#39;], &#39;id&#39;: &#39;link1&#39;}&gt;&gt;&gt; tag.attrs[&#39;class&#39;][&#39;py1&#39;]&gt;&gt;&gt; type(tag.attrs)&lt;class &#39;dict&#39;&gt;&gt;&gt;&gt; tag.string#字符串属性 &#39;Basic Python&#39;&gt;&gt;&gt; type(tag.string)&lt;class &#39;bs4.element.NavigableString&#39;&gt;&gt;&gt;&gt; soup.a.name#获得a标签的名字&#39;a&#39;&gt;&gt;&gt; soup.a.parent.name#获得a标签的父亲的名字&#39;p&#39;&gt;&gt;&gt; soup.a.parent.parent.name#获得a标签的父亲的父亲的名字&#39;body&#39;</code></pre><p>关于注释的例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; newsoup = BeautifulSoup(&quot;&lt;b&gt;&lt;!--This is a comment--&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;&quot;,&quot;html.parser&quot;)#注释&gt;&gt;&gt; newsoup.b.string&#39;This is a comment&#39;&gt;&gt;&gt; type(newsoup.b.string)&lt;class &#39;bs4.element.Comment&#39;&gt;#字符串&gt;&gt;&gt; newsoup.p.string&#39;This is not a comment&#39;&gt;&gt;&gt; type(newsoup.p.string)&lt;class &#39;bs4.element.NavigableString&#39;&gt;</code></pre><ul><li>是字符串还是注释，需要根据<strong>类型</strong>去判断</li></ul><h3 id="HTML遍历"><a href="#HTML遍历" class="headerlink" title="HTML遍历"></a>HTML遍历</h3><p>下行遍历：沿着根节点向叶子节点遍历的</p><p>上行遍历：沿着叶子结点向根节点遍历</p><p>平行遍历：在平行节点之间互相遍历</p><p>标签树的<strong>下行遍历</strong>：</p><ul><li><code>.contents</code>：子节点的列表,将<tag><strong>所有</strong>儿子节点存入列表</tag></li><li><code>.children</code>：子节点的迭代类型,与.contents类似,用于循环遍历儿子节点</li><li><code>.descendants</code>：子孙节点的迭代类型,包含所有子孙节点,用于循环遍历</li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)&gt;&gt;&gt; soup.head&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.head.contents[&lt;title&gt;This is a python demo page&lt;/title&gt;]#.contents&gt;&gt;&gt; soup.body.contents[&#39;\n&#39;, &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;, &#39;\n&#39;, &lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;, &#39;\n&#39;]&gt;&gt;&gt; len(soup.body.contents)5&gt;&gt;&gt; soup.body.contents[1]&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;#.children 遍历儿子节点for child in soup.body.children:    print(child)#.descendants 遍历子孙节点for child in soup.body.descendants:    print(child)</code></pre><ul><li>一个标签的子节点并不仅仅只有标签节点，也存在<strong>字符串节点</strong>，如：’\n’</li></ul><p>标签树的<strong>上行遍历</strong>：</p><ul><li><code>.parent</code>：节点的父亲标签</li><li><code>.parents</code>：节点先辈标签的迭代类型,用于循环遍历先辈节点</li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)#.parent&gt;&gt;&gt; soup.title.parent&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&gt;&gt;&gt; soup.html.parent&lt;html&gt;&lt;head&gt;&lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt; soup.parent#空#.parents 上行遍历for parent in soup.a.parents:    if parent is None:        print(parent)    else:        print(parent.name)</code></pre><p>标签树的<strong>平行遍历</strong>：</p><ul><li>.next_sibling：返回按照HTML文本顺序的下一个平行节点标签</li><li>.previous_sibling：返回按照HTML文本顺序的上一个平行节点标签</li><li>.next_siblings：迭代类型,返回按照HTML文本顺序的后续所有平行节点标签</li><li>.previous_siblings：迭代类型,返回按照HTML文本顺序的前续所有平行节点标签</li></ul><p>条件：所有的平行遍历都发生在<strong>同一个父节点</strong>下的各节点间</p><p>注意：任何一个节点的平行、父亲、儿子节点是可能存在<strong>NavigableString</strong>类型的</p><p>例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)#.next_sibling&gt;&gt;&gt; soup.a.next_sibling&#39; and &#39;&gt;&gt;&gt; soup.a.next_sibling.next_sibling&lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;#.previous_sibling&gt;&gt;&gt; soup.a.previous_sibling&#39;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\r\n&#39;&gt;&gt;&gt; soup.a.previous_sibling.previous_sibling#空标签&gt;&gt;&gt; soup.a.parent&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;#遍历后续节点：for sibling in soup.a.next_siblings:    print(sibling)#遍历前续节点for sibling in soup.a.previous_siblings:    print(sibling)</code></pre><h3 id="HTML格式化和编码"><a href="#HTML格式化和编码" class="headerlink" title="HTML格式化和编码"></a>HTML格式化和编码</h3><p>基于bs4库的<code>prettify()</code>方法</p><p>例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)&gt;&gt;&gt; soup.prettify()&#39;&lt;html&gt;\n &lt;head&gt;\n  &lt;title&gt;\n   This is a python demo page\n  &lt;/title&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;p class=&quot;title&quot;&gt;\n   &lt;b&gt;\n    The demo python introduces several python courses.\n   &lt;/b&gt;\n  &lt;/p&gt;\n  &lt;p class=&quot;course&quot;&gt;\n   Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:\n   &lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;\n    Basic Python\n   &lt;/a&gt;\n   and\n   &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;\n    Advanced Python\n   &lt;/a&gt;\n   .\n  &lt;/p&gt;\n &lt;/body&gt;\n&lt;/html&gt;&#39;&gt;&gt;&gt; print(soup.prettify())&lt;html&gt; &lt;head&gt;  &lt;title&gt;   This is a python demo page  &lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;p class=&quot;title&quot;&gt;   &lt;b&gt;    The demo python introduces several python courses.   &lt;/b&gt;  &lt;/p&gt;  &lt;p class=&quot;course&quot;&gt;   Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:   &lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;    Basic Python   &lt;/a&gt;   and   &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;    Advanced Python   &lt;/a&gt;   .  &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&gt;&gt;&gt; print(soup.a.prettify())&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt; Basic Python&lt;/a&gt;</code></pre><p>bs4将任何html文件或字符串都转化为了<strong>utf-8编码</strong></p><h3 id="信息标记"><a href="#信息标记" class="headerlink" title="信息标记"></a>信息标记</h3><p>信息标记的三种形式：</p><ul><li><p>XML（eXtensible Markup Language）：采取了以标签为主，来构建信息表达信息的方式（XML是HTML发展以来的一种通用信息表达形式）</p><ul><li>在标签中具有名字、属性，与HTML类似：<code>&lt;img src=&quot;china,jpg&quot; size=&quot;10&quot;&gt;...&lt;/img&gt;</code></li><li>如果标签中没有内容，可以采用缩写形式：<code>&lt;img src=&quot;china,jpg&quot; size=&quot;10&quot; /&gt;</code></li><li>可以嵌入注释：<code>&lt;!--This is acomment, very useful --&gt;</code></li></ul></li><li><p>JSON（JavsScript Object Notation）：有类型的键值对构建的信息表达方式</p><ul><li>规定：<ul><li>键：对信息类型进行定义</li><li>值：对信息值的描述</li><li>键值对具有数据类型：无论是键还是值，均需要通过<code>&quot;</code>来表示字符串</li><li>当值中有多个信息的时候，采用<code>[,]</code>形式来组织：<code>&quot;name&quot;:[&quot;北京&quot;,&quot;延安&quot;]</code></li><li>键值对之间可以嵌套使用，嵌套时采用<code>{,}</code>书写：<code>&quot;name&quot;:{&quot;oldname&quot;:&quot;北京&quot;,&quot;newname&quot;:&quot;延安&quot;}</code></li></ul></li><li>好处：<ul><li>对于JavaScript等编程语言来说，可以直接将JSON作为程序的一部分</li></ul></li></ul></li><li><p>YAML（YAML Aint Markup Language）：采用无类型键值对，在键值之间不采用任何双引号或相关的类型标记</p><ul><li><p>没有数据类型：<code>name:北京</code></p></li><li><p>可以通过缩进的关系表达所属关系</p></li><li><p>用<code>-</code>表达并联关系</p></li><li><p>用<code>|</code>表示整块数据</p></li><li><p>用<code>#</code>表示注释</p><pre><code class="yaml">  key : value  key : #Comment  -value1  -value2  key :      dubkey : subvalue</code></pre></li></ul></li></ul><p>对比：</p><ul><li>XML最早的通用信息标记语言,可扩展性好,但繁琐.<ul><li>Internet上的信息交互和传递</li></ul></li><li>JSON信息有类型,适合程序处理(js),较XML简洁.<ul><li>移动应用云端和节点的信息通信,无注释.</li></ul></li><li>YAML信息无类型,文本信息比例最高,可读性好.<ul><li>各类系统的配置文件,有注释易读.</li></ul></li></ul><p>信息提取的一般方法：</p><ul><li>完成解析信息的标记形式，再提取关键信息<ul><li>优点：信息解析准确</li><li>缺点：提取过程繁琐，速度慢</li></ul></li><li>无视标记形式,直接搜索关键信息<ul><li>优点:提取过程简洁,速度较快.</li><li>缺点:提取结果准确性与信息內容相关</li></ul></li><li>融合方法:结合形式解析与搜索方法,提取关键信息</li></ul><p>例子：</p><pre><code class="python">#融合方法:先查找a的标签 再解析&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)&gt;&gt;&gt; for link in soup.find_all(&#39;a&#39;):...     print(link.get(&#39;href&#39;))...http://www.icourse163.org/course/BIT-268001http://www.icourse163.org/course/BIT-1001870001</code></pre><h3 id="内容查找"><a href="#内容查找" class="headerlink" title="内容查找"></a>内容查找</h3><p>基本方法：</p><pre><code class="python">&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs)</code></pre><ul><li>返回值：列表，储存查取结果</li><li>name：对标签名称的检索字符串，如果为True则输出所有标签信息，可以使用正则表达式</li><li>attrs：对标签属性值的检索字符串，可标注属性检索，只能够精确查找，否则需要正则表达式</li><li>recursive：是否对子孙所有节点进行检索，默认True</li><li>string：&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串，只能够精确查找，否则需要正则表达式</li></ul><p>注意，由于find_all方法常用，可以简写为：</p><ul><li><code>&lt;tag&gt;.find_all(...)</code>等价于<code>&lt;tag&gt;(...)</code></li><li><code>soup.find_all(...)</code>等价于<code>soup(...)</code></li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; import requests&gt;&gt;&gt; import re&gt;&gt;&gt; r = requests.get(&quot;https://python123.io/ws/demo.html&quot;)&gt;&gt;&gt; demo = r.text#保存页面到变量demo&gt;&gt;&gt; soup = BeautifulSoup(demo,&quot;html.parser&quot;)#name&gt;&gt;&gt; soup.find_all(&#39;a&#39;)[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; soup.find_all([&#39;a&#39;,&#39;b&#39;])[&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;, &lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; for tag in soup.find_all(True):...     print(tag.name)...htmlheadtitlebodypbpaa&gt;&gt;&gt; for tag in soup.find_all(re.compile(&#39;b&#39;)):#使用正则...     print(tag.name)...bodyb#attrs&gt;&gt;&gt; soup.find_all(&#39;p&#39;,&#39;course&#39;)#检索p标签中带有course属性值的标签[&lt;p class=&quot;course&quot;&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses:&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt; and &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;]&gt;&gt;&gt; soup.find_all(id=&#39;link1&#39;)#属性域中id=&#39;link1&#39;的标签  精确查找[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;]&gt;&gt;&gt; soup.find_all(id=&#39;link&#39;)[]&gt;&gt;&gt; soup.find_all(id=re.compile(&#39;link&#39;))#正则[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]#recursive&gt;&gt;&gt; soup.find_all(&#39;a&#39;)[&lt;a class=&quot;py1&quot; href=&quot;http://www.icourse163.org/course/BIT-268001&quot; id=&quot;link1&quot;&gt;Basic Python&lt;/a&gt;, &lt;a class=&quot;py2&quot; href=&quot;http://www.icourse163.org/course/BIT-1001870001&quot; id=&quot;link2&quot;&gt;Advanced Python&lt;/a&gt;]&gt;&gt;&gt; soup.find_all(&#39;a&#39;,recursive=False)[]#string&gt;&gt;&gt; soup.find_all(string = &quot;Basic Python&quot;)#精确[&#39;Basic Python&#39;]&gt;&gt;&gt; soup.find_all(string = re.compile(&quot;python&quot;))#正则[&#39;This is a python demo page&#39;, &#39;The demo python introduces several python courses.&#39;]</code></pre><p>扩展方法（与find_all的参数一样）：</p><ul><li><code>&lt;&gt;.find()</code>：搜索且只返回一个结果,字符串类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_parents()</code>：在先辈节点中搜索,返回列表类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_parent()</code>：在先辈节点中返回一个结果,字符串类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_next_siblings()</code>：在后续平行节点中搜索,返回列表类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_next_sibling()</code>：在后续平行节点中返回一个结果,字符串类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_previous_siblings()</code>：在前序平行节点中搜索,返回列表类型,同<code>.find_all()</code>参数</li><li><code>&lt;&gt;.find_previous_sibling()</code>：在前序平行节点中返回一个结果,字符串类型,同<code>.find_all()</code>参数</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>中国大学排名定向爬虫</p><p>定向爬虫：仅对输入URL进行爬取,不扩展爬取.</p><p>爬取网页：<a href="http://www.zuihaodaxue.com/BCSR/xinxiyutongxingongcheng2019.html" target="_blank" rel="noopener">http://www.zuihaodaxue.com/BCSR/xinxiyutongxingongcheng2019.html</a>，且没有robots.txt文件</p><p>部分html代码：</p><pre><code class="html">&lt;tbody&gt;    &lt;tr class=&quot;bgfd&quot;&gt;        &lt;td class=&quot;ranking&quot;&gt;1&lt;/td&gt;        &lt;td class=&quot;ranking&quot;&gt;1&lt;/td&gt;        &lt;td class=&quot;align-center&quot;&gt;前1%&lt;/td&gt;        &lt;td class=&quot;align-left&quot;&gt;清华大学&lt;/td&gt;        &lt;td&gt;&lt;img src=&quot;../houtai/templates/images/subject/bo1.png&quot; title=&quot;一级学科博士学位授权点&quot;&gt;&lt;/td&gt;        &lt;td&gt;&lt;img src=&quot;../houtai/templates/images/subject/zhong1.png&quot; title=&quot;一级学科国家重点学科&quot;&gt;&lt;/td&gt;        &lt;td&gt;1219&lt;/td&gt;    &lt;/tr&gt;    ...</code></pre><pre><code class="python"># encoding=utf-8from bs4 import BeautifulSoupimport requestsimport bs4def getHTMLText(url):    try:        r = requests.get(url, timeout = 30)#30s        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;&quot;def fillUnivList(ulist, html):    soup = BeautifulSoup(html,&quot;html.parser&quot;)    for tr in soup.find(&#39;tbody&#39;).children:        if isinstance(tr,bs4.element.Tag):            tds = tr(&#39;td&#39;)#tr.find_all(&#39;td&#39;)简写            ulist.append([tds[0].string, tds[3].string, tds[6].string])#大学排名 大学名称 大学总分def printUnivList(ulist, num):    print(&quot;{:^10}\t{:^6}\t{:^10}&quot;.format(&quot;排名&quot;,&quot;名称&quot;,&quot;总分&quot;))    for i in range(num):        u = ulist[i]        print(&quot;{:^10}\t{:^6}\t{:^10}&quot;.format(u[0],u[1],u[2]))def main():    uinfo = []    url = &#39;http://www.zuihaodaxue.com/BCSR/xinxiyutongxingongcheng2019.html&#39;    html = getHTMLText(url)    fillUnivList(uinfo, html)    printUnivList(uinfo, 20)#只列出前20组</code></pre><ul><li><p>上述代码中，由于format输出过程中，采用英文空格填充，因为中英文间距宽度不同，所以会使得结果不会居中</p></li><li><p>为解决居中问题，可以将默认的填充字符由英文空格换成中文空格<code>ch(12288)</code>即可</p></li><li><p>修改后的<code>printUnivList</code>函数：</p><pre><code class="python">  def printUnivList(ulist, num):      tplt = &quot;{0:^10}\t{1:{3}^10}\t{2:^10}&quot;#{3}是采用第三个参数，即中文空格chr(12288)      print(tplt.format(&quot;排名&quot;,&quot;名称&quot;,&quot;总分&quot;,chr(12288)))      for i in range(num):          u = ulist[i]          print(tplt.format(u[0],u[1],u[2],chr(12288)))</code></pre></li></ul><h2 id="正则表达式库"><a href="#正则表达式库" class="headerlink" title="正则表达式库"></a>正则表达式库</h2><ul><li>通用的字符串表达框架</li><li>用来<strong>简洁</strong>的表达一组字符串的表达式</li><li>是字符串表达”简洁“和”特征“思想的工具</li><li>判断某字符串的特征归属</li></ul><p>正则表达式是由<strong>字符</strong>和<strong>操作符</strong>构成的</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><table><thead><tr><th align="center">操作符</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">表示任何单个字符</td><td align="center"></td></tr><tr><td align="center">[]</td><td align="center">字符集，对单个字符给出取值范围</td><td align="center">[abc]表示a、b、c，[a-z]表示a到z单个字符</td></tr><tr><td align="center">[^]</td><td align="center">非字符集，对单个字符给出排除范围</td><td align="center">[^abc]表示非a或b或c的单个字符</td></tr><tr><td align="center">*</td><td align="center">前一个字符0次或无限次扩展</td><td align="center">abc*表示ab、abc、abcc、abccc等</td></tr><tr><td align="center">+</td><td align="center">前一个字符1次或无限次扩展</td><td align="center">abc+表示abc、abcc、abccc等</td></tr><tr><td align="center">?</td><td align="center">前一个字符0次或1次扩展</td><td align="center">abc?表示abc、abcc、abccc等</td></tr><tr><td align="center">|</td><td align="center">左右表达式任意一个</td><td align="center">abc|def表示abc或者是def</td></tr><tr><td align="center">{m}</td><td align="center">扩展前一个字符m次</td><td align="center">ab{2}c表示abbc</td></tr><tr><td align="center">{m,n}</td><td align="center">扩展前一个字符m至n次（包含n）</td><td align="center">ab{1,2}c表示abc、abbc</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td><td align="center">^abc表示abc且在一个字符串的开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串结尾</td><td align="center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td align="center">()</td><td align="center">分组标记，内部只能使用|操作符</td><td align="center">(abc)表示abc，(abc|def)表示abc或def</td></tr><tr><td align="center">\d</td><td align="center">数字，等价于[0-9]</td><td align="center"></td></tr><tr><td align="center">\w</td><td align="center">单词字符，等价于[A-Za-z0-9_]</td><td align="center"></td></tr></tbody></table><h3 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h3><p>一次匹配的结果，包含了很多匹配的相关信息，Match对象的具体类型为<code>re.Match</code></p><p>重要属性：</p><ul><li><code>.string</code>：待匹配的文本</li><li><code>.re</code>：匹配时使用的 pattern对象(即正则表达式)</li><li><code>.pos</code>：正则表达式搜索文本的开始位置</li><li><code>.endpos</code>：正则表达式搜索文本的结束位置</li></ul><p>常用方法：</p><ul><li><code>.group(0)</code>：获得匹配后的字符串</li><li><code>.start()</code>：匹配字符串在原始字符串的开始位置</li><li><code>.end()</code>：匹配字符串在原始字符串的结束位置</li><li><code>.span()</code>：返回(.start(), .end())</li></ul><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&#39;[1-9]\d{5}&#39;,&#39;271035 TaiAn,WeiHai 264200&#39;)&gt;&gt;&gt; m.string&#39;271035 TaiAn,WeiHai 264200&#39;&gt;&gt;&gt; m.rere.compile(&#39;[1-9]\\d{5}&#39;)&gt;&gt;&gt; m.pos0&gt;&gt;&gt; m.endpos26&gt;&gt;&gt; m.group(0)&#39;271035&#39;&gt;&gt;&gt; m.start()0&gt;&gt;&gt; m.end()6&gt;&gt;&gt; m.span()(0, 6)</code></pre><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>re.search()</td><td>在一个字符串中搜索匹配正则表达式的<strong>第一个位置</strong>,返回 match对象</td></tr><tr><td>re.match()</td><td>从一个字符串的<strong>开始位置起</strong>匹配正则表达式,返回 match对象</td></tr><tr><td>re.findall()</td><td>搜索字符串,以<strong>列表</strong>类型返回<strong>全部</strong>能匹配的子串</td></tr><tr><td>re.split()</td><td>将一个字符串按照正则表达式匹配结果进行<strong>分割</strong>,返回列表类型</td></tr><tr><td>re.finditer()</td><td>搜索字符串,返回一个匹配结果的<strong>迭代</strong>类型,每个迭代元素是 match对象</td></tr><tr><td>re.sub()</td><td>在一个字符串中<strong>替换</strong>所有匹配正则表达式的子串,返回替换后的字符串</td></tr></tbody></table><p>函数说明：</p><pre><code class="python">re.search(pattern, string, flags=0)</code></pre><p>在一个字符串中搜索匹配正则表达式的第一个位置，返回 match对象</p><ul><li>pattern：正则表达式的字符串或原生字符串表示<ul><li>原生字符串（raw string）：即<code>r&quot;xxxx&quot;</code>类型字符串</li></ul></li><li>string：待匹配字符串</li><li>flags：正则表达式使用时的控制标记<ul><li><code>re.I(re.IGNORECASE)</code>：<strong>忽略</strong>正则表达式的<strong>大小写</strong>，[A-Z]能够匹配小写字符</li><li><code>re.M(re.MULTILINE)</code>：正则表达式中的<strong>^</strong>操作符能够将给定字符串的<strong>每行</strong>当作匹配开始</li><li><code>re.S(re.DOTALL)</code>：正则表达式中的<strong>.</strong>操作符能够匹配<strong>所有字符</strong>（默认匹配<strong>除换行外</strong>的所有字符）</li></ul></li></ul><blockquote><p>例子：</p><pre><code class="python">import rematch = re.search(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn 271035,WeiHai 264200&#39;)if match :    print(match.group(0))#输出 271035</code></pre></blockquote><hr><pre><code class="python">re.match(pattern, string, flags=0) </code></pre><p>从一个字符串的开始位置起匹配正则表达式，返回match对象</p><ul><li>参数同<code>search</code>函数</li></ul><blockquote><p>例子：</p><pre><code class="python">&#39;&#39;&#39;re.match()从字符串的起始位置开始匹配，如果起始位置匹配不成功，则匹配失败&#39;&#39;&#39;import rematch = re.match(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn 271035,WeiHai 264200&#39;)if match :    print(match.group(0))else:    print(type(match))#输出&lt;class &#39;NoneType&#39;&gt;#匹配成功例子：match = re.match(r&#39;[1-9]\d{5}&#39;,&#39;271035 TaiAn,WeiHai 264200&#39;)if match :    print(match.group(0))else:    print(type(match))#输出 &#39;271035&#39;</code></pre></blockquote><hr><pre><code class="python">re.findall(pattern, string, flags=0) </code></pre><p>搜索字符串，以列表类型返回全部能匹配的子串</p><ul><li>参数同<code>search</code>函数</li></ul><blockquote><p>例子：</p><pre><code class="python">import rels = re.findall(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn 271035 WeiHai 264200 222222 115545&#39;)if ls : print(ls)else: print(type(ls))#[&#39;271035&#39;, &#39;264200&#39;, &#39;222222&#39;, &#39;115545&#39;]</code></pre><p>注意：findall如果使用了<strong>分组</strong>，则输出的内容将是分组中的内容而非find到的结果：</p><pre><code class="python">import rexxx = &quot;a123ca456c&quot;ret = re.findall(r&quot;a(123|456)c&quot;, xxx)print(ret)#[&#39;123&#39;, &#39;456&#39;]</code></pre><p>解决方法：</p><ul><li>加上问号来启用“不捕捉模式”</li><li>不用分组</li></ul><pre><code class="python">#启用“不捕捉模式”ret = re.findall(r&quot;a(?:123|456)c&quot;, xxx)#不用分组ret = re.findall(r&quot;a123c|a456c&quot;, xxx)</code></pre></blockquote><hr><pre><code class="python">re.split(pattern, string, maxsplit=0, flags=0) </code></pre><p>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</p><ul><li>maxsplit：最大分割数，剩余部分作为最后一个元素输出</li><li>其余参数同<code>search</code>函数</li></ul><blockquote><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; re.split(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn271035WeiHai264200wo222222nihao115545abc&#39;)[&#39;TaiAn&#39;, &#39;WeiHai&#39;, &#39;wo&#39;, &#39;nihao&#39;, &#39;abc&#39;]&gt;&gt;&gt; re.split(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn271035WeiHai264200wo222222nihao115545abc&#39;,maxsplit=2)[&#39;TaiAn&#39;, &#39;WeiHai&#39;, &#39;wo222222nihao115545abc&#39;]</code></pre></blockquote><hr><pre><code class="python">re.finditer(pattern, string, flags=0) </code></pre><p>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是 match对象</p><ul><li>参数同<code>search</code>函数</li></ul><blockquote><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; for m in re.finditer(r&#39;[1-9]\d{5}&#39;,&#39;TaiAn271035WeiHai264200wo222222nihao115545abc&#39;) :...     if m:...         print(m.group(0))...         print(type(m))...     else:...         print(&quot;null&quot;)...271035&lt;class &#39;re.Match&#39;&gt;264200&lt;class &#39;re.Match&#39;&gt;222222&lt;class &#39;re.Match&#39;&gt;115545&lt;class &#39;re.Match&#39;&gt;</code></pre></blockquote><hr><pre><code class="python">re.sub(pattern, repl, string, count=0, flags=0)</code></pre><p>用一个新的字符串替换所有匹配正则表达式的子串，返回替换后的字符串</p><ul><li>repl：替换匹配字符串的字符串</li><li>count：匹配的最大替换次数</li><li>其余参数同<code>search</code>函数</li></ul><blockquote><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; re.sub(r&#39;[1-9]\d{5}&#39;,&#39;隐藏邮政编码&#39;,&#39;TaiAn271035WeiHai264200wo222222nihao115545abc&#39;)&#39;TaiAn隐藏邮政编码WeiHai隐藏邮政编码wo隐藏邮政编码nihao隐藏邮政编码abc&#39;</code></pre></blockquote><h3 id="等价用法"><a href="#等价用法" class="headerlink" title="等价用法"></a>等价用法</h3><ul><li><p>函数式用法：一次性操作</p><pre><code class="python">  rst = re.search(r&#39;[1-9]\d{5}&#39;,&#39;BIT 100081&#39;)</code></pre></li><li><p>面向对象用法：编译后的多次操作（能够加快程序运行速度）</p><pre><code class="python">  pat = re.compile(r&#39;[1-9]\d{5}&#39;)  rst = pat.search(&#39;BIT 100081&#39;)</code></pre></li></ul><p>compile函数：</p><pre><code class="python">regex = re.compile(pattern, flags=0)</code></pre><p>将正则表达式的字符串形式编译成正则表达式对象</p><ul><li>pattern：正则表达式的字符串或原生字符串表示</li><li>flags：正则表达式使用时的控制标记</li></ul><p>注意：这里regex才是正则表达式（对象），代表了一组字符串。同时regex对象也含有上述re库提供的的六个方法，但是需要将方法中的<code>pattern</code>参数去除</p><h3 id="贪婪匹配和最小匹配"><a href="#贪婪匹配和最小匹配" class="headerlink" title="贪婪匹配和最小匹配"></a>贪婪匹配和最小匹配</h3><p>Re库<strong>默认</strong>釆用贪婪匹配，即输出匹配<strong>最长</strong>的子串</p><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r&#39;PY.*N&#39;,&#39;PYANBNCNDN&#39;)&gt;&gt;&gt; match.group(0)&#39;PYANBNCNDN&#39;</code></pre><p>最小匹配：输出匹配<strong>最短</strong>的子串，具体方法为 在匹配不同长度的操作符后 加个<code>?</code>即可</p><p>具体扩展的操作符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">*?</td><td align="center">前一个字符0次或无限次扩展,最小匹配</td></tr><tr><td align="center">+?</td><td align="center">前一个字符1次或无限次扩展,最小匹配</td></tr><tr><td align="center">??</td><td align="center">前一个字符0次或1次扩展,最小匹配</td></tr><tr><td align="center">{m,n}?</td><td align="center">扩展前一个字符m至n次(含n),最小匹配</td></tr></tbody></table><p>例子：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search(r&#39;PY.*?N&#39;,&#39;PYANBNCNDN&#39;)&gt;&gt;&gt; match.group(0)&#39;PYAN&#39;</code></pre><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>淘宝商品价格爬取</p><p>搜索接口：<a href="https://s.taobao.com/search?q=篮球" target="_blank" rel="noopener">https://s.taobao.com/search?q=篮球</a><br>翻页接口：第二页 <a href="https://s.taobao.com/search?q=篮球&amp;s=44" target="_blank" rel="noopener">https://s.taobao.com/search?q=篮球&amp;s=44</a><br>                  第三页 <a href="https://s.taobao.com/search?q=篮球&amp;s=88" target="_blank" rel="noopener">https://s.taobao.com/search?q=篮球&amp;s=88</a></p><p>用爬虫爬淘宝，得到的页面是登录页面，想要跳过这个页面，需要提前在浏览器中登录淘宝，并获取hearders信息（关键是<strong>cookie</strong>和User-Agent）用于模拟用户登录，并作为参数传给requests.get(url,headers = header)，获取方法如下：</p><p>首先登陆淘宝账号，然后按 F12 进入检查，在上面的 network 的第一行中拖到最后，找到最上方以search？开头的一栏，右键 Copy–&gt;Copy as URL(bash)，然后打开这个网站： <a href="https://curl.trillworks.com/" target="_blank" rel="noopener">https://curl.trillworks.com/</a> 在里面把复制的内容放进去，选择 Python 然后会发现右边有一个 headers:{省略…}，把这个 headers 放进代码，用一个变量储存，然后在代码中的r equest.get(url,headers=你刚才复制的内容，也就是那个变量）,这个时候你再请求 request.text 返回的就是你要的页面</p><pre><code class="python">import requestsimport redef getHtmlText(url):    try:        header =  {    &#39;authority&#39;: &#39;s.taobao.com&#39;,    &#39;pragma&#39;: &#39;no-cache&#39;,    &#39;cache-control&#39;: &#39;no-cache&#39;,    &#39;upgrade-insecure-requests&#39;: &#39;1&#39;,    &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#39;,    &#39;accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&#39;,    &#39;referer&#39;: ,    &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;,    &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9&#39;,    &#39;cookie&#39;: ,}#隐去了cookie信息和referer信息        r = requests.get(url,headers = header)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        print(&quot;爬取失败&quot;)        return &quot;&quot;def parsePage(ilist,html):    try:        plt = re.findall(r&#39;\&quot;view_price\&quot;:\&quot;\d+\.\d*\&quot;&#39;,html)        tlt = re.findall(r&#39;\&quot;raw_title\&quot;:\&quot;.*?\&quot;&#39;,html)        #print(tlt)        print(len(plt))        for i in range(len(plt)):            price = eval(plt[i].split(&#39;:&#39;)[3])  # eval：去掉双引号或单引号            title = tlt[i].split(&#39;\&quot;&#39;)[3]  # 防止名字中出现:            ilist.append([title,price])        #print(ilist)    except:        print(&quot;解析出错&quot;)def printGoodsList(ilist,num):    print(&quot;=====================================================================================================&quot;)    tplt = &quot;{0:&lt;3}\t{1:&lt;30}\t{2:&gt;6}&quot;    print(tplt.format(&quot;序号&quot;,&quot;商品名称&quot;,&quot;价格&quot;))    count = 0    for g in ilist:        count += 1        if count &lt;= num:               print(tplt.format(count,g[0],g[1]))    print(&quot;=====================================================================================================&quot;)def main():    goods = &quot;篮球&quot;    depth = 1    start_url = &quot;https://s.taobao.com/search?q=&quot;+goods    infoList = []    num = 20    for i in range(depth):        try:            url = start_url + &#39;$S=&#39; + str(44*i)            html = getHtmlText(url)            parsePage(infoList,html)        except:            continue    printGoodsList(infoList,num)main() </code></pre><p>股票数据定向爬取：</p><p>步骤1：从中财网<a href="http://quote.cfi.cn/stockList.aspx获取股票列表" target="_blank" rel="noopener">http://quote.cfi.cn/stockList.aspx获取股票列表</a></p><p>步骤2：根据股票列表获取股票的url，通过每个url获取股票信息</p><p>步骤3：将结果保存到文件中</p><pre><code class="python">#股票数据定向爬虫import reimport requestsfrom bs4 import BeautifulSoupimport traceback#函数功能：原始数据爬取def getHtmlText(url):    try:        r = requests.get(url)        #r.encoding = r.apparent_encoding        r.encoding = &#39;utf-8&#39;        r.raise_for_status()        #print(r.text[-500:])        return r.text    except:        traceback.print_exc()#函数功能：获取股票列表def getStockList(lst,stockListURL):    ra = [11,12,13,14,15,16,17]    #ra = [11]    count = 1    for i in ra:        stock_list_html = getHtmlText(stockListURL+str(i))        soup = BeautifulSoup(stock_list_html,&quot;html.parser&quot;)        a = soup.find_all(&#39;a&#39;)        for i in a:            try :                href = i.attrs[&quot;href&quot;]                stock_a = re.search(r&#39;\d{6}.html$&#39;,href)                if stock_a:                    count += 1                    lst.append(stock_a.group(0))            except:                traceback.print_exc()    return count    #函数功能：进入每个股票的链接，爬取对应股票的相关信息               def getStockInfo(lis,stockInfoURL,fpath,count):    ready_count = 0    f = open(fpath,&#39;a&#39;,encoding=&#39;utf-8&#39;)    for j in lis[:100]:        stock_info_html = getHtmlText(stockInfoURL+str(j))        #print(stock_info_html)        try:            if stock_info_html == &#39;&#39;:                continue            #每个股票存为字典，数据处理较麻烦，有些数据有“杂音”，需单独给出if判断，或在正则中约束            infoDict = { }            soup = BeautifulSoup(stock_info_html,&quot;html.parser&quot;)            stockInfo = soup.find(&#39;div&#39;,attrs={&#39;id&#39;:&#39;act_quote&#39;})            name = stockInfo.find(&#39;div&#39;,attrs={&#39;class&#39;:&#39;Lfont&#39;}).string            #print(name)            infoDict.update({&#39;股票名称&#39;: name})            stockDetialInfo = stockInfo.find(&#39;table&#39;,attrs={&#39;id&#39;:&#39;quotetab_stock&#39;})            td = stockDetialInfo.find_all(&quot;td&quot;)            #print(td)            for item in td:                #print(item.get_text())                text= item.get_text()                if(text==&quot;业绩预告&quot;):                    print(&quot;hear&quot;)                    key = &quot;业绩预告&quot;                    real_val = &quot;业绩预告&quot;                else:                    text_split = re.split(&#39;:|：&#39;,text)#网站程序员分号用了中文和英文两种……                    key = text_split[0]                    val = text_split[1]                    real_val = re.search(r&#39;(-?\d+.?\d*[%|手|万|元]?)|(--)|(正无穷大)&#39;,val).group(0)                infoDict[key] = real_val            f.write(str(infoDict)+&#39;\n&#39;) #每个股票字典数据转为字符串写入文件            ready_count += 1            print(&#39;\r当前第{0:}个,共{1:}个&#39;.format(ready_count,count)) #打印进度        except:            print(&#39;\r当前第{0:}个,共{1:}个&#39;.format(ready_count,count))            traceback.print_exc()    f.close()def main():    lst = []    stock_list_url = &quot;http://quote.cfi.cn/stockList.aspx?t=&quot; #股票列表，翻页接口    stock_info_url = &quot;http://quote.cfi.cn/&quot;                  #每个股票的链接都是http://quote.cfi.cn/000000.html的形式。000000代表六位的股票代码    output_path = &quot;D:\ArticleForProgram\PythonProgram\Spider\StockInfo.txt&quot; #改成自己的    stock_count = getStockList(lst,stock_list_url)    getStockInfo(lst,stock_info_url,output_path,stock_count)main()</code></pre><h2 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h2><p>安装scrapy：</p><pre><code class="python">pip install scrapyscrapy -h</code></pre><p>框架：</p><p><img src="//NU-LL.github.io/2020/02/18/python爬虫/image-20200224175001094.png" alt="总体框架图"></p><p>Engine模块（无需修改）：</p><ul><li>控制所有模块之间的数据流</li><li>根据条件触发事件</li></ul><p>Download模块（无需修改）：</p><ul><li>根据用户请求下载网页</li></ul><p>Scheduler模块（无需修改）：</p><ul><li>对所有爬取请求进行调度管理</li></ul><p>Downloader Middleware中间件（一般无需修改）：</p><ul><li>实施 Engine、 Scheduler和 Downloader之间进行用户可配置的控制</li><li>用户可以通过该中间件的编写来修改、丢弃、新增请求或响应</li></ul><p><strong>Spider模块</strong>：</p><ul><li>解析 Downloader返回的响应( Response)</li><li>产生爬取项( scraped item)</li><li>产生额外的爬取请求( Request)</li></ul><p><strong>Item Pipelines模块</strong>：</p><ul><li>以流水线方式处理 Spider产生的爬取项.</li><li>由一组操作顺序组成,类似流水线,每个操作是一个Item Pipeline类型.</li><li>可能操作包括:清理、检验和查重爬取项中的HTML数据、将数据存储到数据库.</li></ul><p>Spider Middleware中间件：</p><ul><li>对请求和肥取项的再处理</li><li>功能包括修改、丢弃、新增请求或爬取项</li></ul><h3 id="和request库的比较"><a href="#和request库的比较" class="headerlink" title="和request库的比较"></a>和request库的比较</h3><p>相同点：</p><ul><li>两者都可以进行页面请求和肥取, Python肥吧虫的两个重要技术路线.</li><li>两者可用性都好,文档丰富,入门简单.</li><li>两者都没有处理js、提交表单、应对验证码等功能(可扩展).</li></ul><p>不同点：</p><table><thead><tr><th align="center">request</th><th align="center">Scrapy</th></tr></thead><tbody><tr><td align="center">页面级爬虫</td><td align="center">网站级爬虫</td></tr><tr><td align="center">功能库</td><td align="center">框架</td></tr><tr><td align="center">并发性考虑不足,性能较差</td><td align="center">并发性好,性能较高</td></tr><tr><td align="center">重点在于页面下载</td><td align="center">重点在于爬虫结构</td></tr><tr><td align="center">定制灵活</td><td align="center">一般定制灵活,深度定制困难</td></tr><tr><td align="center">上手十分简单</td><td align="center">入门稍难</td></tr></tbody></table><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>Scrapy是为持续运行设计的专业爬虫框架，提供操作的Scrap命令行，其格式为：</p><pre><code class="bash">&gt;scrapy &lt;command&gt; [options] [args]</code></pre><p>常用命令（command）</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th><th align="center">格式</th></tr></thead><tbody><tr><td align="center"><strong>startproject</strong></td><td align="center">创建一个新工程</td><td align="center">scrapy startproject <name> [dir]</name></td></tr><tr><td align="center"><strong>genspider</strong></td><td align="center">创建一个爬虫</td><td align="center">scrapy genspider [options] <name> [domain]</name></td></tr><tr><td align="center">settings</td><td align="center">获得爬虫配置信息</td><td align="center">scrapy settings [options]</td></tr><tr><td align="center"><strong>crawl</strong></td><td align="center">运行一个爬虫</td><td align="center">scrapy crawl <spider></spider></td></tr><tr><td align="center">list</td><td align="center">列出工程中所有爬虫</td><td align="center">scrapy list</td></tr><tr><td align="center">shell</td><td align="center">启动URL调试命令行</td><td align="center">scrapy shell <url></url></td></tr></tbody></table><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><pre><code class="powershell">scrapy startproject demo</code></pre><p>会产生如下文件：</p><ul><li>demo/：外层目录<ul><li>scrapy.cfg：部署 Scrap爬虫的配置文件（服务器上用，本地无需）</li><li>demo/：Scrap框架的用户自定义 Python代码<ul><li>__init__.py：初始化脚本</li><li>items.py：Items代码模板(继承类)</li><li>middlewares.py：Middlewares代码模板(继承类)</li><li>pipelines.py：Pipelines代码模板(继承类)</li><li>settings：Scrap爬虫的配置文件</li><li>spiders/：Spiders代码模板目录(继承类)<ul><li>__pycache__/：缓存目录,无需修改</li><li>__init__.py：初始化脚本</li></ul></li></ul></li></ul></li></ul><h4 id="产生爬虫"><a href="#产生爬虫" class="headerlink" title="产生爬虫"></a>产生爬虫</h4><pre><code class="powershell">cd scrapy genspider demopython123 python123.io#名字 网站</code></pre><p>注意：爬虫名字不能和工程同名</p><p>会在<code>demo\demo\spiders\</code>下增加<code>demopython123.py</code>：</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass Demopython123Spider(scrapy.Spider):#必须继承自scrapy.Spider    name = &#39;demopython123&#39;#爬虫名字    allowed_domains = [&#39;python123.io&#39;]#要爬取的域名    start_urls = [&#39;http://python123.io/&#39;]#框架要爬取的初始页面    def parse(self, response):        pass</code></pre><ul><li><code>parse()</code>用于处理响应,解析内容形成字典,发现新的URL爬取请求</li></ul><h4 id="配置爬虫"><a href="#配置爬虫" class="headerlink" title="配置爬虫"></a>配置爬虫</h4><p>修改<code>demopython123.py</code>：</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass Demopython123Spider(scrapy.Spider):    name = &#39;demopython123&#39;    #allowed_domains = [&#39;python123.io&#39;]    start_urls = [&#39;http://python123.io/ws/demo.html&#39;]#需要爬取的页面    #response：从网络中返回内容所存储的或对应的对象    def parse(self, response):#爬取功能        fname = response.url.split(&#39;/&#39;)[-1]        with open(fname,&#39;wb&#39;) as f:            f.write(response.body)        sele.log(&#39;Save file %s.&#39; % fname)        pass</code></pre><h4 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h4><pre><code class="powershell">scrapy crawl demopython123</code></pre><p>捕获页面最终会在<code>\demo\demo.html</code>处</p><p>但是实际上，生成的<code>demopython123.py</code>文件是简化版，完整版的如下：</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass Demopython123Spider(scrapy.Spider):#必须继承自scrapy.Spider    name = &#39;demopython123&#39;#爬虫名字    def start_request(self):        urls = [            &#39;http://python123.io/ws/demo.html&#39;        ]        for url in urls:            yield scrapy.Request(url=url, callback=self.parse)    def parse(self, response):        pass</code></pre><p>完整版和简化版的区别就在于将简化版中的start_urls变量改为了利用<code>yield</code>生成器的函数start_request</p><h3 id="Scrap爬虫的使用步骤"><a href="#Scrap爬虫的使用步骤" class="headerlink" title="Scrap爬虫的使用步骤"></a>Scrap爬虫的使用步骤</h3><ul><li>步骤1:创建一个工程和 Spider模板</li><li>步骤2:编写 Spider</li><li>步骤3:编写 Item Pipeline</li><li>步骤4:优化配置策略</li></ul><p>涉及到的类：</p><ul><li>Request类：向网络上提交请求的内容</li><li>Response类：从网络中爬取内容的封装类</li><li>Item类：由Spider产生的信息而封装的类</li></ul><h4 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h4><p>class scrapy.http.Request()</p><ul><li>表示一个Request对象</li><li>由 Spider生成,由 Downloader执行.</li></ul><p>属性或方法：</p><table><thead><tr><th align="center">属性或方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.url</td><td align="center">Request对应的请求URL地址</td></tr><tr><td align="center">.method</td><td align="center">对应的请求方法，’GET’、’POST’等</td></tr><tr><td align="center">.headers</td><td align="center">字典类型风格的请求头</td></tr><tr><td align="center">.body</td><td align="center">请求内容主体，字符串类型</td></tr><tr><td align="center">.meta</td><td align="center">用户添加的扩展信息，在 Scrapy内部模块间传递信息使用</td></tr><tr><td align="center">.copy()</td><td align="center">复制该请求</td></tr></tbody></table><h4 id="Response类"><a href="#Response类" class="headerlink" title="Response类"></a>Response类</h4><p>class scrapy.http.Response()</p><ul><li>Response对象表示一个HTTP响应</li><li>由 Downloader生成,由 Spider处理</li></ul><p>属性或方法：</p><table><thead><tr><th align="center">属性或方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.url</td><td align="center">Response对应的请求URL地址</td></tr><tr><td align="center">.status</td><td align="center">HTTP状态码，默认是200</td></tr><tr><td align="center">.headers</td><td align="center">Response对应的头部信息</td></tr><tr><td align="center">.body</td><td align="center">Response对应的内容信息，字符串类型</td></tr><tr><td align="center">.flags</td><td align="center">一组标记</td></tr><tr><td align="center">.request</td><td align="center">产生 Response类型对应的 Request对象</td></tr><tr><td align="center">.copy()</td><td align="center">复制该响应</td></tr></tbody></table><h4 id="Item类"><a href="#Item类" class="headerlink" title="Item类"></a>Item类</h4><p>class scrapy.http.Item()</p><ul><li>Item对象表示一个从HTML页面中提取的信息内容</li><li>由 Spider生成,由 Item Pipeline处理</li><li>Item类似字典类型，可以按照字典类型操作</li></ul><p>Scrapy爬虫支持多种HTML信息提取方法：</p><ul><li>Beautiful Soup</li><li>Ixml</li><li>re</li><li>XPath Selector</li><li>CSS Selector</li></ul><h4 id="CSS-Selector基本使用"><a href="#CSS-Selector基本使用" class="headerlink" title="CSS Selector基本使用"></a>CSS Selector基本使用</h4><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>建立工程</p><pre><code class="powershell">scrapy startproject BaiduStockscd BaiduStocksscrapy genspider stocks baidu.com</code></pre><p>修改<code>spiders\stocks.py</code>文件：</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyimport reclass StocksSpider(scrapy.Spider):#必须继承自scrapy.Spider    name = &#39;stocks&#39;#爬虫名字    start_urls = [&#39;http://quote.eastmoney.com/stocklist.html/&#39;]#框架要爬取的初始页面    def parse(self, response):        for href in response.css(&#39;a::attr(href)&#39;).extract():            try:                stock = re.findall(r&quot;[s][hz]\d{6}&quot;,href)[0]                url = &#39;htps://gupiao.baidu.com/stock&#39; + stock + &#39;.html&#39;                yield scrapy.Request(url, callback=self.parse_stock)#处理该url的回调函数            except:                continue    def parse_stock(self, response):        infoDict = {}        stockInfo = response.css(&#39;.stock-bets&#39;)        name = stockInfo.css(&#39;.bets-name&#39;).extract()[0]        keyList = stockInfo.css(&#39;dt&#39;).extract()        valueList = stockInfo.css(&#39;dd&#39;).extract()        for i in range(len(keyList)):            key = re.findall(r&#39;&gt;.*&lt;/dt&gt;&#39;, keyList[i])[0][1:-5]            try:                val = re.findall(r&#39;\d+\.?.*&lt;/dd&gt;&#39;, valueList[i])[0][0:-5]            except:                val = &#39;--&#39;            infoDict[key] = val        infoDict.update(            {&#39;股票名称&#39;: re.findall(r&#39;\s.*\(&#39;, name)[0].split()[0] + \             re.findall(r&#39;&gt;.*\&lt;&#39;, name)[0][1:-1]})        yield infoDict</code></pre><p>编写Pipelines</p><ul><li>配置pipelines.py文件</li><li>定义对爬取项（Scraped Item）的处理类</li></ul><pre><code class="python"># -*- coding: utf-8 -*-# Define your item pipelines here## Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlclass BaiduStocksPipeline(object):    def process_item(self, item, spider):        return itemclass BaiduStocksInfoPipeline(object):#自己写的新的类    def open_spider(self, spider):#爬虫被调用时对应的pipeline启动的方法        self.f = open(&#39;BaiduStocksInfo.txt&#39;, &#39;w&#39;)    def open_spider(self, spider):#爬虫关闭或结束时对应的pipeline方法        self.f.close()    def process_item(self, item, spider):#对每一个item项进行处理时对应的方法，pipeline中主体函数        try:            line = str(dict(item)) + &#39;\n&#39;            self.f.write(line)        except:            pass        return item</code></pre><p>将新的类让框架知道，修改settings.py：</p><pre><code class="python"># -*- coding: utf-8 -*-...# Configure item pipelines# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = {    &#39; BaiduStocks.pipelines. BaiduStocksInfoPipeline&#39;: 300,}# 修改该参数，由 BaiduStocks.pipelines. BaiduStocksPipeline 改为BaiduStocks.pipelines. BaiduStocksInfoPipeline...</code></pre><p>执行程序：</p><pre><code class="powershell">scrapy crawl stocks</code></pre><p>优化：</p><p>settings.py文件提供如下配置：</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">CONCURRENT_REQUESTS</td><td align="center">Downloader最大并发请求下载数量，默认32</td></tr><tr><td align="center">CONCURRENT_ITEMS</td><td align="center">Item Pipeline最大井发ITEM处理数量，默认100</td></tr><tr><td align="center">CONCURRENT_REQUESTS_PER_DOMAIN</td><td align="center">每个目标域名最大的并发请求数量，默认8</td></tr><tr><td align="center">CONCURRENT_ REQUESTS_PER_IP</td><td align="center">每个目标IP最大的并发请求数量，默认0，非0有效</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mininet</title>
      <link href="/2020/02/13/Mininet/"/>
      <url>/2020/02/13/Mininet/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装Mininet"><a href="#一、安装Mininet" class="headerlink" title="一、安装Mininet"></a>一、安装Mininet</h2><p>1、直接下载官网提供的含有Mininet的虚拟机镜像，地址：<a href="http://mininet.org/download/" target="_blank" rel="noopener">http://mininet.org/download/</a></p><p>2、通过源代码直接安装</p><pre><code class="bash">#在υbunt14.04或更高版本的环境下,获取源代码:git clone http://github.com/mininet/mininet.git#安装 Wininet,需要涉及安装 Wininet、user交换机及OVS软件,可根据wininet/util/install.sh -h命令选择参数进行安装mininet/util/install.sh -n3V 2.5.0#-n：安装核心文件及依赖，-3：安装openflow的1.3版本，-V：安装openvswitch，其后根版本号#安装完成后,使用命令测试Wininet是否安装成功sudo mn --test pingall</code></pre><p>3、软件包管理器直接安装</p><pre><code class="bash">#如果有mininet、OvS以前版本，先进行删除sudo rm -rf /usr/local/bin/mn /usr/local/bin/mnexec \    /usr/local/lib/python*/*/*mininet* \    /usr/local/bin/ovs-* /usr/local/sbin/ovs-*#安装sudo apt-get install mininet#安装完成后,验证控制器是否在运行,如果控制器正在运行,停用控制器:sudo service openvswitch-controller stopsudo update-rc.d openvswitch-controller disable#安装完成后,使用命令测试Wininet是否安装成功sudo mn --test pingall</code></pre><p>Mininet文件结构：</p><ul><li>bin/mn：主运行文件,应用 Python程序编写,定义了MininetRunner类,执行 sudo mn即调用本程序，是模拟网络的主程序,为整个测试创建基础平台。</li><li>mininet：核心代码基本都在这</li><li><strong>custom</strong>：放置自定义python文件，用来自定义拓扑</li><li><strong>util</strong>：放置辅助文件，包括安装脚本、文档辅助生成等</li><li><strong>examples</strong>：含有很多案例，包括miniedit可视化等</li></ul><h2 id="二、命令详解"><a href="#二、命令详解" class="headerlink" title="二、命令详解"></a>二、命令详解</h2><ul><li>网络构建启动参数<ul><li>–topo：</li><li>–custom：</li><li>–switch：</li><li>–controller：</li><li>–mac：</li></ul></li><li>内部交互命令<ul><li>dump</li><li>net</li><li>nodes</li><li>links</li><li>dpctl</li><li>iperf</li></ul></li><li>外部运行参数<ul><li>-c：清除配置信息</li><li>-h：帮助</li></ul></li></ul><h3 id="–topo"><a href="#–topo" class="headerlink" title="–topo"></a>–topo</h3><ul><li>单一拓扑：整个网络拓扑中交换机有且只有一个,其可以下挂一个或多个主机<code>sudo mn --topo=single,3</code></li><li>线性拓扑：交换机连接呈线形排列,且每个交换机所连接主机数目只有一个<code>sudo mn --topo=linear,4</code></li><li>树形拓扑：交换机连接成树形排列,且每个交换机所连接主机一般有多个<code>sudo mn --topo=tree,depth=2,fanout=2</code>（depth：交换机的深度，即交换机的层数，fanout：扇出，广度，即每一个交换机下挂几个节点）</li><li>自定义拓扑：Python编写文件 file.py,执行此脚本即可创建定义的拓扑,<code>--custon</code>与<code>--topo</code>联用<code>sudo mn --custom file.py --topo mytopo</code>（file.py采用绝对路径，mytopo为file.py中自定义的类）</li></ul><h3 id="–switch"><a href="#–switch" class="headerlink" title="–switch"></a>–switch</h3><p>定义 mininet要使用的交换机（默认使用OVSK,即 OpenVSwitch交换机）</p><p><img src="//NU-LL.github.io/2020/02/13/Mininet/image-20200213202144514.png" alt="switch参数"></p><h3 id="–controller"><a href="#–controller" class="headerlink" title="–controller"></a>–controller</h3><p>定义要使用的控制器,如果没有指定则使用 mininet中默认的控制器</p><p>连接远程控制器,可以指定存在于本机或者与之相连通设备上的控制器,指定远程控制器方法:</p><pre><code class="bash">sudo mn --controller=remote,--ip=[controller IP],--port=[port]</code></pre><ul><li><code>--ip</code>和–port可以忽略，默认为本机ip和6653/6633端口</li></ul><h3 id="–mac"><a href="#–mac" class="headerlink" title="–mac"></a>–mac</h3><p>自动设置设备的MAC地址</p><p>让MAC地址易读,即设置交换机的MAC、主机MAC及IP地址<strong>从小到大</strong>排序,且设置简单唯一,不仅让机器容易获取,也容易让肉眼很容易识别其ID.使用方法:</p><pre><code class="bash">sudo mn --topo=tree,depth=2,fanout=2,--mac</code></pre><h3 id="内部交互命令"><a href="#内部交互命令" class="headerlink" title="内部交互命令"></a>内部交互命令</h3><p>使用mn默认创建网络,使用一系列命令査看并验证网络系统的链路健壮性.</p><pre><code class="bash">*** No default OpenFlow controller found for default switch!*** Falling back to OVS Bridge*** Creating network*** Adding controller*** Adding hosts:h1 h2 *** Adding switches:s1 *** Adding links:(h1, s1) (h2, s1) *** Configuring hostsh1 h2 *** Starting controller*** Starting 1 switchess1 ...*** Starting CLI:#查看链路信息mininet&gt; neth1 h1-eth0:s1-eth1h2 h2-eth0:s1-eth2s1 lo:  s1-eth1:h1-eth0 s1-eth2:h2-eth0#查看网络节点mininet&gt; nodesavailable nodes are: h1 h2 s1#查看链路信息mininet&gt; linksh1-eth0&lt;-&gt;s1-eth1 (OK OK)h2-eth0&lt;-&gt;s1-eth2 (OK OK)#查看连通性mininet&gt; pingall*** Ping: testing ping reachabilityh1 -&gt; h2 h2 -&gt; h1 *** Results: 0% dropped (2/2 received)</code></pre><p><img src="//NU-LL.github.io/2020/02/13/Mininet/image-20200213212154682.png" alt="常用内部交互命令"></p><ul><li>py指令的意义是在现有的网络中动态扩展其他网络<ul><li><code>py help(节点名)</code>：查询相关节点的帮助，如py help(h1)</li></ul></li><li>注意dpctl指令的作用范围为<strong>全局</strong></li></ul><p>注：在内部交互中如需要输入shell命令，只需在shell命令前加上<code>sh</code>即可</p><h2 id="三、Mininet可视化"><a href="#三、Mininet可视化" class="headerlink" title="三、Mininet可视化"></a>三、Mininet可视化</h2><p>Miniedit可视化,直接在界面上编辑任意拓扑,生成 python自定义拓扑脚本,简单方便.</p><p>Mininet2.2.0+内置 miniedit.在mininet/examples下提供 miniedit.py脚本,执行脚本后显示可视化界面,可自定义拓扑及配置属性.</p><ul><li>前提条件：安装python-tk：<code>sudo apt install python-tk</code></li></ul><h2 id="四、实验一：玩转流表"><a href="#四、实验一：玩转流表" class="headerlink" title="四、实验一：玩转流表"></a>四、实验一：玩转流表</h2><p>掌握 OpenvSwitch下发流表操作;掌握添加、删除流表命令以及设备通信的原理</p><p>Mininet创建一个默认树形拓扑并指定Mininet的控制器进行基本的添加、删除流表操作,使网络实现网络通信和不通信.</p><p>链接脚本<code>exper1.py</code>文件：</p><pre><code class="python">#!/usr/bin/pythonfrom mininet.topo import Topofrom mininet.net import Mininetfrom mininet.node import RemoteControllerfrom mininet.link import TCLinkfrom mininet.util import dumpNodeConnertionsclass MyTopo( Topo ):    &quot;Simple topology example.&quot;    def __init__( self ):        &quot;Create custom topo.&quot;        # Initialize topology        Topo.__init__( self )        # Add hosts and switches        Host1 = self.addHost( &#39;h1&#39; )        Host2 = self.addHost( &#39;h2&#39; )        Host3 = self.addHost( &#39;h3&#39; )        Switch1 = self.addSwitch( &#39;s1&#39; )        Switch2 = self.addSwitch( &#39;s2&#39; )        # Add links        self.addLink( Host1, Switch1 )        self.addLink( Host2, Switch1 )        self.addLink( Host3, Switch2 )        self.addLink( Switch1, Switch2 )topos = { &#39;mytopo&#39;: ( lambda: MyTopo() ) }</code></pre><p>整个网络的拓扑如下：</p><p><img src="//NU-LL.github.io/2020/02/13/Mininet/image-20200215152846335.png" alt="自定义网络拓扑"></p><ul><li>其中Controller采用ryu远程控制器（该控制器在本地搭建）</li></ul><p>步骤：</p><pre><code class="bash">#首先创建ryu远程控制器cd ~/ryu/ryu/appryu-manager simple_switch.py#根据脚本产生自定义拓扑网络(其中ip和port为远程控制器的ip和port)mn --custom exper1.py --topo mytopo --controller=remote,ip=127.0.0.1,port=6633#查看静态流表（初次查看可以发现并没有流表产生）mininet&gt; dpctl dump-flows#ping下后再次查看，发现产生了很多流表mininet&gt; pingallmininet&gt; dpctl dump-flows#删除之前的所有流表mininet&gt; dpctl del-flows#通过dpctl手动添加流表，实现数据转发mininet&gt; dpctl add-flows in_port=1,action=output:2#1号端口进来的数据从2号端口出去mininet&gt; dpctl add-flows in_port=2,action=output:1#2号端口进来的数据从1号端口出去mininet&gt; dpctl dump-flowsmininet&gt; h1 ping h2#成功mininet&gt; h1 ping h3#ping 失败mininet&gt; h2 ping h3#ping 失败#删除流表(下述两种方式均可)mininet&gt; dpctl del-flows in_port=2#删除所有in_port=2的流表mininet&gt; dpctl dump-flowsmininet&gt; sh ovs-ofctl del-flows s1 in_port=1#调用shell删除s1中in_port=1的流表mininet&gt; dpctl dump-flows#添加丢弃数据包的流表mininet&gt; dpctl add-flows in_port=2,actions=drop#丢弃2号端口输入的</code></pre><ul><li>注：dpctl是对<strong>全局</strong>的交换机起作用，添加删除都是全局的</li><li>想要h3和h1或h2通信，需要添加3号端口（s1交换机的3号端口）与1号端口（s2之间的1号端口）之间的的通信</li><li>流表具有优先级，一般来说控制器下发的流表是高于用户自己添加到流表</li></ul><h2 id="五、实验二：模拟多数据中心带宽实验"><a href="#五、实验二：模拟多数据中心带宽实验" class="headerlink" title="五、实验二：模拟多数据中心带宽实验"></a>五、实验二：模拟多数据中心带宽实验</h2><ul><li>通过 Minnett模拟搭建基于不同数据中心的网络拓扑;</li><li>掌握多数据中心网络拓扑的构建;</li><li>熟悉网络性能测试工具 Iperf,根据实验测试SDN网络的性能;</li><li>通过程序生成真实网络流量</li></ul><p>应用价值：</p><ul><li>树状拓扑结构容错能力强</li><li>降低数据中心成本消耗</li><li>提供重新排列的全带宽无阻碍路径</li><li>提高带宽利用率</li><li>分析数据中心网络流量性能</li><li>为真实数据中心和仿真测试床提供有用信息</li></ul><p>流量模拟：</p><p>网络性能评估中—个巨大的挑战就是如何生成真实的网络流量,可以通过程序来创造人工的网络流量,通过建立测试环境来模拟真实的状况.此应用主要以数据中心网络为目标场景,在 mininet仿真环境中尽可能地还原数据中心内部的真实流量情况.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mininet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 网络虚拟化： network namespace 简介</title>
      <link href="/2020/02/10/linux%20%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%9A%20network%20namespace%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/10/linux%20%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%9A%20network%20namespace%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>本文转载自：<a href="https://cizixs.com/2017/02/10/network-virtualization-network-namespace/" target="_blank" rel="noopener">https://cizixs.com/2017/02/10/network-virtualization-network-namespace/</a></p><p>network namespace 是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中。这篇文章介绍 network namespace 的基本概念和用法，network namespace 是 linux 内核提供的功能，这篇文章借助 <code>ip</code> 命令来完成各种操作。<code>ip</code> 命令来自于 <code>iproute2</code> 安装包，一般系统会默认安装，如果没有的话，请读者自行安装。</p><p><strong>NOTE</strong>：<code>ip</code> 命令因为需要修改系统的网络配置，默认需要 sudo 权限。这篇文章使用 root 用户执行，请不要在生产环境或者重要的系统中用 root 直接执行，以防产生错误。</p><p><code>ip</code> 命令管理的功能很多， 和 network namespace 有关的操作都是在子命令 <code>ip netns</code> 下进行的，可以通过 <code>ip netns help</code> 查看所有操作的帮助信息。</p><p>默认情况下，使用 <code>ip netns</code> 是没有网络 namespace 的，所以 <code>ip netns ls</code> 命令看不到任何输出。</p><pre><code class="bash">[root@localhost ~]# ip netns helpUsage: ip netns list       ip netns add NAME       ip netns delete NAME       ip netns identify PID       ip netns pids NAME       ip netns exec NAME cmd ...       ip netns monitor[root@localhost ~]# ip netns ls</code></pre><p>创建 network namespace 也非常简单，直接使用 <code>ip netns add</code> 后面跟着要创建的 namespace 名称。如果相同名字的 namespace 已经存在，命令会报 <code>Cannot create namespace</code> 的错误。</p><pre><code class="bash">[root@localhost ~]# ip netns add net1[root@localhost ~]# ip netns lsnet1</code></pre><p><code>ip netns</code> 命令创建的 network namespace 会出现在 <code>/var/run/netns/</code> 目录下，如果需要管理其他不是 <code>ip netns</code> 创建的 network namespace，只要在这个目录下创建一个指向对应 network namespace 文件的链接就行。</p><p>有了自己创建的 network namespace，我们还需要看看它里面有哪些东西。对于每个 network namespace 来说，它会有自己独立的网卡、路由表、ARP 表、iptables 等和网络相关的资源。<code>ip</code> 命令提供了 <code>ip netns exec</code> 子命令可以在对应的 network namespace 中执行命令，比如我们要看一下这个 network namespace 中有哪些网卡。更棒的是，<strong>要执行的可以是任何命令，不只是和网络相关的</strong>（当然，和网络无关命令执行的结果和在外部执行没有区别）。比如下面例子中，执行 <code>bash</code> 命令了之后，后面所有的命令都是在这个 network namespace 中执行的，好处是不用每次执行命令都要把 <code>ip netns exec NAME</code> 补全，缺点是你无法清楚知道自己当前所在的 <code>shell</code>，容易混淆。</p><pre><code class="bash">[root@localhost ~]# ip netns exec net1 ip addr1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00[root@localhost ~]# ip netns exec net1 bash[root@localhost ~]# ip addr1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00[root@localhost ~]# exitexit</code></pre><p><strong>更新</strong>：通过修改 bash 的前缀信息可以区分不同 shell，操作如下：</p><pre><code class="bash">$ ip netns exec ns1 /bin/bash --rcfile &lt;(echo &quot;PS1=\&quot;namespace ns1&gt; \&quot;&quot;)namespace ns1&gt; ping www.google.comPING www.google.com (178.60.128.38) 56(84) bytes of data.64 bytes from cache.google.com (178.60.128.38): icmp_seq=1 ttl=58 time=17.6 ms</code></pre><p><code>ip netns exec</code> 后面跟着 namespace 的名字，比如这里的 <code>net1</code>，然后是要执行的命令，只要是合法的 shell 命令都能运行，比如上面的 <code>ip addr</code> 或者 <code>bash</code>。</p><p>每个 namespace 在创建的时候会自动创建一个 <code>lo</code> 的 interface，它的作用和 linux 系统中默认看到的 <code>lo</code> 一样，都是为了实现 loopback 通信。如果希望 <code>lo</code> 能工作，不要忘记启用它：</p><pre><code class="bash">[root@localhost ~]# ip netns exec net1 ip link set lo up</code></pre><p>默认情况下，network namespace 是不能和主机网络，或者其他 network namespace 通信的。</p><h2 id="network-namespace-之间通信"><a href="#network-namespace-之间通信" class="headerlink" title="network namespace 之间通信"></a>network namespace 之间通信</h2><p>有了不同 network namespace 之后，也就有了网络的隔离，但是如果它们之间没有办法通信，也没有实际用处。要把两个网络连接起来，linux 提供了 <code>veth pair</code> 。可以把 <code>veth pair</code> 当做是双向的 pipe（管道），从一个方向发送的网络数据，可以直接被另外一端接收到；或者也可以想象成两个 namespace 直接通过一个特殊的虚拟网卡连接起来，可以直接通信。</p><p>使用上面提到的方法，我们再创建另外一个 network namespace，这里我们使用 <code>net0</code> 和 <code>net1</code> 两个名字。</p><p>我们可以使用 <code>ip link add type veth</code> 来创建一对 veth pair 出来，需要记住的是 veth pair 无法单独存在，删除其中一个，另一个也会自动消失。</p><pre><code class="bash">[root@localhost ~]# ip link add type veth[root@localhost ~]# ip link4: veth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000    link/ether 36:88:73:83:c9:64 brd ff:ff:ff:ff:ff:ff5: veth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000    link/ether fe:7e:75:4d:79:2e brd ff:ff:ff:ff:ff:ff</code></pre><p><strong>小知识</strong>: 创建 veth pair 的时候可以自己指定它们的名字，比如 <code>ip link add vethfoo type veth peer name vethbar</code> 创建出来的两个名字就是 <code>vethfoo</code> 和 <code>vethbar</code> 。因为这里我们对名字没有特殊要求，所以就直接使用系统自动生成的名字。如果 pair 的一端接口处于 DOWN 状态，另一端能自动检测到这个信息，并把自己的状态设置为 <code>NO-CARRIER</code>。</p><p>创建结束之后，我们能看到名字为 <code>veth0</code> 和 <code>veth1</code> 两个网络接口，名字后面的数字是系统自动生成的。接下来，要做的是把这对 veth pair 分别放到已经两个 namespace 里面，这个可以使用 <code>ip link set DEV netns NAME</code> 来实现：</p><pre><code class="bash">[root@localhost ~]# ip link set veth0 netns net0[root@localhost ~]# ip link set veth1 netns net1[root@localhost ~]# ip netns exec net0 ip addr1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:004: veth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000    link/ether 36:88:73:83:c9:64 brd ff:ff:ff:ff:ff:ff[root@localhost ~]# ip netns exec net1 ip addr1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:005: veth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000    link/ether fe:7e:75:4d:79:2e brd ff:ff:ff:ff:ff:ff</code></pre><p>最后，我们给这对 veth pair 配置上 ip 地址，并启用它们。</p><pre><code class="bash">[root@localhost ~]# ip netns exec net0 ip link set veth0 up[root@localhost ~]# ip netns exec net0 ip addr add 10.0.1.1/24 dev veth0[root@localhost ~]# ip netns exec net0 ip route10.0.1.0/24 dev veth0  proto kernel  scope link  src 10.0.1.1[root@localhost ~]# ip netns exec net1 ip link set veth1 up[root@localhost ~]# ip netns exec net1 ip addr add 10.0.1.2/24 dev veth1</code></pre><p>可以看到，最每个 namespace 中，在配置玩 ip 之后，还自动生成了对应的路由表信息，网络 <code>10.0.1.0/24</code> 数据报文都会通过 veth pair 进行传输。使用 <code>ping</code> 命令可以验证它们的连通性：</p><pre><code class="bash">[root@localhost ~]# ip netns exec net0 ping -c 3 10.0.1.2PING 10.0.1.2 (10.0.1.2) 56(84) bytes of data.64 bytes from 10.0.1.2: icmp_seq=1 ttl=64 time=0.039 ms64 bytes from 10.0.1.2: icmp_seq=2 ttl=64 time=0.039 ms64 bytes from 10.0.1.2: icmp_seq=3 ttl=64 time=0.139 ms--- 10.0.1.2 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2004msrtt min/avg/max/mdev = 0.039/0.072/0.139/0.047 ms</code></pre><p>完成这些，我们创建的网络拓扑结构如下所示：</p><p>![网络拓扑图](linux 网络虚拟化： network namespace 简介/728b3d6dgy1fcl8ox6rsyj213o0f8ab7.jpg)</p><h2 id="使用-bridge-连接不同的-namespace"><a href="#使用-bridge-连接不同的-namespace" class="headerlink" title="使用 bridge 连接不同的 namespace"></a>使用 bridge 连接不同的 namespace</h2><p>虽然 veth pair 可以实现两个 network namespace 之间的通信，但是当多个 namespace 需要通信的时候，就无能为力了。<br>讲到多个网络设备通信，我们首先想到的交换机和路由器。因为这里要考虑的只是同个网络，所以只用到交换机的功能。linux 当然也提供了虚拟交换机的功能，我们还是用 <code>ip</code> 命令来完成所有的操作。</p><p><strong>NOTE</strong>：和 bridge 有关的操作也可以使用命令 <code>brctl</code>，这个命令来自 <code>bridge-utils</code> 这个包，读者可以根据自己的发行版进行安装，使用方法请查阅 man 页面或者相关文档。</p><p>首先我们来创建需要的 bridge，简单起见名字就叫做 <code>br0</code>。</p><pre><code class="bash">[root@localhost ~]# ip link add br0 type bridge[root@localhost ~]# ip link set dev br0 up</code></pre><p>下面只演示一个 namespace 的操作，其他 namespace 要做的事情和这个类似。创建 veth pair：</p><pre><code class="bash">[root@localhost ~]# ip link add type veth</code></pre><p>把其中一个 veth（veth1） 放到 net0 里面，设置它的 ip 地址并启用它：</p><pre><code class="bash">[root@localhost ~]# ip link set dev veth1 netns net0[root@localhost ~]# ip netns exec net0 ip link set dev veth1 name eth0[root@localhost ~]# ip netns exec net0 ip addr add 10.0.1.1/24 dev eth0[root@localhost ~]# ip netns exec net0 ip link set dev eth0 up</code></pre><p>最后，把另一个 veth（veth0）连接到创建的 bridge 上，并启用它：</p><pre><code class="bash">[root@localhost ~]# ip link set dev veth0 master br0[root@localhost ~]# ip link set dev veth0 up</code></pre><p>可以通过 <code>bridge</code> 命令（也是 iproute2 包自带的命令）来查看 bridge 管理的 link 信息：</p><pre><code class="bash">[root@localhost ~]# bridge link17: veth0 state UP : &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master br0 state forwarding priority 32 cost 2</code></pre><p>最后通过 ping 命令来测试网络的连通性：</p><pre><code class="bash">[root@localhost ~]# ip netns exec net0 ping -c 3 10.0.1.3PING 10.0.1.3 (10.0.1.3) 56(84) bytes of data.64 bytes from 10.0.1.3: icmp_seq=1 ttl=64 time=0.251 ms64 bytes from 10.0.1.3: icmp_seq=2 ttl=64 time=0.047 ms64 bytes from 10.0.1.3: icmp_seq=3 ttl=64 time=0.046 ms--- 10.0.1.3 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2008ms</code></pre><p>下图是这部分网络的拓扑结构，如果对 docker 网络熟悉的话，其实这和 docker 默认的 bridge 网络模型非常相似。当然要实现每个 namespace 对外网的访问还需要额外的配置（设置默认网关，开启 ip_forward，为网络添加 NAT 规则等）。</p><p>![网络拓扑图](linux 网络虚拟化： network namespace 简介/728b3d6dgy1fcl8khvmjfj21hc0u0770.jpg)</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实战</title>
      <link href="/2020/01/29/python%E5%AE%9E%E6%88%98/"/>
      <url>/2020/01/29/python%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、串口调试助手"><a href="#一、串口调试助手" class="headerlink" title="一、串口调试助手"></a>一、串口调试助手</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>工具列表：</p><table><thead><tr><th align="center">工具</th><th align="center">功能</th><th align="center">下载地址</th></tr></thead><tbody><tr><td align="center">Python 3.7.4</td><td align="center">Python官方包（解释器）</td><td align="center"><a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></td></tr><tr><td align="center">pySerial 3.4</td><td align="center">Serial Port访问的Python封装库</td><td align="center"><a href="https://pypi.org/project/pyserial/" target="_blank" rel="noopener">https://pypi.org/project/pyserial/</a> <a href="https://github.com/pyserial/pyserial" target="_blank" rel="noopener">https://github.com/pyserial/pyserial</a> <a href="https://pythonhosted.org/pyserial/" target="_blank" rel="noopener">https://pythonhosted.org/pyserial/</a></td></tr><tr><td align="center">wxPython 4.0.4</td><td align="center">跨平台开源GUI库 <a href="https://www.wxwidgets.org/" target="_blank" rel="noopener">wxWidgets</a> 的Python封装库</td><td align="center"><a href="https://www.wxpython.org/" target="_blank" rel="noopener">https://www.wxpython.org/</a> <a href="https://pypi.org/project/wxPython/" target="_blank" rel="noopener">https://pypi.org/project/wxPython/</a></td></tr><tr><td align="center">wxFormBuilder 3.8.0</td><td align="center">wxPython GUI界面构建工具</td><td align="center"><a href="https://github.com/wxFormBuilder/wxFormBuilder" target="_blank" rel="noopener">https://github.com/wxFormBuilder/wxFormBuilder</a></td></tr><tr><td align="center">PyCharm Community 2019.3.1</td><td align="center">一款流行的Python集成开发环境</td><td align="center"><a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/</a></td></tr><tr><td align="center">PyInstaller 3.5</td><td align="center">Python应用程序打包工具</td><td align="center"><a href="http://www.pyinstaller.org/" target="_blank" rel="noopener">http://www.pyinstaller.org/</a> <a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="noopener">https://github.com/pyinstaller/pyinstaller</a></td></tr><tr><td align="center">vspd 9</td><td align="center">虚拟串口驱动，可以在PC上虚拟出Serial Port</td><td align="center"><a href="https://www.eltima.com/products/vspdxp/" target="_blank" rel="noopener">https://www.eltima.com/products/vspdxp/</a></td></tr><tr><td align="center">sscom 5.13.1</td><td align="center">大虾和丁丁联合推出的一款很流行的串口调试工具</td><td align="center"><a href="http://www.daxia.com/sscom/" target="_blank" rel="noopener">http://www.daxia.com/sscom/</a></td></tr></tbody></table><p>pip：</p><pre><code class="python">#升级pippython -m pip install --upgrade pip#查看需要升级的包pip list --outdated#pip升级包  建议通过Anaconda Navigator升级pip install --upgrade 要升级的包名</code></pre><p>安装包：</p><pre><code class="python">#串口pip install pyserial#跨平台GUI库wxWidgets的python版pip install wxPython#打包发布工具pip install pyinstaller</code></pre><p>单纯使用wxPython设计GUI界面时仅能是手工写代码布局，我们需要一款可视化的界面设计工具，本文选择的是wxFormBuilder，从其github官网下载安装包并安装。安装完成打开软件便可在Designer里尽情创作界面，创作完成后点击”Python”便可看到Python GUI源代码，这个GUI源代码后续直接复制到工程里使用。</p><h3 id="2、界面设计"><a href="#2、界面设计" class="headerlink" title="2、界面设计"></a>2、界面设计</h3><p>在真正进入代码设计界面前，首先应该在纸上画一个界面草图，确定应该有哪些元素构成，这些元素分别位于界面上什么位置。下面是界面简图，界面主要包括三大部分：接收区、配置区、发送区，接收区用于显示从串口接收到的数据；配置区用于配置串口参数；发送区用于编辑要从串口发送出去的数据。</p><p><img src="//NU-LL.github.io/2020/01/29/python实战/640.webp" alt="界面简图"></p><p>下一步需要将设计简图解析成如下的wxPython组件图，将简图里的元素转换成wxPython里的真实组件。这一步需要配合查阅wxPython相关手册，了解wxPython有哪些组件。</p><p>有一个地方需要特别提醒的是，wxWrapSizer里的控件是从左到右自上而下排列的，有的时候为了排版，会故意插入一些无效的wxStaticText来占位，下图中便用了4个占位的wxStaticText（浅色框表示）。</p><p><img src="//NU-LL.github.io/2020/01/29/python实战/640-1580308847803.webp" alt="wxPython组件图"></p><p>下面便可以在wxFormBuilder里照样子创作出真正的界面了。</p><h4 id="2-1wxFormBuilder入门"><a href="#2-1wxFormBuilder入门" class="headerlink" title="2.1wxFormBuilder入门"></a>2.1wxFormBuilder入门</h4><ul><li>wxWidgets项目官方主页: <a href="https://www.wxwidgets.org/" target="_blank" rel="noopener">https://www.wxwidgets.org/</a></li><li>wxPython项目官方主页: <a href="https://www.wxpython.org/" target="_blank" rel="noopener">https://www.wxpython.org/</a></li></ul><p>wxWidgets的各种UI控件功能均是通过class来实现的，这个链接 <a href="http://docs.wxwidgets.org/3.0/page_class_cat.html" target="_blank" rel="noopener">http://docs.wxwidgets.org/3.0/page_class_cat.html</a> 列出了wxWidgets里的所有class，wxPython并没有实现wxWidgets里全部class，但基本实现了大部分常用class，这个链接 <a href="https://docs.wxpython.org/wx.1moduleindex.html" target="_blank" rel="noopener">https://docs.wxpython.org/wx.1moduleindex.html</a> 列出了wxPython里所有的class。</p><h5 id="2-1-1基础布局"><a href="#2-1-1基础布局" class="headerlink" title="2.1.1基础布局"></a>2.1.1基础布局</h5><p>一个GUI的基础框架包括：<code>Frame</code>（外围轮廓）、<code>Sizer</code>（内部控件区）、<code>menubar</code>（顶部菜单栏）、<code>statusBar</code>（底部状态栏）。</p><p>第一步是添加一个Frame，这是GUI的轮廓基础，其size（default为500； 300）决定了GUI整体界面的大小。</p><p>第二步是在Frame下添加一个Sizer，后续所有控件均是放在Sizer里的。关于Sizer部分需要特别说明一下，wxPython提供的Sizer类型有如下七种：<code>wxBoxSizer</code>、<code>wxWrapSizer</code>、<code>wxStaticBoxSizer</code>、<code>wxGridSizer</code>、<code>wxFlexGridSizer</code>、<code>wxGridBagSizer</code>、<code>wxStdDialogButtonSizer</code>，Sizer的样式决定了后续控件的整体相对位置关系，选定了Sizer即选定了GUI界面样式。关于这七种Sizer的具体样式请见 <a href="https://docs.wxpython.org/sizers_overview.html#sizers-overview" target="_blank" rel="noopener">https://docs.wxpython.org/sizers_overview.html#sizers-overview</a>。如果你觉得单个Sizer里的控件布局太单调，你可以嵌套使用Sizer，这是实现GUI界面控件布局多样化的关键。</p><ul><li>wxBoxSizer：自上而下布局，因此里边的控件在Sizer是自上而下排列的，各个控件的位置后续在属性里还可以微调，但改变不了自上而下的格局。（可以在属性栏中调整是垂直或水平布置其子级）</li><li>wxWrapSizer：暂时猜测是自左向右，自上向下的布局，会随着界面的拉伸而改变</li><li>wxStaticBoxSizer：与wxBoxSizer相似，但由一个静态框包围。</li><li>wxGridSizer：一个二维大小调整器。所有子项都具有相同的大小，为最大子项的大小（可以通过属性调整行列大小）。</li><li>wxFlexGridSizer：从wxGridSizer派生的另一个二维sizer。每列的宽度和每行的高度是根据相应行列最大子元素的最低要求分别计算的。此外，如果为sizer分配了与其请求的大小不同的大小，则可以将列和行属性设为可拉伸的。</li><li>wxGridBagSizer：与其他类不同，它可以直接将元素放在sizer中的给定位置。</li><li>wxStdDialogButtonSizer：</li></ul><p>第三步是在Frame顶部添加一个<code>menubar</code></p><p>第四步是在Frame底部添加一个<code>statusBar</code></p><h5 id="2-1-2控件"><a href="#2-1-2控件" class="headerlink" title="2.1.2控件"></a>2.1.2控件</h5><p>基础布局搞定之后，接下来便是在Sizer里添加控件，wxPython支持的控件非常丰富，其中比较常用的是如下几个：<code>button</code>（按钮）、<code>staticText</code>（静态显示文本框）、<code>textCtrl</code>（输入输出文本框）、<code>Choice</code>（复选框）、<code>checkBox</code>（选中框）、<code>slider</code>（滑动条）。前面痞子衡选择的Sizer是wxBoxSizer，即自上而下布局，因此这些控件在Sizer是自上而下排列的，各个控件的位置后续在属性里还可以微调，但改变不了自上而下的格局。</p><h5 id="2-1-3属性"><a href="#2-1-3属性" class="headerlink" title="2.1.3属性"></a>2.1.3属性</h5><ul><li>name：在后续python代码的对象名，一般需要按其功能修改，修改后使得代码阅读/修改起来更直观</li><li>label：在GUI里显示的标签名，也需要按其功能修改，方便用户使用软件</li><li>size：控件尺寸，这个尺寸最大不应超过Sizer尺寸</li><li>flag：调整对齐方式从而调整控件在Sizer里的位置</li></ul><p>另外有一个属性不得不说，即控件位置<code>pos</code>，在wxFormBuilder里设置这个属性并不生效，猜想可能跟Sizer样式有关，因为Sizer决定了控件间相对位置关系，因此控件的pos不能随意设置。 </p><h5 id="2-1-4生成代码"><a href="#2-1-4生成代码" class="headerlink" title="2.1.4生成代码"></a>2.1.4生成代码</h5><p>当GUI界面布局全部完成之后，需选择File-&gt;Generate Code或F8生成python代码，需要复制所有的python代码并保存在单独的文件里（其中Frame class名为com_win），并存放于\pzh-py-com\src目录下，此时需要另外新建一个名为main的主函数文件，并放在\pzh-py-com\src目录下。其中main文件内容如下：</p><pre><code class="python">import wximport sys, osimport winclass mainWin(win.com_win):    def clearRecvDisplay( self, event ):        event.Skip()    def openClosePort( self, event ):        event.Skip()    def clearSendDisplay( self, event ):        event.Skip()    def sendData( self, event ):        self.m_textCtrl_recv.Clear()        self.m_textCtrl_recv.SetValue(&#39;hello world&#39;)if __name__ == &#39;__main__&#39;:    app = wx.App()    main_win = mainWin(None)    main_win.SetTitle(u&quot;PyCOM v0.1.0&quot;)    main_win.Show()    app.MainLoop()</code></pre><p>main.py里并没有实现具体功能，只有一个hello world打印的效果，此处只是演示界面已经创建成功，界面运行效果如下：</p><h3 id="3、串口功能实现"><a href="#3、串口功能实现" class="headerlink" title="3、串口功能实现"></a>3、串口功能实现</h3><p>pySerial是一套基于python实现serial port访问的库，使用非常简单，可在其官网浏览一遍其提供的API： <a href="https://pythonhosted.org/pyserial/pyserial_api.html" target="_blank" rel="noopener">https://pythonhosted.org/pyserial/pyserial_api.html</a>，下面整理了比较常用的API如下：</p><pre><code class="python">class Serial(SerialBase):    # 初始化串口参数    def __init__(self, *args, **kwargs):    # 打开串口    def open(self):    # 关闭串口    def close(self):    # 获取串口打开状态    def isOpen(self):    # 设置input_buffer/output_buffer大小    def set_buffer_size(self, rx_size=4096, tx_size=None):    # 获取input_buffer（接收缓冲区）里的byte数据个数    def inWaiting(self):    # 从串口读取size个byte数据    def read(self, size=1):    # 清空input_buffer    def reset_input_buffer(self):    # 向串口写入data里所有数据    def write(self, data):    # 等待直到output_buffer里的数据全部发送出去    def flush(self):    # 清空output_buffer    def reset_output_buffer(self):</code></pre><p>　　pySerial常用参数整理如下，需要特别强调的是任何运行时刻对如下参数进行修改，均是直接应用生效的，不需要重新调用open()和close()去激活。</p><table><thead><tr><th>参数名</th><th>功能解释</th><th>备注/可设值</th></tr></thead><tbody><tr><td>port</td><td>设备名</td><td>/dev/ttyUSB0 on GNU/Linux or COM3 on Windows</td></tr><tr><td>baudrate (int)</td><td>波特率</td><td>/</td></tr><tr><td>bytesize</td><td>数据位bit个数</td><td>FIVEBITS, SIXBITS, SEVENBITS, EIGHTBITS</td></tr><tr><td>stopbits</td><td>停止位</td><td>STOPBITS_ONE, STOPBITS_ONE_POINT_FIVE, STOPBITS_TWO</td></tr><tr><td>parity</td><td>奇偶校验位</td><td>PARITY_NONE, PARITY_EVEN, PARITY_ODD PARITY_MARK, PARITY_SPACE</td></tr><tr><td>timeout (float)</td><td>接收超时</td><td>None：blocking mode             0: non-blocking mode             x: 超时时间x秒</td></tr><tr><td>write_timeout (float)</td><td>发送超时</td><td>同timeout</td></tr></tbody></table><h3 id="4、打包"><a href="#4、打包" class="headerlink" title="4、打包"></a>4、打包</h3><p>在使用PyInstaller进行打包工作之前，首先需要确定你的Python应用程序所调用的所有第三方库是不是在PyInstaller支持列表里，这个主页显示了PyInstaller支持的所有第三方库： <a href="https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages" target="_blank" rel="noopener">https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages</a></p><p>在使用PyInstaller打包前必须明白一点的是，PyInstaller仅能将.py格式的源文件以及其所调用的相关Python第三方源文件库打包进最终的.exe文件，如果你的应用程序会用到图片等多媒体文件，这些多媒体文件并不能被打包，后续exe在使用时，这些多媒体文件必须一同在场，并且还要保证与打包/开发时的<strong>相对路径是一致</strong>的。</p><p>使用如下命令格式打包:</p><pre><code class="python">pystaller -F -w [src1.py] [src2.py]... -i  [pic.ico]</code></pre><ul><li><code>-F</code>的意思是将应用程序打包成单个可执行文件（与其对立的命令是-D，打包成多文件放在一个文件夹）</li><li><code>-w</code>表明要打包成窗口型（与其对立的命令是-c，控制台型）</li><li><code>[src1.py] [src2.py] [...]</code>为你自己创建的应用程序源文件(src1.py必须是含<strong>main</strong>的主函数文件)</li><li><code>-i</code>指定图标文件。</li></ul><p>打包命令成功执行之后，会生成如下文件：</p><ul><li><code>build\</code>：存放的是PyInstaller在打包过程中生成的调试信息文件</li><li><code>dist\main.exe</code>：最终的可执行文件</li><li><code>main.spec</code>：PyInstaller自动生成的命令解释文件（在命令行里输入的命令首先被翻译放到.spec文件里，然后PyInstaller主要是根据.spec文件打包）</li></ul><p>关于不会一起打包图片的情况，可以考虑通过这篇博客 <a href="https://blog.csdn.net/monster_li57/article/details/80601050" target="_blank" rel="noopener">pyinstaller打包——图片资源无法显示问题</a> 实现，思路大概原理是事先将图片编码存到.py源文件里，这样在打包时便可将这个图片数据.py源文件直接打包进exe文件，后续在运行时首先将图片数据解码出来并在本地保存为临时图片，等图片加载完成之后可以删除临时图片文件。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2020/01/16/Docker/"/>
      <url>/2020/01/16/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="一、环境搭建（Ubuntu-18-04）"><a href="#一、环境搭建（Ubuntu-18-04）" class="headerlink" title="一、环境搭建（Ubuntu 18.04）"></a>一、环境搭建（Ubuntu 18.04）</h2><p>本文前期Docker环境为：Windows10 1809 企业版 + VMware Workstation 15 Pro + Ubuntu 18.04.2LTS</p><p>后期Kubernetes环境为：Windows10 1809 企业版 + Vagrant 2.2.7 + VirtualBox 6.1.4 + centos7/Ubuntu 18.04 LTS</p><h3 id="Vagrant-VirtualBox"><a href="#Vagrant-VirtualBox" class="headerlink" title="Vagrant+VirtualBox"></a>Vagrant+VirtualBox</h3><p>下载Vagrant安装包：<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">官网链接</a></p><p>下载VirtualBox安装包：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">官网链接</a>，不过VirtualBox下载需要梯子，可以通过<a href="https://mirror.tuna.tsinghua.edu.cn/help/virtualbox/" target="_blank" rel="noopener">清华镜像</a>下载</p><p>vagrant的相关image可以通过<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">该网址</a>进行搜索</p><p>上述两个软件均傻瓜式安装即可，可以通过下面的方法利用Vagrant在VirtualBox中创建虚拟机：</p><pre><code class="powershell">#查看Vagrant版本vagrant -v#创建目录mkdir centos7####################创建centos 7的镜像##############################初始化一个centos7的Vagrant file（类似于makefile）vagrant init centos/7#创建centos7的虚拟机，此处会下载image，时间较久vagrant up####################创建ubuntu的镜像##############################初始化一个Ubuntu 18.04 LTS的Vagrant filevagrant init ubuntu/bionic64#创建Ubuntu 18.04 LTS的虚拟机，此处会下载image，时间较久vagrant up####################国内镜像源 创建ubuntu的镜像##############################初始化一个Ubuntu 18.04 LTS的Vagrant filevagrant init ubuntu/bionic64#采用清华镜像 vagrant box add https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/bionic-server-cloudimg-amd64-vagrant.box --name ubuntu/bionic64#创建Ubuntu 18.04 LTS的虚拟机，此处会下载image，时间较久vagrant up</code></pre><ul><li>注意：如需换成其他镜像需要自己去<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/" target="_blank" rel="noopener">清华镜像</a>（有可能没有）中查找对应的<code>box</code>文件</li><li>也可以采取用其他方式下载<code>box</code>文件（如百度网盘），再通过命令行添加，详细方法即相关地址可以参考<a href="https://c4ys.com/archives/1230" target="_blank" rel="noopener">这篇博客</a></li><li>如果Windows用户名是中文，则可能在<code>vagrant up</code>这一步报<code>incompatible character encodings: GBK and UTF-8 (Encoding::CompatibilityError)</code>类似错误，具体方法详见<a href="https://blog.csdn.net/eebaicai/article/details/82148901?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">这篇博客</a>，概括为以下几步：<ul><li>设置环境变量VAGRANT_HOME为不包含中文的路径，该环境变量是用于保存Vagrant下载的<code>box</code>镜像文件（具体路径为<code>$(VAGRANT_HOME)/.vagrant.d</code>）</li><li>修改VirtualBox中全局配置选项中的 默认虚拟电脑位置VirtualBox VMs的路径 ，不能包含中文名</li></ul></li><li>注意Vagrant和VirtualBox版本需要匹配，有的版本不匹配可能会报各种错误，本文中测试一切正常</li><li>默认Vagrant当前配置为在启用<code>SharedFoldersEnableSymlinksCreate</code>选项的情况下创建VirtualBox同步的文件夹。 如果不信任Vagrant访客，则可能要禁用此选项。 有关此选项的更多信息，请参考<a href="https://www.virtualbox.org/manual/ch04.html#sharedfolders" target="_blank" rel="noopener">VirtualBox手册</a>。<ul><li>可以通过环境变量全局禁用此选项：<code>VAGRANT_DISABLE_VBOXSYMLINKCREATE = 1</code></li><li>在Vagrantfile中配置如下代码：<code>config.vm.synced_folder &#39;/host/path&#39;, &#39;/guest/path&#39;, SharedFoldersEnableSymlinksCreate: false</code></li></ul></li></ul><p>通过Vagrant命令进入centos7中的shell：</p><pre><code class="powershell">vagrant ssh</code></pre><p>如果想通过其他方式登录虚拟机（如：Xshell），可以通过如下命令获取hostname、port、IdentityFile三个配置信息：</p><pre><code class="powershell">E:\Ubuntu&gt;vagrant ssh-configHost default  HostName 127.0.0.1  User vagrant  Port 2222  UserKnownHostsFile /dev/null  StrictHostKeyChecking no  PasswordAuthentication no  IdentityFile E:/Ubuntu/.vagrant/machines/default/virtualbox/private_key  IdentitiesOnly yes  LogLevel FATAL</code></pre><p>其中：HostName为主机IP地址，Port为开放的端口，IdentityFile为Public Key秘钥文件的路径，依次填入其他软件的相应设置中即可访问该虚拟机</p><p>另外，该虚拟机默认登录账号用户名为vagrant，密码为vagrant，root账号密码为vagrant。也有可能没有root密码，需要通过<code>sudo passwd</code>命令重设密码</p><blockquote><p>附：ubuntu18.04换清华源：</p><p>编辑<code>/etc/apt/sources.list</code>文件，修改为以下内容</p><pre><code class="bash"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></blockquote><h3 id="安装Docker-Engine-Community"><a href="#安装Docker-Engine-Community" class="headerlink" title="安装Docker Engine - Community"></a>安装Docker Engine - Community</h3><p>官方文档教程详见<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">这里</a></p><p>设置源</p><pre><code class="bash">#更新sudo apt-get update#安装依赖sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common#添加Docker官方GPG秘钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -#添加Docker源sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code></pre><blockquote><p>由于Docker官方源不稳定，推荐国内源：</p><ul><li>docker官方中国区 <code>https://registry.docker-cn.com</code></li><li>网易 <code>http://hub-mirror.c.163.com</code></li><li>ustc <code>http://docker.mirrors.ustc.edu.cn</code></li><li>阿里云 <code>http://&lt;你的ID&gt;.mirror.aliyuncs.com</code></li></ul><p>ustc帮助文档：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><pre><code class="bash">sudo vi /etc/docker/daemon.json#添加以下内容 注意不能是https 否则最后一点下载不下来{    &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot;],    ......}#重启docker服务service docker restart</code></pre></blockquote><p>安装</p><pre><code class="bash">#安装Docker Engine - Communitysudo apt-get update#安装最新版sudo apt-get install docker-ce docker-ce-cli containerd.io#验证sudo docker versionsudo docker run hello-world</code></pre><blockquote><p>或者自己选择版本安装</p><pre><code class="bash">apt-cache madison docker-cesudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></pre></blockquote><p>卸载Docker Engine - Community</p><pre><code class="bash">sudo apt-get purge docker-ce#删除所有镜像，容器和卷(volumes)：sudo rm -rf /var/lib/docker</code></pre><h2 id="二、Docker的镜像和容器"><a href="#二、Docker的镜像和容器" class="headerlink" title="二、Docker的镜像和容器"></a>二、Docker的镜像和容器</h2><h3 id="架构和底层"><a href="#架构和底层" class="headerlink" title="架构和底层"></a>架构和底层</h3><ul><li>Docker是一个平台，提供一个开发、打包、运行app的平台</li><li>把app和底层设备隔离开</li></ul><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200204233756060.png" alt="Docker架构"></p><p>Docker Engine：</p><ul><li>后台进程（dockerd）<ul><li>提供 REST API 的服务（Server）<ul><li>提供 CLI（client，客户端）</li></ul></li><li>C-S架构</li></ul></li></ul><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200204233846121.png" alt="Docker Engine"></p><p>整体架构：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200204234359788.png" alt="整体架构"></p><ul><li>Client：Docker提供的命令（可以和host在一台机器上）</li><li>Docker Host：启动了dockerd的机器<ul><li>images</li><li>containers</li></ul></li><li>Registry：库，类似于GitHub</li></ul><p>docker底层技术支持：</p><ul><li>Namespaces:隔离pid、net、ipc、mnt、uts</li><li>Control groups:做资源限制</li><li>Union file systems:Container和 nimage的分层</li></ul><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>官方命令手册：<a href="https://docs.docker.com/engine/reference/commandline/image/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/image/</a></p><ul><li>文件和 meta data的集合( root filesystem)</li><li>分层的,并且每一层都可以添加改变删除文件,成为一个新的image</li><li>不同的image可以共享相同的 layer</li><li>Image本身是read-only的</li></ul><p>Dockerfile：通过该文件定义一个image并能够构建该image</p><p>BaseImge：直接基于Linux的内核，在内核上制作的一个镜像（如各种Linux的发行版：ubuntu、centos等），可以在该镜像上在制作一个新的image</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200205000255254.png" alt="image-20200205000255254"></p><p>常用命令：</p><pre><code class="bash">#使docker前不需要加sudosudo groupadd docker#新建一个组sudo gpasswd -a 用户名 组名#添加用户到组sudo service docker restart#重启docker#查看dockerhub上的镜像sudo docker search image名字#查看本机上的镜像sudo docker image lssudo docker images#从Dockerhub上拉取sudo docker pull ubuntu:14.04#从Dockerhub上xxx处拉取（第三方）sudo docker pull ubuntu:14.04/XXX#运行dockersudo docker run image名字sudo docker run -d image名字#后台运行sudo docker run -d -e PENG=xxxx image名字#后台运行，且设置一个PENG的环境变量，值为xxxx#交互式的运行docker，并进入其控制台sudo docker run -it image名字#查看本机上的在运行的容器（正在运行的，常驻内存）sudo docker container ls#查看本机上所有的容器（正在运行的和已经退出的）sudo docker container ls -asudo docker container ls -aq#列出所有的idsudo docker ps -a#删除contaninersudo docker container rm idsudo docker rm idsudo docker rm $(sudo docker container ls -aq)#删除所有#停止contaninersudo docker container stop idsudo docker stop id#删除imagesudo docker image rm idsudo docker rmi id#显示容器的详细信息sudo docker inspect id#查看容器运行的输出logsudo docker logs id或--name指定的名字</code></pre><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>官方命令手册：<a href="https://docs.docker.com/engine/reference/commandline/container/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/container/</a></p><ul><li>通过image创建(copy)</li><li>在image layer之上建立一个container layer(可读写)</li><li>类比面向对象:类（image）和实例（container）</li><li>Image负责app的存储和分发, Container负责运行app</li></ul><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200205001054091.png" alt="Container"></p><h3 id="构建自己的image"><a href="#构建自己的image" class="headerlink" title="构建自己的image"></a>构建自己的image</h3><pre><code class="bash">#基于container(xxx,名字,name)创建一个image(yyy)  不提倡，不安全sudo docker container commit xxx yyysudo docker commit xxx yyy#从dockerfile构建一个imagesudo docker image build -t tag(docker的tag) .(基于那个目录构建)sudo docker build -t tag(docker的tag) .(基于那个目录构建)#例子sudo docker build -t dockerusernull/flask-hello-world /home/null/Code/docker/helloworld/</code></pre><p><strong>调试</strong></p><p>每次构建的时候，在每一层都会生成临时容器并通过<code>--&gt;</code>显示出该容器的id，可以通过</p><pre><code class="bash">sudo docker run -it 临时容器id /bin/bash</code></pre><p><strong>运行</strong></p><pre><code class="bash">sudo docker run image名字sudo docker run -d image名字#后台运行sudo docker run -d --name=demo image名字#后台运行 并指定一个名字 否则会自动分配#停止contaninersudo docker container stop idsudo docker stop id#启动contaninersudo docker start id或名字#例子sudo docker run dockerusernull/flask-hello-world</code></pre><ul><li><code>--name</code>指定的名字具有唯一性，可以替代id用于别的命令</li><li><code>docker start</code>：只要不删除，该命令就能够重新启动stop的容器</li></ul><p><strong>exec</strong>：进运行中的容器内部，看具体的细节</p><pre><code class="bash">sudo docker exec -it 容器id /bin/bash#exec：对运行中的容器执行的命令(/bin/bash) -it：交互式的执行sudo docker exec -it 容器id ip a#打印运行中的容器的ip地址</code></pre><ul><li>不止运行/bin/bash，还可运行其他命令，如：python等</li></ul><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p><ul><li><p><code>FROM</code>：选择base image，在该base image上构建新的image</p><ul><li><code>FROM scratch</code>：从头制作base image</li><li>尽量使用官方的image作为 base image</li></ul></li><li><p><code>LABEL</code>：定义image的metadata（类似代码中的注释）</p><ul><li><pre><code class="dockerfile">  LABEL maintainer=&quot;xiaoquwl@gmail.com&quot;  LABEL version=&quot;1.0&quot;  LABEL description=&quot;This is description&quot;</code></pre></li><li><p>不可少，能够让人更加明白</p></li></ul></li><li><p><code>RUN</code>：运行命令，每一次RUN都会使image生成新的一层</p><ul><li><p>为了美观,复杂的RUN请用反斜线换行</p></li><li><p>避免无用分层,合并多条命令成一行</p></li><li><pre><code class="dockerfile">  RUN yum update &amp;&amp; yum install -y vim \      python-dev#反斜线换行  RUN apt-get update &amp;&amp; apt-get install -y perl \      pwgen --no-install-recommends &amp;&amp; rm -rf \      /var/ib/apt/ists/*#注意清理 cache   RUN /bin/bash -c &#39;source $HOME/.bashrc; echo $HOME&#39;</code></pre></li></ul></li><li><p><code>WORKDIR</code>：设定当前工作目录（类似于cd）</p><ul><li><pre><code class="dockerfile">  WORKDIR /test#如果没有会自动创建test目录  WORKDIR demo  RUN pwd#输出结果应该是/test/demo</code></pre></li><li><p>用 <code>WORKDIR</code>,不要用 <code>RUN cd</code></p></li><li><p>尽量使用绝对目录</p></li></ul></li><li><p><code>ADD</code>和<code>COPY</code>：把本地的一些文件添加到docker image中</p><ul><li><p>ADD除了拷贝的功能外还能够解压缩</p></li><li><p>大部分情况,COPY优于ADD</p></li><li><p>添加远程文件/目录请使用curl或者wget</p></li><li><pre><code class="dockerfile">  ADd hello /#简单拷贝  ADD test.tar.gz /#添加到根目录并解压  #WORKDIR和ADD联合使用  WORKDIR /root  ADD hello test/ #hello文件位置/root/test/hello   WORKDIR /root  COPY hello test/ #hello文件位置/root/test/hello </code></pre></li></ul></li><li><p><code>ENV</code>：设置一个环境变量或常量</p><ul><li><p>尽量使用ENV增加可维护性</p></li><li><pre><code class="dockerfile">  ENV MYSQL_VERSION 5.6#设置常量  RUN apt-get install -y mysql-server=&quot;${MYSQL_VERSION}&quot; \      &amp;&amp; rm -rf /var/lib/apt/lists/*#引用常量</code></pre></li></ul></li><li><p><code>VOLUME</code>和<code>EXPOSE</code>：主要用于存储和网络</p><ul><li><code>VOLUME</code>：指定在容器中某一个目录中产生的数据，同时挂载到Linux主机中的某一个目录上，并且会创建一个docker volume的对象</li><li><code>EXPOSE</code>：会将运行中的container中的端口暴露出来</li></ul></li><li><p>shell和exec格式</p><ul><li><p>shell格式：后面是shell命令</p><ul><li><pre><code class="dockerfile">  RUN apt-get install -y vim  CMD echo &quot;hello docker&quot;  ENTRYPOINT echo &quot;hello docker&quot;</code></pre></li></ul></li></ul></li></ul><pre><code>* exec格式：需要根据特点的格式指出命令和参数    * ```dockerfile        #XXX [&quot;命令&quot;,&quot;参数&quot;,...]        RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]        CMD [&quot;/bin/echo&quot;,&quot;hello docker&quot;]        ENTRYPOINT [&quot;/bin/echo&quot;,&quot;hello docker&quot;]        #以下两种输出结果不一样        ENV name Docker        ENTRYPOINT [&quot;/bin/echo&quot;,&quot;hello $name&quot;]#hello $name        ENTRYPOINT [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]#hello Docker(-c表示后面的事bash的参数)        ```</code></pre><ul><li><p><code>CMD</code>和<code>ENTRYPOINT</code>：</p><ul><li><p><code>RUN</code>:执行命令并创建新的 image Layer</p></li><li><p><code>CMD</code>:设置容器启动后默认执行的命令和参数</p><ul><li>容器启动时默认执行的命令</li><li>如果 docker run指定了其它命令,CMD命令被忽略<ul><li>此处docker run指<code>docker run 镜像名</code>，再加任意一个参数均会忽略CMD命令，如<code>docker run -it 镜像名 /bin/bash</code></li></ul></li><li>如果定义了多个CMD,只有最后一个会执行</li></ul></li><li><p><code>ENTRYPOINT</code>:设置容器启动时运行的命令</p><ul><li><p>让容器以应用程序或者服务的形式运行</p></li><li><p>不会被忽略,一定会执行</p></li><li><pre><code class="dockerfile">  #执行一个shel脚本  COPY docker-entrypoint.sh /usr/local/bin/   ENTRYPOINT [&quot;docker-entrypoint sh&quot;]</code></pre></li></ul></li></ul></li></ul><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>直接发布镜像：</p><ul><li><p>在<a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a>网站上注册账号</p></li><li><p><code>sudo docker login</code>，在本机上通过命令行登录DockerHub</p></li><li><p><code>sudo docker push 账号名/image名字:tag</code>或<code>sudo push 账号名/image名字:tag</code>往DockerHub上推</p></li></ul><p>发布Dockerfile：</p><ul><li>在DockerHub上绑定Github账号</li><li>在GitHub上分享Dockerfile</li><li>DockerHub会自动从GitHub上克隆Dockerfile</li><li>DockerHub后台服务器会自动根据Dockerfile构建image</li></ul><h3 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h3><p>不做限制的容器会尽最大可能占用物理机的资源，可以通过<code>docker run</code>命令指定对容器的限制</p><ul><li>对memory的限制<ul><li><code>--memory</code>：若只指定该参数，则swap memory也是同样大小，总共消耗内存为2*memory<ul><li>eg：sudo docker run –memory=200M 容器id</li></ul></li><li><code>--memory-swap</code>：指定swap memory参数</li></ul></li><li>对cpu的限制<ul><li><code>--cpu-shares</code>：限制相对权重，即每个容器根据该值来分配物理机上的cpu算力<ul><li>sudo docker run –cpu-shares=10 –name=test1 容器id –cpu 1</li><li>sudo docker run –cpu-shares=5 –name=test2 容器id –cpu 1</li><li>上述两个容器会按照test1：test2=2：1占用cpu</li></ul></li><li><code>--cpu</code>：利用编号指定运行的cpu</li></ul></li></ul><h3 id="实战——ubuntu上打包stress"><a href="#实战——ubuntu上打包stress" class="headerlink" title="实战——ubuntu上打包stress"></a>实战——ubuntu上打包stress</h3><h4 id="python常驻程序"><a href="#python常驻程序" class="headerlink" title="python常驻程序"></a>python常驻程序</h4><p>新建Dockerfile：</p><pre><code class="dockerfile">FROM python:2.7LABEL maintainer=&quot;NULL&quot;WORKDIR /pyappRUN pip install flaskCOPY app.py /pyappEXPOSE 5000CMD python app.py</code></pre><ul><li><code>EXPOSE</code>：在此处代表要暴露出去的端口</li><li><code>CMD</code>：此处用于表示之后一直运行的程序</li></ul><h4 id="ubuntu上打包stress"><a href="#ubuntu上打包stress" class="headerlink" title="ubuntu上打包stress"></a>ubuntu上打包stress</h4><p>新建Dockerfile：</p><pre><code class="dockerfile">FROM ubuntuRUN apt-get updata &amp;&amp; apt-get install -y stressENTRYPOINT [&quot;/user/bin/stress&quot;]CMD []</code></pre><ul><li><code>ENTRYPOINT</code>：在此处代表要执行的命令</li><li><code>CMD</code>：此处用于接受之后docker run后的参数，传递给<code>ENTRYPOINT</code>指定的命令<ul><li>可以在<code>[]</code>中指定默认的参数</li></ul></li></ul><h2 id="三、docker网络"><a href="#三、docker网络" class="headerlink" title="三、docker网络"></a>三、docker网络</h2><p>docker网络分类：</p><ul><li>单机网络<ul><li><strong>Bridge Network</strong></li><li>Host Network</li><li>None Network</li></ul></li><li>多机网络<ul><li>Overlay Network</li></ul></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>整个网络的数据传输是通过<strong>数据包</strong>的形式来传输的</p><p>数据包的打包有一个分层的概念，即ISO/OSI的七层模型和TCP/IP的五层模型：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200209142623011.png" alt="网络分层"></p><p>数据包到达另一台电脑或服务器，需要通过<strong>路由</strong></p><p>IP地址：设备的标识</p><ul><li>公有IP：互联网上的唯一标识,可以访问 Internet</li><li>私有IP：不可在互联网上使用,仅供机构内部使用</li><li>ABC三类ip地址：<a href="https://blog.csdn.net/kzadmxz/article/details/73658168" target="_blank" rel="noopener">https://blog.csdn.net/kzadmxz/article/details/73658168</a></li></ul><p>私有IP地址访问互联网，需要<strong>网络地址转换</strong>，即<strong>NAT</strong></p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200209150545483.png" alt="网络地址转换"></p><p>Linux命令：</p><ul><li><code>ping</code>：<strong>检查ip的可达性</strong>，ping不通不能保证机器出问题了，可能是中间路由或者防火墙等其他某一环节出问题了</li><li><code>telnet</code>：<strong>检查服务的可用性</strong></li></ul><h3 id="Linux中network-namespace"><a href="#Linux中network-namespace" class="headerlink" title="Linux中network namespace"></a>Linux中network namespace</h3><p>每创建一个container，会同时创建一个network namespace</p><pre><code class="bash">#查看本机network namespacesudo ip netns list#删除本机network namespacesudo ip netns delete xxxx#添加network namespacesudo ip netns add xxxx#在xxxx这个network namespace中执行命令sudo ip netns exec xxxx ip asudo ip netns exec xxxx ip linksudo ip netns exec xxxx ip link set dev lo up#将xxxx中的lo网卡up</code></pre><p>其他相关命令和知识可以参考<a href="https://cizixs.com/2017/02/10/network-virtualization-network-namespace/" target="_blank" rel="noopener">这篇博客</a>，如链接消失，可见我博客中的备份</p><h3 id="Docker-Bridge0详解"><a href="#Docker-Bridge0详解" class="headerlink" title="Docker Bridge0详解"></a>Docker Bridge0详解</h3><p>即bridge Network。</p><p>建议参考上一小节中提到的博客</p><pre><code class="bash">#列出当前docker中有哪些网络sudo docker network ls#列出bridge的详细情况，通过Containers一栏可以看出哪个container连接上该bridgesudo docker network inspect bridge#列出本机上bridge的相关信息，可以通过该命令看出docker0网卡接上了那个veth接口brctl show</code></pre><p>两个容器之间相互通信的情况：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200210150411463.png" alt="image-20200210150411463"></p><ul><li>蓝色框框为两个容器</li><li>绿色的一对为veth（虚拟网络接口）</li><li>docker容器中会连接到主机的docker0网卡上</li></ul><p>单个容器访问internet的情况：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200210150701170.png" alt="image-20200210150701170"></p><ul><li>主机通过eth0访问外网</li><li>docker0中的数据通过NAT（网络地址转换）转换到eth0中</li><li>这里的NAT是通过iptables实现</li></ul><h3 id="docker之间的link"><a href="#docker之间的link" class="headerlink" title="docker之间的link"></a>docker之间的link</h3><p>即通过<code>link</code>指令，可以将一个容器只需指定对方容器名字就可以链接到另一个容器上，而无需指定IP地址及端口。注意，link指令含有方向，只能单向链接</p><p>该指令实际使用不多</p><p>直接上例子</p><pre><code class="bash">#创建busybox容器test1sudo docker run -d --name test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;#创建busybox容器test2，并连接到test1sudo docker run -d --name test2 --link test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;#进入test2中sudo docker exec -it test2 /bin/sh#在test2中ping test1(ip:172.17.0.3) 无论名字还是ip均可ping 172.17.0.3ping test1#反之，进入test1sudo docker exec -it test1 /bin/sh#在test1中ping test2(ip:172.17.0.2) 只有ip可以ping 172.17.0.2ping test2#ping不通ping 172.17.0.3ping test1</code></pre><p>创建一个新的Bridge并连接上Container：</p><pre><code class="bash">#创建一个新的bridge，叫my-bridge（-d：driver）sudo docker nerwork create -d bridge my-bridge#查看bridgesudo docker network lsbrctl show#和上个命令一样#创建busybox容器test3，指定network为my-bridgesudo docker run -d --name test3 --network my-bridge busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;#显示bridge及连接的情况brctl show#显示bridge的详细信息sudo docker network inspect bridge的id(通过sudo docker network ls和brctl show可以查看)#将其他container连接到新建的bridge上sudo docker network connect my-bridge test2</code></pre><p>多个容器若都连接在了同一个用户自己创建的bridge上，则可以<strong>不需通过链接</strong>就能够通过名字直接访问</p><pre><code class="bash">#进入my-bridge绑定的test3中，可以直接通过名字ping通后来接入的test2(ip:192.18.0.3)sudo docker rxrc -it test3 /bin/shping 192.18.0.3ping test2</code></pre><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>如果想要将docker中的端口转发给外部：</p><pre><code class="bash">#将容器中的80端口映射到本地的80端口sudo docker run --name web -d -p 80:80 nginx#查看映射的端口sudo docker ps#此时可以通过curl在外部（虚拟机上）直接访问容器内部的端口curl 192.168.205.10</code></pre><p>示意图：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200211000724333.png" alt="image-20200211000724333"></p><ul><li>注：eth1到本地网卡上的端口转发是通过设置虚拟机修改而成的</li></ul><h3 id="host和none网络"><a href="#host和none网络" class="headerlink" title="host和none网络"></a>host和none网络</h3><p>none network：</p><pre><code class="bash">#创建busybox容器test1，指定network为nonesudo docker run -d --name test1 --network none busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;#查看none上连接的containersudo docker network inspect none#进入container中sudo docker exec -it test1 /bin/sh#运行命令ip a#发现只有lo</code></pre><ul><li>none network表示一种孤立的网络，除了<code>sudo docker exec -it</code>命令能够访问之外，不能通过其他方法访问</li></ul><p>host network：</p><pre><code class="bash">#创建busybox容器test1，指定network为hostsudo docker run -d --name test1 --network host busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;#查看host上连接的containersudo docker network inspect host#进入container中sudo docker exec -it test1 /bin/sh#运行命令ip a#发现此处的网卡和Linux主机上的一样</code></pre><ul><li>host network表示该容器没有自己独立的namespace，根Linux主机中的namespace network共享同一套</li><li>可能会和Linux主机上的一些端口存在冲突</li></ul><h3 id="多机通信"><a href="#多机通信" class="headerlink" title="多机通信"></a>多机通信</h3><p>为实现如下效果：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200211004225893.png" alt="多机通信"></p><ul><li>两个docker的ip地址需要不一样</li><li>运用VXLAN技术</li><li>通过overlay network实现，创建overlay与bridge、host、none一致</li><li>需要用到分布式存储技术（采用etcd），用于在单机上占据ip地址</li></ul><h2 id="四、Docker的持久化存储和数据共享"><a href="#四、Docker的持久化存储和数据共享" class="headerlink" title="四、Docker的持久化存储和数据共享"></a>四、Docker的持久化存储和数据共享</h2><p>回顾之前讲的Container，Container具有可读可写的能力，image只具有可读的能力。但是在stop再rm Container之后，Container中的数据不会保存，Container中的数据相当于一个临时的数据</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200205001054091.png" alt="Container"></p><p>docker持久化数据的方案分以下两种：</p><ul><li>基于<strong>本地文件系统</strong>的 Volume.可以在执行 Docker create或 Docker run时,通过<code>-v</code>参数将主机的目录作为容器的数据卷.这部分功能便是基于本地文件系统的 volume管理.</li><li>基于<strong>plugin</strong>的 Volume,支持第三方的存储方案,比如NAS，aws</li></ul><p>Volume的类型：</p><ul><li>受管理的 data Volume,由 docker后台自动创建.</li><li>绑定挂载的 Volume,具体挂载位置可以由用户指定.</li></ul><h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><p>场景：一般来说有些容器自己会产生一些数据，我们需要保证这些数据的安全，不想随着container的消失而消失，比如说数据库等，通过Dockerfile中的<code>VOLUME</code>关键字实现。</p><pre><code class="bash">#创建mysql container(mysql的Dockerfile中有：VOLUME /var/lib/mysql),初始密码为空，将在/var/lib/mysql处产生的volume重命名为mysql(将mysql volume映射到container中的/var/lib/mysql目录)sudo docker run -d -v mysql:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysqlsudo docker ps#查看volumesudo docker volume lssudo docker volume 上一步命令查看的id#会自动挂载到/var/lib/docker/volumes/xxxx(id)/_data#删除volumesudo docker volume rm id或者-v指定的名字</code></pre><h3 id="Bind-Mounting"><a href="#Bind-Mounting" class="headerlink" title="Bind Mounting"></a>Bind Mounting</h3><p>bind Mounting不需要在Dockerfile中定义文件产生的路径，只需在命令行中指定即可：</p><pre><code class="bash">#创建容器，将当前目录$(pwd)映射到container中的/usr/share/nginx/html目录sudo docker run -d -v $(pwd):/usr/share/nginx/html id</code></pre><h2 id="五、Docker-Compose多容器部署"><a href="#五、Docker-Compose多容器部署" class="headerlink" title="五、Docker Compose多容器部署"></a>五、Docker Compose多容器部署</h2><p>官方链接：<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">https://docs.docker.com/compose/</a>、<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><p>多容器的app会带来的缺点：</p><ul><li>要从 Dockerfile build image或者 Dockerhub拉取 image</li><li>要创建多个 container</li><li>要管理这些 container(启动、停止、删除)</li></ul><p>Docker Compose的诞生就是为了解决该问题，可以看成是批处理</p><ul><li>Docker Compose是一个命令行工具</li><li>这个工具可以通过一个<code>yml</code>文件定义多容器的 docker应用</li><li>通过一条命令就可以根据<code>yml</code>文件的定义去创建或者管理这多个容器</li></ul><p>yml文件默认名：<code>docker-compose.yml</code>，包含三个重要概念：Services、Networks、Volumes</p><p>Services：</p><ul><li><p>一个 service代表一个 container,这个 container可以从dockerhub的image来创建,或者从本地的 Dockerfile build出来的image来创建</p></li><li><p>Service的启动类似 docker run,我们可以给其指定network和 volume,所以可以给 service指定 network和Volume的引用（service中的参数和docker run中的参数类似）</p><pre><code class="yaml">  services:    db:#services名字      image:postgres:9.4#采用的image      volumes:        - “db-data:/var/lib/postgresql/data”      network:#新建的bridge       - back-tier</code></pre><pre><code class="yaml">  services:    worker:      build:./worker      links:#有了network，links可有可无        - db        - redis      network:       - back-tier</code></pre></li></ul><p>实例：</p><pre><code class="yaml">version: &#39;3&#39;services:  wordpress:    image: wordpress    ports:      - 8080:80    environment:      WORDPRESS_DB_HOST: mysql      WORDPRESS_DB_PASSWORD: root    networks:      - my-bridge  mysql:    image: mysql    environment:      MYSQL_ROOT_PASSWORD: root      MYSQL_DATABASE: wordpress    volumes:      - mysql-data:/var/lib/mysql    networks:      - my-bridgevolumes:  mysql-data:networks:  my-bridge:    driver: bridge</code></pre><h3 id="安装和基本使用"><a href="#安装和基本使用" class="headerlink" title="安装和基本使用"></a>安装和基本使用</h3><p>安装：</p><ul><li><p>docker for mac或windows 会自动安装</p></li><li><p>Linux安装步骤：<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></p><pre><code class="bash">  #下载至/usr/local/bin/docker-compose  sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.3/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose  #添加可执行权限  sudo chmod +x /usr/local/bin/docker-compose  #查看版本信息 验证是否安装成功  docker-compose --version</code></pre></li></ul><p>使用：</p><p>docker Compose的使用大部分都会联合<code>yml</code>文件的使用</p><pre><code class="bash">#创建docker-compose.yml文件中的servicedocker-compose updocker-compose up -d#后台运行，但是不会打印log#查看docker-compose中的情况docker-compose psdocker-compose images#列出所定义的container以及使用的image#执行container中的命令docker-compose exec yml文件中定义的service container中的命令#停止docker-compose中的容器docker-compose stop#停止并删除docker-compose中的容器、bridge、volumedocker-compose down</code></pre><h3 id="水平扩展和负载均衡"><a href="#水平扩展和负载均衡" class="headerlink" title="水平扩展和负载均衡"></a>水平扩展和负载均衡</h3><p>通过docker-compose命令的<code>--scale</code>参数</p><pre><code class="bash">#多开service中的containerdocker-compose up --sacle yml文件service中的某一个container=个数</code></pre><h2 id="六、容器编排Swarm-mode"><a href="#六、容器编排Swarm-mode" class="headerlink" title="六、容器编排Swarm mode"></a>六、容器编排Swarm mode</h2><p>Swarm是一种集群的架构，其中含有节点，每一个节点中可以含有两种角色，即manager和worker</p><ul><li>manager：整个集群的大脑，至少需要2个及以上，所以需要同步，docker提供了一个内置的分布式的存储数据库，通过raft协议进行同步</li><li>worker：节点比manager多，通过gossip网络进行同步</li></ul><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200212235626905.png" alt="底层架构"></p><p>重要概念：</p><ul><li>Service：与docker Compose中的service类似，但是最终运行在那台机器上是不确定的</li><li>Replicas：横向扩展时，一个replicas就是一个容器</li></ul><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200212235931699.png" alt="Service和Replicas"></p><p>注：此图产生了三个容器，会调度系统调度到不同的节点上去，即该service最终会运行在那些swarm节点上是不知道的</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200213000340881.png" alt="swarm上创建service时的调度过程"></p><p>例子：</p><p>创建一个三节点的swarm集群：</p><p>节点一：</p><pre><code class="bash">#初始化swarm并创建manager节点，同时指定manager的地址sudo docker swarm init --advertise-addr=192.168.205.10#查看swarm当前的节点sudo docker node ls</code></pre><p>借点二：</p><pre><code class="bash">#创建worker节点并加入该swarm集群（init后会提供该命令），用于将另一台机器加入称为workersudo docker join --token xxxx(init后会提供) 192.168.205.10:端口号</code></pre><p>节点三：</p><pre><code class="bash">#创建worker节点并加入该swarm集群（init后会提供该命令），用于将另一台机器加入称为workersudo docker join --token xxxx(init后会提供) 192.168.205.10:端口号</code></pre><h3 id="Service的创建维护和水平扩展"><a href="#Service的创建维护和水平扩展" class="headerlink" title="Service的创建维护和水平扩展"></a>Service的创建维护和水平扩展</h3><p><code>docker service</code>命令类似于<code>docker run</code>，只是不是在本地上运行</p><pre><code class="bash">#创建一个busybox的service，叫demosudo docker service create --name demo busybox sh -c &quot;while true; do sleep 3600;done&quot;#查看servicesudo docker service lssudo docker service ps service名字#查看service的详细情况（包括分布在那台机器/节点上）#横向扩展servicesudo docker service scale service名字=扩展数#通过ls命令显示的REPLICAS栏可以查看#删除servicesudo docker service rm demo#由于可能存在横向扩展，所以实际上会比较慢</code></pre><ul><li><code>sudo docker service ls</code>命令显示的REPLICAS栏：<ul><li>分母：创建时规定的横向扩展数量（scale）</li><li>分子：有几个已经ready了</li></ul></li><li><code>scale</code>命令扩展时，如果有部分节点上的service失效了（退出、shutdown等），系统会在任意节点上再起一个直到达到scale规定的数目</li></ul><h3 id="集群服务器通信——RoutingMesh"><a href="#集群服务器通信——RoutingMesh" class="headerlink" title="集群服务器通信——RoutingMesh"></a>集群服务器通信——RoutingMesh</h3><p>RoutingMesh的两种体现：</p><ul><li>Internal：Container和Container之间的访问通过overlay网络（通过VIP虚拟IP）</li><li>Ingress：如果服务有绑定接口，则此服务可以通过任意swarm节点的相应接口访问</li></ul><h4 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h4><p>docker Compose在单机的情况下，不同的service可以通过对方的名字相互访问（底层通过DNS服务实现）。而在swarm class中，不同的service有可能在不同的节点上，不同的service之间也能通过service name通信，也有DNS服务。</p><p>对于Swarm来说，有内置的DNS服务发现的功能，通过service命令创建service时，如果是连接到一个overlay的网络上，会为连接到overlay网络上的所有的service去增加一条DNS的记录，通过该记录就能知道IP地址（并不是实际上该service所在的容器的ip地址，而是虚拟的ip地址，即VIP，一旦service创建好后，VIP就不会改变，但是和具体的ip地址绑定是通过LVS（Linux Virtual Service）实现的），就可以访问其服务</p><p>例子：</p><p><code>swarm-manager</code>节点：</p><pre><code class="bash">#创建overlay网络，命名demosudo docker network create -d overlay demo#创建一个whoami的service，提供web服务，如果访问8000端口会返回他的hostnamesudo docker service create --name whoami -p 8000:8000 --network demo -d jwilder/whoami#将内部8000端口映射到本地8000端口#查看是否运行sudo docker service ls#查看运行在哪里sudo docker service ps whoami#swarm-manager#查看容器 是否映射出了8000sudo docker ps#查看8000端口curl 127.0.0.1:8000#创建第二个service，采用busybox，命名clientsudo docker service create --name client -d --network demo busybox sh -c &quot;while true; do sleep 3600; done&quot;#查看是否运行sudo docker service ls#查看运行在哪里sudo docker service ps client#swarm-worker1#查看容器 是否映射出了8000sudo docker ps#扩展下whoamisudo docker service scale whoami=2#查看另一台在哪里sudo docker service ps whoami#swarm-manager、swarm-worker2</code></pre><p>进入<code>swarm-worker1</code>节点：</p><pre><code class="bash">#尚未扩展前：#查看service是否运行sudo docker ps#进入service中sudo docker exec -it service的id sh#直接ping另一台serviceping whoami#能够ping通，能够发现实际上是ping10.0.0.7#横向扩展后：ping whoami#能够ping通，能够发现实际上是ping10.0.0.7#直接去查看swarm class中维护的dns服务器nslookup whoami#查看真正的容器地址nslookup tasks.whoami</code></pre><ul><li>不管service有几个横向扩展，但是最后的VIP只有一个，而且访问这个VIP时，Swarm会自动做负载均衡，依次轮流访问这几个横向扩展的service</li><li>上述的负载均衡以及VIP均通过LVS（Linux Virtual Service）实现</li></ul><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><ul><li>外部访问的负载均衡</li><li>服务端口被暴露到各个 swarm节点</li><li>内部通过IPVS进行负载均衡</li></ul><p>当我们去任何一台Swarm节点上去访问端口服务的时候，会把该服务通过本地节点的IPVS（IP的virtual service），通过LVS把该服务负载均衡：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200218173537430.png" alt="示意图"></p><ul><li>当外部访问docker host3的8080端口时（该节点上没有对应service），IPVS会将该请求转发到另外两台具有service的节点上</li></ul><p>例子：</p><p><code>swarm-manager</code>节点：</p><pre><code class="bash">#创建overlay网络，命名demosudo docker network create -d overlay demo#创建一个whoami的service，提供web服务，如果访问8000端口会返回他的hostnamesudo docker service create --name whoami -p 8000:8000 --network demo -d jwilder/whoami#将内部8000端口映射到本地8000端口#扩展下whoamisudo docker service scale whoami=2#查看运行情况suod docker service ps whoami#swarm-manager、swarm-worker2#不断获取，会依次返回两台不同节点机器的id(负载均衡)curl 127.0.0.1:8000curl 127.0.0.1:8000curl 127.0.0.1:8000...</code></pre><p>进入<code>swarm-worker1</code>节点：</p><pre><code class="bash">#获取，发现任可以访问curl 127.0.0.1:8000#查看本地转发规则iptables -nl -t nat</code></pre><h3 id="docker-stack部署swarm"><a href="#docker-stack部署swarm" class="headerlink" title="docker stack部署swarm"></a>docker stack部署swarm</h3><p>利用Docker compose file，即<code>yml</code>文件，主要通过<code>deploy</code>命令，官方文档：<a href="https://docs.docker.com/compose/compose-file/#deploy" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/#deploy</a></p><p>注意：该处的docker compose file中不能利用build命令构建本地image，只能通过<strong>远程拉取</strong></p><p>以下均为<code>deploy</code>下的子命令：</p><ul><li><code>endpoint_mode</code>：<ul><li>vip（默认）：service之间通过vip互访（底层会通过LVS自动做均衡负载）</li><li>dnsrr：直接使用service的ip地址互访，也会通过dnsrr（DNS round-robin）做均衡负载</li></ul></li><li><code>labels</code>：帮助信息</li><li><code>mode</code>：<ul><li>global：不能通过scale命令做横向扩展，整个class中只有一个service</li><li>replicated（默认）：可以横向扩展</li></ul></li><li><code>placement</code>：<ul><li>constraints：<ul><li><code>- node.role==manager</code>：一定会部署到manager上</li></ul></li><li>preferences：<ul><li>详见：<a href="https://docs.docker.com/compose/compose-file/#placement" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/#placement</a></li></ul></li></ul></li><li><code>replicas</code>：<ul><li>当<code>mode</code>设置成replicated时，可以在初始化时就指定需要几个service</li></ul></li><li><code>resources</code>：资源的限制<ul><li>cpu：‘0.5’</li><li>memory：20M</li></ul></li><li><code>restart_policy</code>：重启条件即参数设置<ul><li>delay：延时</li><li>max_attempts：最大尝试次数</li></ul></li><li><code>update_config</code>：更新时要遵循的原则<ul><li>parallelism：并行数（最多能够同时更新几个service）</li><li>delay：延时（每次更新的间隔时间）</li></ul></li></ul><p>例子：</p><p>利用yml文件部署wordpress</p><pre><code class="yaml">version: &#39;3&#39;services:  web:    image: wordpress    ports:      - 8080:80    environment:      WORDPRESS_DB_HOST: mysql      WORDPRESS_DB_PASSWORD: root    networks:      - my-network    depends_on:      - mysql    deploy:      mode: replicated      replicas: 3      restart_policy:        condition: on-failure        delay: 5s        max_attempts: 3      update_config:        parallelism: 1        delay: 10s  mysql:    image: mysql    environment:      MYSQL_ROOT_PASSWORD: root      MYSQL_DATABASE: wordpress    volumes:      - mysql-data:/var/lib/mysql    networks:      - my-network    deploy:      mode: global      placement:        constraints:          - node.role == managervolumes:  mysql-data:networks:  my-network:    driver: overlay</code></pre><p>进入swarm manager节点：</p><pre><code class="bash">#语法：sudo docker stack deploy 自定义的名字 --compose-file=xxxx.ymlsudo docker stack deploy wordpress --compose-file=docker-compose.yml#查看情况sudo docker stack ps wordpress#只查看servicesudo docker stack services wordpress#删除所有container及网络sudo docker stack rm wordpress</code></pre><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>docker compose file中有些是关于数据库的用户名和密码的，为了安全性考虑需要secret manager</p><p>需要加密的部分：</p><ul><li>用户名密码</li><li>SSH Key</li><li>TLS认证</li><li>任何不想让别人看到的数据</li></ul><p>docker secret management特点：</p><ul><li>存在 Swarm Manager节点 Raft database里（加密的）.<ul><li>多个manager节点通过Raft database确保数据一致</li></ul></li><li>Secret可以 assign给一个 service,这个 service就能看到这个 secret</li><li>在 container内部 Secret看起来像文件,但是实际是在内存中</li></ul><p>使用例子：</p><pre><code class="bash">#创建secret#方法一：#从文件中创建secret，创建完成后最好删除掉该文件sudo docker secret create secret的名字 要加密的文件#查看sudo docker secret ls#方法二#从标准输入中创建secretecho &quot;admin&quot; | sudo docker secret create secret的名字 -#查看sudo docker secret ls#删除secretsudo docker secret rm secret的名字#使用secret#创建一个busybox的container，命名client（可以通过多次使用--secret传入几个secret）sudo docker service create --name client --secret secret的名字 busybox sh -c &quot;while true; do sleep 3600; done&quot;#进入containersudo docker exec -it 容器的id(可通过docker ps查看) shcd /run/secrets#会存在一个secret名字的文件#可以直接查看secret的明文cat secret名字的文件</code></pre><p>最典型使用mysql时传入密码的例子：</p><pre><code class="bash">echo &quot;admin&quot; | sudo docker secret create my-pw -#通过MYSQL中的MYSQL_ROOT_PASSWORD_FILE环境变量指定密码sudo docker service create --name db --secret my-pw -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-pw mysql#进入container内部确认mysql密码sudo docker exec -it 容器的id(可通过docker ps查看) shmysql -u root -p#之后输入密码：admin即可进入mysql的交互中</code></pre><h3 id="docker-stack中使用secret"><a href="#docker-stack中使用secret" class="headerlink" title="docker stack中使用secret"></a>docker stack中使用secret</h3><p>通过<code>secret</code>指定使用哪个secret</p><p>例子：</p><p>利用yml文件部署wordpress</p><pre><code class="yaml">version: &#39;3&#39;services:  web:    image: wordpress    ports:      - 8080:80    secrets:      - my-pw    environment:      WORDPRESS_DB_HOST: mysql      WORDPRESS_DB_PASSWORD_FILE: /run/secrets/my-pw    networks:      - my-network    depends_on:      - mysql    deploy:      mode: replicated      replicas: 3      restart_policy:        condition: on-failure        delay: 5s        max_attempts: 3      update_config:        parallelism: 1        delay: 10s  mysql:    image: mysql    secrets:      - my-pw    environment:      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my-pw      MYSQL_DATABASE: wordpress    volumes:      - mysql-data:/var/lib/mysql    networks:      - my-network    deploy:      mode: global      placement:        constraints:          - node.role == managervolumes:  mysql-data:networks:  my-network:    driver: overlay## secrets:#   my-pw:#    file: ./password</code></pre><h3 id="service更新"><a href="#service更新" class="headerlink" title="service更新"></a>service更新</h3><p>注意：为保证service不会中断，需要保证scale&gt;=2</p><p>对正在运行的service进行更新：</p><pre><code class="bash">#创建overlay网络，命名demosudo docker network create -d overlay demo#创建一个whoami的service，提供web服务，将本地的5000映射到class中的8080端口sudo docker service create --name web -p 8080:5000 --network demo xiaopeng163/python-flask-demo:1.0#查看sudo docker service ps web#扩展下websudo docker service scale web=2#查看运行情况curl 127.0.0.1:8080#更新imagesudo docker service update --image xiaopeng163/python-flask-demo:2.0 web#再次查看，会发现1.0的已经被shutdown了，并重新开了两个2.0的containersudo docker service ps web#更新端口sudo service updata --publish-rm 8080:5000 --publish-add 8088:5000 web</code></pre><h2 id="七、容器编排Kubernetes"><a href="#七、容器编排Kubernetes" class="headerlink" title="七、容器编排Kubernetes"></a>七、容器编排Kubernetes</h2><p>kubernetes架构：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200219235941920.png" alt="架构图"></p><p>其中Master节点架构：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200220000101254.png" alt="Master节点架构"></p><ul><li>API Service：暴露给外界访问</li><li>Scheduler：调度模块</li><li>Controller：控制模块，对节点的控制</li><li>etcd：分布式的存储，存储k8s的状态和配置</li></ul><p>node节点架构：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200220000307417.png" alt="node节点架构"></p><ul><li>Pod：在k8s中，是在容器中调度的最小单位，是具有相同的namespace（包含了所有namespace，如user namespace、network namespace）的一些Container组合</li><li>Docker：容器技术之一（k8s中采用docker，还有其他容器技术）</li><li>kubelet：类似于一个代理，受master节点控制，负责在node节点上创建、管理容器、network以及volume</li><li>kube-proxy：端口的代理转发以及service的服务发现和负载均衡</li><li>Flientd：日志的采集、存储、查询</li><li>Optional Add-ons：插件</li></ul><h3 id="搭建k8s单节点环境"><a href="#搭建k8s单节点环境" class="headerlink" title="搭建k8s单节点环境"></a>搭建k8s单节点环境</h3><p>k8s首席构造师github：<a href="https://github.com/kelseyhightower" target="_blank" rel="noopener">https://github.com/kelseyhightower</a></p><p>常用工具介绍：</p><ul><li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way" target="_blank" rel="noopener">kubernetes-the-hard-way</a>：不借助任何脚本，从命令行去操作安装kubernetes</li><li><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">minikube</a>：本地快速创建一个节点的kubernetes集群<ul><li>通过利用virtualbox创建一台虚拟机，该虚拟机中会安装好kubernetes</li></ul></li><li><a href="https://github.com/kubernetes/kubeadm" target="_blank" rel="noopener">kubeadm</a>：方便的本地搭建多节点的kubernetes集群</li><li><a href="https://github.com/kubernetes/kops" target="_blank" rel="noopener">kops</a>：在云上搭建kubernetes集群</li><li><a href="https://cores.com/tectonic" target="_blank" rel="noopener">tectonic</a>：少于10个节点免费</li><li><a href="https://labs.play-with-k8s.com" target="_blank" rel="noopener">play with kubernetes</a>：网站上搭建，无需任何工作，四个小时保存时间</li></ul><p>minikube安装（<a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">参考文档</a>）：</p><ul><li><p>ubuntu上：</p><pre><code class="bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_1.7.2-0_amd64.deb \ &amp;&amp; sudo dpkg -i minikube_1.7.2-0_amd64.deb#使用以下命令检查下egrep -q &#39;vmx|svm&#39; /proc/cpuinfo &amp;&amp; echo yes || echo no#如果输出 no 且如本文一样使用Windows + VirtualBox + minikube，需要通过以下命令创建一个单节点的kubernetes集群（具体命令后文会细说）sudo minikube start --vm-driver=none#sudo minikube config set vm-driver none#</code></pre></li><li><p>需要安装依赖的<code>kubectl</code>（客户端的CLI，可看上面的架构图）</p><pre><code class="bash">  #ubuntu上可以使用该命令安装：  sudo snap install kubectl --classic  #其余Linux发行版可以使用以下命令  curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl  chmod +x ./kubectl  sudo mv ./kubectl /usr/local/bin/kubectl</code></pre></li><li><p>虚拟化工具virtualbox</p><pre><code class="bash">  #测试版本号  minikube version  kubectl version</code></pre></li></ul><p><code>kubectl</code>的上下文：一些配置信息或者认证信息，称之为context，即上下文</p><p>kubectl的<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" target="_blank" rel="noopener">官方帮助文档</a></p><p>命令：</p><pre><code class="bash">#创建一个单节点的kubernetes集群（适用于mac或Linux上直接装minikube+virtualbox用户）sudo minikube start --vm-driver=virtualbox#适用于本文中Windows+virtualbox，在virtualbox中的虚拟机中安装minikube用户，缺点是有可能会影响Linux虚拟机和不能使用minikube ssh等命令sudo minikube start --vm-driver=none#如果是国内，可以尝试如下命令sudo minikube start --vm-driver=none --image-mirror-country=cnsudo minikube start --vm-driver=none --image-mirror-country=cn --registry-mirror=https://registry.docker-cn.com --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers#进入通过minikube创建的虚拟机中sudo minikube ssh#停止虚拟机sudo minikube stop#当前使用的config的基本情况sudo kubectl config view#查看当前使用的上下文sudo kubectl config get-contexts#当前的kubernetes的集群情况sudo kubectl cluster-info</code></pre><h4 id="kubectl命令行补全补丁"><a href="#kubectl命令行补全补丁" class="headerlink" title="kubectl命令行补全补丁"></a>kubectl命令行补全补丁</h4><p>kubectl自带命令行补全的脚本，通过命令：</p><pre><code class="bash">#Linuxkubectl completion bashsource &lt;(kubectl completion bash)</code></pre><p>进行打补丁补全。其他系统可以参考<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" target="_blank" rel="noopener">官方文档</a>最后一节<code>Optional kubectl configurations</code></p><h3 id="最小调度单位pod"><a href="#最小调度单位pod" class="headerlink" title="最小调度单位pod"></a>最小调度单位pod</h3><p>Pod是k8s集群中运行部署应用或服务的最小单元，一个Pod由一个或多个容器组成，kubernetes中不对容器进行直接操作。在一个Pod中，容器共享网络和存储，并且在一个Node上运行。</p><p>Kubernetes为每个Pod都分配了唯一的IP地址，称之为Pod IP，一个Pod里的多个容器共享Pod IP地址。Kubernetes要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用虚拟二层网络技术来实现，例如Flannel、Open vSwitch等。因此，在Kubernetes里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。</p><p>pod具有如下的一些特性：</p><ul><li>pod共享一个namespace（包含用户、网络、存储等）<ul><li>如果一个pod中有两个Container，则这两个Container可以直接通过localhost进行通信，如同在本地一个Linux上运行的两个进程</li></ul></li></ul><p>基本操作例子：</p><p>pod_nginx.yml文件（根据kubernetes提供的一个API格式定义一个资源，这里是pod）：</p><pre><code class="yaml">apiVersion: v1kind: Pod #资源类型metadata:  name: nginx #pod名字  labels:    app: nginxspec: #pod中的关键部分  containers: #可以包含多个容器  - name: nginx #第一个Container Container名字    image: nginx    ports:    - containerPort: 80</code></pre><p>创建及基本管理：</p><pre><code class="bash">#查看kubernetes集群是否正常kubectl version#根据pod_nginx.yml创建podkubectl create -f pod_nginx.yml#kubectl delete -f pod_nginx.yml#删除pod#查看podkubectl get pods#显示pod的详细信息(包括容器的ip(172.17.0.4)、在那个节点上)kubectl get pods -o wide#进入minikube中的虚拟机中minikube ssh#查看虚拟机中containerdocker ps#进入容器内部docker exec -it 容器id sh#退出容器exit#查看bridge网络的详细情况 可以找到创建的iginx连接到了bridge网络上（ip:172.17.0.4/16）docker network inspect bridgeexit#退出minikube#直接对pod进行可交互的操作，进入pod中的第一个容器内部（可以通过-c指定进入那个容器内部，默认第一个） 执行shkubectl exec -it nginx(pod名字) sh#具体描述一个podkubectl desrcibe pods nginx(pod名字)#将minikube中的80端口暴露出来为8080端口kubectl port-forward nginx8080:80#一旦停止，端口映射就会停止</code></pre><h3 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h3><p><strong>ReplicationController</strong>种类：</p><p>rc_nginx.yml文件：</p><pre><code class="yaml">apiVersion: v1kind: ReplicationController metadata:  name: nginxspec:  replicas: 3 #3个横向扩展  selector:    app: nginx  template:    metadata:      name: nginx      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx        ports:        - containerPort: 80</code></pre><ul><li>通过ReplicationController创建的pod，kubernetes能够自动帮我们维持对应数量的pods</li></ul><p>创建：</p><pre><code class="bash">#根据rc_nginx.yml创建podkubectl create -f rc_nginx.yml#查看 ReplicationController 情况kubectl get rc#查看pod(可以发现有3个pod)kubectl get pods#尝试删除一个podkubectl delete pods pod的id(通过get pods查询)#再次查看pod(发现仍有3个pod)kubectl get pods#横向扩展 修改为2kubectl scale rc nginx(名字) --replicas=2kubectl get pods#查看后只有两个kubectl get rc</code></pre><p><strong>ReplicaSet</strong>种类：</p><p>rs_nginx.yml文件：</p><pre><code class="yaml">apiVersion: apps/v1kind: ReplicaSetmetadata:  name: nginx  labels:    tier: frontendspec:  replicas: 3 #3个横向扩展  selector:    matchLabels:      tier: frontend  template:    metadata:      name: nginx      labels:        tier: frontend    spec:      containers:      - name: nginx        image: nginx        ports:        - containerPort: 80</code></pre><ul><li>ReplicaSet是ReplicationController的升级版，ReplicaSet支持new set-based selector</li></ul><p>创建：</p><pre><code class="bash">#根据rs_nginx.yml创建podkubectl create -f rs_nginx.yml#查看 ReplicaSet 情况kubectl get rs#查看pod(可以发现有3个pod)kubectl get pods#横向扩展 修改为2kubectl scale rs nginx(名字) --replicas=2kubectl get pods#查看后只有两个kubectl get rs</code></pre><h3 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h3><p>官方文档：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></p><p>Deployments控制器提供了Pod和ReplicaSets的声明性更新。即Deployments会描述一种希望的状态，如有三个扩展（–replicas=3）、pod中的具体的docker image版本以及相关的更新，Deployments controller都会努力使该声明实现（Deployments会通过创建ReplicaSet进而来创建pods）</p><p>注意：不能独立对 通过Deployments创建的Pod和ReplicaSets 进行操作（尤其是删除操作）</p><h4 id="创建和管理"><a href="#创建和管理" class="headerlink" title="创建和管理"></a>创建和管理</h4><p>deployment_nginx.yml文件：</p><pre><code class="yaml">apiVersion: apps/v1kind: Deployment #类型为Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 3  #此处其实就是ReplicaSet 保证pod的数量  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:  #指定pod需要的Container      containers:      - name: nginx  #Container名字        image: nginx:1.12.2  #Container image        ports:        - containerPort: 80</code></pre><p>创建：</p><pre><code class="bash">#根据deployment_nginx.yml创建Deploymentkubectl create -f deployment_nginx.yml#查看Deploymentkubectl get deployment#查看 ReplicaSet 情况kubectl get rs#查看 pod 情况kubectl get pods</code></pre><p>Deployment相关命令：</p><pre><code class="bash">#查看Deploymentkubectl get deployment#查看Deployment 显示更多信息kubectl get deployment -o wide#对deployment中的image进行升级kubectl set image deployment(resource) nginx-deployment(名字) nginx=nginx:1.13(image)#查看Deployment 显示更多信息（包括image版本）kubectl get deployment -o wide#查看 ReplicaSet 情况kubectl get rs#会发现存在一个旧的（停止）一个新的#查看 pod 情况kubectl get pods#查看整个 deployment 的历史kubectl rollout history deployment(resource) nginx-deployment(名字)#退回 deployment 的之前版本（即没有更新image之前）kubectl rollout undo deployment(resource) nginx-deployment(名字)#查看Deployment 显示更多信息（包括image版本）kubectl get deployment -o wide#查看节点信息（ip地址）kubectl get node -o wide</code></pre><h3 id="使用Tectonic搭建本地多节点"><a href="#使用Tectonic搭建本地多节点" class="headerlink" title="使用Tectonic搭建本地多节点"></a>使用Tectonic搭建本地多节点</h3><p><a href="https://coreos.com/tectonic/" target="_blank" rel="noopener">Tectonic</a>为CoreOS的产品：收费企业级产品，可免费试用。</p><p>搭建本地多节点教程：<a href="https://coreos.com/tectonic/docs/latest/tutorials/sandbox/install.html" target="_blank" rel="noopener">https://coreos.com/tectonic/docs/latest/tutorials/sandbox/install.html</a>（实测Tectonic下的sandbox已经不能正常获取！！！该实验无法正常进行！！！）</p><p>本质是通过vagrant在virtualbox上创建多台虚拟机（CoreOS系统，Container Linux）</p><p>修改kubeconfig文件，使kubectl命令同时支持minikube和tectnic（修改kubeconfig文件，添加新的cluster、context、user，具体配置可以参看<a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" target="_blank" rel="noopener">官方说明</a>），通过以下命令可以进行切换：</p><pre><code class="bash">#查看目前的上下文变量kubectl config get-contexts#切换kubectl config use-context 上一个命令中的NAME栏名字</code></pre><h3 id="基础网络Cluster-Network"><a href="#基础网络Cluster-Network" class="headerlink" title="基础网络Cluster Network"></a>基础网络Cluster Network</h3><p>Cluster Network的<a href="https://kubernetes.io/docs/concepts/cluster-administration/networking" target="_blank" rel="noopener">官方说明</a></p><p>pod_busybox.yml文件：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: busybox-pod  labels:    app: busyboxspec:  containers:  - name: busybox-container    image: busybox    command:      - sleep      - &quot;360000&quot;</code></pre><p>pod_nginx.yml文件：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx-pod  labels:    app: nginxspec:  containers:  - name: nginx-container    image: nginx    ports:    - name: nginx-port      containerPort: 80</code></pre><p>service_nginx.yml文件：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: nginx-servicespec:  ports:  - port: 8080    nodePort: 8080    targetPort: nginx-port    protocol: TCP  selector:    app: nginx  type: NodePort</code></pre><p>w1节点上：</p><pre><code class="bash">#根据.yml创建podkubectl create -f pod_busybox.ymlkubectl create -f pod_nginx.yml#查看具体情况kubectl get pods -o wide#两个pod详细情况：#busybox-pod ip:10.2.0.50  节点w1#nginx-pod   ip:10.2.0.51  节点w1#在w1中（未进入pod中）pingping 10.2.0.50#能够ping通ping 10.2.0.51#能够ping通#进入busybox-podkubectl exec -it busybox-pod sh#查看ipip a#尝试ping nginx-podping 10.2.0.51#能够ping通</code></pre><p>c1节点：</p><pre><code class="bash">#c1节点ping w1节点上的busybox-podping 10.2.0.50#能够ping通#c1节点ping w1节点上的nginx-podping 10.2.0.51#能够ping通</code></pre><p>上述网络关系的拓扑图：</p><p><img src="//NU-LL.github.io/2020/01/16/Docker/image-20200225225507153.png" alt="网络关系拓扑图"></p><ul><li>flannel插件：coreos出品，开源免费，通过该插件实现了两台机器之间的overlay网络</li><li>诸如flannel插件的其他开源插件还有很多，在本节开头的网址进入后会有其他插件介绍说明以及插件必须遵守的原则</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>在cluster中，每个pod都有自己独立的ip地址，并且都能够相互ping通，不论pod是否在同一台设备（节点）上（机器本身也能够ping通任意一个pod的ip地址，详见上一节）</p><p>注意：不要直接去使用和管理pods：</p><ul><li>当我们使用 ReplicaSet 或者 ReplicationController 水平扩展 scale 的时候,Pods有可能会被 terminated(终止)</li><li>当我们使用 Deployment 的时候,我们去更新 Docker Image Version,旧的Pods会被 terminated(终止),然后新的Pods创建</li></ul><p>在Kubernetes中，Pod会经历“生老病死”而无法复活，也就是说，分配给Pod的IP会随着Pod的销毁而消失，这就导致一个问题——如果有一组Pod组成一个集群来提供服务，某些Pod提供后端服务API，某些Pod提供前端界面UI，那么该如何保证前端能够稳定地访问这些后端服务呢？这就是Service的由来。</p><p>Service在Kubernetes中是一个抽象的概念，它定义了一组逻辑上的Pod和一个访问它们的策略（通常称之为微服务）。这一组Pod能够被Service访问到，通常是通过Label选择器确定的。</p><p>创建service：</p><p>1、命令行创建</p><pre><code class="bash">#给pod创建service 供外部访问kubectl expoese &lt;resources&gt; &lt;resources名字&gt;</code></pre><p>2、yml文件中通过<code>kind: Service</code>定义，主要有以下三种service</p><ul><li><strong>ClusterIP</strong>：ip地址是cluster内部均可以访问的，但是外界缺无法访问（这种内部的ip称为ClusterIP），外界可以通过service的ip访问（一般service的ip不会变动，而pod的ip会变动）</li><li><strong>NodePort</strong>：将要访问的port绑定到所有node上，因为node对外可以提供访问（假设node的ip为公网ip），所以该类型的service外界也是可以访问的，但是这种方式暴露的port有范围限制（30000-32767）</li><li><strong>LoadBalancer</strong>：一般需要结合云服务使用，由云服务商提供。实际环境中运用较多</li><li><strong>ExternalName</strong>：通过DNS的方式。实际环境中运用较多</li><li>Default：即ClusterIP，默认为ClusterIP方式</li></ul><p>以上均是通过ip地址访问的，但是其实也是可以通过dns访问，但是需要相关的插件</p><hr><p>ClusterIP的相关例子：</p><p>例子1：</p><p>w1节点上：</p><pre><code class="bash">#根据上一节.yml创建podkubectl create -f pod_busybox.ymlkubectl create -f pod_nginx.yml#查看具体情况kubectl get pods -o wide#两个pod详细情况：#busybox-pod ip:10.2.0.254  节点w1#nginx-pod   ip:10.2.0.252  节点w1#创建servicekubectl expoese pods nginx-pod#查看service状态kubectl get svc#service name:nginx-pod  ip:10.3.248.3</code></pre><p>c1节点：</p><pre><code class="bash">curl 10.3.248.3#可以直接通过service访问pod</code></pre><hr><p>例子2：</p><p>deployment_python_http.yml文件：</p><pre><code class="yaml">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: service-testspec:  replicas: 2  selector:    matchLabels:      app: service_test_pod  template:    metadata:      labels:        app: service_test_pod    spec:      containers:      - name: simple-http        image: python:2.7        imagePullPolicy: IfNotPresent        command: [&quot;/bin/bash&quot;]        args: [&quot;-c&quot;, &quot;echo \&quot;&lt;p&gt;Hello from $(hostname)&lt;/p&gt;\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;]        ports:        - name: http          containerPort: 8080</code></pre><p>w1节点上：</p><pre><code class="bash">#docker pull python:2.7#根据.yml文件创建Deploymentkubectl create -f deployment_python_http.ymlkubectl get pods -o wide#pod1 name:service-test-1863849916-b13b6 ip:10.2.0.142  节点w1#pod2 name:service-test-1863849916-ts7xr ip:10.2.0.141  节点w1</code></pre><p>c1节点上：</p><pre><code class="bash">curl 10.2.0.142:8080#可以直接访问pod1&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;curl 10.2.0.141:8080#可以直接访问pod2&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;</code></pre><p>w1节点上：</p><pre><code class="bash">#查看deployment情况kubectl get deployment#创建deployment服务service-testkubectl expose deployment service-test#查看服务情况kubectl get svc#service name: service-test  ip:10.3.120.168</code></pre><p>c1节点上：</p><pre><code class="bash">curl 10.3.120.168:8080#可以直接通过service访问pod&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;curl 10.3.120.168:8080#可以直接通过service访问pod&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;curl 10.3.120.168:8080#可以直接通过service访问pod&lt;p&gt;Hello from service-test-1863849916-ts7xr&lt;/p&gt;curl 10.3.120.168:8080#可以直接通过service访问pod&lt;p&gt;Hello from service-test-1863849916-b13b6&lt;/p&gt;...</code></pre><ul><li>访问service ip会自动做一个<strong>负载均衡</strong></li></ul><hr><p>例子3：</p><p>接例子2中的换件，在c1中：</p><pre><code class="bash">#不停地调用while true; do curl 10.3.120.168:8080; done</code></pre><p>w1节点中：</p><pre><code class="bash">#直接编辑deployment_python_http.yml 达到应用升级kubectl edit deployment service-test#会自动打开deployment_python_http.yml文件#将 Hello from $(hostname) 修改为 Hello new version from $(hostname)#查看podskubectl get pods#可以看到旧的pods已经终止，同时会生成并运行一个新的pods</code></pre><ul><li>修改deployment_python_http.yml文件后，c1中的程序检测到该服务会停止一段时间，但是最后会恢复至正常</li><li>该更新并不是Rolling Updata，即并不是零宕机更新，有一段时间会存在不能访问服务器</li></ul><h3 id="NodePort类型service以及Label简单应用"><a href="#NodePort类型service以及Label简单应用" class="headerlink" title="NodePort类型service以及Label简单应用"></a>NodePort类型service以及Label简单应用</h3><p>演示：</p><p>service中（c1节点pod_nginx.yml）：</p><p>创建pod_nginx.yml：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx-pod  labels:    app: nginx #具体的label，与后文中的service的yml文件中的label对应spec:  containers:  - name: nginx-container    image: nginx    ports:    - name: nginx-port #端口名字      containerPort: 80 #具体的端口</code></pre><ul><li>labels：几乎所有的资源都可以设置一个label，由一对key value组成，且可以设置不止一个</li></ul><pre><code class="bash">#创建podkubectl create -f pod_nginx.yml#查看状态kubectl get pods -o wide#通过expose给改pod创建一个NodePort类型的servicekubectl expose pods nginx-pod --type=NodePort#查看状态kubectl get svc#name:kubernetes ClusterIP ip:10.3.0.1 port:443/TCP#name:nginx-pod NodePort ip:10.3.38.138 port:80:31404/TCPkubectl get node -o wide#查看c1的ipkubectl describe node c1的id#172.17.4.101#查看w1的ipkubectl describe node w1的id#172.17.4.201#删除该service，注意pod还在kubectl delete service nginx-pod</code></pre><ul><li>直接在浏览器中打开<code>172.17.4.101:31404</code>或<code>172.17.4.201:31404</code>即可正常访问Nginx</li></ul><p><strong>NodePort</strong>类型的service会将端口映射到整个Cluster上的每个node的ip地址上，所以可以通过Cluster的任意一个节点的ip地址+端口去访问服务</p><p>类似创建pod，该service也可以通过<code>.yml</code>文件（service_nginx.yml）创建：</p><pre><code class="yaml">apiVersion: v1kind: Service #创建servicemetadata:  name: nginx-service #名字spec:  ports:  - port: 32333 #需要暴露的端口    nodePort: 32333 #暴露到nodeport上    targetPort: nginx-port #目标端口名，对应上述pod的yml文件中描述的port    protocol: TCP  selector: #通过label去选择到底暴露那个pod    app: nginx  type: NodePort #创建service的类型</code></pre><ul><li>注意<code>selector</code>应该和上文中的pod创建时指名的label一致，指名是该pod</li></ul><p>再次创建：</p><pre><code class="bash">#查看运行中的pod的label是否和yml文件中描述的吻合kubectl get pods --show-labels#创建servicekubectl create -f service_nginx.yml#查看kubectl get svc#name:kubernetes ClusterIP ip:10.3.0.1 port:443/TCP#name:nginx-pod NodePort ip:10.3.124.158 port:32333:32333/TCP</code></pre><ul><li>此时，直接在浏览器中打开<code>172.17.4.101:32333</code>或<code>172.17.4.201:32333</code>即可正常访问Nginx</li></ul><hr><p>label例子演示：</p><p>由上文中提到的，几乎所有的资源都可以设置一个label，由一对key value组成，且可以设置不止一个，具体使用如下：</p><p>pod_busybox.yml文件：</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: busybox-pod  labels:    app: busyboxspec:  nodeSelector: #定义一个node的selector（筛选器）    hardware: good #自定义的label  containers:  - name: busybox-container    image: busybox    command:      - sleep      - &quot;360000&quot;</code></pre><p>创建：</p><pre><code class="bash">#创建podkubectl create -f pod_busybox.yml#查看状态kubectl get pods#可以发现现在该busybox pod的状态都是pending</code></pre><ul><li>pod_busybox状态一直是pending的原因为：整个Cluster中的所有node上的label匹配不到<code>hardware=good</code>的label，所以该pod一直不能正常部署到node上</li></ul><pre><code class="bash">#查看所有node上的所有labelkubectl get node --show-labels#获取node的id(name)kubectl get node#手动在node上添加labelkubectl label node node的id hardware=good#等待一阵之后，查看kubectl get pods#发现已经由pending状态变为Running状态</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/01/10/python/"/>
      <url>/2020/01/10/python/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>感谢廖雪峰老师提供这么好的教程，此文档为本人学习中所做笔记</p><p>以<code>#</code>开头的语句是注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p><p>Python程序是大小写敏感的，如果写错了大小写，程序会报错。</p><p>按照约定俗成的惯例，应该始终坚持使用<strong><em>4个空格</em></strong>的缩进。</p><h3 id="1-数据类型和变量"><a href="#1-数据类型和变量" class="headerlink" title="1.数据类型和变量"></a>1.数据类型和变量</h3><h4 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h4><ul><li><p>整数</p><ul><li>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的</li></ul></li><li><p>浮点数</p><ul><li>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</li></ul></li><li><p>字符串</p><ul><li><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。</p></li><li><p>为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p><pre><code class="python">  &gt;&gt;&gt; print(&#39;\\\t\\&#39;)  \       \  &gt;&gt;&gt; print(r&#39;\\\t\\&#39;)  \\\t\\</code></pre></li><li><p>为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p><pre><code class="python">  &gt;&gt;&gt; print(&#39;&#39;&#39;line1  ... line2  ... line3&#39;&#39;&#39;)  line1  line2  line3</code></pre><p>  上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入，注意<code>...</code>是提示符，不是代码的一部分</p></li><li><p>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用</p><pre><code class="python">  print(r&#39;&#39;&#39;hello,\n  world&#39;&#39;&#39;)  #结果如下  hello,\n  world</code></pre></li></ul></li><li><p>布尔值</p><ul><li>布尔值只有<code>True</code>、<code>False</code>两种值</li><li>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</li></ul></li><li><p>空值</p><ul><li>空值是Python里一个特殊的值，用<code>None</code>表示</li><li><code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</li></ul></li></ul><h4 id="1-2变量"><a href="#1-2变量" class="headerlink" title="1.2变量"></a>1.2变量</h4><p>可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p><p>这种 变量本身类型 不固定的语言称之为<em>动态语言<em>，与之对应的是</em>静态语言</em></p><p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p><h4 id="1-3常量"><a href="#1-3常量" class="headerlink" title="1.3常量"></a>1.3常量</h4><p>常量就是不能变的变量。在Python中，通常用全部大写的变量名表示常量：</p><pre><code class="python">PI = 3.14159265359</code></pre><p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变</p><h4 id="1-4除法相关"><a href="#1-4除法相关" class="headerlink" title="1.4除法相关"></a>1.4除法相关</h4><p>在Python中，有两种除法，一种除法是<code>/</code>：</p><pre><code class="python">&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0</code></pre><p><code>/</code>除法计算结果是<strong>浮点数</strong>，即使是两个整数恰好整除，结果也是浮点数</p><p>还有一种除法是<code>//</code>，称为<strong>地板除</strong>，两个整数的除法仍然是整数：</p><pre><code class="python">&gt;&gt;&gt; 10 // 33</code></pre><p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个<strong>余数运算</strong>，可以得到两个整数相除的余数：</p><pre><code class="python">&gt;&gt;&gt; 10 % 31</code></pre><h3 id="2-字符串和编码"><a href="#2-字符串和编码" class="headerlink" title="2.字符串和编码"></a>2.字符串和编码</h3><h4 id="2-0前言-字符编码"><a href="#2-0前言-字符编码" class="headerlink" title="2.0前言 字符编码"></a>2.0前言 字符编码</h4><p><strong>历史关系</strong></p><p>捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p><p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>&#39;0&#39;</code>和整数<code>0</code>是不同的；</p><p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p><p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th>字符</th><th>ASCII</th><th>Unicode</th><th>UTF-8</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>00000000 01000001</td><td>01000001</td></tr><tr><td>中</td><td>x</td><td>01001110 00101101</td><td>11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p><strong>计算机系统通用的字符编码工作方式</strong></p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p><img src="//NU-LL.github.io/2020/01/10/python/0.png" alt="rw-file-utf-8"></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="//NU-LL.github.io/2020/01/10/python/0-1578660589334.png" alt="web-utf-8"></p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h4 id="2-1Python的字符串"><a href="#2-1Python的字符串" class="headerlink" title="2.1Python的字符串"></a>2.1Python的字符串</h4><p>在最新的Python 3版本中，字符串是以Unicode编码的</p><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><pre><code class="python">&gt;&gt;&gt; ord(&#39;A&#39;)65&gt;&gt;&gt; ord(&#39;中&#39;)20013&gt;&gt;&gt; chr(66)&#39;B&#39;&gt;&gt;&gt; chr(25991)&#39;文&#39;</code></pre><p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p><pre><code class="python">&gt;&gt;&gt; &#39;\u4e2d\u6587&#39;&#39;中文&#39;</code></pre><p>两种写法完全是等价的。</p><p>由上文可知，Python的字符串在内存中以Unicode表示，如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><pre><code class="python">x = b&#39;ABC&#39;</code></pre><p>要注意<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，虽然内容显示一样，但<code>bytes</code>的每个字符都只占用一个字节。</p><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><pre><code class="python">&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)b&#39;ABC&#39;&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;ascii&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)</code></pre><p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p><p>反过来，要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; b&#39;ABC&#39;.decode(&#39;ascii&#39;)&#39;ABC&#39;&gt;&gt;&gt; b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)&#39;中文&#39;</code></pre><p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错</p><p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p><pre><code class="python">&gt;&gt;&gt; b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)&#39;中&#39;</code></pre><p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数，如果将<code>str</code>换成<code>bytes</code>，<code>len()</code>函数就计算字节数</p><ul><li>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</li></ul><p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><p>当你的源代码中包含中文的时候，就需要务必指定保存为UTF-8编码。我们通常在文件开头写上这两行：</p><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-</code></pre><ul><li><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p></li><li><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p></li></ul><h4 id="2-2格式化"><a href="#2-2格式化" class="headerlink" title="2.2格式化"></a>2.2格式化</h4><p>和C语言是一致的，用<code>%</code>实现：</p><pre><code class="python">&gt;&gt;&gt; &#39;Hello, %s&#39; % &#39;world&#39;&#39;Hello, world&#39;&gt;&gt;&gt; &#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)&#39;Hi, Michael, you have $1000000.&#39;</code></pre><p>在字符串内部，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p><p>常见的占位符有：</p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><pre><code class="python">&gt;&gt;&gt; print(&#39;%2d-%02d&#39; % (3, 1)) 3-01&gt;&gt;&gt; print(&#39;%.2f&#39; % 3.1415926)3.14</code></pre><p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p><pre><code class="python">&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)&#39;Age: 25. Gender: True&#39;</code></pre><p>当需要显示<code>%</code>时，用<code>%%</code>来转义成<code>%</code></p><p><strong>format()</strong></p><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比%要麻烦得多：</p><pre><code class="python">&gt;&gt;&gt; &#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)&#39;Hello, 小明, 成绩提升了 17.1%&#39;</code></pre><h3 id="3-使用list和tuple"><a href="#3-使用list和tuple" class="headerlink" title="3.使用list和tuple"></a>3.使用list和tuple</h3><h4 id="3-1list列表"><a href="#3-1list列表" class="headerlink" title="3.1list列表"></a>3.1list列表</h4><p>list，列表，是一种有序的集合，可以随时添加和删除其中的元素。</p><p>用<code>len()</code>函数可以获得list元素的个数</p><p>基础操作类似于数组</p><pre><code class="python">#创建&gt;&gt;&gt; classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]#获取长度&gt;&gt;&gt; len(classmates)3#访问元素 0~3&gt;&gt;&gt; classmates[0]&#39;Michael&#39;#反向 访问元素 -1~-3&gt;&gt;&gt; classmates[-1]&#39;Tracy&#39;</code></pre><p>增加，删除：</p><pre><code class="python">#追加元素到末尾&gt;&gt;&gt; classmates.append(&#39;Adam&#39;)&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]#插入到指定的位置&gt;&gt;&gt; classmates.insert(1, &#39;Jack&#39;)&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;, &#39;Adam&#39;]#删除list末尾的元素&gt;&gt;&gt; classmates.pop()&#39;Adam&#39;&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Jack&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]#删除指定位置的元素&gt;&gt;&gt; classmates.pop(1)&#39;Jack&#39;&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]#某个元素替换成别的元素&gt;&gt;&gt; classmates[1] = &#39;Sarah&#39;&gt;&gt;&gt; classmates[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]</code></pre><p>list里面的元素的<strong>数据类型可以不同</strong>：</p><pre><code class="python">&gt;&gt;&gt; L = [&#39;Apple&#39;, 123, True]#list元素也可以是另一个list&gt;&gt;&gt; s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;]&gt;&gt;&gt; len(s)4#要拿到&#39;php&#39;可以写s[2][1]，类似二维数组</code></pre><p>空的list，长度为0</p><p>注意：</p><p>list实际上可以理解为一个指向数组的指针，也就是说list和tuple的底层实现有点类似（见后文中的 tuple的本质 章节），所以普通的list赋值是指针的赋值：</p><pre><code class="python">a = [1,2,3]b = a#将a赋值给b之后，a和b指向同一块区域b = [1,2]#修改后a、b均修改#这里需要拷贝：a = [1,2,3]b = a[:]#将a中内容全部拷贝给b，a和b指向不同区域b = [1,2]#修改后 a中内容不会修改</code></pre><h4 id="3-2tuple元组"><a href="#3-2tuple元组" class="headerlink" title="3.2tuple元组"></a>3.2tuple元组</h4><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦<strong>初始化就不能修改</strong>，所以没有append()，insert()这样的方法。其他获取元素的方法和list是一样。</p><p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就<strong>必须被确定下来</strong>，比如：</p><pre><code class="python">&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2)#定义一个空的tuple（注意这里是tuple，不是数学公式中的小括号）&gt;&gt;&gt; t = ()&gt;&gt;&gt; t()</code></pre><p>注意：只有1个元素的tuple定义时为了和数学公式中的小括号区分，必须加一个<strong>逗号</strong><code>,</code>来消除歧义：</p><pre><code class="python">&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,)</code></pre><h5 id="3-2-1tuple的本质"><a href="#3-2-1tuple的本质" class="headerlink" title="3.2.1tuple的本质"></a>3.2.1tuple的本质</h5><p>tuple的本质有点类似C语言中的<code>const *</code>，即tuple的每个元素，指向永远不变。</p><p>例子：</p><pre><code class="python">&gt;&gt;&gt; t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])&gt;&gt;&gt; t[2][0] = &#39;X&#39;&gt;&gt;&gt; t[2][1] = &#39;Y&#39;&gt;&gt;&gt; t(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])</code></pre><p>这个tuple定义的时候有3个元素，分别是<code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个list。但是tuple最后却变了，为什么？</p><p>我们先看看定义的时候tuple包含的3个元素：</p><p><img src="//NU-LL.github.io/2020/01/10/python/0-1578666556949.png" alt="tuple-0"></p><p>当我们把list的元素<code>&#39;A&#39;</code>和<code>&#39;B&#39;</code>修改为<code>&#39;X&#39;</code>和<code>&#39;Y&#39;</code>后，tuple变为：</p><p><img src="//NU-LL.github.io/2020/01/10/python/0-1578666556950.png" alt="tuple-1"></p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p><h3 id="4-条件判断"><a href="#4-条件判断" class="headerlink" title="4.条件判断"></a>4.条件判断</h3><h4 id="4-1if语句"><a href="#4-1if语句" class="headerlink" title="4.1if语句"></a>4.1if语句</h4><p><code>elif</code>是<code>else if</code>的缩写，可以有多个<code>elif</code>，<code>if</code>语句的完整形式是：</p><pre><code class="python">if &lt;条件判断1&gt;:    &lt;执行1&gt;elif &lt;条件判断2&gt;:    &lt;执行2&gt;elif &lt;条件判断3&gt;:    &lt;执行3&gt;else:    &lt;执行4&gt;</code></pre><p><code>if</code>判断条件还可以简写，比如写：</p><pre><code class="python">if x:    print(&#39;True&#39;)</code></pre><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h4 id="4-2input"><a href="#4-2input" class="headerlink" title="4.2input"></a>4.2input</h4><p>用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思。</p><p>注意：<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p><pre><code class="python">s = input(&#39;birth: &#39;)birth = int(s)if birth &lt; 2000:    print(&#39;00前&#39;)else:    print(&#39;00后&#39;)</code></pre><h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h3><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，即<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p><p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。</p><pre><code class="python">&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]#循环sum = 0for x in range(101):    sum = sum + xprint(sum)</code></pre><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。</p><pre><code class="python">sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)</code></pre><p>在循环中，<code>break</code>语句可以提前退出循环。</p><p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p><h3 id="6-使用dict和set"><a href="#6-使用dict和set" class="headerlink" title="6.使用dict和set"></a>6.使用dict和set</h3><h4 id="6-1dict字典"><a href="#6-1dict字典" class="headerlink" title="6.1dict字典"></a>6.1dict字典</h4><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><pre><code class="python">#初始化&gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}&gt;&gt;&gt; d[&#39;Michael&#39;]95#通过key将数据放入dict&gt;&gt;&gt; d[&#39;Adam&#39;] = 67&gt;&gt;&gt; d[&#39;Adam&#39;]67#替换&gt;&gt;&gt; d[&#39;Jack&#39;] = 90&gt;&gt;&gt; d[&#39;Jack&#39;]90&gt;&gt;&gt; d[&#39;Jack&#39;] = 88&gt;&gt;&gt; d[&#39;Jack&#39;]88#删除，对应的value也会从dict中删除&gt;&gt;&gt; d.pop(&#39;Bob&#39;)75&gt;&gt;&gt; d{&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85}</code></pre><p>如果key不存在，dict就会报错</p><p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p><pre><code class="python">&gt;&gt;&gt; &#39;Thomas&#39; in dFalse</code></pre><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><pre><code class="python">&gt;&gt;&gt; d.get(&#39;Thomas&#39;)&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)-1</code></pre><p>注意：</p><ul><li>返回<code>None</code>的时候Python的交互环境不显示结果。</li><li>dict内部存放的顺序和key放入的顺序是没有关系的。</li><li>dict的key必须是<strong>不可变对象</strong>。（哈希算法，利用key计算value的位置）<ul><li>字符串、整数等都是不可变的，而list是可变的，不能作为key</li></ul></li></ul><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><h4 id="6-2set"><a href="#6-2set" class="headerlink" title="6.2set"></a>6.2set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><pre><code class="python">&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s{1, 2, 3}#重复元素在set中自动被过滤&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s{1, 2, 3}</code></pre><p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p><p>基本操作：</p><pre><code class="python">#添加 可以重复添加，但不会有效果&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s{1, 2, 3, 4}&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s{1, 2, 3, 4}#删除&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s{1, 2, 3}</code></pre><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的<strong>交集</strong>、<strong>并集</strong>等操作：</p><pre><code class="python">&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2{2, 3}&gt;&gt;&gt; s1 | s2{1, 2, 3, 4}</code></pre><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样<strong>不可以放入可变对象</strong>，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</p><h4 id="6-3不可变对象"><a href="#6-3不可变对象" class="headerlink" title="6.3不可变对象"></a>6.3不可变对象</h4><p>上面我们讲了，str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><pre><code class="python">&gt;&gt;&gt; a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>而对于不可变对象，比如str，对str进行操作呢：</p><pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39;&gt;&gt;&gt; a.replace(&#39;a&#39;, &#39;A&#39;)&#39;Abc&#39;&gt;&gt;&gt; a&#39;abc&#39;</code></pre><p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>&#39;Abc&#39;</code>，但变量<code>a</code>最后仍是<code>&#39;abc&#39;</code>，应该怎么理解呢？</p><p>我们先把代码改成下面这样：</p><pre><code class="python">&gt;&gt;&gt; a = &#39;abc&#39;&gt;&gt;&gt; b = a.replace(&#39;a&#39;, &#39;A&#39;)&gt;&gt;&gt; b&#39;Abc&#39;&gt;&gt;&gt; a&#39;abc&#39;</code></pre><p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p><pre><code class="ascii">┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘</code></pre><p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p><pre><code class="ascii">┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘┌───┐                  ┌───────┐│ b │─────────────────&gt;│ &#39;Abc&#39; │└───┘                  └───────┘</code></pre><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1-调用函数"><a href="#1-调用函数" class="headerlink" title="1.调用函数"></a>1.调用函数</h3><p>Python的官方网站查看内置函数文档：<a href="https://docs.python.org/zh-cn/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/functions.html</a></p><h4 id="1-1数据类型转换"><a href="#1-1数据类型转换" class="headerlink" title="1.1数据类型转换"></a>1.1数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数，<code>hex()</code>函数把一个整数转换成十六进制表示的字符串</p><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><pre><code class="python">&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1</code></pre><h3 id="2-定义函数"><a href="#2-定义函数" class="headerlink" title="2.定义函数"></a>2.定义函数</h3><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p><pre><code class="python">def my_abs(x):    if x &gt;= 0:        return x    else:        return -xprint(my_abs(-99))#增加对参数类型的检查def my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError(&#39;bad operand type&#39;)    if x &gt;= 0:        return x    else:        return -x</code></pre><p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p><h4 id="2-1空函数"><a href="#2-1空函数" class="headerlink" title="2.1空函数"></a>2.1空函数</h4><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><pre><code class="python">def nop():    pass</code></pre><p><code>pass</code>语句可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p><h4 id="2-2返回多个值"><a href="#2-2返回多个值" class="headerlink" title="2.2返回多个值"></a>2.2返回多个值</h4><p>例如：</p><pre><code class="python">import mathdef move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny</code></pre><p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p><pre><code class="python">#看起来是两个值&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0#实际上是一个tuple&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0)</code></pre><p>在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="3函数的参数"><a href="#3函数的参数" class="headerlink" title="3函数的参数"></a>3函数的参数</h3><h4 id="3-1位置参数"><a href="#3-1位置参数" class="headerlink" title="3.1位置参数"></a>3.1位置参数</h4><pre><code class="python">def power(x):    return x * x</code></pre><p>对于<code>power(x)</code>函数，参数<code>x</code>就是一个位置参数。</p><p>当我们调用<code>power</code>函数时，必须传入有且仅有的一个参数<code>x</code></p><p>修改原函数后的<code>power(x, n)</code>函数，可以计算任意n次方：</p><pre><code class="python">def power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s</code></pre><p>修改后的<code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p><h4 id="3-2默认参数"><a href="#3-2默认参数" class="headerlink" title="3.2默认参数"></a>3.2默认参数</h4><p>新的<code>power(x, n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用</p><p>由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><pre><code class="python">def power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s</code></pre><p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code></p><p>默认参数可以简化函数的调用，但是需要注意：</p><ul><li>必选参数在前，默认参数在后，否则Python的解释器会报错</li><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>默认参数在函数定义的时候就被计算出来了，且必须指向一个不变对象，见后文例子</li></ul><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。</p><hr><p>默认参数例子：</p><pre><code class="python">def add_end(L=[]):    L.append(&#39;END&#39;)    return L</code></pre><p>当你正常调用时，结果似乎不错：</p><pre><code class="python">&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, &#39;END&#39;]&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]#使用默认参数调用时，再次调用add_end()，结果就不对了&gt;&gt;&gt; add_end()[&#39;END&#39;]&gt;&gt;&gt; add_end()[&#39;END&#39;, &#39;END&#39;]&gt;&gt;&gt; add_end()[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</code></pre><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！</p><p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p><pre><code class="python">def add_end(L=None):    if L is None:        L = []    L.append(&#39;END&#39;)    return L</code></pre><p>现在，无论调用多少次，都不会有问题：</p><h4 id="3-3可变参数"><a href="#3-3可变参数" class="headerlink" title="3.3可变参数"></a>3.3可变参数</h4><pre><code class="python">def calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum</code></pre><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数</p><p>如果已经有一个list或者tuple，Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><pre><code class="python">&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14</code></pre><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p><h4 id="3-4关键字参数"><a href="#3-4关键字参数" class="headerlink" title="3.4关键字参数"></a>3.4关键字参数</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><pre><code class="python">def person(name, age, **kw):    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</code></pre><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><pre><code class="python">#只传入必选参数&gt;&gt;&gt; person(&#39;Michael&#39;, 30)name: Michael age: 30 other: {}#传入任意个数的关键字参数&gt;&gt;&gt; person(&#39;Bob&#39;, 35, city=&#39;Beijing&#39;)name: Bob age: 35 other: {&#39;city&#39;: &#39;Beijing&#39;}&gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)name: Adam age: 45 other: {&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;}</code></pre><p>和可变参数类似，已经有一个dict，Python允许你在dict前面加一个<code>**</code>号，把dict的元素变成可变参数传进去：</p><pre><code class="python">&gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra)name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}</code></pre><h4 id="3-5命名关键字参数"><a href="#3-5命名关键字参数" class="headerlink" title="3.5命名关键字参数"></a>3.5命名关键字参数</h4><p>对于<em>关键字参数</em>，函数的调用者可以传入<em>任意不受限制</em>的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。</p><p>如果要限制关键字参数的名字，就可以用<strong>命名关键字参数</strong>，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p><pre><code class="python">def person(name, age, *, city, job):    print(name, age, city, job)</code></pre><p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><pre><code class="python">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)Jack 24 Beijing Engineer</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><pre><code class="python">def person(name, age, *args, city, job):    print(name, age, args, city, job)</code></pre><p>命名关键字参数<strong>必须传入参数名</strong>，这和位置参数不同。如果没有传入参数名，调用将报错</p><p>命名关键字参数也可以有缺省值，从而简化调用</p><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就<strong>必须</strong>加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数：</p><pre><code class="python">def person(name, age, city, job):    # 缺少 *，city和job被视为位置参数    pass</code></pre><h4 id="3-6组合参数"><a href="#3-6组合参数" class="headerlink" title="3.6组合参数"></a>3.6组合参数</h4><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong>。</p><p>比如定义一个函数，包含上述若干种参数：</p><pre><code class="python">def f1(a, b, c=0, *args, **kw):    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)def f2(a, b, c=0, *, d, **kw):    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)</code></pre><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre><code class="python">&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = {}&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {}&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;)a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {}&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x=99)a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {&#39;x&#39;: 99}&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {&#39;ext&#39;: None}</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><pre><code class="python">#调用f1&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}#调用f2&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = {&#39;d&#39;: 88, &#39;x&#39;: &#39;#&#39;}&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = {&#39;x&#39;: &#39;#&#39;}</code></pre><p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p><h3 id="4递归函数"><a href="#4递归函数" class="headerlink" title="4递归函数"></a>4递归函数</h3><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p><p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，<strong>return语句不能包含表达式</strong>。这样，<strong>编译器</strong>或者<strong>解释器</strong>就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><pre><code class="python">#没有尾递归优化def fact(n):    if n==1:        return 1    return n * fact(n - 1)#有尾递归优化def fact(n):    return fact_iter(n, 1)def fact_iter(num, product):    if num == 1:        return product    return fact_iter(num - 1, num * product)</code></pre><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code>fact(n)</code>函数改成尾递归方式，也会导致栈溢出。</p><h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="3-1切片"><a href="#3-1切片" class="headerlink" title="3.1切片"></a>3.1切片</h3><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p><p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p><pre><code class="python">&gt;&gt;&gt; L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]&gt;&gt;&gt; L[0:3][&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]#如果第一个索引是0，还可以省略&gt;&gt;&gt; L[:3][&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]#支持倒数切片&gt;&gt;&gt; L[-2:][&#39;Bob&#39;, &#39;Jack&#39;]&gt;&gt;&gt; L[-2:-1][&#39;Bob&#39;]</code></pre><p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p><pre><code class="python">#创建一个更大的数列&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99]#前10个数，每两个取一个&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]#所有数，每5个取一个：&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]#原样复制一个list&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99]</code></pre><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</p><p>同样，字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串</p><h3 id="3-2迭代"><a href="#3-2迭代" class="headerlink" title="3.2迭代"></a>3.2迭代</h3><p>如果给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C语言，迭代list是通过下标完成的</p><p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代</p><pre><code class="python">&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}&gt;&gt;&gt; for key in d:...     print(key)...acb</code></pre><p>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</p><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p><p>由于字符串也是可迭代对象，因此，也可以作用于<code>for</code>循环</p><p>通过collections模块的Iterable类型可以判断一个对象是否为可迭代对象：</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False</code></pre><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p><pre><code class="python">&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):...     print(i, value)...0 A1 B2 C</code></pre><p>上面的<code>for</code>循环里，同时引用了两个变量，在Python里是很常见的</p><h3 id="3-3列表生成式"><a href="#3-3列表生成式" class="headerlink" title="3.3列表生成式"></a>3.3列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><pre><code class="python">#普通方法&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]#运用列表生成式 生成复杂的list&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#for循环后＋if&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]#两层循环&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;][&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]#for循环中同时使用两个甚至多个变量&gt;&gt;&gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }&gt;&gt;&gt; [k + &#39;=&#39; + v for k, v in d.items()][&#39;y=B&#39;, &#39;x=A&#39;, &#39;z=C&#39;]#把一个list中所有的字符串变成小写&gt;&gt;&gt; L = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]&gt;&gt;&gt; [s.lower() for s in L][&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</code></pre><h3 id="3-4生成器"><a href="#3-4生成器" class="headerlink" title="3.4生成器"></a>3.4生成器</h3><p>如果列表元素可以按照某种算法推算出来，那我们可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><pre><code class="python">&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;#通过next()函数获得generator的下一个返回值&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)64&gt;&gt;&gt; next(g)81&gt;&gt;&gt; next(g)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。</p><p>generator保存的是算法，每次调用<code>next(g)</code>，就计算出<code>g</code>的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><p>generator是可迭代对象，所以能够使用<code>for</code>循环迭代</p><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><p>定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><pre><code class="python">#普通函数 生成斐波拉契数列def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        print(b)        a, b = b, a + b        n = n + 1    return &#39;done&#39;#generatordef fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        yield b        a, b = b, a + b        n = n + 1    return &#39;done&#39;</code></pre><blockquote><p>其中赋值语句：</p><pre><code class="python">a, b = b, a + b</code></pre><p>相当于：</p><pre><code class="python">t = (b, a + b) # t是一个tuplea = t[0]b = t[1]</code></pre><p>但不必显式写出临时变量t就可以赋值。</p></blockquote><p>这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。可概括为以下三点：</p><ul><li>生成器是一个不断产生值的函数</li><li>包含yield语句的函数是一个生成器</li><li>生成器每次产生一个值(yield语句)，函数被冻结，被唤醒后再产生一个值</li></ul><blockquote><p>例子，定义一个generator，依次返回数字1，3，5：</p><pre><code class="python">def odd():    print(&#39;step 1&#39;)    yield 1    print(&#39;step 2&#39;)    yield(3)    print(&#39;step 3&#39;)    yield(5)</code></pre><p>调用该generator时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值：</p><pre><code class="python">&gt;&gt;&gt; o = odd()&gt;&gt;&gt; next(o)step 11&gt;&gt;&gt; next(o)step 23&gt;&gt;&gt; next(o)step 35&gt;&gt;&gt; next(o)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>可以看到，<code>odd</code>不是普通函数，而是generator，在执行过程中，遇到<code>yield</code>就中断，下次又继续执行。执行3次<code>yield</code>后，已经没有<code>yield</code>可以执行了，所以，第4次调用<code>next(o)</code>就报错。</p></blockquote><p>用<code>for</code>循环调用generator时（如这种：<code>for n in fib(6)</code>），发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><pre><code class="python">&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:...     try:...         x = next(g)...         print(&#39;g:&#39;, x)...     except StopIteration as e:...         print(&#39;Generator return value:&#39;, e.value)...         break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done</code></pre><h3 id="3-5迭代器"><a href="#3-5迭代器" class="headerlink" title="3.5迭代器"></a>3.5迭代器</h3><p>可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True</code></pre><p>而生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器</strong>：<code>Iterator</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterator)False</code></pre><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><pre><code class="python">&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)True</code></pre><p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p><strong>总之</strong>：</p><ul><li>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</li><li>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</li><li>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的<ul><li>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等会先通过<code>iter()</code>函数获得一个<code>Iterator</code>对象</li></ul></li></ul><h2 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h2><h3 id="4-1高阶函数"><a href="#4-1高阶函数" class="headerlink" title="4.1高阶函数"></a>4.1高阶函数</h3><p>函数本身也可以赋值给变量，即：变量可以指向函数。</p><p>如果一个变量指向了一个函数，那么，可以通过该变量来调用这个函数</p><pre><code class="python">&gt;&gt;&gt; f = abs&gt;&gt;&gt; f&lt;built-in function abs&gt;&gt;&gt;&gt; f(-10)10</code></pre><p>函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p><pre><code class="python">&gt;&gt;&gt; abs = 10#修改abs的指向&gt;&gt;&gt; abs(-10)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;int&#39; object is not callable#要恢复abs函数，需要重启Python交互环境。</code></pre><p>注意：由于<code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改<code>abs</code>变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</p><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数</strong>。</p><p>如：</p><pre><code class="python">def add(x, y, f):    return f(x) + f(y)</code></pre><p>编写高阶函数，就是让函数的参数能够接收别的函数。函数式编程就是指这种高度抽象的编程范式。</p><h4 id="4-1-1map-reduce"><a href="#4-1-1map-reduce" class="headerlink" title="4.1.1map/reduce"></a>4.1.1map/reduce</h4><p>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><blockquote><p>比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><pre><code class="ascii">            f(x) = x * x                  │                  │  ┌───┬───┬───┬───┼───┬───┬───┬───┐  │   │   │   │   │   │   │   │   │  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼[ 1   2   3   4   5   6   7   8   9 ]  │   │   │   │   │   │   │   │   │  │   │   │   │   │   │   │   │   │  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼[ 1   4   9  16  25  36  49  64  81 ]</code></pre><p>现在，我们用Python代码实现：</p><pre><code class="python">&gt;&gt;&gt; def f(x):...     return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p><code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p></blockquote><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x^2^，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p><pre><code class="python">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</code></pre><p>只需要一行代码。</p><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><pre><code class="python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></pre><blockquote><p>比如对一个序列求和，就可以用<code>reduce</code>实现：</p><pre><code class="python">&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):...     return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25</code></pre><p>比如把<code>str</code>转换为<code>int</code>：</p><pre><code class="python">from functools import reduceDIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}def str2int(s):    def fn(x, y):        return x * 10 + y    def char2num(s):        return DIGITS[s]    return reduce(fn, map(char2num, s))</code></pre><p>还可以用lambda函数进一步简化成：</p><pre><code class="python">from functools import reduceDIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}def char2num(s):    return DIGITS[s]def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</code></pre><p>lambda函数的用法在后面介绍。</p></blockquote><h4 id="4-1-2filter"><a href="#4-1-2filter" class="headerlink" title="4.1.2filter"></a>4.1.2filter</h4><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><blockquote><p>把一个序列中的空字符串删掉：</p><pre><code class="python">def not_empty(s):    return s and s.strip()list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))# 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre></blockquote><p>注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h4 id="4-1-3sorted"><a href="#4-1-3sorted" class="headerlink" title="4.1.3sorted"></a>4.1.3sorted</h4><p>Python内置的<code>sorted()</code>函数就可以对list从小到大进行排序：</p><pre><code class="python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]</code></pre><p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p><blockquote><p>如按绝对值大小排序：</p><pre><code class="python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]</code></pre><p>这个过程可以理解为：</p><pre><code class="python">list = [36, 5, -12, 9, -21]#原始的listkeys = [36, 5,  12, 9,  21]#经过key=abs处理过的list</code></pre><p>然后<code>sorted()</code>函数按照keys进行排序，并按照对应关系返回list相应的元素：</p><pre><code class="ascii">keys排序结果 =&gt; [5, 9,  12,  21, 36]                |  |    |    |   |最终结果     =&gt; [5, 9, -12, -21, 36]</code></pre></blockquote><p>默认情况下，对字符串排序，是按照ASCII的大小比较的</p><p>要进行<strong>反向排序</strong>，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p><h3 id="4-2返回函数"><a href="#4-2返回函数" class="headerlink" title="4.2返回函数"></a>4.2返回函数</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><pre><code class="python">def lazy_sum(*args):    def sum():        ax = 0        for n in args:            ax = ax + n        return ax    return sum</code></pre><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><pre><code class="python">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;#真正计算求和的结果&gt;&gt;&gt; f()25</code></pre><p>调用函数<code>f</code>时，才真正计算求和的结果</p><p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“<strong>闭包</strong>（Closure）”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p><pre><code class="python">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False</code></pre><p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p><h4 id="4-2-1闭包"><a href="#4-2-1闭包" class="headerlink" title="4.2.1闭包"></a>4.2.1闭包</h4><p>注意到返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。</p><blockquote><p>例子：</p><pre><code class="python">def count():    fs = []    for i in range(1, 4):        def f():             return i*i        fs.append(f)    return fsf1, f2, f3 = count()</code></pre><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p><p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p><pre><code class="python">&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9</code></pre><p>全部都是<code>9</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p></blockquote><p>返回闭包时牢记一点：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。</p><blockquote><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><pre><code class="python">def count():    def f(j):        def g():            return j*j        return g    fs = []    for i in range(1, 4):        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()    return fs</code></pre><p>再看看结果：</p><pre><code class="python">&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()4&gt;&gt;&gt; f3()9</code></pre><p>缺点是代码较长，可利用lambda函数缩短代码。</p></blockquote><h4 id="4-2-2关键字global与nonlocal"><a href="#4-2-2关键字global与nonlocal" class="headerlink" title="4.2.2关键字global与nonlocal"></a>4.2.2关键字global与nonlocal</h4><p>第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。</p><p>第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误</p><h3 id="4-3匿名函数"><a href="#4-3匿名函数" class="headerlink" title="4.3匿名函数"></a>4.3匿名函数</h3><p>匿名函数<code>lambda x: x * x</code>实际上就是：</p><pre><code class="python">def f(x):    return x * x</code></pre><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><pre><code class="python">&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;&gt;&gt;&gt; f(5)25</code></pre><p>同样，也可以把匿名函数作为返回值返回，比如：</p><pre><code class="python">def build(x, y):    return lambda: x * x + y * y</code></pre><h3 id="4-4装饰器"><a href="#4-4装饰器" class="headerlink" title="4.4装饰器"></a>4.4装饰器</h3><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字</p><pre><code class="python">&gt;&gt;&gt; def now():...     print(&#39;2015-3-25&#39;)...&gt;&gt;&gt; now.__name__&#39;now&#39;</code></pre><p>现在，假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间<strong>动态增加功能</strong>的方式，称之为“<strong>装饰器</strong>”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><pre><code class="python">def log(func):    def wrapper(*args, **kw):        print(&#39;call %s():&#39; % func.__name__)        return func(*args, **kw)    return wrapper</code></pre><p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的<strong>@</strong>语法，把decorator置于函数的定义处：</p><pre><code class="python">@logdef now():    print(&#39;2015-3-25&#39;)</code></pre><p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p><pre><code class="python">&gt;&gt;&gt; now()call now():2015-3-25</code></pre><p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p><pre><code class="python">now = log(now)</code></pre><p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p><p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p><pre><code class="python">def log(text):    def decorator(func):        def wrapper(*args, **kw):            print(&#39;%s %s():&#39; % (text, func.__name__))            return func(*args, **kw)        return wrapper    return decorator</code></pre><p>这个3层嵌套的decorator用法如下：</p><pre><code class="python">@log(&#39;execute&#39;)def now():    print(&#39;2015-3-25&#39;)</code></pre><p>执行结果如下：</p><pre><code class="python">&gt;&gt;&gt; now()execute now():2015-3-25</code></pre><p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p><pre><code class="python">&gt;&gt;&gt; now = log(&#39;execute&#39;)(now)</code></pre><p>我们来剖析上面的语句，首先执行<code>log(&#39;execute&#39;)</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p><p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>&#39;now&#39;</code>变成了<code>&#39;wrapper&#39;</code>：</p><pre><code class="python">&gt;&gt;&gt; now.__name__&#39;wrapper&#39;</code></pre><p>因为返回的那个<code>wrapper()</code>函数名字就是<code>&#39;wrapper&#39;</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p><pre><code class="python">import functoolsdef log(func):    @functools.wraps(func)    def wrapper(*args, **kw):        print(&#39;call %s():&#39; % func.__name__)        return func(*args, **kw)    return wrapper</code></pre><p>或者针对带参数的decorator：</p><pre><code class="python">import functoolsdef log(text):    def decorator(func):        @functools.wraps(func)        def wrapper(*args, **kw):            print(&#39;%s %s():&#39; % (text, func.__name__))            return func(*args, **kw)        return wrapper    return decorator</code></pre><p><code>import functools</code>是导入<code>functools</code>模块。模块的概念稍候讲解。现在，只需记住在定义<code>wrapper()</code>的前面加上<code>@functools.wraps(func)</code>即可。</p><h3 id="4-5偏函数"><a href="#4-5偏函数" class="headerlink" title="4.5偏函数"></a>4.5偏函数</h3><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</p><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，作用就是把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><pre><code class="python">&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&#39;1000000&#39;)64#重设默认值&gt;&gt;&gt; int2(&#39;1000000&#39;, base=10)1000000</code></pre><p>最后，创建偏函数时，实际上可以接收 函数对象、<code>*args</code>和<code>**kw</code>这3个参数</p><blockquote><p>例子：</p><pre><code class="python">int2 = functools.partial(int, base=2)int2(&#39;10010&#39;)#相当于kw = { &#39;base&#39;: 2 }int(&#39;10010&#39;, **kw)</code></pre><p>又：</p><pre><code class="python">max2 = functools.partial(max, 10)max2(5, 6, 7)#相当于args = (10, 5, 6, 7)#实际上会把10作为*args的一部分自动加到左边max(*args)</code></pre><p>注意上述例子中会把10作为<em>args的一部分自动加到*</em>左边**</p></blockquote><h2 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h2><h3 id="5-0模块和包"><a href="#5-0模块和包" class="headerlink" title="5.0模块和包"></a>5.0模块和包</h3><p>在Python中，一个.py文件就称之为一个模块（Module）。</p><p>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p><blockquote><p>例子：</p><p>一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块，一个<code>xyz.py</code>的文件就是一个名字叫<code>xyz</code>的模块。</p><p>现在，假设我们的<code>abc</code>和<code>xyz</code>这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p><pre><code class="ascii">mycompany├─ __init__.py├─ abc.py└─ xyz.py</code></pre><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p></blockquote><p>可以有多级目录，组成多级层次的包结构</p><blockquote><p>例子：</p><pre><code class="ascii">mycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py ├─ abc.py └─ utils.py</code></pre><p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p><p><code>mycompany.web</code>也是一个模块，该模块对应为<code>mycompany.web.__init__.py</code>文件。</p></blockquote><p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p><h3 id="5-1使用模块"><a href="#5-1使用模块" class="headerlink" title="5.1使用模块"></a>5.1使用模块</h3><p>Python模块的标准文件模板：</p><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-&#39; a test module &#39;__author__ = &#39;Michael Liao&#39;import sysdef test():    args = sys.argv    if len(args)==1:        print(&#39;Hello, world!&#39;)    elif len(args)==2:        print(&#39;Hello, %s!&#39; % args[1])    else:        print(&#39;Too many arguments!&#39;)if __name__==&#39;__main__&#39;:    test()</code></pre><p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p><p>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p><p>第6行使用<code>__author__</code>变量把作者写进去</p><p>使用<code>sys</code>模块的第一步，就是导入该模块。导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称</p><blockquote><p>如：</p><p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；</p><p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael]</code>。</p></blockquote><p>注意到这两行代码：</p><pre><code class="python">if __name__==&#39;__main__&#39;:    test()</code></pre><p>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p><ul><li><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p></li><li><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p></li></ul><p>注意：private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p><h3 id="5-2安装第三方模块"><a href="#5-2安装第三方模块" class="headerlink" title="5.2安装第三方模块"></a>5.2安装第三方模块</h3><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><p>注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是<code>pip3</code>。</p><p>一般来说，第三方库都会在Python官方的<a href="https://pypi.python.org/" target="_blank" rel="noopener">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称</p><p>推荐直接使用<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a>，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p><p>下载安装后，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p><h4 id="5-2-1模块搜索路径"><a href="#5-2-1模块搜索路径" class="headerlink" title="5.2.1模块搜索路径"></a>5.2.1模块搜索路径</h4><p>默认情况下，Python解释器会搜索 当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><pre><code class="python">&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#39;&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#39;, ..., &#39;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#39;]</code></pre><p>如果我们要添加自己的搜索目录，有两种方法：</p><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><pre><code class="python">&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)</code></pre><p>这种方法是在运行时修改，运行结束后失效。</p><p>第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。</p><h2 id="六、面向对象编程"><a href="#六、面向对象编程" class="headerlink" title="六、面向对象编程"></a>六、面向对象编程</h2><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p><h3 id="6-1类和实例"><a href="#6-1类和实例" class="headerlink" title="6.1类和实例"></a>6.1类和实例</h3><p>以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><pre><code class="python">class Student(object):    pass</code></pre><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过类名+()实现的：</p><pre><code class="python">&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt; Student&lt;class &#39;__main__.Student&#39;&gt;</code></pre><p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p><p>可以自由地给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p><pre><code class="python">&gt;&gt;&gt; bart.name = &#39;Bart Simpson&#39;&gt;&gt;&gt; bart.name&#39;Bart Simpson&#39;</code></pre><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><pre><code class="python">class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score</code></pre><p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去</p><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h4 id="6-1-1数据封装"><a href="#6-1-1数据封装" class="headerlink" title="6.1.1数据封装"></a>6.1.1数据封装</h4><p>每个实例拥有各自的<code>name</code>和<code>score</code>这些数据，我们可以通过函数来访问这些数据。将这些封装数据的函数和<code>Student</code>类本身关联起来，我们称之为类的方法：</p><pre><code class="python">class Student(object):    def __init__(self, name, score):        self.name = name        self.score = score    def print_score(self):        print(&#39;%s: %s&#39; % (self.name, self.score))</code></pre><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><pre><code class="python">&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)&gt;&gt;&gt; bart.print_score()Bart Simpson: 59</code></pre><p>封装的另一个好处是随时可以给<code>Student</code>类增加新的方法</p><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p><pre><code class="python">&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)&gt;&gt;&gt; lisa = Student(&#39;Lisa Simpson&#39;, 87)&gt;&gt;&gt; bart.age = 8&gt;&gt;&gt; bart.age8&gt;&gt;&gt; lisa.ageTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;Student&#39; object has no attribute &#39;age&#39;</code></pre><h3 id="6-2访问限制"><a href="#6-2访问限制" class="headerlink" title="6.2访问限制"></a>6.2访问限制</h3><p>从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的<code>name</code>、<code>score</code>属性</p><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><blockquote><p>把Student类改一改：</p><pre><code class="python">class Student(object):    def __init__(self, name, score):        self.__name = name        self.__score = score    def print_score(self):        print(&#39;%s: %s&#39; % (self.__name, self.__score))</code></pre><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p></blockquote><p>如果外部代码要获取name和score，可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法</p><p>同理，要允许外部代码修改score，可以再给Student类增加<code>set_score</code>方法</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><pre><code class="python">&gt;&gt;&gt; bart._Student__name&#39;Bart Simpson&#39;</code></pre><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p><p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p><h3 id="6-3继承和多态"><a href="#6-3继承和多态" class="headerlink" title="6.3继承和多态"></a>6.3继承和多态</h3><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）</p><blockquote><p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：</p><pre><code class="python">class Animal(object):    def run(self):        print(&#39;Animal is running...&#39;)</code></pre><p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p><pre><code class="python">class Dog(Animal):    passclass Cat(Animal):    pass</code></pre><p>最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法</p><p>也可以对子类增加一些方法，比如Dog类：</p><pre><code class="python">class Dog(Animal):    def run(self):        print(&#39;Dog is running...&#39;)    def eat(self):        print(&#39;Eating meat...&#39;)</code></pre><p>对<code>Dog</code>和<code>Cat</code>类改进如下：</p><pre><code class="python">class Dog(Animal):    def run(self):        print(&#39;Dog is running...&#39;)class Cat(Animal):    def run(self):        print(&#39;Cat is running...&#39;)</code></pre><p>再次运行，结果如下：</p><pre><code class="python">Dog is running...Cat is running...</code></pre><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p></blockquote><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断</p><blockquote><p>例子：</p><pre><code class="python">a = list() # a是list类型b = Animal() # b是Animal类型c = Dog() # c是Dog类型&gt;&gt;&gt; isinstance(a, list)True&gt;&gt;&gt; isinstance(b, Animal)True&gt;&gt;&gt; isinstance(c, Dog)True</code></pre></blockquote><p><strong>多态</strong>：对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><ul><li>对扩展开放：允许新增<code>Animal</code>子类；</li><li>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</li></ul><blockquote><p>例子：</p><pre><code class="python">class Animal(object):    def run(self):        print(&#39;Animal is running...&#39;)class Dog(Animal):    def run(self):        print(&#39;Dog is running...&#39;)class Cat(Animal):    def run(self):        print(&#39;Cat is running...&#39;)#只需要animal类型的变量即可def run_twice(animal):    animal.run()    animal.run()#调用：&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running...&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running...#新增Tortoise类，并调用仍然可以正常运行class Tortoise(Animal):    def run(self):        print(&#39;Tortoise is running slowly...&#39;)&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly...</code></pre></blockquote><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><pre><code class="ascii">                ┌───────────────┐                │    object     │                └───────────────┘                        │           ┌────────────┴────────────┐           │                         │           ▼                         ▼    ┌─────────────┐           ┌─────────────┐    │   Animal    │           │    Plant    │    └─────────────┘           └─────────────┘           │                         │     ┌─────┴──────┐            ┌─────┴──────┐     │            │            │            │     ▼            ▼            ▼            ▼┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │└─────────┘  └─────────┘  └─────────┘  └─────────┘</code></pre><h4 id="6-3-1静态语言和动态语言在此处的区别"><a href="#6-3-1静态语言和动态语言在此处的区别" class="headerlink" title="6.3.1静态语言和动态语言在此处的区别"></a>6.3.1静态语言和动态语言在此处的区别</h4><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><pre><code class="python">class Timer(object):    def run(self):        print(&#39;Start...&#39;)</code></pre><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p><h3 id="6-4获取对象信息"><a href="#6-4获取对象信息" class="headerlink" title="6.4获取对象信息"></a>6.4获取对象信息</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>基本类型都可以用<code>type()</code>判断：</p><pre><code class="python">&gt;&gt;&gt; type(123)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(&#39;str&#39;)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &#39;NoneType&#39;&gt;#指向函数或者类&gt;&gt;&gt; type(abs)&lt;class &#39;builtin_function_or_method&#39;&gt;&gt;&gt;&gt; type(a)&lt;class &#39;__main__.Animal&#39;&gt;</code></pre><p><code>type()</code>函数返回对应的Class类型</p><p>比较：</p><pre><code class="python">#判断基本数据类型可以直接写int，str等&gt;&gt;&gt; type(123)==type(456)True&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type(&#39;abc&#39;)==type(&#39;123&#39;)True&gt;&gt;&gt; type(&#39;abc&#39;)==strTrue#判断一个对象是否是函数#使用types模块中定义的常量&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():...     pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue</code></pre><h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h4><p>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。</p><blockquote><p>例如上次的继承关系：</p><pre><code class="python">object -&gt; Animal -&gt; Dog -&gt; Husky</code></pre><p>那么，<code>isinstance()</code>就可以告诉我们，一个对象是否是某种类型。</p><pre><code class="python">&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Dog)True&gt;&gt;&gt; isinstance(h, Animal)True#基本类型&gt;&gt;&gt; isinstance(&#39;a&#39;, str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b&#39;a&#39;, bytes)True#判断一个变量是否是某些类型中的一种&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True</code></pre></blockquote><p>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><pre><code class="python">&gt;&gt;&gt; dir(&#39;ABC&#39;)[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]</code></pre><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p><p>自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; class MyDog(object):...     def __len__(self):...         return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100</code></pre><p>仅仅把属性和方法列出来是不够的，配合内置函数<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p><pre><code class="python">&gt;&gt;&gt; class MyObject(object):...     def __init__(self):...         self.x = 9...     def power(self):...         return self.x * self.x...&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？True&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81&gt;&gt;&gt; obj = MyObject()&gt;&gt;&gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？False&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？True&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;19&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;19#试图获取不存在的属性，会抛出AttributeError的错误#可以传入一个default参数，如果属性不存在，就返回默认值&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404404#也可以获得对象的方法&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？True&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81</code></pre><p>注意：只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接获取就直接获取</p><h3 id="6-5实例属性和类属性"><a href="#6-5实例属性和类属性" class="headerlink" title="6.5实例属性和类属性"></a>6.5实例属性和类属性</h3><p>直接在class中定义属性，这种属性是<strong>类属性</strong>，归该类所有</p><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。</p><blockquote><p>例子：</p><pre><code class="python">&gt;&gt;&gt; class Student(object):...     name = &#39;Student&#39;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student</code></pre></blockquote><p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将<strong>屏蔽掉类属性</strong>，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h2 id="七、面向对象高级编程"><a href="#七、面向对象高级编程" class="headerlink" title="七、面向对象高级编程"></a>七、面向对象高级编程</h2><h3 id="7-1使用-slots"><a href="#7-1使用-slots" class="headerlink" title="7.1使用_slots_"></a>7.1使用_<em>slots_</em></h3><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p><p>但是，给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给class绑定方法。给class绑定方法后，所有实例均可调用</p><p>如果我们想要限制实例的属性，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</p><blockquote><p>例子：</p><pre><code class="python">class Student(object):    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;&gt;&gt;&gt; s.age = 25 # 绑定属性&#39;age&#39;&gt;&gt;&gt; s.score = 99 # 绑定属性&#39;score&#39;Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;</code></pre></blockquote><p>注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p><h3 id="7-2使用-property"><a href="#7-2使用-property" class="headerlink" title="7.2使用@property"></a>7.2使用@property</h3><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把属性随便改。解决方法就是增加一个<code>set_xxx()</code>方法来设置属性，再通过一个<code>get_xxx()</code>来获取属性，这样，在<code>set_sss()</code>方法里，就可以检查参数。但是，这样的调用方法又略显复杂，没有直接用属性这么直接简单。</p><p>对于Python来说，可以利用之前的装饰器（decorator），对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p><pre><code class="python">class Student(object):    @property    def score(self):        return self._score    @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&#39;score must be an integer!&#39;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&#39;score must between 0 ~ 100!&#39;)        self._score = value</code></pre><p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p><pre><code class="python">&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last):  ...ValueError: score must between 0 ~ 100!</code></pre><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><pre><code class="python">class Student(object):    @property    def birth(self):        return self._birth    @birth.setter    def birth(self, value):        self._birth = value    @property    def age(self):        return 2015 - self._birth</code></pre><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<em>只读</em>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p><h3 id="7-3多重继承"><a href="#7-3多重继承" class="headerlink" title="7.3多重继承"></a>7.3多重继承</h3><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p><p>回忆一下<code>Animal</code>类层次的设计，假设我们要实现以下4种动物：</p><ul><li>Dog - 狗狗；</li><li>Bat - 蝙蝠；</li><li>Parrot - 鹦鹉；</li><li>Ostrich - 鸵鸟。</li></ul><p>类的层次设计可以根据不同的需求来确定不同的设计，如果同时需要多种层次类型就需要多重继承。</p><blockquote><p>主要的类层次仍按照哺乳类和鸟类设计：</p><pre><code class="python">class Animal(object):    pass# 大类:class Mammal(Animal):    passclass Bird(Animal):    pass# 各种动物:class Dog(Mammal):    passclass Bat(Mammal):    passclass Parrot(Bird):    passclass Ostrich(Bird):    pass#给动物再加上Runnable和Flyable的功能class Runnable(object):    def run(self):        print(&#39;Running...&#39;)class Flyable(object):    def fly(self):        print(&#39;Flying...&#39;)#需要Runnable功能的动物，就多继承一个Runnableclass Dog(Mammal, Runnable):    pass#需要Flyable功能的动物，就多继承一个Flyableclass Bat(Mammal, Flyable):    pass</code></pre></blockquote><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p><h4 id="7-3-1MinIn"><a href="#7-3-1MinIn" class="headerlink" title="7.3.1MinIn"></a>7.3.1MinIn</h4><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为MixIn。</p><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><blockquote><p>python自带的很多库也使用了MixIn。举个例子，Python自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p><p>比如，编写一个多进程模式的TCP服务，定义如下：</p><pre><code class="python">#多进程模式的TCP服务class MyTCPServer(TCPServer, ForkingMixIn):    pass#多线程模式的UDP服务class MyUDPServer(UDPServer, ThreadingMixIn):    pass#协程模型class MyTCPServer(TCPServer, CoroutineMixIn):    pass</code></pre><p>不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p></blockquote><h3 id="7-4定制类"><a href="#7-4定制类" class="headerlink" title="7.4定制类"></a>7.4定制类</h3><p>除<code>__slots__</code>、<code>__len__()</code>之外，Python的class中还有许多这种形如<code>__xxx__</code>的变量或者函数名，可以帮助我们定制类。</p><h4 id="7-4-1-str-、-repr"><a href="#7-4-1-str-、-repr" class="headerlink" title="7.4.1__str__、_repr_"></a>7.4.1__str__、_<em>repr_</em></h4><p>我们先定义一个<code>Student</code>类，打印一个实例：</p><pre><code class="python">&gt;&gt;&gt; class Student(object):...     def __init__(self, name):...         self.name = name...&gt;&gt;&gt; print(Student(&#39;Michael&#39;))&lt;__main__.Student object at 0x109afb190&gt;</code></pre><p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p><p>怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p><pre><code class="python">&gt;&gt;&gt; class Student(object):...     def __init__(self, name):...         self.name = name...     def __str__(self):...         return &#39;Student object (name: %s)&#39; % self.name...&gt;&gt;&gt; print(Student(&#39;Michael&#39;))Student object (name: Michael)</code></pre><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><p>但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p><pre><code class="python">&gt;&gt;&gt; s = Student(&#39;Michael&#39;)&gt;&gt;&gt; s&lt;__main__.Student object at 0x109afb310&gt;</code></pre><p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p><p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p><pre><code class="python">class Student(object):    def __init__(self, name):        self.name = name    def __str__(self):        return &#39;Student object (name=%s)&#39; % self.name    __repr__ = __str__</code></pre><h4 id="7-4-2-iter"><a href="#7-4-2-iter" class="headerlink" title="7.4.2_iter_"></a>7.4.2_<em>iter_</em></h4><p>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p><pre><code class="python">class Fib(object):    def __init__(self):        self.a, self.b = 0, 1 # 初始化两个计数器a，b    def __iter__(self):        return self # 实例本身就是迭代对象，故返回自己    def __next__(self):        self.a, self.b = self.b, self.a + self.b # 计算下一个值        if self.a &gt; 100000: # 退出循环的条件            raise StopIteration()        return self.a # 返回下一个值</code></pre><p>现在，试试把Fib实例作用于for循环：</p><pre><code class="python">&gt;&gt;&gt; for n in Fib():...     print(n)...11235...4636875025</code></pre><h4 id="7-4-3-getitem"><a href="#7-4-3-getitem" class="headerlink" title="7.4.3_getitem_"></a>7.4.3_<em>getitem_</em></h4><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p><pre><code class="python">&gt;&gt;&gt; Fib()[5]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;Fib&#39; object does not support indexing</code></pre><p>要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p><pre><code class="python">class Fib(object):    def __getitem__(self, n):        a, b = 1, 1        for x in range(n):            a, b = b, a + b        return a</code></pre><p>现在，就可以按下标访问数列的任意一项了：</p><pre><code class="python">&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[1]1&gt;&gt;&gt; f[2]2&gt;&gt;&gt; f[3]3&gt;&gt;&gt; f[10]89&gt;&gt;&gt; f[100]573147844013817084101</code></pre><p>但是list有个神奇的切片方法：</p><pre><code class="python">&gt;&gt;&gt; list(range(100))[5:10][5, 6, 7, 8, 9]</code></pre><p>对于Fib却报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象<code>slice</code>，所以要做判断：</p><pre><code class="python">class Fib(object):    def __getitem__(self, n):        if isinstance(n, int): # n是索引            a, b = 1, 1            for x in range(n):                a, b = b, a + b            return a        if isinstance(n, slice): # n是切片            start = n.start            stop = n.stop            if start is None:                start = 0            a, b = 1, 1            L = []            for x in range(stop):                if x &gt;= start:                    L.append(a)                a, b = b, a + b            return L</code></pre><p>现在试试Fib的切片：</p><pre><code class="python">&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0:5][1, 1, 2, 3, 5]&gt;&gt;&gt; f[:10][1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre><p>但是没有对step参数作处理：</p><pre><code class="python">&gt;&gt;&gt; f[:10:2][1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</code></pre><p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p><p>此外，如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>。</p><p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p><p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p><h4 id="7-4-4-getattr"><a href="#7-4-4-getattr" class="headerlink" title="7.4.4_getattr_"></a>7.4.4_<em>getattr_</em></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p><pre><code class="python">class Student(object):    def __init__(self):        self.name = &#39;Michael&#39;</code></pre><p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p><pre><code class="python">&gt;&gt;&gt; s = Student()&gt;&gt;&gt; print(s.name)Michael&gt;&gt;&gt; print(s.score)Traceback (most recent call last):  ...AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;</code></pre><p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个attribute。</p><p>要避免这个错误，除了可以加上一个<code>score</code>属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p><pre><code class="python">class Student(object):    def __init__(self):        self.name = &#39;Michael&#39;    def __getattr__(self, attr):        if attr==&#39;score&#39;:            return 99</code></pre><p>当调用不存在的属性时，比如<code>score</code>，Python解释器会试图调用<code>__getattr__(self, &#39;score&#39;)</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值：</p><pre><code class="python">&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name&#39;Michael&#39;&gt;&gt;&gt; s.score99</code></pre><p>返回函数也是完全可以的：</p><pre><code class="python">class Student(object):    def __getattr__(self, attr):        if attr==&#39;age&#39;:            return lambda: 25</code></pre><p>只是调用方式要变为：</p><pre><code class="python">&gt;&gt;&gt; s.age()25</code></pre><p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p><p>此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让class只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p><pre><code class="python">class Student(object):    def __getattr__(self, attr):        if attr==&#39;age&#39;:            return lambda: 25        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)</code></pre><p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p><p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p><blockquote><p>举个例子：</p><p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p><ul><li><a href="http://api.server/user/friends" target="_blank" rel="noopener">http://api.server/user/friends</a></li><li><a href="http://api.server/user/timeline/list" target="_blank" rel="noopener">http://api.server/user/timeline/list</a></li></ul><p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p><p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p><pre><code class="python">class Chain(object):    def __init__(self, path=&#39;&#39;):        self._path = path    def __getattr__(self, path):        return Chain(&#39;%s/%s&#39; % (self._path, path))    def __str__(self):        return self._path    __repr__ = __str__</code></pre><p>试试：</p><pre><code class="python">&gt;&gt;&gt; Chain().status.user.timeline.list&#39;/status/user/timeline/list&#39;</code></pre><p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p><p>还有些REST API会把参数放到URL中，比如GitHub的API：</p><pre><code class="python">GET /users/:user/repos</code></pre><p>调用时，需要把<code>:user</code>替换为实际用户名。如果我们能写出这样的链式调用：</p><pre><code class="python">Chain().users(&#39;michael&#39;).repos</code></pre><p>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p></blockquote><h4 id="7-4-5-call"><a href="#7-4-5-call" class="headerlink" title="7.4.5_call_"></a>7.4.5_<em>call_</em></h4><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。</p><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p><pre><code class="python">class Student(object):    def __init__(self, name):        self.name = name    def __call__(self):        print(&#39;My name is %s.&#39; % self.name)</code></pre><p>调用方式如下：</p><pre><code class="python">&gt;&gt;&gt; s = Student(&#39;Michael&#39;)&gt;&gt;&gt; s() # self参数不要传入My name is Michael.</code></pre><p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p><p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例：</p><pre><code class="python">&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable(&#39;str&#39;)False</code></pre><p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p><h3 id="7-5使用枚举类"><a href="#7-5使用枚举类" class="headerlink" title="7.5使用枚举类"></a>7.5使用枚举类</h3><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><pre><code class="python">from enum import EnumMonth = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))</code></pre><p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p><pre><code class="python">for name, member in Month.__members__.items():    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)</code></pre><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p><p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><pre><code class="python">from enum import Enum, unique@uniqueclass Weekday(Enum):    Sun = 0 # Sun的value被设定为0    Mon = 1    Tue = 2    Wed = 3    Thu = 4    Fri = 5    Sat = 6</code></pre><p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p><p>访问这些枚举类型可以有若干种方法：</p><pre><code class="python">&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&#39;Tue&#39;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; print(day1 == Weekday(1))True&gt;&gt;&gt; Weekday(7)Traceback (most recent call last):  ...ValueError: 7 is not a valid Weekday&gt;&gt;&gt; for name, member in Weekday.__members__.items():...     print(name, &#39;=&gt;&#39;, member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat</code></pre><p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p><h3 id="7-6使用元类"><a href="#7-6使用元类" class="headerlink" title="7.6使用元类"></a>7.6使用元类</h3><h4 id="7-6-1type"><a href="#7-6-1type" class="headerlink" title="7.6.1type()"></a>7.6.1type()</h4><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>比方说我们要定义一个<code>Hello</code>的class，就写一个<code>hello.py</code>模块：</p><pre><code class="python">class Hello(object):    def hello(self, name=&#39;world&#39;):        print(&#39;Hello, %s.&#39; % name)</code></pre><p>当Python解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的class对象，测试如下：</p><pre><code class="python">&gt;&gt;&gt; from hello import Hello&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; print(type(h))&lt;class &#39;hello.Hello&#39;&gt;</code></pre><p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是class <code>Hello</code>。</p><p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数。</p><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出<code>Hello</code>类，而无需通过<code>class Hello(object)...</code>的定义：</p><pre><code class="python">&gt;&gt;&gt; def fn(self, name=&#39;world&#39;): # 先定义函数...     print(&#39;Hello, %s.&#39; % name)...&gt;&gt;&gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class &#39;type&#39;&gt;&gt;&gt;&gt; print(type(h))&lt;class &#39;__main__.Hello&#39;&gt;</code></pre><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p><p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p><h4 id="7-6-2metaclass"><a href="#7-6-2metaclass" class="headerlink" title="7.6.2metaclass"></a>7.6.2metaclass</h4><p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p><p>metaclass，直译为元类，简单的解释就是：</p><p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p><p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p><p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p><p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p><p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个<code>add</code>方法：</p><p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p><pre><code class="python"># metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type):    def __new__(cls, name, bases, attrs):        attrs[&#39;add&#39;] = lambda self, value: self.append(value)        return type.__new__(cls, name, bases, attrs)</code></pre><p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数<code>metaclass</code>：</p><pre><code class="python">class MyList(list, metaclass=ListMetaclass):    pass</code></pre><p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p><p><code>__new__()</code>方法接收到的参数依次是：</p><ol><li>当前准备创建的类的对象；</li><li>类的名字；</li><li>类继承的父类集合；</li><li>类的方法集合。</li></ol><p>测试一下<code>MyList</code>是否可以调用<code>add()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; L = MyList()&gt;&gt;&gt; L.add(1)&gt;&gt; L[1]</code></pre><p>而普通的<code>list</code>没有<code>add()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; L2 = list()&gt;&gt;&gt; L2.add(1)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;list&#39; object has no attribute &#39;add&#39;</code></pre><p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p><p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p><p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p><p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p><p>让我们来尝试编写一个ORM框架。</p><p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个<code>User</code>类来操作对应的数据库表<code>User</code>，我们期待他写出这样的代码：</p><pre><code class="python">class User(Model):    # 定义类的属性到列的映射：    id = IntegerField(&#39;id&#39;)    name = StringField(&#39;username&#39;)    email = StringField(&#39;email&#39;)    password = StringField(&#39;password&#39;)# 创建一个实例：u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)# 保存到数据库：u.save()</code></pre><p>其中，父类<code>Model</code>和属性类型<code>StringField</code>、<code>IntegerField</code>是由ORM框架提供的，剩下的魔术方法比如<code>save()</code>全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。</p><p>现在，我们就按上面的接口来实现该ORM。</p><p>首先来定义<code>Field</code>类，它负责保存数据库表的字段名和字段类型：</p><pre><code class="python">class Field(object):    def __init__(self, name, column_type):        self.name = name        self.column_type = column_type    def __str__(self):        return &#39;&lt;%s:%s&gt;&#39; % (self.__class__.__name__, self.name)</code></pre><p>在<code>Field</code>的基础上，进一步定义各种类型的<code>Field</code>，比如<code>StringField</code>，<code>IntegerField</code>等等：</p><pre><code class="python">class StringField(Field):    def __init__(self, name):        super(StringField, self).__init__(name, &#39;varchar(100)&#39;)class IntegerField(Field):    def __init__(self, name):        super(IntegerField, self).__init__(name, &#39;bigint&#39;)</code></pre><p>下一步，就是编写最复杂的<code>ModelMetaclass</code>了：</p><pre><code class="python">class ModelMetaclass(type):    def __new__(cls, name, bases, attrs):        if name==&#39;Model&#39;:            return type.__new__(cls, name, bases, attrs)        print(&#39;Found model: %s&#39; % name)        mappings = dict()        for k, v in attrs.items():            if isinstance(v, Field):                print(&#39;Found mapping: %s ==&gt; %s&#39; % (k, v))                mappings[k] = v        for k in mappings.keys():            attrs.pop(k)        attrs[&#39;__mappings__&#39;] = mappings # 保存属性和列的映射关系        attrs[&#39;__table__&#39;] = name # 假设表名和类名一致        return type.__new__(cls, name, bases, attrs)</code></pre><p>以及基类<code>Model</code>：</p><pre><code class="python">class Model(dict, metaclass=ModelMetaclass):    def __init__(self, **kw):        super(Model, self).__init__(**kw)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Model&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] = value    def save(self):        fields = []        params = []        args = []        for k, v in self.__mappings__.items():            fields.append(v.name)            params.append(&#39;?&#39;)            args.append(getattr(self, k, None))        sql = &#39;insert into %s (%s) values (%s)&#39; % (self.__table__, &#39;,&#39;.join(fields), &#39;,&#39;.join(params))        print(&#39;SQL: %s&#39; % sql)        print(&#39;ARGS: %s&#39; % str(args))</code></pre><p>当用户定义一个<code>class User(Model)</code>时，Python解释器首先在当前类<code>User</code>的定义中查找<code>metaclass</code>，如果没有找到，就继续在父类<code>Model</code>中查找<code>metaclass</code>，找到了，就使用<code>Model</code>中定义的<code>metaclass</code>的<code>ModelMetaclass</code>来创建<code>User</code>类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。</p><p>在<code>ModelMetaclass</code>中，一共做了几件事情：</p><ol><li>排除掉对<code>Model</code>类的修改；</li><li>在当前类（比如<code>User</code>）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个<code>__mappings__</code>的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）；</li><li>把表名保存到<code>__table__</code>中，这里简化为表名默认为类名。</li></ol><p>在<code>Model</code>类中，就可以定义各种操作数据库的方法，比如<code>save()</code>，<code>delete()</code>，<code>find()</code>，<code>update</code>等等。</p><p>我们实现了<code>save()</code>方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出<code>INSERT</code>语句。</p><p>编写代码试试：</p><pre><code class="python">u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)u.save()</code></pre><p>输出如下：</p><pre><code class="python">Found model: UserFound mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;Found mapping: id ==&gt; &lt;IntegerField:uid&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;SQL: insert into User (password,email,username,id) values (?,?,?,?)ARGS: [&#39;my-pwd&#39;, &#39;test@orm.org&#39;, &#39;Michael&#39;, 12345]</code></pre><p>可以看到，<code>save()</code>方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。</p><p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p><h2 id="八、错误、调试和测试"><a href="#八、错误、调试和测试" class="headerlink" title="八、错误、调试和测试"></a>八、错误、调试和测试</h2><h3 id="8-1错误处理"><a href="#8-1错误处理" class="headerlink" title="8.1错误处理"></a>8.1错误处理</h3><h4 id="8-1-1try"><a href="#8-1-1try" class="headerlink" title="8.1.1try"></a>8.1.1try</h4><p>高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p><pre><code class="python">try:    print(&#39;try...&#39;)    r = 10 / 0    print(&#39;result:&#39;, r)except ZeroDivisionError as e:    print(&#39;except:&#39;, e)finally:    print(&#39;finally...&#39;)print(&#39;END&#39;)#错误输出：try...except: division by zerofinally...END#如果把除数0改成2，即修改正确后，输出：try...result: 5finally...END</code></pre><p>由于没有错误发生，所以<code>except</code>语句块不会被执行，但是<code>finally</code>如果有，则一定会被执行（可以没有<code>finally</code>语句）。</p><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句：</p><pre><code class="python">try:    print(&#39;try...&#39;)    r = 10 / int(&#39;2&#39;)    print(&#39;result:&#39;, r)except ValueError as e:    print(&#39;ValueError:&#39;, e)except ZeroDivisionError as e:    print(&#39;ZeroDivisionError:&#39;, e)else:    print(&#39;no error!&#39;)finally:    print(&#39;finally...&#39;)print(&#39;END&#39;)</code></pre><p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”</p><p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p><p><a href="https://docs.python.org/zh-cn/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/exceptions.html#exception-hierarchy</a></p><p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理。也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。</p><h4 id="8-1-2调用栈"><a href="#8-1-2调用栈" class="headerlink" title="8.1.2调用栈"></a>8.1.2调用栈</h4><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p><blockquote><p>例子：</p><pre><code class="python"># err.py文件:def foo(s):    return 10 / int(s)def bar(s):    return foo(s) * 2def main():    bar(&#39;0&#39;)main()#输出$ python3 err.pyTraceback (most recent call last):#告诉我们这是错误的跟踪信息。  File &quot;err.py&quot;, line 11, in &lt;module&gt;#调用main()出错了，在代码文件err.py的第11行代码    main()  File &quot;err.py&quot;, line 9, in main#调用bar(&#39;0&#39;)出错了，在代码文件err.py的第9行代码    bar(&#39;0&#39;)  File &quot;err.py&quot;, line 6, in bar#原因是return foo(s) * 2这个语句出错了，但这还不是最终原因    return foo(s) * 2  File &quot;err.py&quot;, line 3, in foo#原因是return 10 / int(s)这个语句出错了    return 10 / int(s)ZeroDivisionError: division by zero#表明这是错误产生的源头</code></pre><p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p></blockquote><h4 id="8-1-3记录错误"><a href="#8-1-3记录错误" class="headerlink" title="8.1.3记录错误"></a>8.1.3记录错误</h4><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p><pre><code class="python"># err_logging.pyimport loggingdef foo(s):    return 10 / int(s)def bar(s):    return foo(s) * 2def main():    try:        bar(&#39;0&#39;)    except Exception as e:        logging.exception(e)main()print(&#39;END&#39;)</code></pre><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：</p><pre><code class="python">$ python3 err_logging.pyERROR:root:division by zeroTraceback (most recent call last):  File &quot;err_logging.py&quot;, line 13, in main    bar(&#39;0&#39;)  File &quot;err_logging.py&quot;, line 9, in bar    return foo(s) * 2  File &quot;err_logging.py&quot;, line 6, in foo    return 10 / int(s)ZeroDivisionError: division by zeroEND</code></pre><p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p><h4 id="8-1-4抛出错误"><a href="#8-1-4抛出错误" class="headerlink" title="8.1.4抛出错误"></a>8.1.4抛出错误</h4><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例：</p><pre><code class="python"># err_raise.pyclass FooError(ValueError):    passdef foo(s):    n = int(s)    if n==0:        raise FooError(&#39;invalid value: %s&#39; % s)    return 10 / nfoo(&#39;0&#39;)#执行后：$ python3 err_raise.pyTraceback (most recent call last):  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;    foo(&#39;0&#39;)  File &quot;err_throw.py&quot;, line 8, in foo    raise FooError(&#39;invalid value: %s&#39; % s)__main__.FooError: invalid value: 0</code></pre><p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</p><p>最后，我们来看另一种错误处理的方式：</p><pre><code class="python"># err_reraise.pydef foo(s):    n = int(s)    if n==0:        raise ValueError(&#39;invalid value: %s&#39; % s)    return 10 / ndef bar():    try:        foo(&#39;0&#39;)    except ValueError as e:        print(&#39;ValueError!&#39;)        raisebar()</code></pre><p>在<code>bar()</code>函数中，已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p><p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型：</p><pre><code class="python">try:    10 / 0except ZeroDivisionError:    raise ValueError(&#39;input error!&#39;)</code></pre><p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p><h3 id="8-2调试"><a href="#8-2调试" class="headerlink" title="8.2调试"></a>8.2调试</h3><p>第一种方法简单直接粗暴有效，就是用<code>print()</code>把可能有问题的变量打印出来看看</p><h4 id="8-2-1断言"><a href="#8-2-1断言" class="headerlink" title="8.2.1断言"></a>8.2.1断言</h4><p>第二种是用断言。凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代</p><pre><code class="python">def foo(s):    n = int(s)    assert n != 0, &#39;n is zero!&#39;    return 10 / ndef main():    foo(&#39;0&#39;)</code></pre><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p><pre><code class="python">$ python err.pyTraceback (most recent call last):  ...AssertionError: n is zero!</code></pre><p>程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><pre><code class="python">$ python -O err.pyTraceback (most recent call last):  ...ZeroDivisionError: division by zero</code></pre><h4 id="8-2-2logging"><a href="#8-2-2logging" class="headerlink" title="8.2.2logging"></a>8.2.2logging</h4><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p><pre><code class="python">import loggings = &#39;0&#39;n = int(s)logging.info(&#39;n = %d&#39; % n)print(10 / n)</code></pre><p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。怎么回事？</p><p>别急，在<code>import logging</code>之后添加一行配置再试试：</p><pre><code class="python">import logginglogging.basicConfig(level=logging.INFO)</code></pre><p>看到输出了：</p><pre><code class="python">$ python err.pyINFO:root:n = 0Traceback (most recent call last):  File &quot;err.py&quot;, line 8, in &lt;module&gt;    print(10 / n)ZeroDivisionError: division by zero</code></pre><p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h4 id="8-2-3pdb"><a href="#8-2-3pdb" class="headerlink" title="8.2.3pdb"></a>8.2.3pdb</h4><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p><pre><code class="python"># err.pys = &#39;0&#39;n = int(s)print(10 / n)</code></pre><p>然后启动：</p><pre><code class="python">$ python -m pdb err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()-&gt; s = &#39;0&#39;</code></pre><p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码<code>-&gt; s = &#39;0&#39;</code>。输入命令<code>l</code>来查看代码：</p><pre><code class="python">(Pdb) l  1     # err.py  2  -&gt; s = &#39;0&#39;  3     n = int(s)  4     print(10 / n)</code></pre><p>输入命令<code>n</code>可以单步执行代码：</p><pre><code class="python">(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()-&gt; n = int(s)(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()-&gt; print(10 / n)</code></pre><p>任何时候都可以输入命令<code>p 变量名</code>来查看变量：</p><pre><code class="python">(Pdb) p s&#39;0&#39;(Pdb) p n0</code></pre><p>输入命令<code>q</code>结束调试，退出程序：</p><pre><code class="python">(Pdb) q</code></pre><p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p><pre><code class="python">pdb.set_trace()</code></pre><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><pre><code class="python"># err.pyimport pdbs = &#39;0&#39;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n)</code></pre><p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行：</p><pre><code class="python">$ python err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()-&gt; print(10 / n)(Pdb) p n0(Pdb) cTraceback (most recent call last):  File &quot;err.py&quot;, line 7, in &lt;module&gt;    print(10 / n)ZeroDivisionError: division by zero</code></pre><p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p><h3 id="8-3单元测试"><a href="#8-3单元测试" class="headerlink" title="8.3单元测试"></a>8.3单元测试</h3><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>比如对函数<code>abs()</code>，我们可以编写出以下几个测试用例：</p><ol><li>输入正数，比如<code>1</code>、<code>1.2</code>、<code>0.99</code>，期待返回值与输入相同；</li><li>输入负数，比如<code>-1</code>、<code>-1.2</code>、<code>-0.99</code>，期待返回值与输入相反；</li><li>输入<code>0</code>，期待返回<code>0</code>；</li><li>输入非数值类型，比如<code>None</code>、<code>[]</code>、<code>{}</code>，期待抛出<code>TypeError</code>。</li></ol><p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p><p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p><p>单元测试通过后有什么意义呢？如果我们对<code>abs()</code>函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对<code>abs()</code>函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p><p>我们来编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p><pre><code class="python">&gt;&gt;&gt; d = Dict(a=1, b=2)&gt;&gt;&gt; d[&#39;a&#39;]1&gt;&gt;&gt; d.a1</code></pre><p><code>mydict.py</code>代码如下：</p><pre><code class="python">class Dict(dict):    def __init__(self, **kw):        super().__init__(**kw)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] = value</code></pre><p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p><pre><code class="python">import unittestfrom mydict import Dictclass TestDict(unittest.TestCase):    def test_init(self):        d = Dict(a=1, b=&#39;test&#39;)        self.assertEqual(d.a, 1)        self.assertEqual(d.b, &#39;test&#39;)        self.assertTrue(isinstance(d, dict))    def test_key(self):        d = Dict()        d[&#39;key&#39;] = &#39;value&#39;        self.assertEqual(d.key, &#39;value&#39;)    def test_attr(self):        d = Dict()        d.key = &#39;value&#39;        self.assertTrue(&#39;key&#39; in d)        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)    def test_keyerror(self):        d = Dict()        with self.assertRaises(KeyError):            value = d[&#39;empty&#39;]    def test_attrerror(self):        d = Dict()        with self.assertRaises(AttributeError):            value = d.empty</code></pre><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p><pre><code class="python">self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等</code></pre><p>另一种重要的断言就是期待抛出指定类型的Error，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p><pre><code class="python">with self.assertRaises(KeyError):    value = d[&#39;empty&#39;]</code></pre><p>而通过<code>d.empty</code>访问不存在的key时，我们期待抛出<code>AttributeError</code>：</p><pre><code class="python">with self.assertRaises(AttributeError):    value = d.empty</code></pre><h4 id="8-3-1运行单元测试"><a href="#8-3-1运行单元测试" class="headerlink" title="8.3.1运行单元测试"></a>8.3.1运行单元测试</h4><p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p><pre><code class="python">if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p><pre><code class="python">$ python mydict_test.py</code></pre><p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p><pre><code class="python">$ python -m unittest mydict_test.....----------------------------------------------------------------------Ran 5 tests in 0.000sOK</code></pre><p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p><h4 id="8-3-2setUp与tearDown"><a href="#8-3-2setUp与tearDown" class="headerlink" title="8.3.2setUp与tearDown"></a>8.3.2setUp与tearDown</h4><p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p><p><code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p><pre><code class="python">class TestDict(unittest.TestCase):    def setUp(self):        print(&#39;setUp...&#39;)    def tearDown(self):        print(&#39;tearDown...&#39;)</code></pre><p>可以再次运行测试看看每个测试方法调用前后是否会打印出<code>setUp...</code>和<code>tearDown...</code>。</p><h4 id="8-3-3文档测试"><a href="#8-3-3文档测试" class="headerlink" title="8.3.3文档测试"></a>8.3.3文档测试</h4><p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如<a href="https://docs.python.org/zh-cn/3/library/re.html" target="_blank" rel="noopener">re模块</a>就带了很多示例代码：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)&gt;&gt;&gt; m.group(0)&#39;def&#39;</code></pre><p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p><p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p><p>答案是肯定的。</p><p>当我们编写注释时，如果写上这样的注释：</p><pre><code class="python">def abs(n):    &#39;&#39;&#39;    Function to get absolute value of number.    Example:    &gt;&gt;&gt; abs(1)    1    &gt;&gt;&gt; abs(-1)    1    &gt;&gt;&gt; abs(0)    0    &#39;&#39;&#39;    return n if n &gt;= 0 else (-n)</code></pre><p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p><p>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用<code>...</code>表示中间一大段烦人的输出。</p><p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p><pre><code class="python"># mydict2.pyclass Dict(dict):    &#39;&#39;&#39;    Simple dict but also support access as x.y style.    &gt;&gt;&gt; d1 = Dict()    &gt;&gt;&gt; d1[&#39;x&#39;] = 100    &gt;&gt;&gt; d1.x    100    &gt;&gt;&gt; d1.y = 200    &gt;&gt;&gt; d1[&#39;y&#39;]    200    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)    &gt;&gt;&gt; d2.c    &#39;3&#39;    &gt;&gt;&gt; d2[&#39;empty&#39;]    Traceback (most recent call last):        ...    KeyError: &#39;empty&#39;    &gt;&gt;&gt; d2.empty    Traceback (most recent call last):        ...    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;    &#39;&#39;&#39;    def __init__(self, **kw):        super(Dict, self).__init__(**kw)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] = valueif __name__==&#39;__main__&#39;:    import doctest    doctest.testmod()</code></pre><p>运行<code>python mydict2.py</code>：</p><pre><code class="python">$ python mydict2.py</code></pre><p>什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把<code>__getattr__()</code>方法注释掉，再运行就会报错：</p><pre><code class="python">$ python mydict2.py**********************************************************************File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 10, in __main__.DictFailed example:    d1.xException raised:    Traceback (most recent call last):      ...    AttributeError: &#39;Dict&#39; object has no attribute &#39;x&#39;**********************************************************************File &quot;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&quot;, line 16, in __main__.DictFailed example:    d2.cException raised:    Traceback (most recent call last):      ...    AttributeError: &#39;Dict&#39; object has no attribute &#39;c&#39;**********************************************************************1 items had failures:   2 of   9 in __main__.Dict***Test Failed*** 2 failures.</code></pre><p>注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</p><h2 id="九、IO编程"><a href="#九、IO编程" class="headerlink" title="九、IO编程"></a>九、IO编程</h2><p>举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p><p>同步和异步的区别就在于是否等待IO执行的结果。很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。</p><p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p><p>注意，本章的IO编程都是<strong>同步模式</strong>，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。</p><h3 id="9-1文件读写"><a href="#9-1文件读写" class="headerlink" title="9.1文件读写"></a>9.1文件读写</h3><p>Python内置了读写文件的函数，用法和C是兼容的。</p><h4 id="9-1-1读文件"><a href="#9-1-1读文件" class="headerlink" title="9.1.1读文件"></a>9.1.1读文件</h4><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)#默认读取UTF-8编码的文本文件</code></pre><blockquote><p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p><pre><code class="python">&gt;&gt;&gt; f=open(&#39;/Users/michael/notfound.txt&#39;, &#39;r&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: &#39;/Users/michael/notfound.txt&#39;</code></pre></blockquote><blockquote><p>要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)&gt;&gt;&gt; f.read()b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节</code></pre><p>读取UTF-8编码的文本文件：</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)&gt;&gt;&gt; f.read()&#39;测试&#39;</code></pre><p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></pre></blockquote><p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：</p><pre><code class="python">&gt;&gt;&gt; f.read()&#39;Hello, world!&#39;</code></pre><p>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p><pre><code class="python">&gt;&gt;&gt; f.close()</code></pre><blockquote><p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><pre><code class="python">try:    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)    print(f.read())finally:    if f:        f.close()</code></pre></blockquote><p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p><pre><code class="python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:    print(f.read())</code></pre><p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p><p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p><p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p><pre><code class="python">for line in f.readlines():    print(line.strip()) # 把末尾的&#39;\n&#39;删掉</code></pre><h4 id="9-1-2file-like-object"><a href="#9-1-2file-like-object" class="headerlink" title="9.1.2file-like object"></a>9.1.2file-like object</h4><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p><p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p><h4 id="9-1-3写文件"><a href="#9-1-3写文件" class="headerlink" title="9.1.3写文件"></a>9.1.3写文件</h4><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;)&gt;&gt;&gt; f.write(&#39;Hello, world!&#39;)&gt;&gt;&gt; f.close()</code></pre><p>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p><pre><code class="python">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f:    f.write(&#39;Hello, world!&#39;)</code></pre><p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p><p>细心的童鞋会发现，以<code>&#39;w&#39;</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>&#39;a&#39;</code>以追加（append）模式写入。</p><p>所有模式的定义及含义可以参考Python内建函数的<a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="9-2StringIO和BytesIO"><a href="#9-2StringIO和BytesIO" class="headerlink" title="9.2StringIO和BytesIO"></a>9.2StringIO和BytesIO</h3><h4 id="9-2-1StringIO"><a href="#9-2-1StringIO" class="headerlink" title="9.2.1StringIO"></a>9.2.1StringIO</h4><p>StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p><pre><code class="python">&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&#39;hello&#39;)5&gt;&gt;&gt; f.write(&#39; &#39;)1&gt;&gt;&gt; f.write(&#39;world!&#39;)6&gt;&gt;&gt; print(f.getvalue())hello world!</code></pre><p><code>getvalue()</code>方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><pre><code class="python">&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)&gt;&gt;&gt; while True:...     s = f.readline()...     if s == &#39;&#39;:...         break...     print(s.strip())...Hello!Hi!Goodbye!</code></pre><h4 id="9-2-2BytesIO"><a href="#9-2-2BytesIO" class="headerlink" title="9.2.2BytesIO"></a>9.2.2BytesIO</h4><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p><pre><code class="python">&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;))6&gt;&gt;&gt; print(f.getvalue())b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</code></pre><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p><pre><code class="python">&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)&gt;&gt;&gt; f.read()b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</code></pre><p>StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。</p><h3 id="9-3操作文件和目录"><a href="#9-3操作文件和目录" class="headerlink" title="9.3操作文件和目录"></a>9.3操作文件和目录</h3><p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数：</p><pre><code class="python">&gt;&gt;&gt; import os&gt;&gt;&gt; os.name # 操作系统类型&#39;posix&#39;</code></pre><p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p><p>要获取详细的系统信息，可以调用<code>uname()</code>函数：</p><pre><code class="python">&gt;&gt;&gt; os.uname()posix.uname_result(sysname=&#39;Darwin&#39;, nodename=&#39;MichaelMacPro.local&#39;, release=&#39;14.3.0&#39;, version=&#39;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#39;, machine=&#39;x86_64&#39;)</code></pre><p>注意<code>uname()</code>函数在Windows上不提供，也就是说，<code>os</code>模块的某些函数是跟操作系统相关的。</p><h4 id="9-3-1环境变量"><a href="#9-3-1环境变量" class="headerlink" title="9.3.1环境变量"></a>9.3.1环境变量</h4><p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个变量中，可以直接查看：</p><pre><code class="python">&gt;&gt;&gt; os.environenviron({&#39;VERSIONER_PYTHON_PREFER_32_BIT&#39;: &#39;no&#39;, &#39;TERM_PROGRAM_VERSION&#39;: &#39;326&#39;, &#39;LOGNAME&#39;: &#39;michael&#39;, &#39;USER&#39;: &#39;michael&#39;, &#39;PATH&#39;: &#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#39;, ...})</code></pre><p>要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code>：</p><pre><code class="python">&gt;&gt;&gt; os.environ.get(&#39;PATH&#39;)&#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#39;&gt;&gt;&gt; os.environ.get(&#39;x&#39;, &#39;default&#39;)&#39;default&#39;</code></pre><h4 id="9-3-2操作文件和目录"><a href="#9-3-2操作文件和目录" class="headerlink" title="9.3.2操作文件和目录"></a>9.3.2操作文件和目录</h4><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><pre><code class="python"># 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)&#39;/Users/michael&#39;# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join(&#39;/Users/michael&#39;, &#39;testdir&#39;)&#39;/Users/michael/testdir&#39;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&#39;/Users/michael/testdir&#39;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&#39;/Users/michael/testdir&#39;)</code></pre><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，<code>os.path.join()</code>返回这样的字符串：</p><pre><code class="python">part-1/part-2</code></pre><p>而Windows下会返回这样的字符串：</p><pre><code class="python">part-1\part-2</code></pre><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><pre><code class="python">&gt;&gt;&gt; os.path.split(&#39;/Users/michael/testdir/file.txt&#39;)(&#39;/Users/michael/testdir&#39;, &#39;file.txt&#39;)</code></pre><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p><pre><code class="python">&gt;&gt;&gt; os.path.splitext(&#39;/path/to/file.txt&#39;)(&#39;/path/to/file&#39;, &#39;.txt&#39;)</code></pre><p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p><p>文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p><pre><code class="python"># 对文件重命名:&gt;&gt;&gt; os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)# 删掉文件:&gt;&gt;&gt; os.remove(&#39;test.py&#39;)</code></pre><p>但是复制文件的函数居然在<code>os</code>模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p><p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p><p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p><pre><code class="python">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)][&#39;.lein&#39;, &#39;.local&#39;, &#39;.m2&#39;, &#39;.npm&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;.vim&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, ...]</code></pre><p>要列出所有的<code>.py</code>文件，也只需一行代码：</p><pre><code class="python">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;][&#39;apis.py&#39;, &#39;config.py&#39;, &#39;models.py&#39;, &#39;pymonitor.py&#39;, &#39;test_db.py&#39;, &#39;urls.py&#39;, &#39;wsgiapp.py&#39;]</code></pre><h3 id="9-4序列化"><a href="#9-4序列化" class="headerlink" title="9.4序列化"></a>9.4序列化</h3><h4 id="9-4-1pickle"><a href="#9-4-1pickle" class="headerlink" title="9.4.1pickle"></a>9.4.1pickle</h4><p>在程序运行的过程中，所有的变量都是在内存中，</p><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><p>Python提供了<code>pickle</code>模块来实现序列化。</p><p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object</p><pre><code class="python">&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&#39;Bob&#39;, age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b&#39;\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#39;&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;wb&#39;)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close()</code></pre><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。</p><pre><code class="python">&gt;&gt;&gt; f = open(&#39;dump.txt&#39;, &#39;rb&#39;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d{&#39;age&#39;: 20, &#39;score&#39;: 88, &#39;name&#39;: &#39;Bob&#39;}</code></pre><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p><h4 id="9-4-2JSON"><a href="#9-4-2JSON" class="headerlink" title="9.4.2JSON"></a>9.4.2JSON</h4><p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p><pre><code class="python">import jsonclass Student(object):    def __init__(self, name, age, score):        self.name = name        self.age = age        self.score = scores = Student(&#39;Bob&#39;, 20, 88)print(json.dumps(s))</code></pre><p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p><pre><code class="python">Traceback (most recent call last):  ...TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable</code></pre><p>错误的原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p><p>如果连<code>class</code>的实例对象都无法序列化为JSON，这肯定不合理！</p><p>别急，我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数：</p><p><a href="https://docs.python.org/zh-cn/3/library/json.html#json.dumps" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/json.html#json.dumps</a></p><p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p><p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p><pre><code class="python">def student2dict(std):    return {        &#39;name&#39;: std.name,        &#39;age&#39;: std.age,        &#39;score&#39;: std.score    }</code></pre><p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为JSON：</p><pre><code class="python">&gt;&gt;&gt; print(json.dumps(s, default=student2dict)){&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}</code></pre><p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p><pre><code class="python">print(json.dumps(s, default=lambda obj: obj.__dict__))</code></pre><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p><p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p><pre><code class="python">def dict2student(d):    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])</code></pre><p>运行结果如下：</p><pre><code class="python">&gt;&gt;&gt; json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt;</code></pre><p>打印出的是反序列化的<code>Student</code>实例对象。</p><p>对中文进行JSON序列化时，<code>json.dumps()</code>提供了一个<code>ensure_ascii</code>参数，当<code>ensure_ascii=True</code>时，会将中文转化为unicode编码，反之<code>ensure_ascii=False</code>，仍转化为汉字</p><h2 id="十、进程和线程"><a href="#十、进程和线程" class="headerlink" title="十、进程和线程"></a>十、进程和线程</h2><h3 id="10-1多进程"><a href="#10-1多进程" class="headerlink" title="10.1多进程"></a>10.1多进程</h3><p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p><p>注意：由于Windows没有<code>fork</code>调用，上面的代码在Windows上无法运行。</p><h4 id="10-1-1multiprocessing"><a href="#10-1-1multiprocessing" class="headerlink" title="10.1.1multiprocessing"></a>10.1.1multiprocessing</h4><p><code>multiprocessing</code>模块是跨平台版本的多进程模块。</p><p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p><pre><code class="python">from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name):    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))if __name__==&#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p = Process(target=run_proc, args=(&#39;test&#39;,))    print(&#39;Child process will start.&#39;)    p.start()    p.join()    print(&#39;Child process end.&#39;)</code></pre><p>执行结果如下：</p><pre><code class="python">Parent process 928.Child process will start.Run child process test (929)...Child Process end.</code></pre><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p><p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h4 id="10-1-2pool"><a href="#10-1-2pool" class="headerlink" title="10.1.2pool"></a>10.1.2pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p><pre><code class="python">from multiprocessing import Poolimport os, time, randomdef long_time_task(name):    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))    start = time.time()    time.sleep(random.random() * 3)    end = time.time()    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))if __name__==&#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p = Pool(4)    for i in range(5):        p.apply_async(long_time_task, args=(i,))    print(&#39;Waiting for all subprocesses done...&#39;)    p.close()    p.join()    print(&#39;All subprocesses done.&#39;)</code></pre><p>执行结果如下：</p><pre><code class="python">Parent process 669.Waiting for all subprocesses done...Run task 0 (671)...Run task 1 (672)...Run task 2 (673)...Run task 3 (674)...Task 2 runs 0.14 seconds.Run task 4 (673)...Task 1 runs 0.27 seconds.Task 3 runs 0.86 seconds.Task 0 runs 1.41 seconds.Task 4 runs 1.91 seconds.All subprocesses done.</code></pre><p>代码解读：</p><p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p><p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：</p><pre><code class="python">p = Pool(5)</code></pre><p>就可以同时跑5个进程。</p><p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p><h4 id="10-1-3子进程"><a href="#10-1-3子进程" class="headerlink" title="10.1.3子进程"></a>10.1.3子进程</h4><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p><p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p><p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p><pre><code class="python">import subprocessprint(&#39;$ nslookup www.python.org&#39;)r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])print(&#39;Exit code:&#39;, r)</code></pre><p>运行结果：</p><pre><code class="python">$ nslookup www.python.orgServer:        192.168.19.4Address:    192.168.19.4#53Non-authoritative answer:www.python.org    canonical name = python.map.fastly.net.Name:    python.map.fastly.netAddress: 199.27.79.223Exit code: 0</code></pre><p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p><pre><code class="python">import subprocessprint(&#39;$ nslookup&#39;)p = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)print(output.decode(&#39;utf-8&#39;))print(&#39;Exit code:&#39;, p.returncode)</code></pre><p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p><pre><code class="python">set q=mxpython.orgexit</code></pre><p>运行结果如下：</p><pre><code class="python">$ nslookupServer:        192.168.19.4Address:    192.168.19.4#53Non-authoritative answer:python.org    mail exchanger = 50 mail.python.org.Authoritative answers can be found from:mail.python.org    internet address = 82.94.164.166mail.python.org    has AAAA address 2001:888:2000:d::a6Exit code: 0</code></pre><h4 id="10-1-4进程间通信"><a href="#10-1-4进程间通信" class="headerlink" title="10.1.4进程间通信"></a>10.1.4进程间通信</h4><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p><p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p><pre><code class="python">from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q):    print(&#39;Process to write: %s&#39; % os.getpid())    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:        print(&#39;Put %s to queue...&#39; % value)        q.put(value)        time.sleep(random.random())# 读数据进程执行的代码:def read(q):    print(&#39;Process to read: %s&#39; % os.getpid())    while True:        value = q.get(True)        print(&#39;Get %s from queue.&#39; % value)if __name__==&#39;__main__&#39;:    # 父进程创建Queue，并传给各个子进程：    q = Queue()    pw = Process(target=write, args=(q,))    pr = Process(target=read, args=(q,))    # 启动子进程pw，写入:    pw.start()    # 启动子进程pr，读取:    pr.start()    # 等待pw结束:    pw.join()    # pr进程里是死循环，无法等待其结束，只能强行终止:    pr.terminate()</code></pre><p>运行结果如下：</p><pre><code class="python">Process to write: 50563Put A to queue...Process to read: 50564Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue.</code></pre><p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所以，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p><h3 id="10-2多线程"><a href="#10-2多线程" class="headerlink" title="10.2多线程"></a>10.2多线程</h3><p>Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p><p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p><pre><code class="python">import time, threading# 新线程执行的代码:def loop():    print(&#39;thread %s is running...&#39; % threading.current_thread().name)    n = 0    while n &lt; 5:        n = n + 1        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))        time.sleep(1)    print(&#39;thread %s ended.&#39; % threading.current_thread().name)print(&#39;thread %s is running...&#39; % threading.current_thread().name)t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)t.start()t.join()print(&#39;thread %s ended.&#39; % threading.current_thread().name)</code></pre><p>执行结果如下：</p><pre><code class="python">thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended.</code></pre><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p><h4 id="10-2-1Lock"><a href="#10-2-1Lock" class="headerlink" title="10.2.1Lock"></a>10.2.1Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>此时需要创建一把锁，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p><pre><code class="python">balance = 0lock = threading.Lock()def run_thread(n):    for i in range(100000):        # 先要获取锁:        lock.acquire()        try:            # 放心地改吧:            change_it(n)        finally:            # 改完了一定要释放锁:            lock.release()</code></pre><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h4 id="10-2-2多核CPU"><a href="#10-2-2多核CPU" class="headerlink" title="10.2.2多核CPU"></a>10.2.2多核CPU</h4><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p><p>假设想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p><p>试试用Python写个死循环：</p><pre><code class="python">import threading, multiprocessingdef loop():    x = 0    while True:        x = x ^ 1for i in range(multiprocessing.cpu_count()):    t = threading.Thread(target=loop)    t.start()</code></pre><p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p><p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p><p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter  Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p><p>所以，在Python中，可以使用多线程，但<strong>不要指望能有效利用多核</strong>。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p><h3 id="10-3ThreadLocal"><a href="#10-3ThreadLocal" class="headerlink" title="10.3ThreadLocal"></a>10.3ThreadLocal</h3><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p><p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p><pre><code class="python">def process_student(name):    std = Student(name)    # std是局部变量，但是每个函数都要用它，因此必须传进去：    do_task_1(std)    do_task_2(std)def do_task_1(std):    do_subtask_1(std)    do_subtask_2(std)def do_task_2(std):    do_subtask_2(std)    do_subtask_2(std)</code></pre><p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的<code>Student</code>对象，不能共享。</p><p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p><pre><code class="python">global_dict = {}def std_thread(name):    std = Student(name)    # 把std放到全局变量global_dict中：    global_dict[threading.current_thread()] = std    do_task_1()    do_task_2()def do_task_1():    # 不传入std，而是根据当前线程查找：    std = global_dict[threading.current_thread()]    ...def do_task_2():    # 任何函数都可以查找出当前线程的std变量：    std = global_dict[threading.current_thread()]    ...</code></pre><p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p><p>有没有更简单的方式？</p><p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p><pre><code class="python">import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student():    # 获取当前线程关联的student:    std = local_school.student    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))def process_thread(name):    # 绑定ThreadLocal的student:    local_school.student = name    process_student()t1 = threading.Thread(target= process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)t2 = threading.Thread(target= process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)t1.start()t2.start()t1.join()t2.join()</code></pre><p>执行结果：</p><pre><code class="python">Hello, Alice (in Thread-A)Hello, Bob (in Thread-B)</code></pre><p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p><p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p><p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p><p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p><h3 id="10-4分布式进程"><a href="#10-4分布式进程" class="headerlink" title="10.4分布式进程"></a>10.4分布式进程</h3><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p><p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p><p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p><p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p><p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p><pre><code class="python"># task_master.pyimport random, time, queuefrom multiprocessing.managers import BaseManager# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager):    pass# 把两个Queue都注册到网络上, callable参数关联了Queue对象:QueueManager.register(&#39;get_task_queue&#39;, callable=lambda: task_queue)QueueManager.register(&#39;get_result_queue&#39;, callable=lambda: result_queue)# 绑定端口5000, 设置验证码&#39;abc&#39;:manager = QueueManager(address=(&#39;&#39;, 5000), authkey=b&#39;abc&#39;)# 启动Queue:manager.start()# 获得通过网络访问的Queue对象:task = manager.get_task_queue()result = manager.get_result_queue()# 放几个任务进去:for i in range(10):    n = random.randint(0, 10000)    print(&#39;Put task %d...&#39; % n)    task.put(n)# 从result队列读取结果:print(&#39;Try get results...&#39;)for i in range(10):    r = result.get(timeout=10)    print(&#39;Result: %s&#39; % r)# 关闭:manager.shutdown()print(&#39;master exit.&#39;)</code></pre><p>windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定，其次，在绑定端口并设置验证码中，windows下需要填写ip地址，linux下不填默认为本地：</p><pre><code class="python">def gettask():    return task_queue;def getresult():    return result_queue;def test():    #windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定    BaseManager.register(&#39;get_task&#39;,callable = gettask);    BaseManager.register(&#39;get_result&#39;,callable = getresult);    #绑定端口并设置验证码，windows下需要填写ip地址，linux下不填默认为本地    manager = BaseManager(address = (&#39;127.0.0.1&#39;,5002),authkey = b&#39;123&#39;);</code></pre><p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p><p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p><pre><code class="python"># task_worker.pyimport time, sys, queuefrom multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager):    pass# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register(&#39;get_task_queue&#39;)QueueManager.register(&#39;get_result_queue&#39;)# 连接到服务器，也就是运行task_master.py的机器:server_addr = &#39;127.0.0.1&#39;print(&#39;Connect to server %s...&#39; % server_addr)# 端口和验证码注意保持与task_master.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey=b&#39;abc&#39;)# 从网络连接:m.connect()# 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 从task队列取任务,并把结果写入result队列:for i in range(10):    try:        n = task.get(timeout=1)        print(&#39;run task %d * %d...&#39; % (n, n))        r = &#39;%d * %d = %d&#39; % (n, n, n*n)        time.sleep(1)        result.put(r)    except Queue.Empty:        print(&#39;task queue is empty.&#39;)# 处理结束:print(&#39;worker exit.&#39;)</code></pre><p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p><p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p><pre><code class="python">$ python3 task_master.pyPut task 3411...Put task 1605...Put task 1398...Put task 4729...Put task 5300...Put task 7471...Put task 68...Put task 4219...Put task 339...Put task 7866...Try get results...</code></pre><p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p><pre><code class="python">$ python3 task_worker.pyConnect to server 127.0.0.1...run task 3411 * 3411...run task 1605 * 1605...run task 1398 * 1398...run task 4729 * 4729...run task 5300 * 5300...run task 7471 * 7471...run task 68 * 68...run task 4219 * 4219...run task 339 * 339...run task 7866 * 7866...worker exit.</code></pre><p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p><pre><code class="python">Result: 3411 * 3411 = 11634921Result: 1605 * 1605 = 2576025Result: 1398 * 1398 = 1954404Result: 4729 * 4729 = 22363441Result: 5300 * 5300 = 28090000Result: 7471 * 7471 = 55815841Result: 68 * 68 = 4624Result: 4219 * 4219 = 17799961Result: 339 * 339 = 114921Result: 7866 * 7866 = 61873956</code></pre><p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p><p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中：</p><pre><code class="ascii">                                             │┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐│task_master.py                           │  │  │task_worker.py                        ││                                         │     │                                      ││  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     ││  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() ││              │                          │  │  │              │                       ││              │                          │     │              │                       ││              ▼                          │  │  │              │                       ││  ┌─────────────────────────────────┐    │     │              │                       ││  │QueueManager                     │    │  │  │              │                       ││  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       ││  │ │ task_queue │ │ result_queue │ │&lt;───┼──┼──┼──────────────┘                       ││  │ └────────────┘ └──────────────┘ │    │     │                                      ││  └─────────────────────────────────┘    │  │  │                                      │└─────────────────────────────────────────┘     └──────────────────────────────────────┘                                             │                                          Network</code></pre><p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p><p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p><p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p><h2 id="十二、正则表达式"><a href="#十二、正则表达式" class="headerlink" title="十二、正则表达式"></a>十二、正则表达式</h2><ul><li>通用的字符串表达框架</li><li>用来<strong>简洁</strong>的表达一组字符串的表达式</li><li>是字符串表达”简洁“和”特征“思想的工具</li><li>判断某字符串的特征归属</li></ul><p>正则表达式是由<strong>字符</strong>和<strong>操作符</strong>构成的</p><p>操作符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">表示任何单个字符</td><td align="center"></td></tr><tr><td align="center">[]</td><td align="center">字符集，对单个字符给出取值范围</td><td align="center">[abc]表示a、b、c，[a-z]表示a到z单个字符</td></tr><tr><td align="center">[^]</td><td align="center">非字符集，对单个字符给出排除范围</td><td align="center">[^abc]表示非a或b或c的单个字符</td></tr><tr><td align="center">*</td><td align="center">前一个字符0次或无限次扩展</td><td align="center">abc*表示ab、abc、abcc、abccc等</td></tr><tr><td align="center">+</td><td align="center">前一个字符1次或无限次扩展</td><td align="center">abc+表示abc、abcc、abccc等</td></tr><tr><td align="center">?</td><td align="center">前一个字符0次或1次扩展</td><td align="center">abc?表示abc、abcc、abccc等</td></tr><tr><td align="center">|</td><td align="center">左右表达式任意一个</td><td align="center">abc|def表示abc或者是def</td></tr><tr><td align="center">{m}</td><td align="center">扩展前一个字符m次</td><td align="center">ab{2}c表示abbc</td></tr><tr><td align="center">{m,n}</td><td align="center">扩展前一个字符m至n次（包含n）</td><td align="center">ab{1,2}c表示abc、abbc</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td><td align="center">^abc表示abc且在一个字符串的开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串结尾</td><td align="center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td align="center">()</td><td align="center">分组标记，内部只能使用|操作符</td><td align="center">(abc)表示abc，(abc|def)表示abc或def</td></tr><tr><td align="center">\d</td><td align="center">数字，等价于[0-9]</td><td align="center"></td></tr><tr><td align="center">\w</td><td align="center">单词字符，等价于[A-Za-z0-9_]</td><td align="center"></td></tr></tbody></table><h3 id="12-1基础"><a href="#12-1基础" class="headerlink" title="12.1基础"></a>12.1基础</h3><p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配<strong>一个数字</strong>，<code>\w</code>可以匹配<strong>一个字母或数字</strong>，<code>\W</code>可一匹配一个<strong>非字母或数字的字符</strong>，所以：</p><ul><li><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</li><li><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</li><li><code>&#39;\w\w\d&#39;</code>可以匹配<code>&#39;py3&#39;</code>；</li></ul><p><code>.</code>可以匹配<strong>任意字符</strong>，所以：</p><ul><li><code>&#39;py.&#39;</code>可以匹配<code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code>等等。</li></ul><p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示<strong>任意个字符</strong>（包括0个），用<code>+</code>表示<strong>至少一个字符</strong>，用<code>?</code>表示<strong>0个或1个字符</strong>，用<code>{n}</code>表示<strong>n个字符</strong>，用<code>{n,m}</code>表示<strong>n-m个字符</strong>：</p><p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。</p><p>我们来从左到右解读一下：</p><ol><li><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li><li><code>\s</code>可以匹配<strong>一个空格</strong>（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39; &#39;</code>等；</li><li><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li></ol><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p><p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p><h3 id="12-2进阶"><a href="#12-2进阶" class="headerlink" title="12.2进阶"></a>12.2进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示<strong>范围</strong>，比如：</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;Py3000&#39;</code>等等；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul><p><code>A|B</code>可以匹配<strong>A或B</strong>，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p><p><code>^</code>表示<strong>行的开头</strong>，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示<strong>行的结束</strong>，<code>\d$</code>表示必须以数字结束。</p><p>你可能注意到了，<code>py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p><h3 id="12-3re模块"><a href="#12-3re模块" class="headerlink" title="12.3re模块"></a>12.3re模块</h3><p>Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p><pre><code class="python">s = &#39;ABC\\-001&#39; # Python的字符串# 对应的正则表达式字符串变成：# &#39;ABC\-001&#39;</code></pre><p>因此我们强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p><pre><code class="python">s = r&#39;ABC\-001&#39; # Python的字符串# 对应的正则表达式字符串不变：# &#39;ABC\-001&#39;</code></pre><p>先看看如何判断正则表达式是否匹配：</p><pre><code class="python">&gt;&gt;&gt; import re&gt;&gt;&gt; re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)&lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;&gt;&gt;&gt; re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010 12345&#39;)&gt;&gt;&gt;</code></pre><p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p><pre><code class="python">test = &#39;用户输入的字符串&#39;if re.match(r&#39;正则表达式&#39;, test):    print(&#39;ok&#39;)else:    print(&#39;failed&#39;)</code></pre><blockquote><p><code>match</code>只从字串的开始位置进行匹配，如果失败，它就此放弃；</p><p><code>search</code>则会锲而不舍地完全遍历整个字串中所有可能的位置，直到成功地找到一个匹配，或者搜索完字串，以失败告终。</p><p>如果你了解match的特性（在某些情况下比较快），大可以自由用它；如果不太清楚，search通常是你需要的那个函数。</p><p>从一堆文本中，找出所有可能的匹配，以列表的形式返回，这种情况用<code>findall</code>这个函数</p></blockquote><h3 id="12-4切分字符串"><a href="#12-4切分字符串" class="headerlink" title="12.4切分字符串"></a>12.4切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p><pre><code class="python">&gt;&gt;&gt; &#39;a b   c&#39;.split(&#39; &#39;)[&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</code></pre><p>嗯，无法识别连续的空格，用正则表达式试试：</p><pre><code class="python">&gt;&gt;&gt; re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p><pre><code class="python">&gt;&gt;&gt; re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><p>再加入<code>;</code>试试：</p><pre><code class="python">&gt;&gt;&gt; re.split(r&#39;[\s\,\;]+&#39;, &#39;a,b;; c  d&#39;)[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p><h3 id="12-5分组"><a href="#12-5分组" class="headerlink" title="12.5分组"></a>12.5分组</h3><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是<strong>要提取的分组</strong>（Group）。比如：</p><p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><pre><code class="python">&gt;&gt;&gt; m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;&gt;&gt;&gt; m.group(0)&#39;010-12345&#39;&gt;&gt;&gt; m.group(1)&#39;010&#39;&gt;&gt;&gt; m.group(2)&#39;12345&#39;</code></pre><p>如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p><p>注意到<code>group(0)</code>永远是原始字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p><p>提取子串非常有用。来看一个更凶残的例子：</p><pre><code class="python">&gt;&gt;&gt; t = &#39;19:05:30&#39;&gt;&gt;&gt; m = re.match(r&#39;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#39;, t)&gt;&gt;&gt; m.groups()(&#39;19&#39;, &#39;05&#39;, &#39;30&#39;)</code></pre><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p><pre><code class="python">&#39;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$&#39;</code></pre><p>对于<code>&#39;2-30&#39;</code>，<code>&#39;4-31&#39;</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h3 id="12-6贪婪匹配"><a href="#12-6贪婪匹配" class="headerlink" title="12.6贪婪匹配"></a>12.6贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p><pre><code class="python">&gt;&gt;&gt; re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()(&#39;102300&#39;, &#39;&#39;)</code></pre><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><pre><code class="python">&gt;&gt;&gt; re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups()(&#39;1023&#39;, &#39;00&#39;)</code></pre><h3 id="12-7编译"><a href="#12-7编译" class="headerlink" title="12.7编译"></a>12.7编译</h3><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p><ol><li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li><li>用编译后的正则表达式去匹配字符串。</li></ol><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p><pre><code class="python">&gt;&gt;&gt; import re# 编译:&gt;&gt;&gt; re_telephone = re.compile(r&#39;^(\d{3})-(\d{3,8})$&#39;)# 使用：&gt;&gt;&gt; re_telephone.match(&#39;010-12345&#39;).groups()(&#39;010&#39;, &#39;12345&#39;)&gt;&gt;&gt; re_telephone.match(&#39;010-8086&#39;).groups()(&#39;010&#39;, &#39;8086&#39;)</code></pre><p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p><h2 id="十三、常用内置模块"><a href="#十三、常用内置模块" class="headerlink" title="十三、常用内置模块"></a>十三、常用内置模块</h2><h3 id="13-1datetime"><a href="#13-1datetime" class="headerlink" title="13.1datetime"></a>13.1datetime</h3><h4 id="13-1-1获取当前日期和时间"><a href="#13-1-1获取当前日期和时间" class="headerlink" title="13.1.1获取当前日期和时间"></a>13.1.1获取当前日期和时间</h4><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now() # 获取当前datetime&gt;&gt;&gt; print(now)2015-05-18 16:28:07.198690&gt;&gt;&gt; print(type(now))&lt;class &#39;datetime.datetime&#39;&gt;</code></pre><p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p><p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p><p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p><h4 id="13-1-2获取指定日期和时间"><a href="#13-1-2获取指定日期和时间" class="headerlink" title="13.1.2获取指定日期和时间"></a>13.1.2获取指定日期和时间</h4><p>直接用参数构造一个<code>datetime</code>：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime&gt;&gt;&gt; print(dt)2015-04-19 12:20:00</code></pre><h4 id="13-1-3datetime转换为timestamp"><a href="#13-1-3datetime转换为timestamp" class="headerlink" title="13.1.3datetime转换为timestamp"></a>13.1.3datetime转换为timestamp</h4><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>你可以认为：</p><pre><code class="python">timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00</code></pre><p>对应的北京时间是：</p><pre><code class="python">timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00</code></pre><p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><p>把一个<code>datetime</code>类型转换为timestamp只需要简单调用<code>timestamp()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp1429417200.0</code></pre><p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p><p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p><h4 id="13-1-4timestamp转换为datetime"><a href="#13-1-4timestamp转换为datetime" class="headerlink" title="13.1.4timestamp转换为datetime"></a>13.1.4timestamp转换为datetime</h4><p>使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1429417200.0&gt;&gt;&gt; print(datetime.fromtimestamp(t))2015-04-19 12:20:00</code></pre><p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间（当前操作系统设定的时区）做转换。</p><p>例如北京时区是东8区，则本地时间：</p><pre><code class="python">2015-04-19 12:20:00</code></pre><p>实际上就是UTC+8:00时区的时间：</p><pre><code class="python">2015-04-19 12:20:00 UTC+8:00</code></pre><p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：</p><pre><code class="python">2015-04-19 04:20:00 UTC+0:00</code></pre><p>timestamp也可以直接被转换到UTC标准时区的时间：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1429417200.0&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间2015-04-19 12:20:00&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间2015-04-19 04:20:00</code></pre><h4 id="13-1-5str转换为datetime"><a href="#13-1-5str转换为datetime" class="headerlink" title="13.1.5str转换为datetime"></a>13.1.5str转换为datetime</h4><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。通过<code>datetime.strptime()</code>实现即可，需要一个日期和时间的格式化字符串：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; cday = datetime.strptime(&#39;2015-6-1 18:19:59&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)&gt;&gt;&gt; print(cday)2015-06-01 18:19:59</code></pre><p>字符串<code>&#39;%Y-%m-%d %H:%M:%S&#39;</code>规定了日期和时间部分的格式。详细的说明请参考<a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">Python文档</a>。</p><p>注意转换后的datetime是没有时区信息的。</p><h4 id="13-1-6datetime转换为str"><a href="#13-1-6datetime转换为str" class="headerlink" title="13.1.6datetime转换为str"></a>13.1.6datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now.strftime(&#39;%a, %b %d %H:%M&#39;))Mon, May 05 16:28</code></pre><h4 id="13-1-7datetime加减"><a href="#13-1-7datetime加减" class="headerlink" title="13.1.7datetime加减"></a>13.1.7datetime加减</h4><p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)&gt;&gt;&gt; now + timedelta(hours=10)datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)&gt;&gt;&gt; now - timedelta(days=1)datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)&gt;&gt;&gt; now + timedelta(days=2, hours=12)datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)</code></pre><h4 id="13-1-8本地时间转换为UTC时间"><a href="#13-1-8本地时间转换为UTC时间" class="headerlink" title="13.1.8本地时间转换为UTC时间"></a>13.1.8本地时间转换为UTC时间</h4><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00&gt;&gt;&gt; dtdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</code></pre><p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，<strong>不能强制设置</strong>为UTC+8:00时区。</p><h4 id="13-1-9时区转换"><a href="#13-1-9时区转换" class="headerlink" title="13.1.9时区转换"></a>13.1.9时区转换</h4><p>先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p><pre><code class="python"># 拿到UTC时间，并强制设置时区为UTC+0:00:&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)&gt;&gt;&gt; print(utc_dt)2015-05-18 09:05:12.377316+00:00# astimezone()将转换时区为北京时间:&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))&gt;&gt;&gt; print(bj_dt)2015-05-18 17:05:12.377316+08:00# astimezone()将转换时区为东京时间:&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt)2015-05-18 18:05:12.377316+09:00# astimezone()将bj_dt转换时区为东京时间:&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt2)2015-05-18 18:05:12.377316+09:00</code></pre><p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p><p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p><p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p><p><strong>总结</strong>：</p><p><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p><p>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p><h3 id="13-2collections"><a href="#13-2collections" class="headerlink" title="13.2collections"></a>13.2collections</h3><h4 id="13-2-1namedtuple"><a href="#13-2-1namedtuple" class="headerlink" title="13.2.1namedtuple"></a>13.2.1namedtuple</h4><p><code>tuple</code>可以表示不变集合，如一个点的二维坐标：</p><pre><code class="python">&gt;&gt;&gt; p = (1, 2)</code></pre><p>但是，很难看出这个<code>tuple</code>是用来表示一个坐标的。</p><p>定义一个class又小题大做了，这时，<code>namedtuple</code>就派上了用场：</p><pre><code class="python">&gt;&gt;&gt; from collections import namedtuple# namedtuple(&#39;名称&#39;, [属性list]):&gt;&gt;&gt; Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2</code></pre><p><code>namedtuple</code>是一个函数，它用来创建一个<em>自定义的<code>tuple</code>对象</em>，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p><p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p><p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类：</p><pre><code class="python">&gt;&gt;&gt; isinstance(p, Point)True&gt;&gt;&gt; isinstance(p, tuple)True</code></pre><p>类似的，如果要用坐标和半径表示一个圆，也可以用<code>namedtuple</code>定义：</p><pre><code class="python"># namedtuple(&#39;名称&#39;, [属性list]):Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])</code></pre><h4 id="13-2-2deque"><a href="#13-2-2deque" class="headerlink" title="13.2.2deque"></a>13.2.2deque</h4><p>使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。</p><p>deque是为了高效实现插入和删除操作的<strong>双向列表</strong>，适合用于队列和栈：</p><pre><code class="python">&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; q.append(&#39;x&#39;)&gt;&gt;&gt; q.appendleft(&#39;y&#39;)&gt;&gt;&gt; qdeque([&#39;y&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;x&#39;])</code></pre><p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p><h4 id="13-2-3defaultdict"><a href="#13-2-3defaultdict" class="headerlink" title="13.2.3defaultdict"></a>13.2.3defaultdict</h4><p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p><pre><code class="python">&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; dd = defaultdict(lambda: &#39;N/A&#39;)&gt;&gt;&gt; dd[&#39;key1&#39;] = &#39;abc&#39;&gt;&gt;&gt; dd[&#39;key1&#39;] # key1存在&#39;abc&#39;&gt;&gt;&gt; dd[&#39;key2&#39;] # key2不存在，返回默认值&#39;N/A&#39;</code></pre><p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p><p>除了在Key不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p><h4 id="13-2-4OrderedDict"><a href="#13-2-4OrderedDict" class="headerlink" title="13.2.4OrderedDict"></a>13.2.4OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。</p><p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p><pre><code class="python">&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])&gt;&gt;&gt; d # dict的Key是无序的{&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2}&gt;&gt;&gt; od = OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])&gt;&gt;&gt; od # OrderedDict的Key是有序的OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)])</code></pre><p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p><pre><code class="python">&gt;&gt;&gt; od = OrderedDict()&gt;&gt;&gt; od[&#39;z&#39;] = 1&gt;&gt;&gt; od[&#39;y&#39;] = 2&gt;&gt;&gt; od[&#39;x&#39;] = 3&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回[&#39;z&#39;, &#39;y&#39;, &#39;x&#39;]</code></pre><p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：</p><pre><code class="python">from collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict):    def __init__(self, capacity):        super(LastUpdatedOrderedDict, self).__init__()        self._capacity = capacity    def __setitem__(self, key, value):        containsKey = 1 if key in self else 0        if len(self) - containsKey &gt;= self._capacity:            last = self.popitem(last=False)            print(&#39;remove:&#39;, last)        if containsKey:            del self[key]            print(&#39;set:&#39;, (key, value))        else:            print(&#39;add:&#39;, (key, value))        OrderedDict.__setitem__(self, key, value)</code></pre><h4 id="13-2-5ChainMap"><a href="#13-2-5ChainMap" class="headerlink" title="13.2.5ChainMap"></a>13.2.5ChainMap</h4><p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。</p><p>什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p><p>下面的代码演示了如何查找<code>user</code>和<code>color</code>这两个参数：</p><pre><code class="python">from collections import ChainMapimport os, argparse# 构造缺省参数:defaults = {    &#39;color&#39;: &#39;red&#39;,    &#39;user&#39;: &#39;guest&#39;}# 构造命令行参数:parser = argparse.ArgumentParser()parser.add_argument(&#39;-u&#39;, &#39;--user&#39;)parser.add_argument(&#39;-c&#39;, &#39;--color&#39;)namespace = parser.parse_args()command_line_args = { k: v for k, v in vars(namespace).items() if v }# 组合成ChainMap:combined = ChainMap(command_line_args, os.environ, defaults)# 打印参数:print(&#39;color=%s&#39; % combined[&#39;color&#39;])print(&#39;user=%s&#39; % combined[&#39;user&#39;])</code></pre><p>没有任何参数时，打印出默认参数：</p><pre><code class="python">$ python3 use_chainmap.pycolor=reduser=guest</code></pre><p>当传入命令行参数时，优先使用命令行参数：</p><pre><code class="python">$ python3 use_chainmap.py -u bobcolor=reduser=bob</code></pre><p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p><pre><code class="python">$ user=admin color=green python3 use_chainmap.py -u bobcolor=greenuser=bob</code></pre><h4 id="13-2-6Counter"><a href="#13-2-6Counter" class="headerlink" title="13.2.6Counter"></a>13.2.6Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p><pre><code class="python">&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter()&gt;&gt;&gt; for ch in &#39;programming&#39;:...     c[ch] = c[ch] + 1...&gt;&gt;&gt; cCounter({&#39;g&#39;: 2, &#39;m&#39;: 2, &#39;r&#39;: 2, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;o&#39;: 1, &#39;n&#39;: 1, &#39;p&#39;: 1})&gt;&gt;&gt; c.update(&#39;hello&#39;) # 也可以一次性update&gt;&gt;&gt; cCounter({&#39;r&#39;: 2, &#39;o&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;l&#39;: 2, &#39;p&#39;: 1, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;n&#39;: 1, &#39;h&#39;: 1, &#39;e&#39;: 1})</code></pre><p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p><h3 id="13-3base64"><a href="#13-3base64" class="headerlink" title="13.3base64"></a>13.3base64</h3><p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p><p>用记事本打开<code>exe</code>、<code>jpg</code>、<code>pdf</code>这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p><p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p><pre><code class="python">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code></pre><p>然后，对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24</code>bit，划为4组，每组正好6个bit</p><p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p><p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p><p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p><p>Python内置的<code>base64</code>可以直接进行base64的编解码：</p><pre><code class="python">&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b&#39;binary\x00string&#39;)b&#39;YmluYXJ5AHN0cmluZw==&#39;&gt;&gt;&gt; base64.b64decode(b&#39;YmluYXJ5AHN0cmluZw==&#39;)b&#39;binary\x00string&#39;</code></pre><p>由于标准的Base64编码后可能出现字符<code>+</code>和<code>/</code>，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>：</p><pre><code class="python">&gt;&gt;&gt; base64.b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)b&#39;abcd++//&#39;&gt;&gt;&gt; base64.urlsafe_b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)b&#39;abcd--__&#39;&gt;&gt;&gt; base64.urlsafe_b64decode(&#39;abcd--__&#39;)b&#39;i\xb7\x1d\xfb\xef\xff&#39;</code></pre><p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过通常情况下完全没有必要。</p><p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p><p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p><p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉。</p><h3 id="13-4struct"><a href="#13-4struct" class="headerlink" title="13.4struct"></a>13.4struct</h3><p>准确地讲，Python没有专门处理字节的数据类型。但由于<code>b&#39;str&#39;</code>可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p><p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的<code>bytes</code>，你得配合位运算符这么写：</p><pre><code class="python">&gt;&gt;&gt; n = 10240099&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8&gt;&gt;&gt; b4 = n &amp; 0xff&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])&gt;&gt;&gt; bsb&#39;\x00\x9c@c&#39;</code></pre><p>非常麻烦。如果换成浮点数就无能为力了。</p><p>好在Python提供了一个<code>struct</code>模块来解决<code>bytes</code>和其他二进制数据类型的转换。</p><p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code>：</p><pre><code class="python">&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&#39;&gt;I&#39;, 10240099)b&#39;\x00\x9c@c&#39;</code></pre><p><code>pack</code>的第一个参数是处理指令，<code>&#39;&gt;I&#39;</code>的意思是：</p><p><code>&gt;</code>表示字节顺序是big-endian，也就是网络序，<code>I</code>表示4字节无符号整数。</p><p>后面的参数个数要和处理指令一致。</p><p><code>unpack</code>把<code>bytes</code>变成相应的数据类型：</p><pre><code class="python">&gt;&gt;&gt; struct.unpack(&#39;&gt;IH&#39;, b&#39;\xf0\xf0\xf0\xf0\x80\x80&#39;)(4042322160, 32896)</code></pre><p>根据<code>&gt;IH</code>的说明，后面的<code>bytes</code>依次变为<code>I</code>：4字节无符号整数和<code>H</code>：2字节无符号整数。</p><p><code>struct</code>模块定义的数据类型可以参考Python官方文档：</p><p><a href="https://docs.python.org/zh-cn/3/library/struct.html#format-characters" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/struct.html#format-characters</a></p><blockquote><p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用<code>struct</code>分析一下。</p><p>首先找一个bmp文件，没有的话用“画图”画一个。</p><p>读入前30个字节来分析：</p><pre><code class="python">&gt;&gt;&gt; s = b&#39;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00&#39;</code></pre><p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p><p>两个字节：<code>&#39;BM&#39;</code>表示Windows位图，<code>&#39;BA&#39;</code>表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。</p><p>所以，组合起来用<code>unpack</code>读取：</p><pre><code class="python">&gt;&gt;&gt; struct.unpack(&#39;&lt;ccIIIIIIHH&#39;, s)(b&#39;B&#39;, b&#39;M&#39;, 691256, 0, 54, 40, 640, 360, 1, 24)</code></pre><p>结果显示，<code>b&#39;B&#39;</code>、<code>b&#39;M&#39;</code>说明是Windows位图，位图大小为640x360，颜色数为24。</p></blockquote><h3 id="13-5hashlib"><a href="#13-5hashlib" class="headerlink" title="13.5hashlib"></a>13.5hashlib</h3><p>Python的hashlib提供了常见的摘要算法（又称哈希算法、散列算法），如MD5，SHA1等等。</p><p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p><pre><code class="python">import hashlibmd5 = hashlib.md5()md5.update(&#39;how to use md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;))print(md5.hexdigest())</code></pre><p>计算结果如下：</p><pre><code class="python">d26a53750bc40b38b65a520292f69306</code></pre><p>如果数据量很大，可以分块多次调用<code>update()</code>，最后计算的结果是一样的：</p><pre><code class="python">import hashlibmd5 = hashlib.md5()md5.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))md5.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))print(md5.hexdigest())</code></pre><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p><p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p><pre><code class="python">import hashlibsha1 = hashlib.sha1()sha1.update(&#39;how to use sha1 in &#39;.encode(&#39;utf-8&#39;))sha1.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))print(sha1.hexdigest())</code></pre><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p><p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p><p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章<code>&#39;how to learn hashlib in python - by Bob&#39;</code>，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p><p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p><p>考虑这么个情况，很多用户喜欢用<code>123456</code>，<code>888888</code>，<code>password</code>这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p><pre><code class="python">&#39;e10adc3949ba59abbe56e057f20f883e&#39;: &#39;123456&#39;&#39;21218cca77804d2ba1922c33e0151105&#39;: &#39;888888&#39;&#39;5f4dcc3b5aa765d61d8327deb882cf99&#39;: &#39;password&#39;</code></pre><p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p><p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p><p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p><pre><code class="python">def calc_md5(password):    return get_md5(password + &#39;the-Salt&#39;)</code></pre><p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p><p>但是如果有两个用户都使用了相同的简单口令比如<code>123456</code>，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p><p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p><h3 id="13-6hmac"><a href="#13-6hmac" class="headerlink" title="13.6hmac"></a>13.6hmac</h3><p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的<code>password_md5</code>对比计算<code>md5(password)</code>的结果，如果一致，用户输入的口令就是正确的。</p><p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p><p>如果salt是我们自己随机生成的，通常我们计算MD5时采用<code>md5(message + salt)</code>。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p><p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p><p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p><p>Python自带的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p><p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：</p><pre><code class="python">&gt;&gt;&gt; import hmac&gt;&gt;&gt; message = b&#39;Hello, world!&#39;&gt;&gt;&gt; key = b&#39;secret&#39;&gt;&gt;&gt; h = hmac.new(key, message, digestmod=&#39;MD5&#39;)&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)&gt;&gt;&gt; h.hexdigest()&#39;fa4ee7d173f2d97ee79022d1a7355bcf&#39;</code></pre><p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是<code>bytes</code>类型，<code>str</code>类型需要首先编码为<code>bytes</code>。</p><h3 id="13-7itertools"><a href="#13-7itertools" class="headerlink" title="13.7itertools"></a>13.7itertools</h3><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p><p>首先，我们看看<code>itertools</code>提供的几个“无限”迭代器：</p><pre><code class="python">&gt;&gt;&gt; import itertools&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; for n in natuals:...     print(n)...123...</code></pre><p>因为<code>count()</code>会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按<code>Ctrl+C</code>退出。</p><p><code>cycle()</code>会把传入的一个序列无限重复下去：</p><pre><code class="python">&gt;&gt;&gt; import itertools&gt;&gt;&gt; cs = itertools.cycle(&#39;ABC&#39;) # 注意字符串也是序列的一种&gt;&gt;&gt; for c in cs:...     print(c)...&#39;A&#39;&#39;B&#39;&#39;C&#39;&#39;A&#39;&#39;B&#39;&#39;C&#39;...</code></pre><p>同样停不下来。</p><p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p><pre><code class="python">&gt;&gt;&gt; ns = itertools.repeat(&#39;A&#39;, 3)&gt;&gt;&gt; for n in ns:...     print(n)...AAA</code></pre><p>无限序列只有在<code>for</code>迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。</p><p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列：</p><pre><code class="python">&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)&gt;&gt;&gt; list(ns)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p><h4 id="13-7-1chain"><a href="#13-7-1chain" class="headerlink" title="13.7.1chain()"></a>13.7.1chain()</h4><p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p><pre><code class="python">&gt;&gt;&gt; for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):...     print(c)# 迭代效果：&#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;X&#39; &#39;Y&#39; &#39;Z&#39;</code></pre><h4 id="13-7-2groupby"><a href="#13-7-2groupby" class="headerlink" title="13.7.2groupby()"></a>13.7.2groupby()</h4><p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p><pre><code class="python">&gt;&gt;&gt; for key, group in itertools.groupby(&#39;AAABBBCCAAA&#39;):...     print(key, list(group))...A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]B [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;]C [&#39;C&#39;, &#39;C&#39;]A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]</code></pre><p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素<code>&#39;A&#39;</code>和<code>&#39;a&#39;</code>都返回相同的key：</p><pre><code class="python">&gt;&gt;&gt; for key, group in itertools.groupby(&#39;AaaBBbcCAAa&#39;, lambda c: c.upper()):...     print(key, list(group))...A [&#39;A&#39;, &#39;a&#39;, &#39;a&#39;]B [&#39;B&#39;, &#39;B&#39;, &#39;b&#39;]C [&#39;c&#39;, &#39;C&#39;]A [&#39;A&#39;, &#39;A&#39;, &#39;a&#39;]</code></pre><h3 id="13-8contextlib"><a href="#13-8contextlib" class="headerlink" title="13.8contextlib"></a>13.8contextlib</h3><p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用<code>try...finally</code>：</p><pre><code class="python">try:    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)    f.read()finally:    if f:        f.close()</code></pre><p>写<code>try...finally</code>非常繁琐。Python的<code>with</code>语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：</p><pre><code class="python">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:    f.read()</code></pre><p>并不是只有<code>open()</code>函数返回的fp对象才能使用<code>with</code>语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p><p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。例如，下面的class实现了这两个方法：</p><pre><code class="python">class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&#39;Begin&#39;)        return self    def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&#39;Error&#39;)        else:            print(&#39;End&#39;)    def query(self):        print(&#39;Query info about %s...&#39; % self.name)</code></pre><p>这样我们就可以把自己写的资源对象用于<code>with</code>语句：</p><pre><code class="python">with Query(&#39;Bob&#39;) as q:    q.query()</code></pre><h4 id="13-8-1-contextmanager"><a href="#13-8-1-contextmanager" class="headerlink" title="13.8.1@contextmanager"></a>13.8.1@contextmanager</h4><p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法，上面的代码可以改写如下：</p><pre><code class="python">from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&#39;Query info about %s...&#39; % self.name)@contextmanagerdef create_query(name):    print(&#39;Begin&#39;)    q = Query(name)    yield q    print(&#39;End&#39;)</code></pre><p><code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了：</p><pre><code class="python">with create_query(&#39;Bob&#39;) as q:    q.query()</code></pre><p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现。例如：</p><pre><code class="python">@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)</code></pre><p>上述代码执行结果为：</p><pre><code class="python">&lt;h1&gt;helloworld&lt;/h1&gt;</code></pre><p>代码的执行顺序是：</p><ol><li><code>with</code>语句首先执行<code>yield</code>之前的语句，因此打印出<code>&lt;h1&gt;</code>；</li><li><code>yield</code>调用会执行<code>with</code>语句内部的所有语句，因此打印出<code>hello</code>和<code>world</code>；</li><li>最后执行<code>yield</code>之后的语句，打印出<code>&lt;/h1&gt;</code>。</li></ol><p>因此，<code>@contextmanager</code>让我们通过编写generator来简化上下文管理。</p><h4 id="13-8-2-closing"><a href="#13-8-2-closing" class="headerlink" title="13.8.2@closing"></a>13.8.2@closing</h4><p>如果一个对象没有实现上下文，我们就不能把它用于<code>with</code>语句。这个时候，可以用<code>closing()</code>来把该对象变为上下文对象。例如，用<code>with</code>语句使用<code>urlopen()</code>：</p><pre><code class="python">from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&#39;https://www.python.org&#39;)) as page:    for line in page:        print(line)</code></pre><p><code>closing</code>也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：</p><pre><code class="python">@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()</code></pre><p>它的作用就是把任意对象变为上下文对象，并支持<code>with</code>语句。</p><p><code>@contextlib</code>还有一些其他decorator，便于我们编写更简洁的代码。</p><h3 id="13-9urllib"><a href="#13-9urllib" class="headerlink" title="13.9urllib"></a>13.9urllib</h3><p>urllib提供了一系列用于操作URL的功能。</p><h4 id="13-9-1Get"><a href="#13-9-1Get" class="headerlink" title="13.9.1Get"></a>13.9.1Get</h4><p>urllib的<code>request</code>模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p><p>例如，对豆瓣的一个URL<code>https://api.douban.com/v2/book/2129650</code>进行抓取，并返回响应：</p><pre><code class="python">from urllib import requestwith request.urlopen(&#39;https://api.douban.com/v2/book/2129650&#39;) as f:    data = f.read()    print(&#39;Status:&#39;, f.status, f.reason)    for k, v in f.getheaders():        print(&#39;%s: %s&#39; % (k, v))    print(&#39;Data:&#39;, data.decode(&#39;utf-8&#39;))</code></pre><p>可以看到HTTP响应的头和JSON数据：</p><pre><code class="python">Status: 200 OKServer: nginxDate: Tue, 26 May 2015 10:02:27 GMTContent-Type: application/json; charset=utf-8Content-Length: 2049Connection: closeExpires: Sun, 1 Jan 2006 01:00:00 GMTPragma: no-cacheCache-Control: must-revalidate, no-cache, privateX-DAE-Node: pidl1Data: {&quot;rating&quot;:{&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0},&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...}</code></pre><p>如果我们要想模拟浏览器发送GET请求，就需要使用<code>Request</code>对象，通过往<code>Request</code>对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：</p><pre><code class="python">from urllib import requestreq = request.Request(&#39;http://www.douban.com/&#39;)req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)with request.urlopen(req) as f:    print(&#39;Status:&#39;, f.status, f.reason)    for k, v in f.getheaders():        print(&#39;%s: %s&#39; % (k, v))    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))</code></pre><p>这样豆瓣会返回适合iPhone的移动版网页：</p><pre><code class="python">...    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;...</code></pre><h4 id="13-9-2Post"><a href="#13-9-2Post" class="headerlink" title="13.9.2Post"></a>13.9.2Post</h4><p>如果要以POST发送一个请求，只需要把参数<code>data</code>以bytes形式传入。</p><p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以<code>username=xxx&amp;password=xxx</code>的编码传入：</p><pre><code class="python">from urllib import request, parseprint(&#39;Login to weibo.cn...&#39;)email = input(&#39;Email: &#39;)passwd = input(&#39;Password: &#39;)login_data = parse.urlencode([    (&#39;username&#39;, email),    (&#39;password&#39;, passwd),    (&#39;entry&#39;, &#39;mweibo&#39;),    (&#39;client_id&#39;, &#39;&#39;),    (&#39;savestate&#39;, &#39;1&#39;),    (&#39;ec&#39;, &#39;&#39;),    (&#39;pagerefer&#39;, &#39;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)])req = request.Request(&#39;https://passport.weibo.cn/sso/login&#39;)req.add_header(&#39;Origin&#39;, &#39;https://passport.weibo.cn&#39;)req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)req.add_header(&#39;Referer&#39;, &#39;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)with request.urlopen(req, data=login_data.encode(&#39;utf-8&#39;)) as f:    print(&#39;Status:&#39;, f.status, f.reason)    for k, v in f.getheaders():        print(&#39;%s: %s&#39; % (k, v))    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))</code></pre><p>如果登录成功，我们获得的响应如下：</p><pre><code class="python">Status: 200 OKServer: nginx/1.2.0...Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn...Data: {&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:{...,&quot;uid&quot;:&quot;1658384301&quot;}}</code></pre><p>如果登录失败，我们获得的响应如下：</p><pre><code class="python">...Data: {&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:{&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536}}</code></pre><h4 id="13-9-3Handler"><a href="#13-9-3Handler" class="headerlink" title="13.9.3Handler"></a>13.9.3Handler</h4><p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用<code>ProxyHandler</code>来处理，示例代码如下：</p><pre><code class="python">proxy_handler = urllib.request.ProxyHandler({&#39;http&#39;: &#39;http://www.example.com:3128/&#39;})proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&#39;realm&#39;, &#39;host&#39;, &#39;username&#39;, &#39;password&#39;)opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open(&#39;http://www.example.com/login.html&#39;) as f:    pass</code></pre><p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，<code>User-Agent</code>头就是用来标识浏览器的。</p><h2 id="十四、常用第三方模块"><a href="#十四、常用第三方模块" class="headerlink" title="十四、常用第三方模块"></a>十四、常用第三方模块</h2><p>基本上，所有的第三方模块都会在<a href="https://pypi.python.org/" target="_blank" rel="noopener">PyPI - the Python Package Index</a>上注册，只要找到对应的模块名字，即可用pip安装。</p><h3 id="14-1Pillow"><a href="#14-1Pillow" class="headerlink" title="14.1Pillow"></a>14.1Pillow</h3><p>PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。</p><p>由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。</p><p>如果安装了Anaconda，Pillow就已经可用了。否则，需要在命令行下通过pip安装：</p><pre><code class="bash">$ pip install pillow</code></pre><h4 id="14-1-1操作图像"><a href="#14-1-1操作图像" class="headerlink" title="14.1.1操作图像"></a>14.1.1操作图像</h4><p>来看看最常见的图像缩放操作，只需三四行代码：</p><pre><code class="python">from PIL import Image# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&#39;test.jpg&#39;)# 获得图像尺寸:w, h = im.sizeprint(&#39;Original image size: %sx%s&#39; % (w, h))# 缩放到50%:im.thumbnail((w//2, h//2))print(&#39;Resize image to: %sx%s&#39; % (w//2, h//2))# 把缩放后的图像用jpeg格式保存:im.save(&#39;thumbnail.jpg&#39;, &#39;jpeg&#39;)</code></pre><p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。</p><p>比如，模糊效果也只需几行代码：</p><pre><code class="python">from PIL import Image, ImageFilter# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&#39;test.jpg&#39;)# 应用模糊滤镜:im2 = im.filter(ImageFilter.BLUR)im2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)</code></pre><p>效果如下：</p><p><img src="//NU-LL.github.io/2020/01/10/python/966760155050624.jfif" alt="PIL-blur"></p><p>PIL的<code>ImageDraw</code>提供了一系列绘图方法，让我们可以直接绘图。比如要生成字母验证码图片：</p><pre><code class="python">from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar():    return chr(random.randint(65, 90))# 随机颜色1:def rndColor():    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2():    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 240 x 60:width = 60 * 4height = 60image = Image.new(&#39;RGB&#39;, (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype(&#39;Arial.ttf&#39;, 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width):    for y in range(height):        draw.point((x, y), fill=rndColor())# 输出文字:for t in range(4):    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save(&#39;code.jpg&#39;, &#39;jpeg&#39;)</code></pre><p>我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：</p><p><img src="//NU-LL.github.io/2020/01/10/python/966760380198752.jfif" alt="验证码"></p><p>如果运行的时候报错：</p><pre><code class="python">IOError: cannot open resource</code></pre><p>这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：</p><pre><code class="python">&#39;/Library/Fonts/Arial.ttf&#39;</code></pre><p>要详细了解PIL的强大功能，请请参考Pillow官方文档：</p><p><a href="https://pillow.readthedocs.org/" target="_blank" rel="noopener">https://pillow.readthedocs.org/</a></p><h3 id="14-2requests"><a href="#14-2requests" class="headerlink" title="14.2requests"></a>14.2requests</h3><p>Python内置的urllib模块用于访问网络资源，但是用起来比较麻烦，而且缺少很多实用的高级功能。</p><p>更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。</p><p>如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install requests</code></p><p>要通过GET访问一个页面，只需要几行代码：</p><pre><code class="python">&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/&#39;) # 豆瓣首页&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.textr.text&#39;&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta name=&quot;description&quot; content=&quot;提供图书、电影、音乐唱片的推荐、评论和...&#39;</code></pre><p>对于带参数的URL，传入一个dict作为<code>params</code>参数：</p><pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/search&#39;, params={&#39;q&#39;: &#39;python&#39;, &#39;cat&#39;: &#39;1001&#39;})&gt;&gt;&gt; r.url # 实际请求的URL&#39;https://www.douban.com/search?q=python&amp;cat=1001&#39;</code></pre><p>requests自动检测编码，可以使用<code>encoding</code>属性查看：</p><pre><code class="python">&gt;&gt;&gt; r.encoding&#39;utf-8&#39;</code></pre><p>无论响应是文本还是二进制内容，我们都可以用<code>content</code>属性获得<code>bytes</code>对象：</p><pre><code class="python">&gt;&gt;&gt; r.contentb&#39;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n...&#39;</code></pre><p>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：</p><pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json&#39;)&gt;&gt;&gt; r.json(){&#39;query&#39;: {&#39;count&#39;: 1, &#39;created&#39;: &#39;2017-11-17T07:14:12Z&#39;, ...</code></pre><p>需要传入HTTP Header时，我们传入一个dict作为<code>headers</code>参数：</p><pre><code class="python">&gt;&gt;&gt; r = requests.get(&#39;https://www.douban.com/&#39;, headers={&#39;User-Agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit&#39;})&gt;&gt;&gt; r.text&#39;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;豆瓣(手机版)&lt;/title&gt;...&#39;</code></pre><p>要发送POST请求，只需要把<code>get()</code>方法变成<code>post()</code>，然后传入<code>data</code>参数作为POST请求的数据：</p><pre><code class="python">&gt;&gt;&gt; r = requests.post(&#39;https://accounts.douban.com/login&#39;, data={&#39;form_email&#39;: &#39;abc@example.com&#39;, &#39;form_password&#39;: &#39;123456&#39;})</code></pre><p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数：</p><pre><code class="python">params = {&#39;key&#39;: &#39;value&#39;}r = requests.post(url, json=params) # 内部自动序列化为JSON</code></pre><p>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成<code>files</code>参数：</p><pre><code class="python">&gt;&gt;&gt; upload_files = {&#39;file&#39;: open(&#39;report.xls&#39;, &#39;rb&#39;)}&gt;&gt;&gt; r = requests.post(url, files=upload_files)</code></pre><p>在读取文件时，注意务必使用<code>&#39;rb&#39;</code>即二进制模式读取，这样获取的<code>bytes</code>长度才是文件的长度。</p><p>把<code>post()</code>方法替换为<code>put()</code>，<code>delete()</code>等，就可以以PUT或DELETE方式请求资源。</p><p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：</p><pre><code class="python">&gt;&gt;&gt; r.headers{Content-Type&#39;: &#39;text/html; charset=utf-8&#39;, &#39;Transfer-Encoding&#39;: &#39;chunked&#39;, &#39;Content-Encoding&#39;: &#39;gzip&#39;, ...}&gt;&gt;&gt; r.headers[&#39;Content-Type&#39;]&#39;text/html; charset=utf-8&#39;</code></pre><p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p><pre><code class="python">&gt;&gt;&gt; r.cookies[&#39;ts&#39;]&#39;example_cookie_12345&#39;</code></pre><p>要在请求中传入Cookie，只需准备一个dict传入<code>cookies</code>参数：</p><pre><code class="python">&gt;&gt;&gt; cs = {&#39;token&#39;: &#39;12345&#39;, &#39;status&#39;: &#39;working&#39;}&gt;&gt;&gt; r = requests.get(url, cookies=cs)</code></pre><p>最后，要指定超时，传入以秒为单位的timeout参数：</p><pre><code class="python">&gt;&gt;&gt; r = requests.get(url, timeout=2.5) # 2.5秒后超时</code></pre><h3 id="14-3chardet"><a href="#14-3chardet" class="headerlink" title="14.3chardet"></a>14.3chardet</h3><p>字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的<code>str</code>和<code>bytes</code>两种数据类型，并且可以通过<code>encode()</code>和<code>decode()</code>方法转换，但是，在不知道编码的情况下，对<code>bytes</code>做<code>decode()</code>不好做。</p><p>对于未知编码的<code>bytes</code>，要把它转换成<code>str</code>，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p><p>当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。</p><p>如果安装了Anaconda，chardet就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install chardet</code></p><p>当我们拿到一个<code>bytes</code>时，就可以对其检测编码。用chardet检测编码，只需要一行代码：</p><pre><code class="python">&gt;&gt;&gt; chardet.detect(b&#39;Hello, world!&#39;){&#39;encoding&#39;: &#39;ascii&#39;, &#39;confidence&#39;: 1.0, &#39;language&#39;: &#39;&#39;}</code></pre><p>检测出的编码是<code>ascii</code>，注意到还有个<code>confidence</code>字段，表示检测的概率是1.0（即100%）。</p><p>再试试检测GBK编码的中文：</p><pre><code class="python">&gt;&gt;&gt; data = &#39;离离原上草，一岁一枯荣&#39;.encode(&#39;gbk&#39;)&gt;&gt;&gt; chardet.detect(data){&#39;encoding&#39;: &#39;GB2312&#39;, &#39;confidence&#39;: 0.7407407407407407, &#39;language&#39;: &#39;Chinese&#39;}</code></pre><p>检测的编码是<code>GB2312</code>，注意到GBK是GB2312的超集，两者是同一种编码，检测正确的概率是74%，<code>language</code>字段指出的语言是<code>&#39;Chinese&#39;</code>。</p><p>对UTF-8编码进行检测：</p><pre><code class="python">&gt;&gt;&gt; data = &#39;离离原上草，一岁一枯荣&#39;.encode(&#39;utf-8&#39;)&gt;&gt;&gt; chardet.detect(data){&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;}</code></pre><p>我们再试试对日文进行检测：</p><pre><code class="python">&gt;&gt;&gt; data = &#39;最新の主要ニュース&#39;.encode(&#39;euc-jp&#39;)&gt;&gt;&gt; chardet.detect(data){&#39;encoding&#39;: &#39;EUC-JP&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;Japanese&#39;}</code></pre><p>可见，用chardet检测编码，使用简单。获取到编码后，再转换为<code>str</code>，就可以方便后续处理。</p><p>chardet支持检测的编码列表请参考官方文档<a href="https://chardet.readthedocs.io/en/latest/supported-encodings.html" target="_blank" rel="noopener">Supported encodings</a>。</p><h3 id="14-4psutil"><a href="#14-4psutil" class="headerlink" title="14.4psutil"></a>14.4psutil</h3><p>要获取一些系统信息，Python可以通过<code>subprocess</code>模块调用并获取结果。但这样做显得很麻烦，尤其是要写很多解析代码。</p><p>在Python中获取系统信息的另一个好办法是使用<code>psutil</code>（ process and system utilities）这个第三方模块。它不仅可以通过一两行代码实现系统监控，还支持Linux／UNIX／OSX／Windows等。更多信息：<a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">https://github.com/giampaolo/psutil</a></p><p>如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：<code>pip install psutil</code></p><h4 id="14-4-1获取CPU信息"><a href="#14-4-1获取CPU信息" class="headerlink" title="14.4.1获取CPU信息"></a>14.4.1获取CPU信息</h4><pre><code class="python">&gt;&gt;&gt; import psutil&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量4&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心2# 2说明是双核超线程, 4则是4核非超线程</code></pre><p>统计CPU的用户／系统／空闲时间：</p><pre><code class="python">&gt;&gt;&gt; psutil.cpu_times()scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)</code></pre><p>再实现类似<code>top</code>命令的CPU使用率，每秒刷新一次，累计10次：</p><pre><code class="python">&gt;&gt;&gt; for x in range(10):...     psutil.cpu_percent(interval=1, percpu=True)...[14.0, 4.0, 4.0, 4.0][12.0, 3.0, 4.0, 3.0][8.0, 4.0, 3.0, 4.0][12.0, 3.0, 3.0, 3.0][18.8, 5.1, 5.9, 5.0][10.9, 5.0, 4.0, 3.0][12.0, 5.0, 4.0, 5.0][15.0, 5.0, 4.0, 4.0][19.0, 5.0, 5.0, 4.0][9.0, 3.0, 2.0, 3.0]</code></pre><h4 id="14-4-2获取内存信息"><a href="#14-4-2获取内存信息" class="headerlink" title="14.4.2获取内存信息"></a>14.4.2获取内存信息</h4><p>使用psutil获取物理内存和交换内存信息，分别使用：</p><pre><code class="python">&gt;&gt;&gt; psutil.virtual_memory()svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480)&gt;&gt;&gt; psutil.swap_memory()sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)</code></pre><p>返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。</p><p>而交换区大小是1073741824 = 1 GB。</p><h4 id="14-4-3获取磁盘信息"><a href="#14-4-3获取磁盘信息" class="headerlink" title="14.4.3获取磁盘信息"></a>14.4.3获取磁盘信息</h4><p>可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：</p><pre><code class="python">&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息[sdiskpart(device=&#39;/dev/disk1&#39;, mountpoint=&#39;/&#39;, fstype=&#39;hfs&#39;, opts=&#39;rw,local,rootfs,dovolfs,journaled,multilabel&#39;)]&gt;&gt;&gt; psutil.disk_usage(&#39;/&#39;) # 磁盘使用情况sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IOsdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)</code></pre><p>可以看到，磁盘<code>&#39;/&#39;</code>的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，<code>opts</code>中包含<code>rw</code>表示可读写，<code>journaled</code>表示支持日志。</p><h4 id="14-4-4获取网络信息"><a href="#14-4-4获取网络信息" class="headerlink" title="14.4.4获取网络信息"></a>14.4.4获取网络信息</h4><p>psutil可以获取网络接口和网络连接信息：</p><pre><code class="python">&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0)&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息{  &#39;lo0&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;127.0.0.1&#39;, netmask=&#39;255.0.0.0&#39;), ...],  &#39;en1&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;10.0.1.80&#39;, netmask=&#39;255.255.255.0&#39;), ...],  &#39;en0&#39;: [...],  &#39;en2&#39;: [...],  &#39;bridge0&#39;: [...]}&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态{  &#39;lo0&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=16384),  &#39;en0&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=1500),  &#39;en1&#39;: snicstats(...),  &#39;en2&#39;: snicstats(...),  &#39;bridge0&#39;: snicstats(...)}</code></pre><p>要获取当前网络连接信息，使用<code>net_connections()</code>：</p><pre><code class="python">&gt;&gt;&gt; psutil.net_connections()Traceback (most recent call last):  ...PermissionError: [Errno 1] Operation not permittedDuring handling of the above exception, another exception occurred:Traceback (most recent call last):  ...psutil.AccessDenied: psutil.AccessDenied (pid=3847)</code></pre><p>你可能会得到一个<code>AccessDenied</code>错误，原因是psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用<code>sudo</code>重新启动：</p><pre><code class="python">$ sudo python3Password: ******Python 3.6.3 ... on darwinType &quot;help&quot;, ... for more information.&gt;&gt;&gt; import psutil&gt;&gt;&gt; psutil.net_connections()[    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62911), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),    sconn(fd=84, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62905), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),    sconn(fd=93, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::&#39;, port=8080), raddr=(), status=&#39;LISTEN&#39;, pid=3725),    sconn(fd=103, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&#39;::127.0.0.1&#39;, port=62918), raddr=addr(ip=&#39;::127.0.0.1&#39;, port=3306), status=&#39;ESTABLISHED&#39;, pid=3725),    sconn(fd=105, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),    sconn(fd=106, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),    sconn(fd=107, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),    ...    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)]</code></pre><h4 id="14-4-5获取进程信息"><a href="#14-4-5获取进程信息" class="headerlink" title="14.4.5获取进程信息"></a>14.4.5获取进程信息</h4><p>通过psutil可以获取到所有进程的详细信息：</p><pre><code class="python">&gt;&gt;&gt; psutil.pids() # 所有进程ID[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]&gt;&gt;&gt; p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境&gt;&gt;&gt; p.name() # 进程名称&#39;python3.6&#39;&gt;&gt;&gt; p.exe() # 进程exe路径&#39;/Users/michael/anaconda3/bin/python3.6&#39;&gt;&gt;&gt; p.cwd() # 进程工作目录&#39;/Users/michael&#39;&gt;&gt;&gt; p.cmdline() # 进程启动的命令行[&#39;python3&#39;]&gt;&gt;&gt; p.ppid() # 父进程ID3765&gt;&gt;&gt; p.parent() # 父进程&lt;psutil.Process(pid=3765, name=&#39;bash&#39;) at 4503144040&gt;&gt;&gt;&gt; p.children() # 子进程列表[]&gt;&gt;&gt; p.status() # 进程状态&#39;running&#39;&gt;&gt;&gt; p.username() # 进程用户名&#39;michael&#39;&gt;&gt;&gt; p.create_time() # 进程创建时间1511052731.120333&gt;&gt;&gt; p.terminal() # 进程终端&#39;/dev/ttys002&#39;&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)&gt;&gt;&gt; p.memory_info() # 进程使用的内存pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)&gt;&gt;&gt; p.open_files() # 进程打开的文件[]&gt;&gt;&gt; p.connections() # 进程相关网络连接[]&gt;&gt;&gt; p.num_threads() # 进程的线程数量1&gt;&gt;&gt; p.threads() # 所有线程信息[pthread(id=1, user_time=0.090318, system_time=0.062736)]&gt;&gt;&gt; p.environ() # 进程环境变量{&#39;SHELL&#39;: &#39;/bin/bash&#39;, &#39;PATH&#39;: &#39;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...&#39;, &#39;PWD&#39;: &#39;/Users/michael&#39;, &#39;LANG&#39;: &#39;zh_CN.UTF-8&#39;, ...}&gt;&gt;&gt; p.terminate() # 结束进程Terminated: 15 &lt;-- 自己把自己结束了</code></pre><p>和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者<code>.py</code>文件时，需要<code>sudo</code>权限。</p><p>psutil还提供了一个<code>test()</code>函数，可以模拟出<code>ps</code>命令的效果：</p><pre><code class="python">$ sudo python3Password: ******Python 3.6.3 ... on darwinType &quot;help&quot;, ... for more information.&gt;&gt;&gt; import psutil&gt;&gt;&gt; psutil.test()USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMANDroot           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_taskroot           1  0.1 2494140    9484 ?             Nov18   01:39  launchdroot          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgentroot          45    ? 2474032    1516 ?             Nov18   00:14  syslogdroot          47  0.1 2504768    8912 ?             Nov18   00:03  kextdroot          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsdroot          53  0.1 2500592    6132 ?             Nov18   00:02  configd...</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 廖雪峰python教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习与TensorFlow2</title>
      <link href="/2020/01/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow2/"/>
      <url>/2020/01/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow2/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习与TensorFlow2"><a href="#深度学习与TensorFlow2" class="headerlink" title="深度学习与TensorFlow2"></a>深度学习与TensorFlow2</h1><p>环境（版本需要匹配）：</p><ul><li>TensorFlow：TensorFlow2.0 GPU版本</li><li>Anaconda：4.8.1（conda -V，conda -list，Python 3.7 version），链接：<a href="https://www.anaconda.com/distribution/#download-section" target="_blank" rel="noopener">https://www.anaconda.com/distribution/#download-section</a></li><li>CUDA：V10.0.130（nvcc -V），链接：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a><ul><li>cuDNN：，链接：<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-archive</a></li></ul></li></ul><h2 id="TensorFlow2基础操作"><a href="#TensorFlow2基础操作" class="headerlink" title="TensorFlow2基础操作"></a>TensorFlow2基础操作</h2><p>TensorFlow中的数据载体叫做张量（Tensor）对象，即<code>tf.Tensor</code>，对应不同的类型，能够存储大量的连续的数据。同时所有的运算操作(Operation，简称 OP)也都是基于张量对象进行的</p><p>什么是Tensor：</p><ul><li>Tensor是一个比较广泛的数据</li><li>标量（scalar）：1.1、2.2等准确的数据类型（维度dim=0）</li><li>向量（vector）：[1.1]、[1.1,2.2,…]（dim=1）</li><li>矩阵（matrix）：[[1.1,2.2],[2.2,2.2],[3.3,2.2]]</li><li>数学上tensor：一般指维度&gt;2时的数据，但是在TensorFlow中维度&gt;=1时的数据全称为tensor，甚至标量也可以看作是tensor，所以工程上讲tensor一般指所有的数据</li></ul><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><h4 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h4><p>数值类型的张量是 TensorFlow 的主要数据载体， 根据维度数来区分，可分为：</p><ul><li><p>标量(Scalar)：单个的实数，如 1.2, 3.4 等，维度(Dimension)数为 0， shape 为[]</p></li><li><p>向量(Vector)：单个实数的有序集合，通过中括号包裹，如[1.2]， [1.2, 3.4]等，维度数为 1，长度不定， shape 为[n]</p></li><li><p>矩阵(Matrix)：n行m列实数的有序集合，如[[1,2], [3,4]]，也可以写成$\begin{bmatrix}<br>  1 &amp; 2\<br>  3 &amp; 4<br>  \end{bmatrix}$，维度数为 2，每个维度上的长度不定， shape 为[n,m]</p></li><li><p>张量(Tensor)：所有维度数dim &gt; 2的数组统称为张量。 张量的每个维度也作轴(Axis)，一般来说，维度代表了具体的物理含义，张量的维度数以及每个维度所代表的具体物理含义需要由用户自行定义。</p><blockquote><p>比如 Shape 为[2,32,32,3]的张量共有 4 维，如果表示图片数据的话，每个维度/轴代表的含义分别是图片数量、 图片高度、 图片宽度、 图片通道数，其中 2 代表了 2 张图片， 32 代表了高、 宽均为 32， 3 代表了 RGB 共 3 个通道</p></blockquote></li></ul><p>在 TensorFlow 中，为了表达方便，一般把标量、向量、矩阵也统称为张量，不作区分，需要根据张量的维度数或形状自行判断</p><p>张量的创建：</p><pre><code class="python">&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; aa = tf.constant(1.2) # TF方式创建标量&gt;&gt;&gt; x = tf.constant([1,2.,3.3]) # TF方式创建向量&gt;&gt;&gt; x&lt;tf.Tensor: id=0, shape=(3,), dtype=float32, numpy=array([1. , 2. , 3.3],dtype=float32)&gt;&gt;&gt;&gt; a = tf.constant([[1,2],[3,4]]) # TF方式创建2行2列的矩阵&gt;&gt;&gt; a&lt;tf.Tensor: id=1, shape=(2, 2), dtype=int32, numpy=array([[1, 2],       [3, 4]])&gt;&gt;&gt;&gt; a = tf.constant([[[1,2],[3,4]],[[5,6],[7,8]]])# TF方式创建3维张量&gt;&gt;&gt; a&lt;tf.Tensor: id=2, shape=(2, 2, 2), dtype=int32, numpy=array([[[1, 2],        [3, 4]],       [[5, 6],        [7, 8]]])&gt;</code></pre><ul><li>id：TensorFlow 中内部索引对象的编号</li><li>shape：张量的形状</li><li>dtype：张量的数值精度</li></ul><blockquote><p>张量可以通过 numpy()方法可以返回 Numpy.array 类型的数据，方便导出数据到系统的其他模块</p><pre><code class="python">&gt;&gt;&gt; x.numpy() # 将 TF 张量的数据导出为 numpy 数组格式array([1. , 2. , 3.3], dtype=float32)</code></pre></blockquote><h4 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2.字符串类型"></a>2.字符串类型</h4><p>使用频率较低。通过传入字符串对象即可创建字符串类型的张量：</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant(&#39;Hello, Deep Learning.&#39;) # 创建字符串&gt;&gt;&gt; a&lt;tf.Tensor: id=3, shape=(), dtype=string, numpy=b&#39;Hello, Deep Learning.&#39;&gt;</code></pre><p>在 <code>tf.strings</code> 模块中，提供了常见的字符串类型的工具函数，如小写化 lower()、 拼接join()、 长度 length()、 切分 split()等</p><blockquote><p>将字符串全部小写化：</p><pre><code class="python">&gt;&gt;&gt; tf.strings.lower(a) # 小写化字符串&lt;tf.Tensor: id=19, shape=(), dtype=string, numpy=b&#39;hello, deep learning.&#39;&gt;</code></pre></blockquote><h4 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3.布尔类型"></a>3.布尔类型</h4><p>布尔类型的张量需要传入 Python 语言的布尔类型数据，转换成 TensorFlow 内部布尔型即可：</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant(True) # 创建布尔类型标量&lt;tf.Tensor: id=22, shape=(), dtype=bool, numpy=True&gt;&gt;&gt;&gt; a = tf.constant([True, False]) # 创建布尔类型向量&lt;tf.Tensor: id=25, shape=(2,), dtype=bool, numpy=array([ True, False])&gt;</code></pre><ul><li>TensorFlow 的布尔类型和 Python 语言的布尔类型并不等价，不能通用</li></ul><h3 id="2、数值精度"><a href="#2、数值精度" class="headerlink" title="2、数值精度"></a>2、数值精度</h3><p>保存的数据位越长，精度越高，同时占用的内存空间也就越大。常用的精度类型有<code>tf.int16</code>、<code>tf.int32</code>、<code>tf.int64</code>、<code>tf.float16</code>、<code>tf.float32</code>、<code>tf.float64</code>等，其中<code>tf.float64</code>即为<code>tf.double</code></p><p>在创建张量时，可以指定张量的保存精度：</p><pre><code class="python">&gt;&gt;&gt; tf.constant(123456789, dtype=tf.int16)&gt;&gt;&gt; tf.constant(123456789, dtype=tf.int32)</code></pre><p>对于大部分深度学习算法，一般使用 tf.int32 和 tf.float32 可满足大部分场合的运算精<br>度要求，部分对精度要求较高的算法，如强化学习某些算法，可以选择使用 tf.int64 和<br>tf.float64 精度保存张量</p><h4 id="1-读取精度"><a href="#1-读取精度" class="headerlink" title="1.读取精度"></a>1.读取精度</h4><p>通过访问张量的<code>dtype</code>成员属性可以判断张量的保存精度</p><pre><code class="python">print(&#39;before:&#39;,a.dtype) # 读取原有张量的数值精度if a.dtype != tf.float32: # 如果精度不符合要求，则进行转换    a = tf.cast(a,tf.float32) # tf.cast 函数可以完成精度转换print(&#39;after :&#39;,a.dtype) # 打印转换后的精度</code></pre><h4 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2.类型转换"></a>2.类型转换</h4><p>通常通过<code>tf.cast</code>函数进行转换：</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant(np.pi, dtype=tf.float16) # 创建 tf.float16 低精度张量&gt;&gt;&gt; tf.cast(a, tf.double) # 转换为高精度张量&lt;tf.Tensor: id=44, shape=(), dtype=float64, numpy=3.140625&gt;</code></pre><p>布尔类型与整型之间相互转换也是合法的：</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant([True, False])&gt;&gt;&gt; tf.cast(a, tf.int32) # 布尔类型转整型&lt;tf.Tensor: id=48, shape=(2,), dtype=int32, numpy=array([1, 0])&gt;</code></pre><ul><li>一般默认 0 表示 False， 1 表示 True，在 TensorFlow 中，将<strong>非 0 数字都视为 True</strong></li></ul><h3 id="3、待优化张量"><a href="#3、待优化张量" class="headerlink" title="3、待优化张量"></a>3、待优化张量</h3><p>为了区分需要计算梯度信息的张量与不需要计算梯度信息的张量， TensorFlow 增加了<br>一种专门的数据类型来<u>支持梯度信息的记录</u>：<code>tf.Variable</code></p><p><code>tf.Variable</code>类型在普通的张量类型基础上添加了 <code>name</code>， <code>trainable</code> 等属性来支持计算图的构建。由于梯度运算会消耗大量的计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入<strong>X</strong>，不需要通过 tf.Variable 封装；相反，对于<u>需要计算梯度并优化</u>的张量， 如神经网络层的<strong>W</strong>和<strong>b</strong>，需要通过 tf.Variable 包裹以便TensorFlow 跟踪相关梯度信息。</p><p>通过<code>tf.Variable()</code>函数可以将普通张量转换为待优化张量：</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant([-1, 0, 1, 2]) # 创建 TF 张量&gt;&gt;&gt; aa = tf.Variable(a) # 转换为 Variable 类型&gt;&gt;&gt; aa.name, aa.trainable # Variable 类型张量的属性(&#39;Variable:0&#39;, True)</code></pre><ul><li>name 属性：命名计算图中的变量，这套命名体系是 TensorFlow 内部维护的， 一般不需要用户关注 name 属性</li><li>trainable属性：当前张量是否需要被优化（创建 Variable 对象时默认启用优化标志，可以设置trainable=False来设置张量不需要优化）</li></ul><p>直接创建待优化张量：</p><pre><code class="python">&gt;&gt;&gt; a = tf.Variable([[1,2],[3,4]]) # 直接创建 Variable 张量&lt;tf.Variable &#39;Variable:0&#39; shape=(2, 2) dtype=int32, numpy=array([[1, 2],       [3, 4]])&gt;</code></pre><p>待优化张量可视为普通张量的特殊类型， 普通张量其实也可以通过<code>GradientTape.watch()</code>方法临时加入跟踪梯度信息的列表，从而支持自动求导功能</p><h3 id="4、创建张量"><a href="#4、创建张量" class="headerlink" title="4、创建张量"></a>4、创建张量</h3><h4 id="1-从数组、列表中创建"><a href="#1-从数组、列表中创建" class="headerlink" title="1.从数组、列表中创建"></a>1.从数组、列表中创建</h4><p>通过<code>tf.convert_to_tensor</code>函数可以创建新 Tensor，并将保存在 Python List 对象或者Numpy Array 对象中的数据导入到新 Tensor 中：</p><pre><code class="python">&gt;&gt;&gt; tf.convert_to_tensor([1,2.]) # 从列表创建张量&lt;tf.Tensor: id=86, shape=(2,), dtype=float32, numpy=array([1., 2.],dtype=float32)&gt;&gt;&gt;&gt; tf.convert_to_tensor(np.array([[1,2.],[3,4]])) # 从数组中创建张量&lt;tf.Tensor: id=88, shape=(2, 2), dtype=float64, numpy=array([[1., 2.],       [3., 4.]])&gt;</code></pre><ul><li>Numpy 浮点数数组默认使用 64 位精度保存数据，可以在需要的时候将其转换为 tf.float32 类型</li><li>实际上， tf.constant()和 tf.convert_to_tensor()都能够自动的把 Numpy 数组或者 Python列表数据类型转化为 Tensor 类型，这两个 API 命名来自 TensorFlow 1.x 的命名习惯，在TensorFlow 2 中函数的名字并不是很贴切，使用其一即可</li></ul><h4 id="2-创建全0全1张量"><a href="#2-创建全0全1张量" class="headerlink" title="2.创建全0全1张量"></a>2.创建全0全1张量</h4><p>通过<code>tf.zeros()</code>和<code>tf.ones()</code>可创建任意形状，且内容全 0 或全 1 的张量：</p><pre><code class="python">&gt;&gt;&gt; tf.zeros([]),tf.ones([]) # 创建全 0，全 1 的标量(&lt;tf.Tensor: id=90, shape=(), dtype=float32, numpy=0.0&gt;,&lt;tf.Tensor: id=91, shape=(), dtype=float32, numpy=1.0&gt;)&gt;&gt;&gt; tf.zeros([1]),tf.ones([1]) # 创建全 0，全 1 的向量(&lt;tf.Tensor: id=96, shape=(1,), dtype=float32, numpy=array([0.],dtype=float32)&gt;,&lt;tf.Tensor: id=99, shape=(1,), dtype=float32, numpy=array([1.],dtype=float32)&gt;)&gt;&gt;&gt; tf.ones([3,2]) # 创建全 1 矩阵，指定 shape 为 3 行 2 列&lt;tf.Tensor: id=108, shape=(3, 2), dtype=float32, numpy=array([[1., 1.],       [1., 1.],       [1., 1.]], dtype=float32)&gt;</code></pre><p>通过<code>tf.zeros_like</code>、<code>tf.ones_like</code>可以方便地新建与某个张量 shape 一致， 且内容为全 0 或全 1 的张量：</p><pre><code class="python">&gt;&gt;&gt; a = tf.ones([2,3]) # 创建一个矩阵&gt;&gt;&gt; tf.zeros_like(a) # 创建一个与 a 形状相同，但是全 0 的新矩阵&lt;tf.Tensor: id=113, shape=(2, 3), dtype=float32, numpy=array([[0., 0., 0.],       [0., 0., 0.]], dtype=float32)&gt;</code></pre><ul><li><code>tf.*_like</code>是一系列的便捷函数，可以通过<code>tf.zeros(a.shape)</code>等方式实现</li></ul><h4 id="3-创建自定义数值张量"><a href="#3-创建自定义数值张量" class="headerlink" title="3.创建自定义数值张量"></a>3.创建自定义数值张量</h4><p>通过<code>tf.fill(shape, value)</code>可以创建全为自定义数值 value 的张量，形状由 shape 参数指定：</p><pre><code class="python">&gt;&gt;&gt; tf.fill([2,2], 99) # 创建 2 行 2 列，元素全为 99 的矩阵&lt;tf.Tensor: id=136, shape=(2, 2), dtype=int32, numpy=array([[99, 99],       [99, 99]])&gt;</code></pre><h4 id="4-创建已知分布的张量"><a href="#4-创建已知分布的张量" class="headerlink" title="4.创建已知分布的张量"></a>4.创建已知分布的张量</h4><p>通过<code>tf.random.normal(shape, mean=0.0, stddev=1.0)</code>可以创建形状为 shape，均值为mean，标准差为 stddev 的<strong>正态分布</strong>：</p><pre><code class="python">&gt;&gt;&gt; tf.random.normal([2,2]) # 创建标准正态分布的张量&lt;tf.Tensor: id=143, shape=(2, 2), dtype=float32, numpy=array([[-0.4307344 , 0.44147003],       [-0.6563149 , -0.30100572]], dtype=float32)&gt;</code></pre><p>通过<code>tf.random.uniform(shape, minval=0, maxval=None, dtype=tf.float32)</code>可以创建采样自[minval, maxval)区间的<strong>均匀分布</strong>的张量：</p><pre><code class="python">&gt;&gt;&gt; tf.random.uniform([2,2]) # 创建采样自[0,1)均匀分布的矩阵&lt;tf.Tensor: id=158, shape=(2, 2), dtype=float32, numpy=array([[0.65483284, 0.63064325],       [0.008816 , 0.81437767]], dtype=float32)&gt;</code></pre><h4 id="5-创建序列"><a href="#5-创建序列" class="headerlink" title="5.创建序列"></a>5.创建序列</h4><p><code>tf.range(limit, delta=1)</code>可以创建[0, limit)之间，步长为 delta 的整型序列，不包含 limit 本身：</p><pre><code class="python">&gt;&gt;&gt; tf.range(10) # 0~10，不包含 10&lt;tf.Tensor: id=180, shape=(10,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;</code></pre><p>通过<code>tf.range(start, limit, delta=1)</code>可以创建[start, limit)，步长为 delta 的序列，不包含limit 本身</p><pre><code class="python">&gt;&gt;&gt; tf.range(1,10,delta=2) # 1~10&lt;tf.Tensor: id=190, shape=(5,), dtype=int32, numpy=array([1, 3, 5, 7, 9])&gt;</code></pre><h3 id="5、张量的典型用途"><a href="#5、张量的典型用途" class="headerlink" title="5、张量的典型用途"></a>5、张量的典型用途</h3><p>标量：误差值的表示、 各种测量指标的表示，比如准确度(Accuracy，简称 acc)，精度(Precision)和召回率(Recall)等</p><p>向量：如在全连接层和卷积神经网络层中，偏置张量b就是使用向量来表示</p><p>矩阵：比如全连接层的批量输入张量X的形状为[b,din]，其中b表示输入样本的个数，即Batch Size，din表示输入特征的长度</p><p>三维张量：表示序列信号，它的格式是$X=[b,sequence,feature\ len]$，其中b表示序列信号的数量， sequence len 表示序列信号在时间维度上的采样点数或步数，feature len 表示每个点的特征长度，自然语言处理(Natural Language Processing，简称 NLP)中会使用到</p><p>四维张量：卷积神经网络中应用广泛，用于保存特征图数据，格式一般为$[b,h,w,c]$，其中b表示输入样本的数量， h/w 分别表示特征图的高/宽，c表示特征图的通道数。部分深度学习框架（如PyTorch）会使用$[b,c,h,w]$格式   </p><p>大于四维的张量一般应用的比较少，如在元学习(Meta Learning)中会采用五维的张量表示方法，理解方法与三、四维张量类似</p><h3 id="6、索引与切片"><a href="#6、索引与切片" class="headerlink" title="6、索引与切片"></a>6、索引与切片</h3><h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h4><p>在 TensorFlow 中， 支持基本的$[i][j]…$标准索引方式，也支持通过逗号分隔索引号的索引方式</p><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([4,32,32,3]) # 创建 4D 张量（4张32*32大小的彩色图片）&gt;&gt;&gt; x[0] # 程序中的第一的索引号应为 0，容易混淆，不过不影响理解&lt;tf.Tensor: id=379, shape=(32, 32, 3), dtype=float32, numpy=array([[[ 1.3005302 , 1.5301839 , -0.32005513],        [-1.3020388 , 1.7837263 , -1.0747638 ], ...        [-1.1092019 , -1.045254 , -0.4980363 ],        [-0.9099222 , 0.3947732 , -0.10433522]]], dtype=float32)&gt;&gt;&gt;&gt; x[2][1][0][1] # 取第 3 张图片，第 2 行，第 1 列的像素， B 通道(第 2 个通道)颜色强度值&lt;tf.Tensor: id=418, shape=(), dtype=float32, numpy=-0.84922135&gt;</code></pre><p>当张量的维度数较高时， 使用$[i][j]…[k]$的方式书写不方便，可以采用$[i,j,…,k]$方式索引，他们是等价的：</p><pre><code class="python">&gt;&gt;&gt; x[1,9,2] # 取第 2 张图片，第 10 行，第 3 列的数据，实现如下&lt;tf.Tensor: id=436, shape=(3,), dtype=float32, numpy=array([ 1.7487534 , -0.41491988, -0.2944692 ], dtype=float32)&gt;</code></pre><h4 id="2-切片"><a href="#2-切片" class="headerlink" title="2.切片"></a>2.切片</h4><p>通过<code>start:end:step</code>切片方式可以方便地提取一段数据，其中 start 为开始读取位置的索引， end 为结束读取位置的索引(不包含 end 位)， step 为采样步长</p><pre><code class="python">&gt;&gt;&gt; x[1:3] # 读取第 2,3 张图片&lt;tf.Tensor: id=441, shape=(2, 32, 32, 3), dtype=float32, numpy=array([[[[ 0.6920027 , 0.18658352, 0.0568333 ],         [ 0.31422952, 0.75933754, 0.26853144],         [ 2.7898 , -0.4284912 , -0.26247284],...</code></pre><p><code>start:end:step</code>切片方式有很多简写方式</p><ul><li>全部省略时即为<code>::</code>， 表示从最开始读取到最末尾，步长为 1（不跳过任何元素）。为了更加简洁， <code>::</code>可以简写为单个冒号<code>:</code></li><li>从第一个元素读取时<code>start</code>可以省略（即start=0可以省略）</li><li>取到最后一个元素时<code>end</code>可以省略</li><li>步长为 1 时<code>step</code>可以省略</li></ul><p>特别地，<code>step</code>可以为负数，当step = -1时，<code>start:end:-1</code>表示从 start 开始， 逆序读取至 end 结束(不包含 end)，索引号$end\leqslant start$</p><pre><code class="python">&gt;&gt;&gt; x = tf.range(9) # 创建 0~9 向量&gt;&gt;&gt; x[8:0:-1] # 从 8 取到 0，逆序，不包含 0&lt;tf.Tensor: id=466, shape=(8,), dtype=int32, numpy=array([8, 7, 6, 5, 4, 3, 2, 1])&gt;&gt;&gt;&gt; x = tf.random.normal([4,32,32,3])&gt;&gt;&gt; x[0,::-2,::-2] # 行、列逆序间隔采样&lt;tf.Tensor: id=487, shape=(16, 16, 3), dtype=float32, numpy=array([[[ 0.63320625, 0.0655185 , 0.19056146],        [-1.0078577 , -0.61400175, 0.61183935],        [ 0.9230892 , -0.6860094 , -0.01580668],        ...</code></pre><p>为了避免出现像 [: , : , : ,1]这样过多冒号的情况，可以使用<code>...</code>符号表示取多个维度上所有的数据， 其中维度的数量需根据规则自动推断：</p><ul><li>当切片方式出现<code>...</code>符号时，<code>...</code>符号左边的维度将自动对齐到最左边</li><li><code>...</code>符号右边的维度将自动对齐到最右边，此时系统再自动推断<code>...</code>符号代表的维度数量</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([4,32,32,3])&gt;&gt;&gt; x[0:2,...,1:] # 高宽维度全部采集&lt;tf.Tensor: id=497, shape=(2, 32, 32, 2), dtype=float32, numpy=array([[[[ 0.575703 , 0.8872789 ],         [ 0.11028383, -0.27128693],         [-0.9950867 , -1.7737272 ],         ...</code></pre><h3 id="7、维度变换"><a href="#7、维度变换" class="headerlink" title="7、维度变换"></a>7、维度变换</h3><p>算法的每个模块对于数据张量的格式有不同的逻辑要求，当现有的数据格式不满足算<br>法要求时，需要通过维度变换将数据调整为正确的格式。这就是维度变换的功能。</p><p>基本的维度变换操作函数包含了改变视图 <code>reshape</code>、 插入新维度 <code>expand_dims</code>，删除维度 <code>squeeze</code>、 交换维度 <code>transpose</code>、 复制数据 <code>tile</code> 等函数</p><p>Batch 维度：为了实现维度变换，我们需要将原始数据插入一个新的维度，并把它定义为 Batch 维度，然后在 Batch 维度对数据进行相关操作，得到变换后的新的数据。这一系列的操作就是维度变换操作。</p><h4 id="1-改变视图-reshape"><a href="#1-改变视图-reshape" class="headerlink" title="1.改变视图 reshape"></a>1.改变视图 reshape</h4><p>张量的视图（View）：就是我们理解张量的方式，比如 shape 为[2,4,4,3]的张量A，从逻辑上可以理解为 2 张图片，每张图片 4 行 4 列，每个位置有 RGB 3 个通道的数据</p><p>张量的存储（Storage）：体现在张量在内存上保存为一段连续的内存区域，对于同样的存储，我们可以有不同的理解方式，比如上述张量A，我们可以在不改变张量的存储下，将张量A理解为 2个样本，每个样本的特征为长度 48 的向量</p><p>同一个存储，从不同的角度观察数据，可以产生不同的视图， 这就是存储与视图的关系。 视图的产生是非常灵活的，但需要保证是合理。</p><p>通过 <code>tf.range()</code>模拟生成一个向量数据，并通过<code>tf.reshape</code>视图改变函数产生不同的视图：</p><pre><code class="python">&gt;&gt;&gt; x=tf.range(96) # 生成向量&gt;&gt;&gt; x=tf.reshape(x,[2,4,4,3]) # 改变 x 的视图，获得 4D 张量，存储并未改变# 可以观察到数据仍然是 0~95 的顺序，可见数据并未改变，改变的是数据的结构&lt;tf.Tensor: id=11, shape=(2, 4, 4, 3), dtype=int32, numpy=array([[[[ 0, 1, 2],         [ 3, 4, 5],         [ 6, 7, 8],         [ 9, 10, 11]],...</code></pre><p>在存储数据时，内存只能以平铺方式按序写入内存，因此视图的层级关系需要人为管理。为了方便表达，一般把张量 shape 列表中相对靠左侧的维度叫作大维度， shape 列表中相对靠右侧的维度叫作小维度（如[2,4,4,3]的张量中，图片数量维度与通道数量相比，图片数量叫作大维度，通道数叫作小维度）</p><p>改变视图操作在提供便捷性的同时，也会带来很多逻辑隐患，主要的原因是改变视图操作的默认前提是<u>存储不需要改变</u>，否则改变视图操作就是非法的</p><blockquote><p>张量A按着初始视图[b,h,w,c]写入的内存布局，改变A的理解方式，它可以有多种合法的理解方式：</p><ul><li>[b,h∙w,c]张量理解为b张图片，h∙w个像素点，c个通道</li><li>[b,h,w∙c]张量理解为b张图片，h行，每行的特征长度为w∙c</li><li>[b,h∙w∙c]张量理解为b张图片，每张图片的特征长度为h∙w∙c</li></ul><p>从语法上来说， 视图变换只需要满足新视图的元素总量与存储区域大小相等即可。正是由于视图的设计的语法约束很少，使得在改变视图时容易出现逻辑隐患。</p><p>不合法的视图变换：</p><p>例如，如果定义新视图为[b,w,h,c]，[b,c,h*w]或者[b,c,h,w]等时，张量的存储顺序需要改变， 如果不同步更新张量的存储顺序，那么恢复出的数据将与新视图不一致，从而导致数据错乱。</p><p>这需要用户理解数据，才能判断操作是否合法。我们会在“交换维度”一节介绍如何改变张量的存储</p></blockquote><p>在通过 reshape 改变视图时，必须始终记住张量的存储顺序，新视图的维度顺序不能与存储顺序相悖，否则需要通过<strong>交换维度</strong>操作将存储顺序同步过来</p><p>在 TensorFlow 中，可以通过张量的 <code>ndim</code> 和 <code>shape</code> 成员属性获得张量的维度数和形<br>状：</p><pre><code class="python">&gt;&gt;&gt; x.ndim,x.shape # 获取张量的维度数和形状列表(4, TensorShape([2, 4, 4, 3]))</code></pre><hr><p>通过 <code>tf.reshape(x, new_shape)</code>，可以将张量的视图任意地合法改变：</p><pre><code class="python">&gt;&gt;&gt; tf.reshape(x,[2,-1])&lt;tf.Tensor: id=520, shape=(2, 48), dtype=int32, numpy=array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,…        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]])&gt;</code></pre><ul><li>参数-1：当前轴上长度需要根据张量总元素不变的法则自动推导（该处推导成(2*4*4*3)/2=48）</li></ul><p>再次改变数据的视图为[2,16,3] ，实现如下：</p><pre><code class="python">&gt;&gt;&gt; tf.reshape(x,[2,-1,3])&lt;tf.Tensor: id=526, shape=(2, 16, 3), dtype=int32, numpy=array([[[ 0, 1, 2], …       [45, 46, 47]],      [[48, 49, 50],…       [93, 94, 95]]])&gt;</code></pre><ul><li>上述一系列连续变换视图操作中，张量的存储顺序始终没有改变，数据在内存中仍然是按着初始写入的顺序0,1,2, ⋯ ,95保存</li></ul><h4 id="2-增删维度"><a href="#2-增删维度" class="headerlink" title="2.增删维度"></a>2.增删维度</h4><h5 id="增加维度"><a href="#增加维度" class="headerlink" title="增加维度"></a>增加维度</h5><p>通过 <code>tf.expand_dims(x, axis)</code>可在指定的 <strong>axis 轴前</strong>可以插入一个新的维度（长度为1）：  </p><pre><code class="python">&gt;&gt;&gt; x = tf.random.uniform([28,28],maxval=10,dtype=tf.int32) # 产生矩阵&lt;tf.Tensor: id=11, shape=(28, 28), dtype=int32, numpy=array([[6, 2, 0, 0, 6, 7, 3, 3, 6, 2, 6, 2, 9, 3, 0, 3, 2, 8, 1, 3, 6, 2, 3, 9, 3, 6, 1, 7],...&gt;&gt;&gt; x = tf.expand_dims(x,axis=2) # axis=2 表示宽维度后面的一个维度&lt;tf.Tensor: id=13, shape=(28, 28, 1), dtype=int32, numpy=array([[[6],        [2],        [0],        [0],        [6],        [7],        [3],...</code></pre><ul><li>增加一个长度为 1 的维度相当于给原有的数据添加一个新维度的概念，数据并不发生改变，仅仅是改变数据的理解方式，因此它其实可以理解为改变视图的一种特殊方式</li></ul><p>需要注意的是， <code>tf.expand_dims</code> 的 axis 为<strong>正</strong>时，表示在当前维度<strong>之前</strong>插入一个新维度； 为<strong>负</strong>时，表示当前维度<strong>之后</strong>插入一个新的维度。以[b,h,w,c]张量为例，不同 axis 参数的实际插入位置如下所示：</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200503172458500.png" alt="增加维度 axis 参数位置示意图"></p><h5 id="删除维度"><a href="#删除维度" class="headerlink" title="删除维度"></a>删除维度</h5><p>与增加维度一样，删除维度只能删除<strong>长度为1</strong>的维度，也不会改变张量的存储。</p><p>通过 <code>tf.squeeze(x, axis)</code>函数， axis 参数为待删除的维度的索引号：</p><pre><code class="python">#数据同上一个例子&gt;&gt;&gt; x = tf.squeeze(x, axis=2) # 删除图片通道数维度&lt;tf.Tensor: id=588, shape=(28, 28), dtype=int32, numpy=array([[8, 2, 2, 0, 7, 0, 1, 4, 9, 1, 7, 4, 8, 2, 7, 4, 8, 2, 9, 8, 8, 0, 9, 9, 7, 5, 9, 7],       [3, 4, 9, 9, 0, 6, 5, 7, 1, 9, 9, 1, 2, 7, 2, 7, 5, 3, 3, 7, 2, 4, 5, 2, 7, 3, 8, 0],...</code></pre><p>如果不指定维度参数 axis，即 <code>tf.squeeze(x)</code>， 那么它会默认删除所有长度为 1 的维度</p><h4 id="3-交换维度"><a href="#3-交换维度" class="headerlink" title="3.交换维度"></a>3.交换维度</h4><p>在保持维度顺序不变的条件下， 仅仅改变张量的理解方式是不够的，有时需要直接调整的存储顺序，即<strong>交换维度</strong>(Transpose)。通过交换维度操作，改变了张量的存储顺序，同时也改变了张量的视图</p><p>我们以图片格式[b,h,w,c]转换到图片格式[b,c,h,w]为例，介绍使用 <code>tf.transpose(x, perm)</code>函数完成维度交换操作，其中参数 perm表示新维度的顺序 List。</p><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([2,32,32,3])&gt;&gt;&gt; tf.transpose(x,perm=[0,3,1,2]) # 交换维度&lt;tf.Tensor: id=603, shape=(2, 3, 32, 32), dtype=float32, numpy=array([[[[-1.93072677e+00, -4.80163872e-01, -8.85614634e-01, ...,          1.49124235e-01, 1.16427064e+00, -1.47740364e+00],         [-1.94761145e+00, 7.26879001e-01, -4.41877693e-01, ...</code></pre><ul><li>图片张量 shape 为[2,32,32,3]，“图片数量、行、列、通道数” 的维度索引分别为 0、 1、 2、 3。交换为[b,c,h,w]格式，新维度的排序为“图片数量、通道数、行、列”，对应的索引号为[0,3,1,2]</li><li>通过 <code>tf.transpose</code> 维度交换后，张量的存储顺序已经改变， 视图也随之改变， 后续的所有操作必须基于新的存续顺序和视图进行。 相对于改变视图操作，维度交换操作的<strong>计算代价更高</strong></li></ul><h4 id="4-复制数据"><a href="#4-复制数据" class="headerlink" title="4.复制数据"></a>4.复制数据</h4><p>可以通过<code>tf.tile(x, multiples)</code>函数完成数据在指定维度上的复制操作， multiples 分别指定了每个维度上面的复制倍数，对应位置为 1 表明不复制，为 2 表明新长度为原来长度的2 倍，即数据复制一份，以此类推</p><pre><code class="python">&gt;&gt;&gt; b = tf.constant([1,2]) # 创建向量 b&gt;&gt;&gt; b = tf.expand_dims(b, axis=0) # 插入新维度，变成矩阵&lt;tf.Tensor: id=645, shape=(1, 2), dtype=int32, numpy=array([[1, 2]])&gt;# 在 Batch 维度上复制数据 1 份，实现如下：&gt;&gt;&gt; b = tf.tile(b, multiples=[2,1]) # 样本维度上复制一份&lt;tf.Tensor: id=648, shape=(2, 2), dtype=int32, numpy=array([[1, 2],       [1, 2]])&gt;</code></pre><p><code>tf.tile</code> 会创建一个<strong>新的张量</strong>来保存复制后的张量，会涉及大量数据的读写 IO 运算，计算代价相对较高</p><h3 id="8、Broadcasting"><a href="#8、Broadcasting" class="headerlink" title="8、Broadcasting"></a>8、Broadcasting</h3><p>Broadcasting 称为广播机制(或自动扩展机制)，它是一种轻量级的张量复制手段，在逻辑上扩展张量数据的形状， 但是只会在需要时才会执行实际存储复制操作。</p><p>对于用户来说， Broadcasting 和 tf.tile 复制的最终效果是一样的，操作对用户透明，但是 Broadcasting 机制节省了大量计算资源，建议在运算过程中尽可能地利用 Broadcasting 机制提高计算效率</p><p>考虑上述的$Y=X@W+b$的例子， $X@W$的 shape 为[2,3]，b的 shape 为[3]，可以通过结合 tf.expand_dims 和 tf.tile 手动完成复制数据操作，将b变换为[2,3]，然后与 $X@W$完成相加运算。但实际上，直接将 shape 为[2,3]与[3]的b相加也是合法的，例如：</p><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([2,4])&gt;&gt;&gt; w = tf.random.normal([4,3])&gt;&gt;&gt; b = tf.random.normal([3])&gt;&gt;&gt; y = x@w+b # 不同 shape 的张量直接相加</code></pre><ul><li><p>会自动调用 Broadcasting函数 <code>tf.broadcast_to(x, new_shape)</code>， 将两者 shape 扩张为相同的[2,3]， 即上式可以等效为</p><pre><code class="python">  &gt;&gt;&gt; y = x@w + tf.broadcast_to(b,[2,3]) # 手动扩展，并相加</code></pre></li><li><p>操作符+在遇到 shape 不一致的 2 个张量时，会自动考虑将 2 个张量自动扩展到一致的 shape，然后再调用 tf.add 完成张量相加运算</p></li></ul><p>所有的运算都需要在正确逻辑（满足Broadcasting 设计的核心思想）下进行， Broadcasting 机制并不会扰乱正常的计算逻辑， 它只会针对于最常见的场景自动完成增加维度并复制数据的功能， 提高开发效率和运行效率。</p><blockquote><p>Broadcasting 机制的核心思想是普适性，即同一份数据能普遍适合于其他位置。 在验证普适性之前，需要先将张量 shape 靠右对齐， 然后进行普适性判断： </p><ul><li>对于<strong>长度为1</strong>的维度，默认这个数据普遍适合于当前维度的其他位置</li><li>对于<strong>不存在</strong>的维度， 则在增加新维度后默认当前数据也是普适于新维度的， 从而可以扩展为更多维度数、 任意长度的张量形状</li></ul></blockquote><p>在进行张量运算时，有些运算在处理不同 shape 的张量时，会隐式地自动调用Broadcasting 机制，如+， -， *， /等运算，将参与运算的张量 Broadcasting 成一个公共shape，再进行相应的计算。  </p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200503181730592.png" alt="加法运算时自动Broadcasting示意图"></p><pre><code class="python">&gt;&gt;&gt; a = tf.random.normal([2,32,32,1])&gt;&gt;&gt; b = tf.random.normal([32,32])&gt;&gt;&gt; a+b,a-b,a*b,a/b # 测试加减乘除运算的 Broadcasting 机制</code></pre><ul><li>这些运算都能 Broadcasting 成[2,32,32,32]的公共 shape，再进行运算</li></ul><h3 id="9、数学运算"><a href="#9、数学运算" class="headerlink" title="9、数学运算"></a>9、数学运算</h3><h4 id="1-加减乘除"><a href="#1-加减乘除" class="headerlink" title="1.加减乘除"></a>1.加减乘除</h4><p>加、 减、 乘、 除是最基本的数学运算，分别通过 <code>tf.add</code>, <code>tf.subtract</code>, <code>tf.multiply</code>, <code>tf.divide</code>函数实现， TensorFlow 已经重载了+、 - 、 ∗ 、 /运算符，推荐直接使用运算符来完成加、 减、 乘、 除运算</p><p>整除和余除也是常见的运算之一，分别通过<code>//</code>和<code>%</code>运算符实现</p><pre><code class="python">&gt;&gt;&gt; a = tf.range(5)&gt;&gt;&gt; b = tf.constant(2)&gt;&gt;&gt; a//b # 整除运算&lt;tf.Tensor: id=115, shape=(5,), dtype=int32, numpy=array([0, 0, 1, 1, 2])&gt;&gt;&gt;&gt; a%b # 余除运算&lt;tf.Tensor: id=117, shape=(5,), dtype=int32, numpy=array([0, 1, 0, 1, 0])&gt;</code></pre><h4 id="2-乘方"><a href="#2-乘方" class="headerlink" title="2.乘方"></a>2.乘方</h4><p>通过 <code>tf.pow(x, a)</code>可以方便地完成$y=x^a$的乘方运算，也可以通过运算符<code>**</code>实现<code>x∗∗a</code>运算：</p><pre><code class="python">&gt;&gt;&gt; x = tf.range(4)&gt;&gt;&gt; tf.pow(x,3) # 乘方运算&lt;tf.Tensor: id=124, shape=(4,), dtype=int32, numpy=array([ 0, 1, 8, 27])&gt;&gt;&gt;&gt; x**2 # 乘方运算符&lt;tf.Tensor: id=127, shape=(4,), dtype=int32, numpy=array([0, 1, 4, 9])&gt;&gt;&gt;&gt; x=tf.constant([1.,4.,9.])&gt;&gt;&gt; x**(0.5) # 平方根&lt;tf.Tensor: id=139, shape=(3,), dtype=float32, numpy=array([1., 2., 3.], dtype=float32)&gt;</code></pre><ul><li>设置指数为$\frac{1}{a}$形式， 即可实现$\sqrt[a]{x}$根号运算</li><li>对于常见的平方和平方根运算，可以使用 <code>tf.square(x)</code>和 <code>tf.sqrt(x)</code>实现</li></ul><h4 id="3-指数和对数"><a href="#3-指数和对数" class="headerlink" title="3.指数和对数"></a>3.指数和对数</h4><p>通过 <code>tf.pow(a, x)</code>或者<code>**</code>运算符也可以方便地实现指数运算$a^x$</p><pre><code class="python">&gt;&gt;&gt; x = tf.constant([1.,2.,3.])&gt;&gt;&gt; 2**x # 指数运算&lt;tf.Tensor: id=179, shape=(3,), dtype=float32, numpy=array([2., 4., 8.], dtype=float32)&gt;&gt;&gt;&gt; tf.exp(1.) # 自然指数运算&lt;tf.Tensor: id=182, shape=(), dtype=float32, numpy=2.7182817&gt;</code></pre><ul><li>对于自然指数$e^x$， 可以通过 <code>tf.exp(x)</code>实现</li></ul><p>自然对数$log_ex$可以通过 <code>tf.math.log(x)</code>实现：</p><pre><code class="python">&gt;&gt;&gt; x=tf.exp(3.)&gt;&gt;&gt; tf.math.log(x) # 对数运算&lt;tf.Tensor: id=186, shape=(), dtype=float32, numpy=3.0&gt;</code></pre><ul><li><p>如果希望计算其它底数的对数，可以根据对数的换底公式$log_ax=\frac{log_ex}{log_ea}$间接实现</p><pre><code class="python">  &gt;&gt;&gt; x = tf.constant([1.,2.])  &gt;&gt;&gt; x = 10**x  &gt;&gt;&gt; tf.math.log(x)/tf.math.log(10.) # 换底公式  &lt;tf.Tensor: id=6, shape=(2,), dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;</code></pre></li></ul><h4 id="4-矩阵乘法"><a href="#4-矩阵乘法" class="headerlink" title="4.矩阵乘法"></a>4.矩阵乘法</h4><p>通过<code>@</code>运算符可以方便的实现矩阵相乘，还可以通过 <code>tf.matmul(a, b)</code>函数实现</p><p>需要注意的是， TensorFlow 中的矩阵相乘可以使用批量方式，也就是张量A和B的维度数可以大于 2。当张量A和B维度数大于 2 时， TensorFlow 会选择A和B的最后两个维度进行矩阵相乘，前面所有的维度都视作Batch 维度</p><pre><code class="python">&gt;&gt;&gt; a = tf.random.normal([4,3,28,32])&gt;&gt;&gt; b = tf.random.normal([4,3,32,2])&gt;&gt;&gt; a@b # 批量形式的矩阵相乘&lt;tf.Tensor: id=236, shape=(4, 3, 28, 2), dtype=float32, numpy=array([[[[-1.66706240e+00, -8.32602978e+00],         [ 9.83304405e+00, 8.15909767e+00],         [ 6.31014729e+00, 9.26124632e-01],...</code></pre><ul><li><p>矩阵相乘函数同样支持自动 Broadcasting 机制</p><pre><code class="python">  &gt;&gt;&gt; a = tf.random.normal([4,28,32])  &gt;&gt;&gt; b = tf.random.normal([32,16])  &gt;&gt;&gt; tf.matmul(a,b) # 先自动扩展，再矩阵相乘  &lt;tf.Tensor: id=264, shape=(4, 28, 16), dtype=float32, numpy=  array([[[-1.11323869e+00, -9.48194981e+00, 6.48123884e+00, ...,           6.53280640e+00, -3.10894990e+00, 1.53050375e+00],          [ 4.35898495e+00, -1.03704405e+01, 8.90656471e+00, ...,</code></pre></li></ul><h2 id="TensorFlow2进阶操作"><a href="#TensorFlow2进阶操作" class="headerlink" title="TensorFlow2进阶操作"></a>TensorFlow2进阶操作</h2><h3 id="1、合并与分割"><a href="#1、合并与分割" class="headerlink" title="1、合并与分割"></a>1、合并与分割</h3><h4 id="1-合并"><a href="#1-合并" class="headerlink" title="1.合并"></a>1.合并</h4><p>合并：将多个张量在某个维度上合并为一个张量</p><p>张量的合并可以使用拼接(Concatenate)和堆叠(Stack)操作实现：</p><ul><li>拼接：不会产生新的维度， 仅在现有的维度上合并</li><li>堆叠：会创建新维度</li></ul><p>选择使用拼接还是堆叠操作来合并张量，取决于具体的场景是否需要创建新维度</p><h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><p>通过<code>tf.concat(tensors, axis)</code>函数拼接张量，其中参数tensors 保存了所有需要合并的张量 List， axis 参数指定需要合并的维度索引</p><pre><code class="python">&gt;&gt;&gt; a = tf.random.normal([4,35,8]) # 模拟成绩册 A&gt;&gt;&gt; b = tf.random.normal([6,35,8]) # 模拟成绩册 B&gt;&gt;&gt; tf.concat([a,b],axis=0) # 拼接合并成绩册&lt;tf.Tensor: id=13, shape=(10, 35, 8), dtype=float32, numpy=array([[[ 1.95299834e-01, 6.87859178e-01, -5.80048323e-01, ...,          1.29430830e+00, 2.56610274e-01, -1.27798581e+00],        [ 4.29753691e-01, 9.11329567e-01, -4.47975427e-01, ...,</code></pre><ul><li>从语法上来说，拼接合并操作可以在任意的维度上进行，唯一的约束是非合并维度的长度<strong>必须一致</strong></li></ul><h5 id="堆叠"><a href="#堆叠" class="headerlink" title="堆叠"></a>堆叠</h5><p>使用<code>tf.stack(tensors, axis)</code>可以堆叠方式合并多个张量，通过 tensors 列表表示， 参数axis 指定新维度插入的位置（用法与 <code>tf.expand_dims</code> 一致，当axis ≥ 0时，在 axis之前插入； 当axis &lt; 0时，在 axis 之后插入新维度）</p><pre><code class="python">&gt;&gt;&gt; a = tf.random.normal([35,8])&gt;&gt;&gt; b = tf.random.normal([35,8])&gt;&gt;&gt; tf.stack([a,b],axis=0) # 堆叠合并为 2 个班级，班级维度插入在最前&lt;tf.Tensor: id=55, shape=(2, 35, 8), dtype=float32, numpy=array([[[ 3.68728966e-01, -8.54765773e-01, -4.77824420e-01,         -3.83714020e-01, -1.73216307e+00, 2.03872994e-02,          2.63810277e+00, -1.12998331e+00],...</code></pre><ul><li>需要所有待合并的张量 shape <strong>完全一致</strong>才可合并</li></ul><h4 id="2-分割"><a href="#2-分割" class="headerlink" title="2.分割"></a>2.分割</h4><p>合并操作的逆过程就是分割，将一个张量分拆为多个张量</p><p>通过<code>tf.split(x, num_or_size_splits, axis)</code>可以完成张量的分割操作</p><ul><li>x：待分割张量</li><li>num_or_size_splits：切割方案。当 num_or_size_splits 为单个数值时，如 10，表<br>  示等长切割为 10 份；当 num_or_size_splits 为 List 时， List 的每个元素表示每份的长度，如[2,4,2,2]表示切割为 4 份，每份的长度依次是 2、 4、 2、 2</li><li>axis：指定分割的维度索引号</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([10,35,8])# 等长切割为 10 份&gt;&gt;&gt; result = tf.split(x, num_or_size_splits=10, axis=0)&gt;&gt;&gt; len(result) # 返回的列表为 10 个张量的列表10&gt;&gt;&gt; result[0] # 查看第一个班级的成绩册张量&lt;tf.Tensor: id=136, shape=(1, 35, 8), dtype=float32, numpy=array([[[-1.7786729 , 0.2970506 , 0.02983334, 1.3970423 ,          1.315918 , -0.79110134, -0.8501629 , -1.5549672 ],        [ 0.5398711 , 0.21478991, -0.08685189, 0.7730989 ,...</code></pre><ul><li>仍保留了第一个维度</li></ul><p>如果希望在某个维度上全部按长度为 1 的方式分割，还可以使用<code>tf.unstack(x, axis)</code>函数。这种方式是<code>tf.split</code>的一种特殊情况，切割长度固定为 1，只需要指定切割维度的索引号即可</p><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([10,35,8])&gt;&gt;&gt; result = tf.unstack(x,axis=0) # Unstack 为长度为 1 的张量&gt;&gt;&gt; len(result) # 返回 10 个张量的列表10&gt;&gt;&gt; result[0] # 第一个班级&lt;tf.Tensor: id=166, shape=(35, 8), dtype=float32, numpy=array([[-0.2034383 , 1.1851563 , 0.25327438, -0.10160723, 2.094969 , -0.8571669 , -0.48985648, 0.55798006],...</code></pre><ul><li>通过<code>tf.unstack</code>切割后，shape 变为[35,8]，即第一个维度消失了，这是与tf.split区别之处</li></ul><h3 id="2、数据统计"><a href="#2、数据统计" class="headerlink" title="2、数据统计"></a>2、数据统计</h3><h4 id="1-向量范数"><a href="#1-向量范数" class="headerlink" title="1.向量范数"></a>1.向量范数</h4><p>向量范数(Vector Norm)是表征向量“长度”的一种度量方法， 它可以推广到张量上。在神经网络中，常用来表示张量的权值大小，梯度大小等。常用的向量范数有：</p><ul><li>L1 范数，定义为向量x的所有元素绝对值之和：$\left | x \right |<em>1=\sum</em>{i}\left | x_i \right |$</li><li>L2 范数，定义为向量x的所有元素的平方和，再开根号：$\left | x \right |<em>2=\sqrt{\sum</em>{i}\left | x_i \right |^2}$</li><li>$\infty$-范数，定义为向量x的所有元素绝对值的最大值：$\left | x \right |_\infty=max_i(\left | x_i \right |)$</li></ul><p>对于矩阵和张量，同样可以利用向量范数的计算公式，等价于将矩阵和张量打平成向量后计算</p><p>通过<code>tf.norm(x, ord)</code>求解张量的 L1、 L2、$\infty$等范数，其中参数ord 指定为 1、 2时计算 L1、 L2 范数，指定为<code>np.inf</code>时计算$\infty$-范数</p><pre><code class="python">&gt;&gt;&gt; x = tf.ones([2,2])&gt;&gt;&gt; tf.norm(x,ord=1) # 计算 L1 范数&lt;tf.Tensor: id=183, shape=(), dtype=float32, numpy=4.0&gt;&gt;&gt;&gt; tf.norm(x,ord=2) # 计算 L2 范数&lt;tf.Tensor: id=189, shape=(), dtype=float32, numpy=2.0&gt;&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; tf.norm(x,ord=np.inf) # 计算∞范数&lt;tf.Tensor: id=194, shape=(), dtype=float32, numpy=1.0&gt;</code></pre><h4 id="2-最值、均值、和"><a href="#2-最值、均值、和" class="headerlink" title="2.最值、均值、和"></a>2.最值、均值、和</h4><p>通过 <code>tf.reduce_max</code>、 <code>tf.reduce_min</code>、 <code>tf.reduce_mean</code>、 <code>tf.reduce_sum</code> 函数可以求解张量在某个维度上的最大、最小、 均值、和，也可以求全局最大、最小、均值、和信息</p><pre><code class="python"># 假设第一个维度为样本数量，第二个维度为当前样本分别属于 10 个类别的概率&gt;&gt;&gt; x = tf.random.normal([4,10]) # 模型生成概率&gt;&gt;&gt; tf.reduce_max(x,axis=1) # 统计概率维度上的最大值&lt;tf.Tensor: id=203, shape=(4,), dtype=float32, numpy=array([1.2410722 , 0.88495886, 1.4170984 , 0.9550192 ], dtype=float32)&gt;&gt;&gt;&gt; tf.reduce_min(x,axis=1) # 统计概率维度上的最小值&lt;tf.Tensor: id=206, shape=(4,), dtype=float32, numpy=array([-0.27862206, -2.4480672 , -1.9983795 , -1.5287997 ], dtype=float32)&gt;&gt;&gt;&gt; tf.reduce_mean(x,axis=1) # 统计概率维度上的均值&lt;tf.Tensor: id=209, shape=(4,), dtype=float32, numpy=array([ 0.39526337, -0.17684573, -0.148988 , -0.43544054], dtype=float32)&gt;# 统计全局的最大、最小、均值、和，返回的张量均为标量&gt;&gt;&gt; x = tf.random.normal([4,10]) # 模型生成概率&gt;&gt;&gt; tf.reduce_max(x),tf.reduce_min(x),tf.reduce_mean(x)(&lt;tf.Tensor: id=218, shape=(), dtype=float32, numpy=1.8653786&gt;, &lt;tf.Tensor: id=220, shape=(), dtype=float32, numpy=-1.9751656&gt;, &lt;tf.Tensor: id=222, shape=(), dtype=float32, numpy=0.014772797&gt;)</code></pre><ul><li>不指定 axis 参数时， <code>tf.reduce_*</code>函数会求解出全局元素的最大、最小、 均值、和等数据</li></ul><p>通过 <code>tf.argmax(x, axis)</code>和 <code>tf.argmin(x, axis)</code>可以求解在 axis 轴上， x 的最大值、 最小值所在的索引号</p><pre><code class="python"># out：&lt;tf.Tensor: id=257, shape=(2, 10), dtype=float32, numpy=array([[0.18773547, 0.1510464 , 0.09431915, 0.13652141, 0.06579739,        0.02033597, 0.06067333, 0.0666793 , 0.14594753, 0.07094406],       [0.5092072 , 0.03887136, 0.0390687 , 0.01911005, 0.03850609,        0.03442522, 0.08060656, 0.10171875, 0.08244187, 0.05604421]], dtype=float32)&gt;&gt;&gt;&gt; pred = tf.argmax(out, axis=1) # 选取概率最大的位置&lt;tf.Tensor: id=262, shape=(2,), dtype=int64, numpy=array([0, 0], dtype=int64)&gt;</code></pre><h3 id="3、张量比较"><a href="#3、张量比较" class="headerlink" title="3、张量比较"></a>3、张量比较</h3><p>通过<code>tf.equal(a, b)</code>(或<code>tf.math.equal(a, b)</code>，两者等价)函数可以比较2个张量是否相等</p><pre><code class="python"># pred：&lt;tf.Tensor: id=272, shape=(100,), dtype=int64, numpy=array([0, 6, 4, 3, 6, 8, 6, 3, 7, 9, 5, 7, 3, 7, 1, 5, 6, 1, 2, 9, 0, 6, 5, 4, 9, 5, 6, 4, 6, 0, 8, 4, 7, 3, 4, 7, 4, 1, 2, 4, 9, 4,...&gt;&gt;&gt; y = tf.random.uniform([100],dtype=tf.int64,maxval=10)&lt;tf.Tensor: id=281, shape=(100,), dtype=int64, numpy=array([0, 9, 8, 4, 9, 7, 2, 7, 6, 7, 3, 4, 2, 6, 5, 0, 9, 4, 5, 8, 4, 2, 5, 5, 5, 3, 8, 5, 2, 0, 3, 6, 0, 7, 1, 1, 7, 0, 6, 1, 2, 1, 3,...&gt;&gt;&gt; out = tf.equal(pred,y) # 预测值与真实值比较，返回布尔类型的张量&lt;tf.Tensor: id=288, shape=(100,), dtype=bool, numpy=array([False, False, False, False, True, False, False, False, False, False, False, False, False, False, True, False, False, True,...</code></pre><p>相关函数汇总表：</p><table><thead><tr><th align="center">函数</th><th align="center">比较逻辑</th></tr></thead><tbody><tr><td align="center">tf.equal(a, b)</td><td align="center">$a=b$</td></tr><tr><td align="center">tf.math.greater(a, b)</td><td align="center">$a&gt;b$</td></tr><tr><td align="center">tf.math.less(a, b)</td><td align="center">$a&lt;b$</td></tr><tr><td align="center">tf.math.greater_equal(a, b)</td><td align="center">$a\geqslant b$</td></tr><tr><td align="center">tf.math.less_equal(a, b)</td><td align="center">$a\leqslant b$</td></tr><tr><td align="center">tf.math.not_equal(a, b)</td><td align="center">$a\neq b$</td></tr><tr><td align="center">tf.math.is_nan(a, b)</td><td align="center">$a=nan$</td></tr></tbody></table><h3 id="4、复制和填充"><a href="#4、复制和填充" class="headerlink" title="4、复制和填充"></a>4、复制和填充</h3><h4 id="1-填充"><a href="#1-填充" class="headerlink" title="1.填充"></a>1.填充</h4><p>之前我们介绍了通过复制的方式可以增加数据的长度，但是重复复制数据会破坏原有的数据结构，并不适合于此处。通常的做法是，在需要补充长度的数据开始或结束处填充足够数量的特定数值， 这些特定数值一般代表了<strong>无效意义</strong>，例如 0，使得填充后的长度满足系统要求。那么这种操作就叫作填充(Padding)</p><p>填充操作可以通过<code>tf.pad(x, paddings)</code>函数实现， 参数 paddings 是包含了多个[Left Padding, Right Padding]的嵌套方案 List，如[[0,0], [2,1], [1,2]]表示第一个维度不填<br>充， 第二个维度左边(起始处)填充两个单元， 右边(结束处)填充一个单元， 第三个维度左边填充一个单元， 右边填充两个单元</p><pre><code class="python">&gt;&gt;&gt; a = tf.constant([1,2,3,4,5,6]) # 第一个句子&gt;&gt;&gt; b = tf.constant([7,8,1,6]) # 第二个句子&gt;&gt;&gt; b = tf.pad(b, [[0,2]]) # 句子末尾填充 2 个 0&lt;tf.Tensor: id=3, shape=(6,), dtype=int32, numpy=array([7, 8, 1, 6, 0, 0])&gt;</code></pre><h4 id="2-复制"><a href="#2-复制" class="headerlink" title="2.复制"></a>2.复制</h4><p>即<code>tf.tile()</code>函数。参考<code>基础操作-&gt;维度变换-&gt;复制数据</code>章节</p><h3 id="5、数据限幅"><a href="#5、数据限幅" class="headerlink" title="5、数据限幅"></a>5、数据限幅</h3><p>可以通过<code>tf.maximum(x, a)</code>实现数据的下限幅，即$x\in [a,+\infty )$。可以通过<code>tf.minimum(x, a)</code>实现数据的上限幅，即$x\in (-\infty ,a]$</p><pre><code class="python">&gt;&gt;&gt; x = tf.range(9)&gt;&gt;&gt; tf.maximum(x,2) # 下限幅到 2&lt;tf.Tensor: id=48, shape=(9,), dtype=int32, numpy=array([2, 2, 2, 3, 4, 5, 6, 7, 8])&gt;&gt;&gt;&gt; tf.minimum(x,7) # 上限幅到 7&lt;tf.Tensor: id=41, shape=(9,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 7])&gt;</code></pre><p>通过组合<code>tf.maximum(x, a)</code>和<code>tf.minimum(x, b)</code>可以实现同时对数据的上下边界限幅，即$x\in [a,b]$</p><pre><code class="python">&gt;&gt;&gt; x = tf.range(9)&gt;&gt;&gt; tf.minimum(tf.maximum(x,2),7) # 限幅为 2~7&lt;tf.Tensor: id=57, shape=(9,), dtype=int32, numpy=array([2, 2, 2, 3, 4, 5, 6, 7, 7])&gt;</code></pre><p>更方便地，我们可以使用<code>tf.clip_by_value</code>函数实现上下限幅：</p><pre><code class="python">&gt;&gt;&gt; x = tf.range(9)&gt;&gt;&gt; tf.clip_by_value(x,2,7) # 限幅为 2~7&lt;tf.Tensor: id=66, shape=(9,), dtype=int32, numpy=array([2, 2, 2, 3, 4, 5, 6, 7, 7])&gt;</code></pre><h3 id="6、高级操作"><a href="#6、高级操作" class="headerlink" title="6、高级操作"></a>6、高级操作</h3><h4 id="1-tf-gather"><a href="#1-tf-gather" class="headerlink" title="1.tf.gather"></a>1.tf.gather</h4><p><code>tf.gather</code>可以实现根据索引号收集数据的目的（与切片类似，但是对于<strong>不规则</strong>的索引方式，切片实现起来非常麻烦， 而<code>tf.gather</code>则更加方便）</p><ul><li>参数1：带收集的张量</li><li>参数2：指定需要收集的索引号</li><li>参数3：指定收集的维度</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.uniform([4,35,8],maxval=100,dtype=tf.int32) # 成绩册张量（4个班级 35个学生 8门科目）# 收集第 1,4,9,12,13,27 号同学成绩&gt;&gt;&gt; tf.gather(x,[0,3,8,11,12,26],axis=1)&lt;tf.Tensor: id=87, shape=(4, 6, 8), dtype=int32, numpy=array([[[43, 10, 93, 85, 75, 87, 28, 19],        [74, 11, 25, 64, 84, 89, 79, 85],...</code></pre><p>索引号可以<strong>乱序</strong>排列，此时收集的数据也是<strong>对应顺序</strong>：</p><pre><code class="python">&gt;&gt;&gt; a=tf.range(8)&gt;&gt;&gt; a=tf.reshape(a,[4,2]) # 生成张量 a&lt;tf.Tensor: id=115, shape=(4, 2), dtype=int32, numpy=array([[0, 1],       [2, 3],       [4, 5],       [6, 7]])&gt;&gt;&gt;&gt; tf.gather(a,[3,1,0,2],axis=0) # 收集第 4,2,1,3 号元素&lt;tf.Tensor: id=119, shape=(4, 2), dtype=int32, numpy=array([[6, 7],       [2, 3],       [0, 1],       [4, 5]])&gt;</code></pre><h4 id="2-tf-gather-nd"><a href="#2-tf-gather-nd" class="headerlink" title="2.tf.gather_nd"></a>2.tf.gather_nd</h4><p>通过 tf.gather_nd 函数，可以通过指定每次采样点的多维坐标来实现采样多个点的目的（利用手动一个一个提取然后stack合并的方式也可以达到同样效果，但是效率极低）</p><ul><li>参数1：带收集的张量</li><li>参数2：指定的采样点的索引坐标</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.uniform([4,35,8],maxval=100,dtype=tf.int32) # 成绩册张量（4个班级 35个学生 8门科目）# 根据多维坐标收集数据&gt;&gt;&gt; tf.gather_nd(x,[[1,1],[2,2],[3,3]])#抽查第 2 个班级的第 2 个同学的所有科目，第 3 个班级的第 3 个同学的所有科目，第 4 个班级的第 4 个同学的所有科目&lt;tf.Tensor: id=256, shape=(3, 8), dtype=int32, numpy=array([[45, 34, 99, 17, 3, 1, 43, 86],       [11, 25, 84, 95, 97, 95, 69, 69],       [ 0, 89, 52, 29, 76, 7, 2, 98]])&gt;</code></pre><p>一般地，在使用 <code>tf.gather_nd</code> 采样多个样本时， 例如希望采样i号班级，j个学生，k门科目的成绩，则可以表达为[. . . , [i,j,k], . . . ]， 外层的括号长度为采样样本的个数，内层列表包含了每个采样点的索引坐标</p><h4 id="3-tf-boolean-mask"><a href="#3-tf-boolean-mask" class="headerlink" title="3.tf.boolean_mask"></a>3.tf.boolean_mask</h4><p>除了可以通过给定索引号的方式采样，还可以通过给定掩码(Mask)的方式进行采样。通过<code>tf.boolean_mask(x, mask, axis)</code>可以在 axis 轴上根据mask 方案进行采样</p><pre><code class="python">&gt;&gt;&gt; x = tf.random.uniform([4,35,8],maxval=100,dtype=tf.int32) # 成绩册张量（4个班级 35个学生 8门科目）# 根据掩码方式采样班级，给出掩码和维度索引&gt;&gt;&gt; tf.boolean_mask(x,mask=[True, False,False,True],axis=0)&lt;tf.Tensor: id=288, shape=(2, 35, 8), dtype=int32, numpy=array([[[43, 10, 93, 85, 75, 87, 28, 19],...</code></pre><ul><li>掩码的长度必须与对应维度的<strong>长度一致</strong></li><li>掩码可以是List嵌套，此时效果与<code>tf.gather_nd</code>类似</li></ul><p><code>tf.boolean_mask</code>既可以实现了<code>tf.gather</code>方式的一维掩码采样， 又可以实现<code>tf.gather_nd</code>方式的多维掩码采样</p><h4 id="4-tf-where"><a href="#4-tf-where" class="headerlink" title="4.tf.where"></a>4.tf.where</h4><p>通过<code>tf.where(cond, a, b)</code>操作可以根据 cond 条件的真假从参数A或B中读取数据， 条件判定规则如下：$o_i=\left{\begin{matrix}<br>a_i &amp; cond_i为True\<br>b_i &amp; cond_i为False<br>\end{matrix}\right.$。其中i为张量的元素索引， 返回的张量大小与A和B一致， 当对应位置的$cond_i$为 True， $o_i$从$a_i$中复制数据；当对应位置的$cond_i$为 False， $o_i$从$a_i$中复制数据</p><pre><code class="python">&gt;&gt;&gt; a = tf.ones([3,3]) # 构造 a 为全 1 矩阵&gt;&gt;&gt; b = tf.zeros([3,3]) # 构造 b 为全 0 矩阵# 构造采样条件&gt;&gt;&gt; cond = tf.constant([[True,False,False],[False,True,False],[True,True,False]])&gt;&gt;&gt; tf.where(cond,a,b) # 根据条件从 a,b 中采样&lt;tf.Tensor: id=384, shape=(3, 3), dtype=float32, numpy=array([[1., 0., 0.],       [0., 1., 0.],       [1., 1., 0.]], dtype=float32)&gt;</code></pre><p>当参数a=b=None时，tf.where 会返回 cond 张量中所有 True 的元素的索引坐标</p><pre><code class="python">&gt;&gt;&gt; cond = tf.constant([[True,False,False],[False,True,False],[True,True,False]])&gt;&gt;&gt; tf.where(cond) # 获取 cond 中为 True 的元素索引&lt;tf.Tensor: id=387, shape=(4, 2), dtype=int64, numpy=array([[0, 0],       [1, 1],       [2, 0],       [2, 1]], dtype=int64)&gt;</code></pre><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([3,3]) # 构造 a&lt;tf.Tensor: id=403, shape=(3, 3), dtype=float32, numpy=array([[-2.2946844 , 0.6708417 , -0.5222212 ],       [-0.6919401 , -1.9418817 , 0.3559235 ],       [-0.8005251 , 1.0603906 , -0.68819374]], dtype=float32)&gt;# 通过比较运算，得到所有正数的掩码：&gt;&gt;&gt; mask=x&gt;0 # 比较操作，等同于 tf.math.greater()&lt;tf.Tensor: id=405, shape=(3, 3), dtype=bool, numpy=array([[False, True, False],       [False, False, True],       [False, True, False]])&gt;# 通过 tf.where 提取此掩码处 True 元素的索引坐标：&gt;&gt;&gt; indices=tf.where(mask) # 提取所有大于 0 的元素索引&lt;tf.Tensor: id=407, shape=(3, 2), dtype=int64, numpy=array([[0, 1],       [1, 2],       [2, 1]], dtype=int64)&gt;# 拿到索引后，通过 tf.gather_nd 即可恢复出所有正数的元素：&gt;&gt;&gt; tf.gather_nd(x,indices) # 提取正数的元素值&lt;tf.Tensor: id=410, shape=(3,), dtype=float32, numpy=array([0.6708417, 0.3559235, 1.0603906], dtype=float32)&gt;# 实际上，也可以直接通过 tf.boolean_mask 获取所有正数的元素向量:&gt;&gt;&gt; tf.boolean_mask(x,mask) # 通过掩码提取正数的元素值&lt;tf.Tensor: id=439, shape=(3,), dtype=float32, numpy=array([0.6708417, 0.3559235, 1.0603906], dtype=float32)&gt;</code></pre><h4 id="5-scatter-nd"><a href="#5-scatter-nd" class="headerlink" title="5.scatter_nd"></a>5.scatter_nd</h4><p>通过<code>tf.scatter_nd(indices, updates, shape)</code>函数可以高效地刷新张量的部分数据，但是这个函数只能在<strong>全0</strong>的白板张量上面执行刷新操作，因此可能需要结合其它操作来实现现有张量的数据刷新功能</p><p>白板的形状通过 shape 参数表示，需要刷新的数据索引号通过 indices 表示，新数据为 updates。 根据 indices 给出的索引位置将 updates 中新的数据依次写入白板中，并返回更新后的结果张量</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200504220326506.png" alt="scatter_nd更新数据示意图"></p><pre><code class="python"># 构造需要刷新数据的位置参数，即为 4、 3、 1 和 7 号位置&gt;&gt;&gt; indices = tf.constant([[4], [3], [1], [7]])# 构造需要写入的数据， 4 号位写入 4.4,3 号位写入 3.3，以此类推&gt;&gt;&gt; updates = tf.constant([4.4, 3.3, 1.1, 7.7])# 在长度为 8 的全 0 向量上根据 indices 写入 updates 数据&gt;&gt;&gt; tf.scatter_nd(indices, updates, [8])&lt;tf.Tensor: id=467, shape=(8,), dtype=float32, numpy=array([0. , 1.1, 0. , 3.3, 4.4, 0. , 0. , 7.7], dtype=float32)&gt;</code></pre><p>3维张量刷新例子：</p><pre><code class="python"># 构造写入位置，即 2 个位置&gt;&gt;&gt; indices = tf.constant([[1],[3]])&gt;&gt;&gt; updates = tf.constant([# 构造写入数据，即 2 个矩阵[[5,5,5,5],[6,6,6,6],[7,7,7,7],[8,8,8,8]],[[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]])# 在 shape 为[4,4,4]白板上根据 indices 写入 updates&gt;&gt;&gt; tf.scatter_nd(indices,updates,[4,4,4])&lt;tf.Tensor: id=477, shape=(4, 4, 4), dtype=int32, numpy=array([[[0, 0, 0, 0],        [0, 0, 0, 0],        [0, 0, 0, 0],        [0, 0, 0, 0]],       [[5, 5, 5, 5], # 写入的新数据 1        [6, 6, 6, 6],        [7, 7, 7, 7],        [8, 8, 8, 8]],       [[0, 0, 0, 0],        [0, 0, 0, 0],        [0, 0, 0, 0],        [0, 0, 0, 0]],       [[1, 1, 1, 1], # 写入的新数据 2        [2, 2, 2, 2],        [3, 3, 3, 3],        [4, 4, 4, 4]]])&gt;</code></pre><h4 id="6-meshgrid"><a href="#6-meshgrid" class="headerlink" title="6.meshgrid"></a>6.meshgrid</h4><p>通过<code>tf.meshgrid</code>函数可以方便地生成二维网格的采样点坐标，方便可视化等应用场合</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-8.,8,100) # 设置 x 轴的采样点&gt;&gt;&gt; y = tf.linspace(-8.,8,100) # 设置 y 轴的采样点&gt;&gt;&gt; x,y = tf.meshgrid(x,y) # 生成网格点，并内部拆分后返回&gt;&gt;&gt; x.shape,y.shape # 打印拆分后的所有点的 x,y 坐标张量 shape(TensorShape([100, 100]), TensorShape([100, 100]))&gt;&gt;&gt; z = tf.sqrt(x**2+y**2)&gt;&gt;&gt; z = tf.sin(z)/z # sinc 函数实现&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; from matplotlib import pyplot as plt# 导入 3D 坐标轴支持&gt;&gt;&gt; from mpl_toolkits.mplot3d import Axes3D&gt;&gt;&gt; fig = plt.figure()&gt;&gt;&gt; ax = Axes3D(fig) # 设置 3D 坐标轴# 根据网格点绘制 sinc 函数 3D 曲面&gt;&gt;&gt; ax.contour3D(x.numpy(), y.numpy(), z.numpy(), 50)&gt;&gt;&gt; plt.show()</code></pre><ul><li>通过在 x 轴上进行采样 100 个数据点， y 轴上采样 100 个数据点，然后利用tf.meshgrid(x, y)即可返回这 10000 个数据点的张量数据， 保存在 shape 为[100,100,2]的张量中。为了方便计算， tf.meshgrid 会返回在 axis=2 维度切割后的 2 个张量A和B，其中张量A包含了所有点的 x 坐标， B包含了所有点的 y 坐标， shape 都为[100,100]</li></ul><h3 id="7、经典数据集加载"><a href="#7、经典数据集加载" class="headerlink" title="7、经典数据集加载"></a>7、经典数据集加载</h3><p><code>keras.datasets</code> 模块提供了常用经典数据集的自动下载、 管理、 加载与转换功能，并且提供了 <code>tf.data.Dataset</code> 数据集对象， 方便实现多线程(Multi-threading)、 预处理(Preprocessing)、 随机打散(Shuffle)和批训练(Training on Batch)等常用数据集的功能</p><p>常用的经典数据集：</p><ul><li>Boston Housing， 波士顿房价趋势数据集，用于回归模型训练与测试</li><li>CIFAR10/100， 真实图片数据集，用于图片分类任务</li><li>MNIST/Fashion_MNIST， 手写数字图片数据集，用于图片分类任务</li><li>IMDB， 情感分类任务数据集，用于文本分类任务</li></ul><hr><p>通过<code>datasets.xxx.load_data()</code>函数即可实现经典数据集的<strong>自动加载</strong>，其中 xxx 代表具体的数据集名称，如“CIFAR10”、“MNIST”。TensorFlow会默认将数据缓存在用户目录下的<code>.keras/datasets</code> 文件夹，用户无需关心数据集是如何保存的。如果当前数据集不在缓存中，则会自动从网络下载、 解压和加载数据集；如果已经在缓存中， 则自动完成加载</p><pre><code class="python">&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; from tensorflow import keras&gt;&gt;&gt; from tensorflow.keras import datasets # 导入经典数据集加载模块# 加载 MNIST 数据集&gt;&gt;&gt; (x, y), (x_test, y_test) = datasets.mnist.load_data()&gt;&gt;&gt; print(&#39;x:&#39;, x.shape, &#39;y:&#39;, y.shape, &#39;x test:&#39;, x_test.shape, &#39;y test:&#39;, y_test)# 返回数组的形状x: (60000, 28, 28) y: (60000,) x test: (10000, 28, 28) y test: [7 2 1 ... 4 5 6]</code></pre><ul><li>通过 load_data()函数会返回相应格式的数据，对于图片数据集 MNIST、 CIFAR10 等，会返回 2 个 tuple，第一个 tuple 保存了用于训练的数据 x 和 y 训练集对象；第 2 个 tuple 则保存了用于测试的数据 x_test 和 y_test 测试集对象，所有的数据都用 Numpy 数组容器保存</li></ul><p>数据加载进入内存后，需要转换成 <code>Dataset</code> 对象。通过<code>Dataset.from_tensor_slices</code>可以将数据<strong>转换成Dataset对象</strong></p><pre><code class="python">&gt;&gt;&gt; train_db = tf.data.Dataset.from_tensor_slices((x, y)) # 以将训练部分的数据图片x和标签y转换成Dataset对象</code></pre><h4 id="1-随机打散"><a href="#1-随机打散" class="headerlink" title="1.随机打散"></a>1.随机打散</h4><p>通过<code>Dataset.shuffle(buffer_size)</code>工具可以设置 Dataset 对象随机打散数据之间的顺序，防止每次训练时数据按固定顺序产生，从而使得模型尝试“记忆”住标签信息</p><pre><code class="python"># train_db为Dataset对象&gt;&gt;&gt; train_db = train_db.shuffle(10000) # 随机打散样本，不会打乱样本与标签映射关系</code></pre><p>buffer_size 参数指定缓冲池的大小，一般设置为一个较大的常数即可。 调用 Dataset提供的这些工具函数会<strong>返回新的Dataset对象</strong>，可以通过<code>db = db.step1().step2().step3()</code>方式按序完成所有的数据处理步骤</p><h4 id="2-批训练"><a href="#2-批训练" class="headerlink" title="2.批训练"></a>2.批训练</h4><p>为了利用显卡的并行计算能力，一般在网络的计算过程中会同时计算多个样本，把这种训练方式叫做批训练，其中一个批中样本的数量叫做<code>Batch Size</code></p><p>为了一次能够从Dataset 中产生 Batch Size 数量的样本，需要设置 Dataset 为批训练方式：</p><pre><code class="python"># train_db为Dataset对象&gt;&gt;&gt; train_db = train_db.batch(128) # 设置批训练， batch size 为 128</code></pre><ul><li>一次并行计算 128 个样本的数据</li></ul><p>Batch Size 一般根据用户的 GPU 显存资源来设置，当显存不足时，可以适量减少 Batch Size 来减少显存使用量</p><h4 id="3-预处理"><a href="#3-预处理" class="headerlink" title="3.预处理"></a>3.预处理</h4><p>Dataset 对象通过提供<code>map(func)</code>工具函数， 可以非常方便地调用用户自定义的预处理逻辑， 它实现在func函数里</p><pre><code class="python">def preprocess(x, y): # 自定义的预处理函数    # 调用此函数时会自动传入 x,y 对象， shape 为[b, 28, 28], [b]    x = tf.cast(x, dtype=tf.float32) / 255.# 标准化到 0~1    x = tf.reshape(x, [-1, 28*28]) # 打平    y = tf.cast(y, dtype=tf.int32) # 转成整型张量    y = tf.one_hot(y, depth=10) # one-hot 编码    # 返回的 x,y 将替换传入的 x,y 参数，从而实现数据的预处理功能    return x,y# 预处理函数实现在 preprocess 函数中，传入函数名即可train_db = train_db.map(preprocess)</code></pre><h4 id="4-循环训练"><a href="#4-循环训练" class="headerlink" title="4.循环训练"></a>4.循环训练</h4><p>对于 Dataset 对象， 在使用时可以通过</p><pre><code class="python">for step, (x,y) in enumerate(train_db): # 迭代数据集对象，带 step 参数</code></pre><p>或</p><pre><code class="python">for x,y in train_db: # 迭代数据集对象</code></pre><p>方式进行迭代，每次返回的 x 和 y 对象即为批量样本和标签，当对 train_db 的所有样本完成一次迭代后， for 循环终止退出</p><p>这样完成一个 Batch 的数据训练（执行一次循环体），叫做一个<strong>Step</strong></p><p>通过多个 step 来完成整个训练集的一次迭代（执行一次整个循环），叫做一个<strong>Epoch</strong></p><p>在实际训练时，通常需要对数据集迭代多个 Epoch 才能取得较好地训练效果：</p><pre><code class="python">for epoch in range(20): # 训练 Epoch 数    for step, (x,y) in enumerate(train_db): # 迭代 Step 数        # training...# 可以通过repeat设置epoch的迭代次数（上面与下面等价）train_db = train_db.repeat(20) # 数据集迭代 20 遍才终止for step, (x,y) in enumerate(train_db): # 迭代 Step 数    # training...</code></pre><ul><li>通过repeat，使得数据集对象内部遍历多次才会退出</li></ul><h3 id="8、MNIST实战"><a href="#8、MNIST实战" class="headerlink" title="8、MNIST实战"></a>8、MNIST实战</h3><pre><code class="python"></code></pre><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经网络属于机器学习的一个研究分支，它特指利用多个神经元去参数化映射函数$f_\theta$的模型</p><h3 id="1、感知机"><a href="#1、感知机" class="headerlink" title="1、感知机"></a>1、感知机</h3><p>感知机是线性模型，并不能处理线性不可分问题。通过在线性模型后添加激活函数后得到<br>活性值(Activation) $a$：$a=\sigma (z)=\sigma (W^Tx+b)$，其中激活函数可以是阶跃函数(Step function)，也可以是符号函数(Sign function)</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505012316465.png" alt="感知机模型"></p><ul><li>接受长度为𝑛的一维向量$x=[x_1,x_2,…,x_n]$</li><li>每个输入节点通过权值为$w_i,i\in [1,n]$的连接汇集为变量𝑧，即：$z=w_1x_1+w_2x_2+…+w_nx_n+b$<ul><li>𝑏称为感知机的偏置(Bias)</li><li>一维向量$W=[w_1,w_2,..w_n]$称为感知机的权值(Weight)</li><li>$z$称为感知机的净活性值(Net Activation)</li></ul></li></ul><p>但是阶跃函数和符号函数在0处是不连续的， 其他位置导数为 0，无法利用梯度下降算法进行参数优化</p><p>以感知机为代表的线性模型不能解决异或(XOR)等线性不可分问题</p><h3 id="2、全连接层"><a href="#2、全连接层" class="headerlink" title="2、全连接层"></a>2、全连接层</h3><p>现代深度学习的核心结构在感知机的基础上，将不连续的阶跃激活函数换成了其它平滑连续可导的激活函数， 并通过堆叠多个网络层来增强网络的表达能力</p><p>如下所示的整个网络层可以通过矩阵关系式表达$O=X@W+b$</p><ul><li>输入矩阵$X$的 shape 定义为$[b,d_{in}]$，$b$为样本数量，此处只有1个样本参与前向运算，$d_{in}$为输入节点数（即<strong>输入特征长度</strong>）</li><li>权值矩阵$W$的 shape 定义为$[d_{in},d_{out}]$，$d_{out}$为输出节点数（即<strong>输出特征长度</strong>）</li><li>偏置向量$b$的 shape 定义为$[d_{out}]$</li><li>输出矩阵$O$包含了$b$个样本的输出特征， shape 为$[b,d_{out}]$</li></ul><p>由于每个输出节点与全部的输入节点相连接，这种网络层称为<strong>全连接层</strong>(Fully-connected Layer)，或者稠密连接层(Dense Layer)，$W$矩阵叫做全连接层的权值矩阵，$b$向量叫做全连接层的偏置向量</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505013252398.png" alt="全连接层"></p><h4 id="1-张量方式实现"><a href="#1-张量方式实现" class="headerlink" title="1.张量方式实现"></a>1.张量方式实现</h4><p>要实现全连接层，只需要定义好权值张量𝑾和偏置张量𝒃，并利用批量矩阵相乘函数<code>tf.matmul()</code>即可完成网络层的计算</p><p>例如， 创建输入𝑿矩阵为𝑏 = 2个样本，每个样本的输入特征长度为$d_{in}$ = 784，输出节点数为$d_{out}$ = 256，故定义权值矩阵𝑾的 shape 为[784,256]，并采用正态分布初始化𝑾；偏置向量𝒃的 shape 定义为[256]，在计算完𝑿@𝑾后相加即可，最终全连接层的输出𝑶的 shape 为[2,256]，即 2 个样本的特征，每个特征长度为 256，代码实现如下：</p><pre><code class="python"># 创建 W,b 张量&gt;&gt;&gt; x = tf.random.normal([2,784])&gt;&gt;&gt; w1 = tf.Variable(tf.random.truncated_normal([784, 256], stddev=0.1))&gt;&gt;&gt; b1 = tf.Variable(tf.zeros([256]))&gt;&gt;&gt; o1 = tf.matmul(x,w1) + b1 # 线性变换&gt;&gt;&gt; o1 = tf.nn.relu(o1) # 激活函数&lt;tf.Tensor: id=31, shape=(2, 256), dtype=float32, numpy=array([[ 1.51279330e+00, 2.36286330e+00, 8.16453278e-01,         1.80338228e+00, 4.58602428e+00, 2.54454136e+00,...</code></pre><h4 id="2-层方式实现"><a href="#2-层方式实现" class="headerlink" title="2.层方式实现"></a>2.层方式实现</h4><p>作为最常用的网络层之一，TensorFlow中有更高层、使用更方便的层实现方式： <code>layers.Dense(units, activation)</code>。</p><p>通过<code>layer.Dense</code>类， 只需要指定输出节点数 Units 和激活函数类型 activation 即可</p><p>注意：</p><ul><li>输入节点数会根据第一次运算时的输入 shape 确定，同时根据输入、输出节点数<br>  自动创建并初始化权值张量𝑾和偏置张量𝒃（因此在新建类 Dense 实例时，并不会立即创建权值张量𝑾和偏置张量𝒃， 而是需要调用 build 函数或者直接进行一次前向计算，才能完成网络参数的创建）</li><li>activation参数指定当前层的激活函数，可以为常见的激活函数或自定义激活函数，也可以指定为 None，即无激活函数</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([4,28*28])&gt;&gt;&gt; from tensorflow.keras import layers # 导入层模块# 创建全连接层，指定输出节点数和激活函数&gt;&gt;&gt; fc = layers.Dense(512, activation=tf.nn.relu)&gt;&gt;&gt; h1 = fc(x) # 通过 fc 类实例完成一次全连接层的计算，返回输出张量&lt;tf.Tensor: id=72, shape=(4, 512), dtype=float32, numpy=array([[0.63339347, 0.21663809, 0. , ..., 1.7361937 , 0.39962345, 2.4346168 ],...</code></pre><p>通过类内部的成员名 kernel 和 bias 来获取权值张量W和偏置张量b对象：</p><pre><code class="python">&gt;&gt;&gt; fc.kernel # 获取 Dense 类的权值矩阵&lt;tf.Variable &#39;dense_1/kernel:0&#39; shape=(784, 512) dtype=float32, numpy=array([[-0.04067389, 0.05240148, 0.03931375, ..., -0.01595572, -0.01075954, -0.06222073],&gt;&gt;&gt; fc.bias # 获取 Dense 类的偏置向量&lt;tf.Variable &#39;dense_1/bias:0&#39; shape=(512,) dtype=float32, numpy=array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</code></pre><p>在优化参数时，需要获得网络的所有待优化的张量参数列表，可以通过类的<code>trainable_variables</code>来返回<strong>待优化参数列表</strong></p><pre><code class="python">&gt;&gt;&gt; fc.trainable_variables # 返回待优化参数列表[&lt;tf.Variable &#39;dense_1/kernel:0&#39; shape=(784, 512) dtype=float32,...,&lt;tf.Variable &#39;dense_1/bias:0&#39; shape=(512,) dtype=float32, numpy=...]</code></pre><p>网络层除了保存了待优化张量列表 trainable_variables，还有部分层包含了不参与梯度优化的张量，如后续介绍的 Batch Normalization 层， 可以通过<code>non_trainable_variables</code>成员返回所有<strong>不需要优化参数列表</strong>。如果希望获得<strong>所有参数列表</strong>， 可以通过类的<code>variables</code>返回</p><pre><code class="python">&gt;&gt;&gt; fc.variables # 返回所有参数列表[&lt;tf.Variable &#39;dense_1/kernel:0&#39; shape=(784, 512) dtype=float32,...,&lt;tf.Variable &#39;dense_1/bias:0&#39; shape=(512,) dtype=float32, numpy=...]</code></pre><ul><li>对于全连接层，内部张量都参与梯度优化</li></ul><p>利用网络层类对象进行前向计算时，只需要调用类的<code>__call__</code>方法即可，即写成<code>fc(x)</code>方式便可（会自动调用类的<code>__call__</code>方法，在<code>__call__</code>方法中会自动调用call方法，由 TensorFlow 框架自动完成）</p><h3 id="3、神经网络"><a href="#3、神经网络" class="headerlink" title="3、神经网络"></a>3、神经网络</h3><p>通过层层堆叠全连接层，保证前一层的输出节点数与当前层的输入节点数匹配，即可堆叠出任意层数的网络。把这种由神经元相互连接而成的网络叫做神经网络</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505021027758.png" alt="4层神经网络结构"></p><p>通过堆叠 4 个全连接层，可以获得层数为 4 的神经网络，由于每层均为全连接层， 称为<strong>全连接网络</strong>。其中第 1~3 个全连接层在网络中间，称之为<strong>隐藏层</strong>1、 2、3，最后一个全连接层的输出作为网络的输出，称为<strong>输出层</strong></p><p>在设计全连接网络时，网络的结构配置等超参数可以按着经验法则自由设置，只需要<br>遵循少量的约束即可。例如：</p><ul><li>隐藏层 1 的输入节点数需和数据的实际特征长度匹配</li><li>每层的输入层节点数与上一层输出节点数匹配</li><li>输出层的激活函数和节点数需要根据任务的具体设定进行设计。</li></ul><p>总的来说，神经网络模型的结构设计自由度较大，至于与哪一组超参数是最优的，这需要很多的领域经验知识和大量的实验尝试</p><h4 id="1-张量方式实现-1"><a href="#1-张量方式实现-1" class="headerlink" title="1.张量方式实现"></a>1.张量方式实现</h4><p>对于多层神经网络，以上图4层网络结构为例， 需要分别定义各层的权值矩阵𝑾和偏置向量𝒃，且每层的参数只能用于对应的层，不能混淆使用。在计算时，只需要按照网络层的顺序，将上一层的输出作为当前层的输入即可。最后一层是否需要添加激活函数通常视具体的任务而定</p><pre><code class="python"># 隐藏层 1 张量w1 = tf.Variable(tf.random.truncated_normal([784, 256], stddev=0.1))b1 = tf.Variable(tf.zeros([256]))# 隐藏层 2 张量w2 = tf.Variable(tf.random.truncated_normal([256, 128], stddev=0.1))b2 = tf.Variable(tf.zeros([128]))# 隐藏层 3 张量w3 = tf.Variable(tf.random.truncated_normal([128, 64], stddev=0.1))b3 = tf.Variable(tf.zeros([64]))# 输出层张量w4 = tf.Variable(tf.random.truncated_normal([64, 10], stddev=0.1))b4 = tf.Variable(tf.zeros([10]))with tf.GradientTape() as tape: # 梯度记录器    # x: [b, 28*28]    # 隐藏层 1 前向计算， [b, 28*28] =&gt; [b, 256]    h1 = x@w1 + tf.broadcast_to(b1, [x.shape[0], 256])    h1 = tf.nn.relu(h1)    # 隐藏层 2 前向计算， [b, 256] =&gt; [b, 128]    h2 = h1@w2 + b2    h2 = tf.nn.relu(h2)    # 隐藏层 3 前向计算， [b, 128] =&gt; [b, 64]    h3 = h2@w3 + b3    h3 = tf.nn.relu(h3)    # 输出层前向计算， [b, 64] =&gt; [b, 10]    h4 = h3@w4 + b4</code></pre><ul><li>在使用 TensorFlow 自动求导功能计算梯度时，需要将前向计算过程放置在tf.GradientTape()环境中，从而利用 GradientTape 对象的 gradient()方法自动求解参数的梯度，并利用 optimizers 对象更新参数</li></ul><h4 id="2-层方式实现-1"><a href="#2-层方式实现-1" class="headerlink" title="2.层方式实现"></a>2.层方式实现</h4><pre><code class="python"># 导入常用网络层 layersfrom tensorflow.keras import layers,Sequentialfc1 = layers.Dense(256, activation=tf.nn.relu) # 隐藏层 1fc2 = layers.Dense(128, activation=tf.nn.relu) # 隐藏层 2fc3 = layers.Dense(64, activation=tf.nn.relu) # 隐藏层 3fc4 = layers.Dense(10, activation=None) # 输出层# 前向计算x = tf.random.normal([4,28*28])h1 = fc1(x) # 通过隐藏层 1 得到输出h2 = fc2(h1) # 通过隐藏层 2 得到输出h3 = fc3(h2) # 通过隐藏层 3 得到输出h4 = fc4(h3) # 通过输出层得到网络输出</code></pre><p>对于这种数据<strong>依次向前传播</strong>的网络， 也可以通过<code>Sequential</code>容器封装成一个网络大类对象，调用大类的前向计算函数一次即可完成所有层的前向计算</p><pre><code class="python"># 导入 Sequential 容器from tensorflow.keras import layers,Sequential# 通过 Sequential 容器封装为一个网络类model = Sequential([    layers.Dense(256, activation=tf.nn.relu) , # 创建隐藏层 1    layers.Dense(128, activation=tf.nn.relu) , # 创建隐藏层 2    layers.Dense(64, activation=tf.nn.relu) , # 创建隐藏层 3    layers.Dense(10, activation=None) , # 创建输出层])# 前向计算得到输出out = model(x)</code></pre><h4 id="3-优化目标"><a href="#3-优化目标" class="headerlink" title="3.优化目标"></a>3.优化目标</h4><p>我们把神经网络从输入到输出的计算过程叫做<strong>前向传播</strong>(Forward Propagation)或<strong>前向计</strong><br><strong>算</strong>。神经网络的前向传播过程，也是数据张量(Tensor)从第一层流动(Flow)至输出层的过程，即从输入数据开始，途径每个隐藏层，直至得到输出并计算误差，这也是 TensorFlow<br>框架名字由来</p><p>前向传播的最后一步就是完成误差的计算$ℒ=g(𝑓_\theta(x),y)$</p><ul><li>其中$𝑓_\theta(\cdot)$代表了利用𝜃参数化的神经网络模型</li><li>$g(\cdot)$称之为误差函数，用来描述当前网络的预测值$𝑓_\theta(x)$与真实标签𝒚之间的差距度量， 比如常用的均方差误差函数</li><li>ℒ称为网络的误差(Error，或损失 Loss)，一般为标量</li></ul><p>我们希望通过在训练集$\mathbb{D}^{train}$上面学习到一组参数𝜃使得训练的误差ℒ最小：</p><p>$\theta^*=\underbrace{arg\ min}_{\theta}g(𝑓_\theta(x),y),x\in \mathbb{D}^{train}$</p><p>上述的最小化优化问题一般采用误差反向传播(Backward Propagation，简称 BP)算法来求解网络参数𝜃的梯度信息，并利用梯度下降(Gradient Descent，简称 GD)算法迭代更新参数：$\theta’=\theta-\eta\cdot\bigtriangledown_\thetaℒ$，其中𝜂为学习率</p><p>网络的参数量是衡量网络规模的重要指标。计算全连接层的参数量方法：</p><p>考虑权值矩阵𝑾，偏置向量𝒃，输入特征长度为$d_{in}$， 输出特征长度为$d_{out}$的网络层， 𝑾的参数量为$d_{in}\cdot d_{out}$，再加上偏置𝒃的参数， 总参数量为$d_{in}\cdot d_{out}+d_{out}$。对于多层的全连接神经网络，总参数量的计算应累加所有全连接层的总参数量</p><h3 id="4、激活函数"><a href="#4、激活函数" class="headerlink" title="4、激活函数"></a>4、激活函数</h3><p>激活函数都是平滑可导的，适合于梯度下降算法</p><h4 id="1-Sigmoid"><a href="#1-Sigmoid" class="headerlink" title="1.Sigmoid"></a>1.Sigmoid</h4><p>Sigmoid 函数也叫 Logistic 函数，定义为$Sigmoid(x)\doteq\frac{1}{1+e^{-x}}$</p><p>它的一个优良特性就是能够把𝑥∈𝑅的输入“压缩” 到𝑥∈(0,1)区间，这个区间的数值在机器学习常用来表示以下意义：</p><ul><li>概率分布 (0,1)区间的输出和概率的分布范围[0,1]契合，可以通过 Sigmoid 函数将输出转译为<strong>概率输出</strong></li><li>信号强度：一般可以将 0~1 理解为某种信号的强度（如像素的颜色强度， 1 代表当前通道颜色最强， 0 代表当前通道无颜色；抑或代表门控值(Gate)的强度， 1 代表当前门控全部开放， 0 代表门控关闭）</li></ul><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505030303847.png" alt="Sigmoid函数曲线"></p><p>可以通过<code>tf.nn.sigmoid</code>实现 Sigmoid 函数：</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-6.,6.,10) # 构造-6~6 的输入向量&gt;&gt;&gt; tf.nn.sigmoid(x) # 通过 Sigmoid 函数&lt;tf.Tensor: id=7, shape=(10,), dtype=float32, numpy=array([0.00247264, 0.00931597, 0.03444517, 0.11920291, 0.33924365, 0.6607564 , 0.8807971 , 0.96555483, 0.99068403, 0.9975274 ], dtype=float32)&gt;</code></pre><h4 id="2-ReLU"><a href="#2-ReLU" class="headerlink" title="2.ReLU"></a>2.ReLU</h4><p>在 ReLU(REctified Linear Unit， 修正线性单元)激活函数提出之前， Sigmoid 函数通常<br>是神经网络的激活函数首选。</p><p>Sigmoid 函数在输入值较大或较小时容易出现梯度值接近于 0 的现象，称为<strong>梯度弥散</strong>现象。出现梯度弥散现象时， 网络参数长时间得不到更新，导致训练不收敛或停滞不动的现象发生， 较深层次的网络模型中更容易出现梯度弥散现象</p><p>ReLU定义为$ReLU(x)\doteq max(0,x)$，函数曲线如下：</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505030816893.png" alt="ReLU函数曲线"></p><p>可以通过<code>tf.nn.relu</code>实现 ReLU 函数：</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-6.,6.,10) # 构造-6~6 的输入向量&gt;&gt;&gt; tf.nn.relu(x) # 通过 ReLU 激活函数&lt;tf.Tensor: id=11, shape=(10,), dtype=float32, numpy=array([0. , 0. , 0. , 0. , 0. , 0.666667, 2. , 3.333334, 4.666667, 6. ], dtype=float32)&gt;</code></pre><p>除了可以使用函数式接口 tf.nn.relu 实现 ReLU 函数外，还可以像 Dense 层一样将ReLU 函数作为一个网络层添加到网络中，对应的类为 <code>layers.ReLU()</code>类。一般来说，激活<br>函数类并不是主要的网络运算层，不计入网络的层数</p><p>ReLU 函数有着优良的梯度特性，在大量的深度学习应用中被验证非常有效，是应用最广泛的激活函数之一</p><h4 id="3-LeakyReLU"><a href="#3-LeakyReLU" class="headerlink" title="3.LeakyReLU"></a>3.LeakyReLU</h4><p>ReLU 函数在𝑥 &lt; 0时导数值恒为 0，也可能会造成梯度弥散现象，为了克服这个问<br>题， LeakyReLU 函数被提出：$LeakyReLU\doteq \left{\begin{matrix}<br>x &amp; x\geqslant 0\<br>px &amp; x&lt;0<br>\end{matrix}\right.$</p><p>其中𝑝为用户自行设置的某较小数值的超参数，如 0.02 等。当𝑝 = 0时， LeayReLU 函数退化为 ReLU 函数；当𝑝 ≠ 0时， 𝑥 &lt; 0处能够获得较小的导数值𝑝，从而避免出现梯度弥散现象</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505031651370.png" alt="LeakyReLU函数曲线"></p><p>可以通过<code>tf.nn.leaky_relu</code>实现 LeakyReLU 函数：</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-6.,6.,10) # 构造-6~6 的输入向量&gt;&gt;&gt; tf.nn.leaky_relu(x, alpha=0.1) # 通过 LeakyReLU 激活函数&lt;tf.Tensor: id=13, shape=(10,), dtype=float32, numpy=array([-0.6 , -0.46666667, -0.33333334, -0.2 , -0.06666666, 0.666667 , 2. , 3.333334 , 4.666667 , 6. ], dtype=float32)&gt;</code></pre><ul><li>alpha 参数代表𝑝</li></ul><p>tf.nn.leaky_relu 对应的类为 <code>layers.LeakyReLU</code>，可以通过LeakyReLU(alpha)创建LeakyReLU 网络层，并设置𝑝参数，像 Dense 层一样将 LeakyReLU层放置在网络的合适位置</p><h4 id="4-Tanh"><a href="#4-Tanh" class="headerlink" title="4.Tanh"></a>4.Tanh</h4><p>Tanh 函数能够将𝑥 ∈ 𝑅的输入“压缩” 到(-1,1)区间，定义为：$tanh(x)\doteq\frac{e^x-e^{-x}}{e^x+e^{-x}}=2sigmoid(2x)-1$（tanh 激活函数可通过 Sigmoid 函数缩放平移后实现）</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505032201454.png" alt="tanh函数曲线"></p><p>可以通过 tf.nn.tanh 实现 tanh 函数：</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-6.,6.,10) # 构造-6~6 的输入向量&gt;&gt;&gt; tf.nn.tanh(x) # 通过 tanh 激活函数&lt;tf.Tensor: id=15, shape=(10,), dtype=float32, numpy=array([-0.9999877 , -0.99982315, -0.997458 , -0.9640276 , -0.58278286, 0.5827831 , 0.9640276 , 0.997458 , 0.99982315, 0.9999877 ], dtype=float32)&gt;</code></pre><h3 id="5、输出层设计"><a href="#5、输出层设计" class="headerlink" title="5、输出层设计"></a>5、输出层设计</h3><p>常见的几种输出类型包括：</p><ul><li>𝑜𝑖 ∈ $𝑅^𝑑$ 输出属于整个实数空间，或者某段普通的实数空间，比如函数值趋势的预<br>  测，年龄的预测问题等</li><li>𝑜𝑖 ∈ [0,1] 输出值特别地落在[0, 1]的区间， 如图片生成，图片像素值一般用[0, 1]区间<br>  的值表示；或者二分类问题的概率，如硬币正反面的概率预测问题</li><li>𝑜𝑖 ∈ [0,  1],   𝑖 𝑜𝑖 = 1 输出值落在[0, 1]的区间， 并且所有输出值之和为 1， 常见的如<br>  多分类问题，如 MNIST 手写数字图片识别，图片属于 10 个类别的概率之和应为 1</li><li>𝑜𝑖 ∈ [-1,  1] 输出值在[-1, 1]之间</li></ul><h4 id="1-普通实数空间"><a href="#1-普通实数空间" class="headerlink" title="1.普通实数空间"></a>1.普通实数空间</h4><p>该类问题较普遍，输出层可以不加激活函数。</p><p>误差的计算直接基于最后一层的输出𝒐和真实值𝒚进行计算， 如采用均方差误差函数度量输出值𝒐与真实值𝒚之间的距离：ℒ = 𝑔(𝒐, 𝒚)，其中𝑔代表了某个具体的误差计算函数，例如 MSE 等</p><h4 id="2-0-1-区间"><a href="#2-0-1-区间" class="headerlink" title="2.[0,1]区间"></a>2.[0,1]区间</h4><p>为了让像素的值范围映射到[0,1]的有效实数空间，需要在输出层后添加某个合适的激活函数𝜎，其中 Sigmoid 函数刚好具有此功能</p><p>对于二分类问题，如硬币的正反面的预测， 输出层可以<strong>只设置一个节点</strong>，表示某个事件 A 发生的概率𝑃(A|𝒙)， 𝒙为网络输入。假设网络的输出标量𝑜表示正面事件出现的概率，则反面事件出现的概率即为1 - 𝑜，网络结构如下所示</p><ul><li>𝑃(正面|𝒙) = 𝑜</li><li>𝑃(反面|𝒙) = 1 - 𝑜</li></ul><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200505180332392.png" alt="单输出节点的二分类网络"></p><ul><li>输出层的净活性值𝑧后添加 Sigmoid 函数即可将输出转译为概率值</li></ul><h4 id="3-0-1-区间，和为1"><a href="#3-0-1-区间，和为1" class="headerlink" title="3.[0,1]区间，和为1"></a>3.[0,1]区间，和为1</h4><p>输出值𝑜𝑖 ∈ [0,1]， 且所有输出值之和为 1，这种设定以多分类问题最为常见</p><p>可以通过在输出层添加 Softmax 函数实现：$Softmax(z_i)=\frac{e^{Z_i}}{\sum^{d_{out}}_{j=1}e^{Z_j}}$</p><ul><li>Softmax 函数不仅可以将输出值映射到[0,1]区间，还满足所有的输出值之和为 1 的特性</li><li>通过 Softmax函数可以将输出层的输出转译为类别概率，在分类问题中使用的非常频繁</li></ul><p>可以通过 tf.nn.softmax 实现 Softmax 函数：</p><pre><code class="python">&gt;&gt;&gt; z = tf.constant([2.,1.,0.1])&gt;&gt;&gt; tf.nn.softmax(z) # 通过 Softmax 函数&lt;tf.Tensor: id=19, shape=(3,), dtype=float32, numpy=array([0.6590012, 0.242433 , 0.0985659], dtype=float32)&gt;</code></pre><p>与 Dense 层类似， Softmax 函数也可以作为网络层类使用， 通过类<code>layers.Softmax(axis=-1)</code>可以方便添加 Softmax 层，其中 axis 参数指定需要进行计算的维度</p><p>在 Softmax 函数的数值计算过程中，容易因输入值偏大发生<strong>数值溢出</strong>现象；在计算交叉熵时，也会出现数值溢出的问题。为了数值计算的稳定性， TensorFlow 中提供了一个统一的接口，将 Softmax 与交叉熵损失函数同时实现，同时也处理了数值不稳定的异常，一般推荐使用这些接口函数，避免分开使用 Softmax 函数与交叉熵损失函数。函数式接口为<code>tf.keras.losses.categorical_crossentropy(y_true, y_pred, from_logits=False)</code></p><ul><li>y_true：One-hot 编码后的真实标签</li><li>y_pred：网络的预测值<ul><li>当 from_logits 设置为 True 时，y_pred 表示须为未经过 Softmax 函数的变量 z</li><li>当 from_logits 设置为 False 时， y_pred 表示为经过 Softmax 函数的输出</li></ul></li><li>为了数值计算稳定性，一般设置 from_logits 为 True（此时<code>tf.keras.losses.categorical_crossentropy</code>将在内部进行 Softmax 函数计算，所以不需要在模型中显式调用 Softmax 函数）</li></ul><pre><code class="python">&gt;&gt;&gt; z = tf.random.normal([2,10]) # 构造输出层的输出&gt;&gt;&gt; y_onehot = tf.constant([1,3]) # 构造真实值&gt;&gt;&gt; y_onehot = tf.one_hot(y_onehot, depth=10) # one-hot 编码# 输出层未使用 Softmax 函数，故 from_logits 设置为 True# 这样 categorical_crossentropy 函数在计算损失函数前，会先内部调用 Softmax 函数&gt;&gt;&gt; loss = keras.losses.categorical_crossentropy(y_onehot,z,from_logits=True)&gt;&gt;&gt; loss = tf.reduce_mean(loss) # 计算平均交叉熵损失&lt;tf.Tensor: id=210, shape=(), dtype=float32, numpy= 2.4201946&gt;</code></pre><p>除了函数式接口， 也可以利用<code>losses.CategoricalCrossentropy(from_logits)</code>类方式同时实现 Softmax 与交叉熵损失函数的计算， from_logits 参数的设置方式相同</p><pre><code class="python"># 创建 Softmax 与交叉熵计算类，输出层的输出 z 未使用 softmax&gt;&gt;&gt; criteon = keras.losses.CategoricalCrossentropy(from_logits=True)&gt;&gt;&gt; loss = criteon(y_onehot,z) # 计算损失&lt;tf.Tensor: id=258, shape=(), dtype=float32, numpy= 2.4201946&gt;</code></pre><h4 id="4-1-1-区间"><a href="#4-1-1-区间" class="headerlink" title="4.[-1,1]区间"></a>4.[-1,1]区间</h4><p>使用 tanh 激活函数即可：</p><pre><code class="python">&gt;&gt;&gt; x = tf.linspace(-6.,6.,10)&gt;&gt;&gt; tf.tanh(x) # tanh 激活函数&lt;tf.Tensor: id=264, shape=(10,), dtype=float32, numpy=array([-0.9999877 , -0.99982315, -0.997458 , -0.9640276 , -0.58278286, 0.5827831 , 0.9640276 , 0.997458 , 0.99982315, 0.9999877 ], dtype=float32)&gt;</code></pre><h3 id="6、误差计算"><a href="#6、误差计算" class="headerlink" title="6、误差计算"></a>6、误差计算</h3><p>常见的误差函数有均方差、 交叉熵、 KL 散度、 Hinge Loss 函数等，其中均方差函数和交叉熵函数在深度学习中比较常见，均方差函数主要用于回归问题，交叉熵函数主要用于分类问题</p><h4 id="1-均方差误差函数"><a href="#1-均方差误差函数" class="headerlink" title="1.均方差误差函数"></a>1.均方差误差函数</h4><p>均方差(Mean Squared Error，简称 MSE)误差函数：把输出向量和真实向量映射到笛卡尔坐标系的两个点上，通过计算这两个点之间的欧式距离(准确地说是欧式距离的平方)来衡量两个向量之间的差距：$MSE(y,o)=\frac{1}{d_{out}}\sum^{d_{out}}_{i=1}(y_i-o_i)^2$</p><ul><li>MSE 误差函数的值总是大于等于 0</li><li>当 MSE 函数达到最小值 0 时， 输出等于真实标签，此时神经网络的参数达到最优状态</li></ul><p>可以通过函数方式或层方式实现 MSE 误差计算。通过函数式调用：</p><pre><code class="python">&gt;&gt;&gt; o = tf.random.normal([2,10]) # 构造网络输出&gt;&gt;&gt; y_onehot = tf.constant([1,3]) # 构造真实值&gt;&gt;&gt; y_onehot = tf.one_hot(y_onehot, depth=10)&gt;&gt;&gt; loss = keras.losses.MSE(y_onehot, o) # 计算均方差&lt;tf.Tensor: id=27, shape=(2,), dtype=float32, numpy=array([0.779179 ,1.6585705], dtype=float32)&gt;</code></pre><ul><li><p>MSE 函数返回的是每个样本的均方差</p></li><li><p>可以在样本维度上再次平均来获得平均样本的均方差</p><pre><code class="python">  &gt;&gt;&gt; loss = tf.reduce_mean(loss) # 计算 batch 均方差  &lt;tf.Tensor: id=30, shape=(), dtype=float32, numpy=1.2188747&gt;</code></pre></li></ul><p>通过层方式实现，对应的类为<code>keras.losses.MeanSquaredError()</code>，和其他层的类一样，调用<code>__call__</code>函数即可完成前向计算：</p><pre><code class="python"># 创建 MSE 类&gt;&gt;&gt; criteon = keras.losses.MeanSquaredError()&gt;&gt;&gt; loss = criteon(y_onehot,o) # 计算 batch 均方差&lt;tf.Tensor: id=54, shape=(), dtype=float32, numpy=1.2188747&gt;</code></pre><h4 id="2-交叉熵误差函数"><a href="#2-交叉熵误差函数" class="headerlink" title="2.交叉熵误差函数"></a>2.交叉熵误差函数</h4><p>熵，在信息论中，用来衡量信息的不确定度。 熵在信息学科中也叫信息熵，或者香农熵。熵越大，代表不确定性越大，信息量也就越大。 某个分布𝑃(𝑖)的熵定义为：$H(P)=-\sum_iP(i)log_2P(i)$</p><ul><li>对于确定的分布，熵取得最小值0，不确定性为0</li><li>由于𝑃(𝑖) ∈ [0,1], $log_2P(i)$ ≤ 0，因此熵𝐻(𝑃)总是大于等于 0</li><li>在 TensorFlow 中，可以用<code>tf.math.log</code>来计算熵</li></ul><p>交叉熵(Cross Entropy)的定义：$H(p||q)=H(p)+D_{KL}(p||q)$</p><ul><li>其中$D_{KL}(p||q)$为𝑝与𝑞的 KL 散度(Kullback-Leibler Divergence)：$D_{KL}(p||q)=\sum_ip(i)log(\frac{p(i)}{q(i)})$<ul><li>KL 散度是用于衡量 2 个分布之间距离的指标：𝑝 = 𝑞时，$D_{KL}(p||q)$取得最小值 0， 𝑝与𝑞之间的差距越大，$D_{KL}(p||q)$也越大</li><li>交叉熵和 KL 散度都不是对称的：<ul><li>$H(p||q)\neq H(q||p)$</li><li>$D_{KL}(p||q)\neq D_{KL}(q||p)$</li></ul></li></ul></li><li>当分类问题中 y 的编码分布𝑝采用 One-hot 编码𝒚时： 𝐻(𝑝) = 0</li></ul><p>分类问题中交叉熵的计算表达式：$H(p||q)=D_{KL}(p||q)=-logo_i$</p><ul><li>𝑖为 One-hot 编码中为 1 的索引号，也是当前输入的真实类别</li><li>ℒ只与真实类别𝑖上的概率𝑜𝑖有关， 对应概率𝑜𝑖越大， 𝐻(𝑝||𝑞)越小</li><li>当对应类别上的概率为 1 时， 交叉熵𝐻(𝑝||𝑞)取得最小值 0，此时网络输出𝒐与真实标签𝒚完全一致，神经网络取得最优状态</li><li>最小化交叉熵损失函数的过程也是最大化正确类别的预测概率的过程</li></ul><h3 id="7、神经网络类型"><a href="#7、神经网络类型" class="headerlink" title="7、神经网络类型"></a>7、神经网络类型</h3><p>全连接层是神经网络最基本的网络类型，优点是全连接层前向计算流程相对简单，梯度求导也较简单，缺点是在处理较大特征长度的数据时， 全连接层的参数量往往较大</p><h4 id="1-卷积神经网络"><a href="#1-卷积神经网络" class="headerlink" title="1.卷积神经网络"></a>1.卷积神经网络</h4><p>全连接层在处理高维度的图片、 视频数据时往往出现网络参数量巨大，训练非常困难。通过利用局部相关性和权值共享的思想，Yann Lecun在1986年提出了卷积神经网络(Convolutional Neural Network， 简称 CNN)</p><p>其中比较流行的模型：</p><ul><li>用于图片分类的 AlexNet、 VGG、 GoogLeNet、 ResNet、 DenseNet 等</li><li>用于目标识别的 RCNN、 Fast RCNN、 Faster RCNN、 Mask RCNN、 YOLO、 SSD 等</li></ul><h4 id="2-循环神经网络"><a href="#2-循环神经网络" class="headerlink" title="2.循环神经网络"></a>2.循环神经网络</h4><p>除了具有空间结构的图片、 视频等数据外，序列信号也是非常常见的一种数据类型，其中一个最具代表性的序列信号就是文本数据。卷积神经网络由于缺乏 Memory 机制和处理不定长序列信号的能力，并不擅长序列信号的任务。循环神经网络(Recurrent Neural Network，被证明非常擅长处理序列信号</p><p>1997年提出的LSTM网络，作为 RNN 的变种，较好地克服了 RNN 缺乏长期记忆、 不擅长处理长序列的问题，在自然语言处理中得到了广泛的应用。基于LSTM 模型， Google 提出了用于机器翻译的 Seq2Seq 模型，并成功商用于谷歌神经机器翻译系统(GNMT)</p><p>其他的 RNN 变种还有 GRU、 双向 RNN 等</p><h4 id="3-注意力（机制）网络"><a href="#3-注意力（机制）网络" class="headerlink" title="3.注意力（机制）网络"></a>3.注意力（机制）网络</h4><p>RNN 并不是自然语言处理的最终解决方案，近年来随着注意力机制(Attention Mechanism)的提出，克服了 RNN 训练不稳定、 难以并行化等缺陷，在自然语言处理和图片生成等领域中逐渐崭露头角</p><p>2017 年， Google 提出了第一个利用纯注意力机制实现的网络模型Transformer，随后基于 Transformer 模型相继提出了一系列的用于机器翻译的注意力网络模型，如 GPT、 BERT、 GPT-2 等</p><p>在其它领域，基于注意力机制，尤其是自注意力(SelfAttention)机制构建的网络也取得了不错的效果，比如基于自注意力机制的 BigGAN 模型等</p><h4 id="4-图卷积神经网络"><a href="#4-图卷积神经网络" class="headerlink" title="4.图卷积神经网络"></a>4.图卷积神经网络</h4><p>图片、 文本等数据具有规则的空间、时间结构，称为 Euclidean Data(欧几里德数据)。卷积神经网络和循环神经网络被证明非常擅长处理这种类型的数据。而像类似于社交网络、 通信网络、 蛋白质分子结构等一系列的不规则空间拓扑结构的数据， 它们显得力不从心。 2016 年，基于前人在一阶近似的谱卷积算法上提出了图卷积网络(Graph Convolution Network， GCN)模型。 GCN 算法实现简单，从空间一阶邻居信息聚合的角度也能直观地理解，在半监督任务上取得了不错效果。随后，一系列的网络模型相继被提出，如 GAT， EdgeConv， DeepGCN 等</p><h2 id="Keras高层接口"><a href="#Keras高层接口" class="headerlink" title="Keras高层接口"></a>Keras高层接口</h2><p>Keras 与 tf.keras 的区别与联系：</p><ul><li>Keras 可以理解为一套搭建与训练神经网络的高层 API 协议， Keras 本身已经实现了此协议， 安装标准的 Keras 库就可以方便地调用TensorFlow、 CNTK 等后端完成加速计算</li><li>在 TensorFlow 中，也实现了一套 Keras 协议，即 tf.keras，它与 TensorFlow 深度融合，且只能基于 TensorFlow 后端运算， 并对TensorFlow 的支持更完美。 对于使用 TensorFlow 的开发者来说， tf.keras 可以理解为一个普通的子模块，与其他子模块，如 tf.math， tf.data 等并没有什么差别。 下文如无特别说明，Keras <strong>均指代 tf.keras</strong>，而不是标准的 Keras 库</li></ul><h3 id="1、常见功能模块"><a href="#1、常见功能模块" class="headerlink" title="1、常见功能模块"></a>1、常见功能模块</h3><p>Keras 提供了一系列高层的神经网络相关类和函数，如经典数据集加载函数（进阶操作–&gt;经典数据集加载 章节中讲到过）、 网络层类、 模型容器、 损失函数类、 优化器类、 经典模型类等</p><h4 id="1-常见网络层类"><a href="#1-常见网络层类" class="headerlink" title="1.常见网络层类"></a>1.常见网络层类</h4><p>对于常见的神经网络层，可以使用张量方式的底层接口函数来实现，这些接口函数一般在<code>tf.nn</code>模块中。</p><p>对于常见的<strong>网络层</strong>，我们一般直接使用层方式来完成模型的搭建，在<code>tf.keras.layers</code>命名空间(下文使用 <code>layers</code> 指代 <code>tf.keras.layers</code>)中提供了大量常见网络层的类，如全连接层、 激活函数层、 池化层、 卷积层、 循环神经网络层等。对于这些网络层类，只需要在创建时指定网络层的相关参数， 并调用<code>__call__</code>方法即可完成前向计算。在调用<code>__call__</code>方法时， Keras 会自动调用每个层的前向传播逻辑，这些逻辑一般实现在类的call 函数中。</p><p>以 Softmax 层为例， 它既可以使用<code>tf.nn.softmax</code>函数在前向传播逻辑中完成Softmax运算， 也可以通过<code>layers.Softmax(axis)</code>类搭建Softmax网络层，其中<code>axis</code>参数指定进行softmax 运算的维度：</p><pre><code class="python">&gt;&gt;&gt; import tensorflow as tf# 导入 keras 模型，不能使用 import keras，它导入的是标准的 Keras 库&gt;&gt;&gt; from tensorflow import keras&gt;&gt;&gt; from tensorflow.keras import layers # 导入常见网络层类# 创建 Softmax 层，并调用__call__方法完成前向计算&gt;&gt;&gt; x = tf.constant([2.,1.,0.1]) # 创建输入张量&gt;&gt;&gt; layer = layers.Softmax(axis=-1) # 创建 Softmax 层&gt;&gt;&gt; out = layer(x) # 调用 softmax 前向计算，输出为 out# 经过 Softmax 网络层后， 得到概率分布 out 为：&lt;tf.Tensor: id=2, shape=(3,), dtype=float32, numpy=array([0.6590012, 0.242433 , 0.0985659], dtype=float32)&gt;# 当然，也可以直接通过 tf.nn.softmax()函数完成计算，代码如下：&gt;&gt;&gt; out = tf.nn.softmax(x) # 调用 softmax 函数完成前向计算</code></pre><h4 id="2-网络容器"><a href="#2-网络容器" class="headerlink" title="2.网络容器"></a>2.网络容器</h4><p>当网络层数变得较深时，手动调用每一层的类实例完成前向传播运算这部分代码显得非常臃肿。可以通过 Keras 提供的网络容器 <code>Sequential</code> 将多个网络层封装成一个大网络模型，只需要调用网络模型的实例一次即可完成数据从第一层到最末层的顺序传播运算  </p><pre><code class="python"># 导入 Sequential 容器from tensorflow.keras import layers, Sequentialnetwork = Sequential([ # 封装为一个网络    layers.Dense(3, activation=None), # 全连接层，此处不使用激活函数    layers.ReLU(),#激活函数层    layers.Dense(2, activation=None), # 全连接层，此处不使用激活函数    layers.ReLU() #激活函数层])x = tf.random.normal([4,3])out = network(x) # 输入从第一层开始， 逐层传播至输出层，并返回输出层的输出</code></pre><p>Sequential 容器也可以通过<code>add()</code>方法继续追加新的网络层， 实现动态创建网络的功能：</p><pre><code class="python">layers_num = 2 # 堆叠 2 次network = Sequential([]) # 先创建空的网络容器for _ in range(layers_num):    network.add(layers.Dense(3)) # 添加全连接层    network.add(layers.ReLU())# 添加激活函数层network.build(input_shape=(4, 4)) # 创建网络参数network.summary()</code></pre><ul><li><p>在完成网络创建时， 网络层类并没有创建内部权值张量等成员变量，此时通过调用类的<code>build</code>方法并指定输入大小，即可自动创建所有层的内部张量</p></li><li><p>通过Sequential容量封装多个网络层时，每层的参数列表将会自动并入Sequential容器的参数列表中，不需要人为合并网络参数列表</p></li><li><p>Sequential 对象的<code>trainable_variables</code>和<code>variables</code>包含了所有层的待优化张量列表和全部张量列表</p><pre><code class="python">  # 打印网络的待优化参数名与 shape  &gt;&gt;&gt; for p in network.trainable_variables:  ...     print(p.name, p.shape) # 参数名和形状  ...  dense/kernel:0 (4, 3)  dense/bias:0 (3,)  dense_1/kernel:0 (3, 3)  dense_1/bias:0 (3,)</code></pre></li><li><p>通过<code>summary()</code>函数可以方便打印出网络结构和参数量，输出：</p><pre><code class="python">  Model: &quot;sequential&quot;  _________________________________________________________________  Layer (type)                 Output Shape              Param #  =================================================================  dense (Dense)                multiple                  15  _________________________________________________________________  re_lu (ReLU)                 multiple                  0  _________________________________________________________________  dense_1 (Dense)              multiple                  12  _________________________________________________________________  re_lu_1 (ReLU)               multiple                  0  =================================================================  Total params: 27  Trainable params: 27  Non-trainable params: 0  _________________________________________________________________</code></pre><ul><li><code>Layer</code>：每层的名字，由 TensorFlow 内部维护，与 Python 的对象名并不一样</li><li><code>Param#</code>：层的参数个数</li><li><code>Total params</code>：统计出了总的参数量</li><li><code>Trainable params</code>：总的待优化参数量</li><li><code>Non-trainable params</code>：总的不需要优化的参数量</li></ul></li></ul><h3 id="2、模型装配、训练与测试"><a href="#2、模型装配、训练与测试" class="headerlink" title="2、模型装配、训练与测试"></a>2、模型装配、训练与测试</h3><p>在训练网络时，一般的流程是通过前向计算获得网络的输出值， 再通过损失函数计算网络误差，然后通过自动求导工具计算梯度并更新，同时间隔性地测试网络的性能。对于这种常用的训练逻辑，可以直接通过 Keras 提供的模型装配与训练等高层接口实现</p><h4 id="1-模型装配"><a href="#1-模型装配" class="headerlink" title="1.模型装配"></a>1.模型装配</h4><p>在 Keras 中，有 2 个比较特殊的类：</p><ul><li>keras.Model类：<strong>网络的母类</strong>，除了具有Layer类的功能，还添加了保存模型、加载模型、 训练与测试模型等便捷功能。<u>Sequential也是Model的子类</u>（具有Model类的所有功能）</li><li>keras.layers.Layer类：<strong>网络层的母类</strong>，定义了网络层的一些常见功能，如添加权值、 管理权值列表等</li></ul><p>下面介绍 Model 及其子类的模型装配与训练功能</p><p>创建网络：</p><pre><code class="python"># 创建 5 层的全连接网络network = Sequential([layers.Dense(256, activation=&#39;relu&#39;),                      layers.Dense(128, activation=&#39;relu&#39;),                      layers.Dense(64, activation=&#39;relu&#39;),                      layers.Dense(32, activation=&#39;relu&#39;),                      layers.Dense(10)])network.build(input_shape=(4, 28*28))network.summary()</code></pre><p>通过<code>compile</code>函数指定网络使用的优化器对象、 损失函数类型， 评价指标等设定，这一步称为<strong>装配</strong></p><pre><code class="python"># 导入优化器，损失函数模块from tensorflow.keras import optimizers,losses# 模型装配# 采用 Adam 优化器，学习率为 0.01;采用交叉熵损失函数，包含 Softmaxnetwork.compile(optimizer=optimizers.Adam(lr=0.01),                loss=losses.CategoricalCrossentropy(from_logits=True),                metrics=[&#39;accuracy&#39;] # 设置测量指标为准确率               )</code></pre><h4 id="2-模型训练"><a href="#2-模型训练" class="headerlink" title="2.模型训练"></a>2.模型训练</h4><p>模型装配完成后，可通过<code>fit()</code>函数送入待训练的数据集和验证用的数据集，实现网络的训练与验证，这一步称为<strong>模型训练</strong></p><pre><code class="python"># 指定训练集为 train_db，验证集为 val_db,训练 5 个 epochs，每 2 个 epoch 验证一次# 返回训练轨迹信息保存在 history 对象中history = network.fit(train_db, epochs=5, validation_data=val_db,                      validation_freq=2)</code></pre><ul><li><p>train_db：tf.data.Dataset对象，也可以传入Numpy Array类型的数据</p></li><li><p>epochs：指定训练迭代的Epoch数量</p></li><li><p>validation_data：指定用于验证(测试)的数据集</p></li><li><p>validation_freq：验证的频率</p></li><li><p>history：训练过程的数据记录，其中<code>history.history</code>为字典对象，包含了训练过程中的loss、测量指标等记录项</p><pre><code class="python">  &gt;&gt;&gt; history.history # 打印训练记录  # 历史训练准确率  {&#39;accuracy&#39;: [0.00011666667, 0.0, 0.0, 0.010666667, 0.02495],   &#39;loss&#39;: [2465719710540.5845, # 历史训练误差            78167808898516.03,            404488834518159.6,            1049151145155144.4,            1969370184858451.0],   &#39;val_accuracy&#39;: [0.0, 0.0], # 历史验证准确率   # 历史验证误差   &#39;val_loss&#39;: [197178788071657.3, 1506234836955706.2]}</code></pre></li></ul><p><code>fit()</code>函数的运行代表了网络的训练过程，会消耗相当的训练时间，并在训练结束后才返回</p><h4 id="3-模型测试"><a href="#3-模型测试" class="headerlink" title="3.模型测试"></a>3.模型测试</h4><p>关于验证和测试的区别，会在过拟合一章详细阐述，此处可以将验证和测试理解为模型评估的一种方式</p><p>通过<code>Model.predict(x)</code>方法即可完成模型的<strong>预测</strong>：</p><pre><code class="python"># 加载一个 batch 的测试数据x,y = next(iter(db_test))print(&#39;predict x:&#39;, x.shape) # 打印当前 batch 的形状out = network.predict(x) # 模型预测，预测结果保存在 out 中print(out)</code></pre><p>如果只是简单的测试模型的<strong>性能</strong>，可以通过<code>Model.evaluate(db)</code>循环测试完db数据集上所有样本，并打印出性能指标：</p><pre><code class="python">network.evaluate(db_test) # 模型测试，测试在 db_test 上的性能表现</code></pre><h3 id="3、模型保存与加载"><a href="#3、模型保存与加载" class="headerlink" title="3、模型保存与加载"></a>3、模型保存与加载</h3><h4 id="1-张量方式"><a href="#1-张量方式" class="headerlink" title="1.张量方式"></a>1.张量方式</h4><p>网络的状态主要体现在网络的结构以及网络层内部张量数据上，因此在<u>拥有网络结构源文件</u>的条件下，直接保存网络张量参数到文件系统上是最轻量级的一种方式</p><p>通过调用<code>Model.save_weights(path)</code>方法，可将当前的网络参数保存到path文件上</p><pre><code class="python">network.save_weights(&#39;weights.ckpt&#39;) # 保存模型的所有张量数据</code></pre><p>在需要的时候，先创建好网络对象，然后调用网络对象的<code>load_weights(path)</code>方法即可将指定的模型文件中保存的张量数值写入到当前网络参数中</p><pre><code class="python"># 重新创建相同的网络结构new_network = Sequential([layers.Dense(256, activation=&#39;relu&#39;),                          layers.Dense(128, activation=&#39;relu&#39;),                          layers.Dense(64, activation=&#39;relu&#39;),                          layers.Dense(32, activation=&#39;relu&#39;),                          layers.Dense(10)])new_network.compile(optimizer=optimizers.Adam(lr=0.01),                    loss=tf.losses.CategoricalCrossentropy(from_logits=True),                    metrics=[&#39;accuracy&#39;]                   )# 从参数文件中读取数据并写入当前网络new_network.load_weights(&#39;weights.ckpt&#39;)print(&#39;loaded weights!&#39;)</code></pre><h4 id="2-网络方式"><a href="#2-网络方式" class="headerlink" title="2.网络方式"></a>2.网络方式</h4><p>通过<code>Model.save(path)</code>函数可以将模型的<strong>结构</strong>以及模型的<strong>参数</strong>保存到path文件上，在<u>不需要网络源文件</u>的条件下，通过<code>keras.models.load_model(path)</code>即可恢复网络结构和网络参数</p><pre><code class="python"># 保存模型结构与模型参数到文件network.save(&#39;model.h5&#39;)print(&#39;saved total model.&#39;)del network # 删除网络对象# 从文件恢复网络结构与网络参数network = keras.models.load_model(&#39;model.h5&#39;)</code></pre><h4 id="3-SavedModel方式"><a href="#3-SavedModel方式" class="headerlink" title="3.SavedModel方式"></a>3.SavedModel方式</h4><p>当需要将模型部署到其他平台时，采用SavedModel方式更具有平台无关性。</p><p>通过<code>tf.saved_model.save(network, path)</code>即可将模型以SavedModel方式保存到path<strong>目录</strong>中</p><pre><code class="python"># 保存模型结构与模型参数到文件tf.saved_model.save(network, &#39;model-savedmodel&#39;)print(&#39;saving savedmodel.&#39;)del network # 删除网络对象</code></pre><p>通过<code>tf.saved_model.load</code>函数即可恢复出模型对象，我们在恢复出模型实例后，完成测试准确率的计算</p><pre><code class="python"># 从文件恢复网络结构与网络参数network = tf.saved_model.load(&#39;model-savedmodel&#39;)# 准确率计量器acc_meter = metrics.CategoricalAccuracy()for x,y in ds_val: # 遍历测试集    pred = network(x) # 前向计算    acc_meter.update_state(y_true=y, y_pred=pred) # 更新准确率统计# 打印准确率print(&quot;Test Accuracy:%f&quot; % acc_meter.result())</code></pre><h3 id="4、自定义网络"><a href="#4、自定义网络" class="headerlink" title="4、自定义网络"></a>4、自定义网络</h3><p>对于需要创建自定义逻辑的网络层，可以通过<strong>自定义类</strong>来实现</p><ul><li>在创建自定义<strong>网络层类</strong>时，需要继承自 layers.Layer 基类</li><li>创建自定义的<strong>网络类</strong>时，需要继承自 keras.Model 基类</li></ul><h4 id="1-自定义网络层"><a href="#1-自定义网络层" class="headerlink" title="1.自定义网络层"></a>1.自定义网络层</h4><p>对于自定义的网络层， 需要实现初始化<code>__init__</code>方法和前向传播逻辑<code>call</code>方法</p><p>以某个具体的自定义网络层为例，假设需要一个没有偏置向量的全连接层，同时固定激活函数为 ReLU 函数：</p><ol><li><p>首先创建类，并继承自 Layer 基类。创建初始化方法，并调用母类的初始化函数。由于是全连接层， 因此需要设置两个参数：输入特征的长度inp_dim和输出特征的长度outp_dim，并通过<code>self.add_variable(name, shape)</code>创建 shape 大小，名字为 name 的张量𝑾，并设置为需要优化</p><pre><code class="python"> class MyDense(layers.Layer):     # 自定义网络层     def __init__(self, inp_dim, outp_dim):         super(MyDense, self).__init__() # 调用母类的初始化函数         # 创建权值张量并添加到类管理列表中，设置为需要优化         self.kernel = self.add_variable(&#39;w&#39;, [inp_dim, outp_dim],                                         trainable=True)         # 此外，通过 tf.Variable 创建的类成员也会自动加入类参数列表         # self.kernel = tf.Variable(tf.random.normal([inp_dim, outp_dim]),         #                           trainable=False)</code></pre><ul><li>self.add_variable会返回张量𝑾的 Python 引用</li><li>变量名 name 由TensorFlow 内部维护， 使用的比较少</li><li>trainable：创建的张量是否需要优化</li></ul></li><li><p>设计自定义类的前向运算逻辑。对于本例，只需要完成𝑶 = 𝑿@𝑾矩阵运算，并通过固定的ReLU激活函数即可</p><pre><code class="python"> def call(self, inputs, training=None):     # 实现自定义类的前向计算逻辑     # X@W     out = inputs @ self.kernel     # 执行激活函数运算     out = tf.nn.relu(out)     return out</code></pre><ul><li>inputs：输入， 由用户在调用时传入</li><li>training：用于指定模型的状态：<ul><li>True：执行训练模式</li><li>False：执行测试模式，默认参数为 None，即测试模式</li></ul></li><li>由于全连接层的训练模式和测试模式逻辑一致，此处不需要额外处理。对于部份测试模式和训练模式不一致的网络层，需要根据 training 参数来设计需要执行的逻辑</li></ul></li></ol><p>此时可以实例化 MyDense 类，并查看其参数列表：</p><pre><code class="python">net = MyDense(4,3) # 创建输入为 4，输出为 3 节点的自定义层net.variables,net.trainable_variables # 查看自定义层的参数列表</code></pre><h4 id="2-自定义网络"><a href="#2-自定义网络" class="headerlink" title="2.自定义网络"></a>2.自定义网络</h4><p>自定义网络类可以和其他标准类一样，通过 Sequential 容器方便地封装成一个网络模型：</p><pre><code class="python">network = Sequential([MyDense(784, 256), # 使用自定义的层                      MyDense(256, 128),                      MyDense(128, 64),                      MyDense(64, 32),                      MyDense(32, 10)])network.build(input_shape=(None, 28*28))network.summary()</code></pre><p>通过堆叠自定义网络层类，可以实现 5 层的全连接层网络，每层全连接层无偏置张量，同时激活函数固定地使用 ReLU 函数</p><hr><p>Sequential 容器适合于数据按序从第一层传播到第二层，再从第二层传播到第三层，以此规律传播的网络模型。对于复杂的网络结构，例如第三层的输入不仅是第二层的输出，还有第一层的输出，此时使用自定义网络更加灵活：</p><ol><li><p>创建自定义网络类，首先创建类， 并继承自 Model 基类，分别创建对应的网络层对象：</p><pre><code class="python"> class MyModel(keras.Model):     # 自定义网络类，继承自 Model 基类     def __init__(self):         super(MyModel, self).__init__() # 调用母类的初始化函数         # 完成网络内需要的网络层的创建工作         self.fc1 = MyDense(28*28, 256)         self.fc2 = MyDense(256, 128)         self.fc3 = MyDense(128, 64)         self.fc4 = MyDense(64, 32)         self.fc5 = MyDense(32, 10)</code></pre></li><li><p>实现自定义网络的前向运算逻辑：</p><pre><code class="python"> def call(self, inputs, training=None):     # 自定义前向运算逻辑     x = self.fc1(inputs)     x = self.fc2(x)     x = self.fc3(x)     x = self.fc4(x)     x = self.fc5(x)     return x</code></pre></li></ol><h3 id="5、模型乐园"><a href="#5、模型乐园" class="headerlink" title="5、模型乐园"></a>5、模型乐园</h3><p>对于常用的网络模型，如 ResNet、 VGG 等，不需要手动创建网络，可以直接从<code>keras.applications</code>子模块中通过一行代码即可创建并使用这些经典模型，同时还可以通过设置 weights 参数加载预训练的网络参数</p><h4 id="1-加载模型"><a href="#1-加载模型" class="headerlink" title="1.加载模型"></a>1.加载模型</h4><p>暂无，等待施工</p><h3 id="6、测量工具"><a href="#6、测量工具" class="headerlink" title="6、测量工具"></a>6、测量工具</h3><p>Keras 提供了一些常用的测量工具，位于<code>keras.metrics</code>模块中，专门用于统计训练过程中常用的指标数据。Keras 的测量工具的使用方法一般有 4 个主要步骤：</p><ul><li>新建测量器</li><li>写入数据</li><li>读取统计数据</li><li>清零测量器</li></ul><h4 id="1-新建测量器"><a href="#1-新建测量器" class="headerlink" title="1.新建测量器"></a>1.新建测量器</h4><p>在<code>keras.metrics</code>模块中，提供了较多的常用测量器类， 如统计平均值的 <code>Mean</code> 类，统计准确率的 <code>Accuracy</code> 类，统计余弦相似度的 <code>CosineSimilarity</code> 类等</p><p>例子：统计误差值</p><p>在前向运算时，会得到每一个 Batch 的平均误差，但是希望统计每个Step的平均误差，因此选择使用Mean测量器：</p><pre><code class="python"># 新建平均测量器，适合 Loss 数据loss_meter = metrics.Mean()</code></pre><h4 id="2-写入数据"><a href="#2-写入数据" class="headerlink" title="2.写入数据"></a>2.写入数据</h4><p>通过测量器的<code>update_state</code>函数可以写入新的数据，测量器会根据自身逻辑记录并处理采样数据。例如，在每个 Step 结束时采集一次 loss 值，代码如下：</p><pre><code class="python"># 记录采样的数据，通过 float()函数将张量转换为普通数值loss_meter.update_state(float(loss))</code></pre><ul><li>放置在每个 Batch 运算结束后即可， 测量器会自动根据采样的数据来统计平均值</li></ul><h4 id="3-读取统计信息"><a href="#3-读取统计信息" class="headerlink" title="3.读取统计信息"></a>3.读取统计信息</h4><p>在采样多次数据后，可以选择在需要的地方调用测量器的<code>result()</code>函数，来获取统计值</p><pre><code class="python"># 打印统计期间的平均 lossprint(step, &#39;loss:&#39;, loss_meter.result())</code></pre><h4 id="4-清除状态"><a href="#4-清除状态" class="headerlink" title="4.清除状态"></a>4.清除状态</h4><p>测量器会统计<strong>所有历史记录</strong>的数据，因此在启动新一轮统计时，有必要清除历史状态。通过<code>reset_states()</code>即可实现清除状态功能</p><p>例如，在每次读取完平均误差后， 清零统计信息，以便下一轮统计的开始</p><pre><code class="python">if step % 100 == 0:    # 打印统计的平均 loss    print(step, &#39;loss:&#39;, loss_meter.result())    loss_meter.reset_states() # 打印完后， 清零测量器</code></pre><h4 id="5-准确率统计实战"><a href="#5-准确率统计实战" class="headerlink" title="5.准确率统计实战"></a>5.准确率统计实战</h4><p>新建准确率测量器</p><pre><code class="python">acc_meter = metrics.Accuracy() # 创建准确率测量器</code></pre><p>Accuracy 类的 update_state函数的参数为预测值和真实值，而不是当前 Batch 的准确率</p><pre><code class="python"># [b, 784] =&gt; [b, 10]，网络输出值out = network(x)# [b, 10] =&gt; [b]，经过 argmax 后计算预测值pred = tf.argmax(out, axis=1)pred = tf.cast(pred, dtype=tf.int32)# 根据预测值与真实值写入测量器acc_meter.update_state(y, pred)</code></pre><p>在统计完测试集所有 Batch 的预测值后， 打印统计的平均准确率， 并清零测量器</p><pre><code class="python"># 读取统计结果print(step, &#39;Evaluate Acc:&#39;, acc_meter.result().numpy())acc_meter.reset_states() # 清零测量器</code></pre><h3 id="7、可视化"><a href="#7、可视化" class="headerlink" title="7、可视化"></a>7、可视化</h3><p>TensorFlow 提供了一个可视化工具<code>TensorBoard</code>。原理是通过将监控数据写入到文件系统， 并利用Web后端监控对应的文件目录， 从而可以允许用户从远程查看网络的监控数据。</p><p>TensorBoard 的使用需要模型代码和浏览器相互配合。在使用 TensorBoard 之前，需要安装 TensorBoard 库：</p><pre><code class="python"># 安装 TensorBoardpip install tensorboard</code></pre><h4 id="1-模型端"><a href="#1-模型端" class="headerlink" title="1.模型端"></a>1.模型端</h4><p>创建写入监控数据的<code>Summary</code>类， 并在需要的时候写入监控数据即可。</p><p>首先通过<code>tf.summary.create_file_writer</code>创建监控对象类实例，并指定监控数据的写入<u>目录</u></p><pre><code class="python"># 创建监控类，监控数据将写入 log_dir 目录summary_writer = tf.summary.create_file_writer(log_dir)</code></pre><hr><p>例子：监控误差数据和可视化数据</p><p>在前向计算完成后，对于误差这种<strong>标量</strong>数据， 我们通过<code>tf.summary.scalar</code>函数记录监控数据，并指定时间戳 step 参数</p><pre><code class="python">with summary_writer.as_default(): # 写入环境    # 当前时间戳 step 上的数据为 loss，写入到名为 train-loss 数据库中    tf.summary.scalar(&#39;train-loss&#39;, float(loss), step=step)</code></pre><ul><li>step：类似于每个数据对应的时间刻度信息（可以理解为数据曲线的x坐标），不宜重复。</li><li>每类数据通过字符串名字来区分，同类的数据需要写入相同名字的数据库中</li></ul><p>对于<strong>图片</strong>类型的数据， 可以通过<code>tf.summary.image</code>函数监控多个图片的张量数据，并通过设置max_outputs参数来选择最多显示的图片数量</p><pre><code class="python">with summary_writer.as_default():# 写入环境    # 写入测试准确率    tf.summary.scalar(&#39;test-acc&#39;, float(total_correct/total), step=step)    # 可视化测试用的图片，设置最多可视化 9 张图片    tf.summary.image(&quot;val-onebyone-images:&quot;, val_images, max_outputs=9, step=step)</code></pre><h4 id="2-浏览器端"><a href="#2-浏览器端" class="headerlink" title="2.浏览器端"></a>2.浏览器端</h4><p>打开 Web 后端：通过在 cmd 终端运行<code>tensorboard --logdir path</code>指定 Web 后端监控的文件目录 path， 即可打开 Web 后端监控进程</p><p>之后打开浏览器，输入网址<code>http://localhost:6006</code>(也可通过 IP 地址远程访问， 具体端口号可能会变动，可查看命令提示) 即可监控网络训练进度</p><p>除了监控标量数据和图片数据外， TensorBoard 还支持通过<code>tf.summary.histogram</code>查看张量数据的直方图分布，以及通过<code>tf.summary.text</code>打印文本信息等功能</p><pre><code class="python">with summary_writer.as_default():    # 当前时间戳 step 上的数据为 loss，写入到 ID 位 train-loss 对象中    tf.summary.scalar(&#39;train-loss&#39;, float(loss), step=step)    # 可视化真实标签的直方图分布    tf.summary.histogram(&#39;y-hist&#39;,y, step=step)    # 查看文本信息    tf.summary.text(&#39;loss-text&#39;,str(float(loss)))</code></pre><p>实际上，除了 TensorBoard 外，Visdom 工具同样可以方便可视化数据。Visdom 可以直接接受PyTorch 的张量类型的数据，但不能直接接受 TensorFlow 的张量类型数据，需要转换为Numpy 数组</p><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p>机器学习的主要目的是从训练集上学习到数据的真实模型， 从而能够在未见过的测试集上也能够表现良好，我们把这种能力叫做<strong>泛化能力</strong></p><h3 id="1、模型的容量"><a href="#1、模型的容量" class="headerlink" title="1、模型的容量"></a>1、模型的容量</h3><p>通俗地讲，模型的容量或表达能力，是指模型拟合复杂函数的能力。一种体现模型容量的指标为模型的假设空间(Hypothesis Space)大小，即模型可以表示的函数集的大小。</p><p>假设空间越大越完备， 从假设空间中搜索出逼近真实模型的函数也就越有可能； 反之，如果假设空间非常受限，就很难从中找到逼近真实模型的函数</p><p>实际上，较大的假设空间并不一定能搜索出更好的函数模型。 由于观测误差的存在，较大的假设空间中可能包含了大量表达能力过强的函数， 能够将训练样本的观测误差也学习进来，从而伤害了模型的泛化能力。挑选合适容量的学习模型是一个很大的难题</p><h3 id="2、过拟合与欠拟合"><a href="#2、过拟合与欠拟合" class="headerlink" title="2、过拟合与欠拟合"></a>2、过拟合与欠拟合</h3><ul><li>过拟合(Overfitting)：当模型的容量过大时，网络模型除了学习到训练集数据的模态之外，还把额外的观测误差也学习进来，导致学习的模型在训练集上面表现较好，但是在未见的样本上表现不佳，也就是模型泛化能力偏弱</li><li>欠拟合(Underfitting)：当模型的容量过小时，模型不能够很好地学习到训练集数据的模态，导致训练集上表现不佳，同时在未见的样本上表现也不佳</li></ul><p>那么如何去选择模型的容量？</p><ul><li><p>统计学习理论中的 VC 维度(Vapnik-Chervonenkis 维度)是一个应用比较广泛的度量函数容量的方法。但是该方法却很少应用到深度学习中去，一部分原因是神经网络过于复杂，很难去确定网络结构背后的数学模型的 VC 维度</p></li><li><p>可以根据奥卡姆剃刀原理(Occam’s razor)来指导神经网络的设计和训练。即“切勿浪费较多东西，去做‘用较少的东西，同样可以做好的事情’。”。也就是说，如果两层的神经网络结构能够很好的表达真实模型，那么三层的神经网络也能够很好的表达，但是我们应该优先选择使用更简单的两层神经网络，因为它的参数量更少，更容易训练，也更容易通过较少的训练样本获得不错的泛化误差</p></li></ul><h4 id="1-欠拟合"><a href="#1-欠拟合" class="headerlink" title="1.欠拟合"></a>1.欠拟合</h4><p>当我们发现当前的模型在训练集上误差一直维持较高的状态，很难优化减少，同时在测试集上也表现不佳时，我们可以考虑是否出现了欠拟合的现象</p><p>可以通过增加神经网络的层数、增大中间维度的大小等手段， 比较好的解决欠拟合的问题。 </p><p>在实际使用过程中，更多的是出现过拟合现象</p><h4 id="2-过拟合"><a href="#2-过拟合" class="headerlink" title="2.过拟合"></a>2.过拟合</h4><p>现代深度神经网络中过拟合现象非常容易出现，主要是因为神经网络的表达能力非常强， 训练集样本数不够</p><h3 id="3、数据集划分"><a href="#3、数据集划分" class="headerlink" title="3、数据集划分"></a>3、数据集划分</h3><p>前面我们介绍了数据集需要划分为训练集(Train set)和测试集(Test set)，但是为了挑选模型超参数和检测过拟合现象，一般需要将原来的训练集再次切分为新的训练集和验证集(Validation set)，即数据集需要切分为训练集、验证集和测试集 3 个子集</p><h4 id="1-验证集与超参数"><a href="#1-验证集与超参数" class="headerlink" title="1.验证集与超参数"></a>1.验证集与超参数</h4><p>验证集：选择模型的超参数(模型选择， Model selection)，功能包括：</p><ul><li>根据验证集的性能表现来调整学习率、 权值衰减系数、 训练次数等</li><li>根据验证集的性能表现来重新调整网络拓扑结构</li><li>根据验证集的性能表现判断是否过拟合和欠拟合</li></ul><p>训练集、验证集和测试集可以按着自定义的比例来划分，比如常见的 60%-20%-20%的划分</p><p>验证集与测试集的区别：</p><ul><li>算法设计人员可以根据<strong>验证集</strong>的表现来调整模型的各种超参数的设置，提升模型的<strong>泛化能力</strong>（测试泛化性能）</li><li>测试集的表现不能用来反馈模型的调整，否则测试集将和验证集的功能重合， 因此在测试集上的性能表现将<strong>无法</strong>代表模型的泛化能力</li></ul><h4 id="2-提前停止"><a href="#2-提前停止" class="headerlink" title="2.提前停止"></a>2.提前停止</h4><p>一般把对训练集中的一个<strong>Batch</strong>运算更新一次叫做一个<strong>Step</strong>， 对训练集的所有样本循环迭代一次叫做一个<strong>Epoch</strong>。验证集可以在数次 Step 或数次 Epoch 后使用，计算模型的验证性能（一般建议几个 Epoch 后进行一次验证运算）</p><ul><li>训练时，一般关注的指标有训练误差、 训练准确率等</li><li>验证时，也有验证误差和验证准确率等</li><li>测试时，也有测试误差和测试准确率等</li></ul><p>通过观测<u>训练准确率</u>和<u>验证准确率</u>可以大致推断模型是否出现过拟合和欠拟合</p><ul><li>过拟合：如果模型的训练误差较低，训练准确率较高，但是验证误差较高，验证准确率较低    <ul><li>解决方法：可以从新设计网络模型的容量，如降低网络的层数、降低网络的参数量、 添加正则化手段、 添加假设空间的约束等，使得模型的实际容量降低</li></ul></li><li>欠拟合：如果训练集和验证集上面的误差都较高，准确率较低<ul><li>解决方法：尝试增大网络的容量，如加深网络的层数、 增加网络的参数量，尝试更复杂的网络结构</li></ul></li></ul><p>实际上， 由于网络的实际容量可以随着训练的进行发生改变，因此在相同的网络设定下，随着训练的进行， 可能观测到不同的过拟合、 欠拟合状况</p><ul><li>在训练的前期，随着训练的进行，模型的训练准确率和测试准确率都呈现增大的趋势，此时并没有出现过拟合现象</li><li>在训练后期，即使是相同网络结构下， 由于模型的实际容量发生改变，我们观察到了过拟合的现象，具体表现为<u>训练准确度继续改善</u>，但是泛化能力变弱(<u>测试准确率减低</u>)</li></ul><p>记录模型的验证准确率，并监控验证准确率的变化， 当发现验证准确率连续𝑛个 Epoch 没有下降时，可以预测可能已经达到了最适合的 Epoch 附近，从而<strong>提前终止</strong>训练</p><h3 id="4、模型设计"><a href="#4、模型设计" class="headerlink" title="4、模型设计"></a>4、模型设计</h3><p>对于神经网络来说，网络的层数和参数量是网络容量很重要的参考指标</p><ul><li>减少网络的层数， 减少每层中网络参数量的规模， 可以有效降低网络的容量</li><li>如果发现模型欠拟合，需要增大网络的容量，可以通过增加层数，增大每层的参数量等方式实现</li></ul><h3 id="5、正则化"><a href="#5、正则化" class="headerlink" title="5、正则化"></a>5、正则化</h3><p>待补充</p><h3 id="6、Dropout"><a href="#6、Dropout" class="headerlink" title="6、Dropout"></a>6、Dropout</h3><p>Dropout 通过随机断开神经网络的连接，减少每次训练时实际参与计算的模型的参数量；但是在测试时， Dropout 会恢复所有的连接，保证模型测试时获得最好的性能</p><p>在 TensorFlow 中，可以通过<code>tf.nn.dropout(x, rate)</code>函数实现某条连接的 Dropout 功能，其中 rate 参数设置断开的概率值𝑝</p><pre><code class="python"># 添加 dropout 操作，断开概率为 0.5x = tf.nn.dropout(x, rate=0.5)</code></pre><p>也可以将 Dropout 作为一个网络层使用， 在网络中间插入一个 Dropout 层：</p><pre><code class="python"># 添加 Dropout 层，断开概率为 0.5model.add(layers.Dropout(rate=0.5))</code></pre><p>随着 Dropout 层的增加，网络模型训练时的实际容量减少，泛化能力变强</p><h3 id="7、数据增强"><a href="#7、数据增强" class="headerlink" title="7、数据增强"></a>7、数据增强</h3><p>增加数据集规模是解决过拟合最重要的途径。在有限的数据集上，通过数据增强技术可以增加训练的样本数量，获得一定程度上的性能提升</p><p>数据增强(Data Augmentation)是指在维持样本标签不变的条件下，根据先验知识改变样本的特征， 使得新产生的样本也符合或者近似符合数据的真实分布</p><p>以图片数据为例。数据集中的图片大小往往是不一致的，为了方便神经网络处理，需要将图片缩放到某个固定的大小，如缩放后的固定224 × 224大小的图片。对于图中的人物图片， 根据先验知识，我们知道旋转、缩放、 平移、裁剪、改变视角、 遮挡某局部区域都不会改变图片的主体类别标签，因此针对图片数据，可以有多种数据增强方式</p><p>TensorFlow 中提供了常用图片的处理函数， 位于<code>tf.image</code>子模块中。通过<code>tf.image.resize</code>函数可以实现图片的缩放功能</p><p>将图片从文件系统读取进来后，即可进行图片数据增强操作。通过预处理：</p><pre><code class="python">def preprocess(x,y):# 预处理函数# x: 图片的路径， y：图片的数字编码x = tf.io.read_file(x)x = tf.image.decode_jpeg(x, channels=3) # RGBA# 图片缩放到 244x244 大小，这个大小根据网络设定自行调整x = tf.image.resize(x, [244, 244])</code></pre><h4 id="1-旋转"><a href="#1-旋转" class="headerlink" title="1.旋转"></a>1.旋转</h4><p>通过<code>tf.image.rot90(x, k=1)</code>可以实现图片按逆时针方式旋转 k 个 90 度</p><pre><code class="python"># 图片逆时针旋转 180 度x = tf.image.rot90(x,2)  </code></pre><h4 id="2-翻转"><a href="#2-翻转" class="headerlink" title="2.翻转"></a>2.翻转</h4><p>图片的翻转分为沿水平轴翻转和竖直轴翻转，可以通过<code>tf.image.random_flip_left_right</code>和<code>tf.image.random_flip_up_down</code>实现图片在水平方向和竖直方向的随机翻转操作</p><pre><code class="python"># 随机水平翻转x = tf.image.random_flip_left_right(x)# 随机竖直翻转x = tf.image.random_flip_up_down(x)</code></pre><h4 id="3-裁剪"><a href="#3-裁剪" class="headerlink" title="3.裁剪"></a>3.裁剪</h4><p>通过在原图的左右或者上下方向去掉部分边缘像素，可以保持图片主体不变，同时获得新的图片样本。在实际裁剪时，一般先将图片缩放到略大于网络输入尺寸的大小， 再裁剪到合适大小</p><p>如网络的输入大小为224 × 224，那么可以先通过 resize 函数将图片缩放到244 × 244大小，再随机裁剪到224 × 224大小：</p><pre><code class="python"># 图片先缩放到稍大尺寸x = tf.image.resize(x, [244, 244])# 再随机裁剪到合适尺寸x = tf.image.random_crop(x, [224,224,3])</code></pre><h4 id="4-生成数据"><a href="#4-生成数据" class="headerlink" title="4.生成数据"></a>4.生成数据</h4><p>通过生成模型在原有数据上进行训练， 学习到真实数据的分布，从而利用生成模型获得新的样本，这种方式也可以在一定程度上提升网络性能。 如通过条件生成对抗网络(Conditional GAN,简称 CGAN)可以生成带标签的样本数据</p><h4 id="5-其他方式"><a href="#5-其他方式" class="headerlink" title="5.其他方式"></a>5.其他方式</h4><p>除了上述介绍的典型图片数据增强方式以外，可以根据先验知识，在不改变图片标签信息的条件下，任意变换图片数据，获得新的图片。如在原图上叠加高斯噪声、通过改变图片的观察视角后、在原图上随机遮挡部分区域等</p><h3 id="8、过拟合问题"><a href="#8、过拟合问题" class="headerlink" title="8、过拟合问题"></a>8、过拟合问题</h3><h4 id="1-数据集构建"><a href="#1-数据集构建" class="headerlink" title="1.数据集构建"></a>1.数据集构建</h4><p>我们使用的数据集样本特性向量长度为 2， 标签为 0 或 1，分别代表了两种类别。借助于<code>scikit-learn</code>库中提供的<code>make_moons</code>工具， 我们可以生成任意多数据的训练集。首先安装 scikit-learn 库：</p><pre><code class="python"># pip 安装 scikit-learn 库pip install -U scikit-learn</code></pre><p>为了演示过拟合现象，采样1000个样本数据，同时添加标准差为 0.25 的高斯噪声数据：</p><pre><code class="python"># 导入数据集生成工具from sklearn.datasets import make_moons# 从 moon 分布中随机采样 1000 个点，并切分为训练集-测试集X, y = make_moons(n_samples = N_SAMPLES, noise=0.25, random_state=100)X_train, X_test, y_train, y_test = train_test_split(X, y,test_size = TEST_SIZE, random_state=42)</code></pre><p>编写make_plot函数，方便根据样本的坐标 X 和样本的标签 y 绘制出数据的分布图：</p><pre><code class="python">def make_plot(X, y, plot_name, file_name, XX=None, YY=None, preds=None):    plt.figure()    # sns.set_style(&quot;whitegrid&quot;)    axes = plt.gca()    axes.set_xlim([x_min,x_max])    axes.set_ylim([y_min,y_max])    axes.set(xlabel=&quot;$x_1$&quot;, ylabel=&quot;$x_2$&quot;)    # 根据网络输出绘制预测曲面    if(XX is not None and YY is not None and preds is not None):        plt.contourf(XX, YY, preds.reshape(XX.shape), 25, alpha = 0.08,                     cmap=cm.Spectral)        plt.contour(XX, YY, preds.reshape(XX.shape), levels=[.5],                    cmap=&quot;Greys&quot;,                    vmin=0, vmax=.6)    # 绘制正负样本    markers = [&#39;o&#39; if i == 1 else &#39;s&#39; for i in y.ravel()]    mscatter(X[:, 0], X[:, 1], c=y.ravel(), s=20,             cmap=plt.cm.Spectral, edgecolors=&#39;none&#39;, m=markers)    # 保存矢量图    plt.savefig(OUTPUT_DIR+&#39;/&#39;+file_name)</code></pre><p>绘制出采样的 1000 个样本分布：</p><pre><code class="python"># 绘制数据集分布make_plot(X, y, None, &quot;dataset.svg&quot;)  </code></pre><h4 id="2-网络层数的影响"><a href="#2-网络层数的影响" class="headerlink" title="2.网络层数的影响"></a>2.网络层数的影响</h4><p>为了探讨不同的网络深度下的过拟合程度，我们共进行了 5 次训练实验。在𝑛 ∈ [0,4]时，构建网络层数为𝑛 + 2层的全连接层网络，并通过 Adam 优化器训练 500 个 Epoch，获得网络在训练集上的分隔曲线</p><pre><code class="python">for n in range(5): # 构建 5 种不同层数的网络    model = Sequential()# 创建容器    # 创建第一层    model.add(Dense(8, input_dim=2,activation=&#39;relu&#39;))    for _ in range(n): # 添加 n 层，共 n+2 层        model.add(Dense(32, activation=&#39;relu&#39;))    model.add(Dense(1, activation=&#39;sigmoid&#39;)) # 创建最末层    model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;adam&#39;,                  metrics=[&#39;accuracy&#39;]) # 模型装配与训练    history = model.fit(X_train, y_train, epochs=N_EPOCHS, verbose=1)    # 绘制不同层数的网络决策边界曲线    preds = model.predict_classes(np.c_[XX.ravel(), YY.ravel()])    title = &quot;网络层数({})&quot;.format(n)    file = &quot;网络容量%f.png&quot;%(2+n*1)    make_plot(X_train, y_train, title, file, XX, YY, preds)</code></pre><h4 id="3-Dropout的影响"><a href="#3-Dropout的影响" class="headerlink" title="3.Dropout的影响"></a>3.Dropout的影响</h4><p>待添加</p><h4 id="4-正则化的影响"><a href="#4-正则化的影响" class="headerlink" title="4.正则化的影响"></a>4.正则化的影响</h4><p>待添加</p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="1、全连接层的问题"><a href="#1、全连接层的问题" class="headerlink" title="1、全连接层的问题"></a>1、全连接层的问题</h3><p>全连接层较高的内存占用量严重限制了神经网络朝着更大规模、更深层数方向的发展</p><h4 id="1-局部相关性"><a href="#1-局部相关性" class="headerlink" title="1.局部相关性"></a>1.局部相关性</h4><p>网络的每个输出节点都与所有的输入节点相连接， 用于提取所有输入节点的特征信息，这种稠密的连接方式是全连接层参数量大、 计算代价高的根本原因。 全连接层也称为稠密连接层(Dense Layer)</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200511214046062.png" alt="全连接示意图"></p><p>基于距离的重要性分布假设特性称为<strong>局部相关性</strong>，只关注和自己距离较近的部分节点，而忽略距离较远的节点。 在这种重要性分布假设下，全连接层的连接模式变成了下图所示的状态，输出节点𝑗只与以𝑗为中心的局部区域(感受野)相连接，与其它像素无连接</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200511214621069.png" alt="局部链接的网络层示意图"></p><p>其中和自己距离较近的部分节点形成的窗口称为<strong>感受野</strong>(Receptive Field)，表征了每个像素对于中心像素的重要性分布情况，网格内的像素才会被考虑，网格外的像素对于中心像素会被忽略</p><h4 id="2-劝值共享"><a href="#2-劝值共享" class="headerlink" title="2.劝值共享"></a>2.劝值共享</h4><p>如下图所示，在计算左上角位置的输出像素时，使用权值矩阵：$W=\begin{bmatrix}<br>w_{11} &amp; w_{12} &amp; w_{13}\<br>w_{21} &amp; w_{22} &amp; w_{23}\<br>w_{31} &amp; w_{32} &amp; w_{33}<br>\end{bmatrix}$</p><p>与对应感受野内部的像素相乘累加， 作为左上角像素的输出值；在计算右下方感受野区域时，共享权值参数𝑾，即使用相同的权值参数𝑾相乘累加，得到右下角像素的输出值，此时网络层的参数量9个，且与输入、输出节点数无关</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200511215857765.png" alt="劝值共享矩阵示意图"></p><p>通过运用局部相关性和权值共享的思想，成功把网络的参数量减少到𝑘 × 𝑘(准确地说，是在单输入通道、 单卷积核的条件下)。这种共享权值的“局部连接层”网络其实就是卷积神经网络</p><h4 id="3-卷积运算"><a href="#3-卷积运算" class="headerlink" title="3.卷积运算"></a>3.卷积运算</h4><p>略</p><h3 id="2、卷积神经网络"><a href="#2、卷积神经网络" class="headerlink" title="2、卷积神经网络"></a>2、卷积神经网络</h3><p>卷积神经网络通过充分利用局部相关性和权值共享的思想，大大地减少了网络的参数量， 从而提高训练效率，更容易实现超大规模的深层网络</p><p>以图片数据为例，卷积层接受高、 宽分别为ℎ、 𝑤，通道数为𝑐𝑖𝑛的输入特征图𝑿，在𝑐𝑜𝑢𝑡个高、 宽都为𝑘，通道数为𝑐𝑖𝑛的卷积核作用下，生成高、 宽分别为ℎ′、 𝑤′，通道数为𝑐𝑜𝑢𝑡的特征图输出。需要注意的是，卷积核的高宽可以不等，为了简化讨论，这里仅讨论高宽都为𝑘的情况</p><h4 id="1-单通道输入和单卷积核"><a href="#1-单通道输入和单卷积核" class="headerlink" title="1.单通道输入和单卷积核"></a>1.单通道输入和单卷积核</h4><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200512112621597.png" alt="示意图"></p><p>完成第一个感受野区域的特征提取后，感受野窗口向右移动一个步长单位(Strides， 记为𝑠， 默认为 1)</p><h4 id="2-多通道输入和单卷积核"><a href="#2-多通道输入和单卷积核" class="headerlink" title="2.多通道输入和单卷积核"></a>2.多通道输入和单卷积核</h4><p>在多通道输入的情况下， 卷积核的通道数需要和输入𝑿的通道数量相匹配， 卷积核的第𝑖个通道和𝑿的第𝑖个通道运算，得到第𝑖个中间矩阵，此时可以视为单通道输入与单卷积核的情况， 所有通道的中间矩阵对应元素再次相加， 作为最终输出</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200512112150245.png" alt="多通道输入和单卷积核"></p><p>整个的计算示意图如下所示， 输入的每个通道处的感受野均与卷积核的对应通道相乘累加，得到与通道数量相等的中间变量，这些中间变量全部相加即得到当前位置的输出值。 输入通道的通道数量决定了卷积核的通道数。 一个卷积核只能得到一个输出矩阵，无论输入𝑿的通道数量</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200512112452481.png" alt="多通道输入和单卷积核计算示意图"></p><h4 id="3-多通道输入、多卷积核"><a href="#3-多通道输入、多卷积核" class="headerlink" title="3.多通道输入、多卷积核"></a>3.多通道输入、多卷积核</h4><p>一般来说，一个卷积核只能完成某种逻辑的特征提取，当需要同时提取多种逻辑特征时， 可以通过增加多个卷积核来得到多种特征，提高神经网络的表达能力，这就是多通道输入、 多卷积核的情况</p><p>当出现多卷积核时， 第𝑖 ($i \in [1,n]$， 𝑛为卷积核个数)个卷积核与输入𝑿运算得到第𝑖个输出矩阵(也称为输出张量𝑶的通道𝑖）， 最后全部的输出矩阵在通道维度上进行拼接(Stack 操作，创建输出通道数的新维度)，产生输出张量𝑶， 𝑶包含了𝑛个通道数</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200512113018813.png" alt="多卷积核示意图"></p><ul><li>每个卷积核的大小𝑘、步长𝑠、填充设定等都是统一设置（保证输出的每个通道大小一致）</li></ul><h4 id="4-步长"><a href="#4-步长" class="headerlink" title="4.步长"></a>4.步长</h4><p>感受野密度的控制手段一般是通过移动步长(Strides)实现的</p><p>步长是指感受野窗口每次移动的长度单位，对于2D输入来说，分为沿𝑥(向右)方向和𝑦(向下)方向的移动长度</p><ul><li>当步长设计的较小时，感受野以较小幅度移动窗口，有利于提取到更多的特征信息，输出张量的尺寸也更大</li><li>当步长设计的较大时， 感受野以较大幅度移动窗口，有利于减少计算代价， 过滤冗余信息，输出张量的尺寸也更小</li></ul><h4 id="5-填充"><a href="#5-填充" class="headerlink" title="5.填充"></a>5.填充</h4><p>在网络模型设计时，有时希望输出𝑶的高宽能够与输入𝑿的高宽相同， 从而方便网络参数的设计、 残差连接等</p><p>方法：通过在原输入𝑿的高和宽维度上面进行填充(Padding)若干无效元素操作，得到增大的输入𝑿′。 通过精心设计填充单元的数量， 在𝑿′上面进行卷积运算得到输出𝑶的高宽可以和原输入𝑿相等，甚至更大</p><p>卷积神经层的输出尺寸$[b,h’,w’,c_{out}]$由卷积核的数量$c_{out}$，卷积核的大小𝑘，步长𝑠，填充数𝑝(只考虑上下填充数量$p_h$相同，左右填充数量$p_w$相同的情况)以及输入𝑿的高宽ℎ/𝑤共同决定， 它们之间的数学关系可以表达为：</p><p>$h’=\left \lfloor \frac{h+2\cdot p_h-k}{s} \right \rfloor+1$</p><p>$w’=\left \lfloor \frac{w+2\cdot p_w-k}{s} \right \rfloor+1$</p><ul><li>其中$p_h$、$p_w$分别表示高、宽方向的填充数量</li><li>$\left \lfloor \right \rfloor$表示向下取整</li></ul><p>在 TensorFlow 中， 在𝑠 = 1 时， 如果希望输出𝑶和输入𝑿高、 宽相等， 只需要简单地设置参数<code>padding=”SAME”</code>即可使 TensorFlow 自动计算 padding 数量</p><h3 id="3、卷积层实现"><a href="#3、卷积层实现" class="headerlink" title="3、卷积层实现"></a>3、卷积层实现</h3><p>在 TensorFlow 中，既可以通过自定义权值的底层实现方式搭建神经网络，也可以直接调用现成的卷积层类的高层方式快速搭建复杂网络</p><h4 id="1-自定义权值"><a href="#1-自定义权值" class="headerlink" title="1.自定义权值"></a>1.自定义权值</h4><p>通过<code>tf.nn.conv2d</code>函数可以方便地实现 2D 卷积运算。<code>tf.nn.conv2d</code>基于输入$X:[b,h,w,c_{in}]$和卷积核$W:[k,k,c_{in},c_{out}]$进行卷积运算， 得到输出$O:[b,h’,w’,c_{out}]$</p><ul><li>$c_{in}$：输入通道数</li><li>$c_{out}$：卷积核的数量，即输出特征图的通道数</li><li>$k$：卷积核宽高</li><li>$b$：图片数量</li></ul><pre><code class="python">&gt;&gt;&gt; x = tf.random.normal([2,5,5,3]) # 模拟输入， 3 通道，高宽为 5# 需要根据[k,k,cin,cout]格式创建 W 张量， 4 个 3x3 大小卷积核&gt;&gt;&gt; w = tf.random.normal([3,3,3,4])# 步长为 1, padding 为 0,&gt;&gt;&gt; out = tf.nn.conv2d(x,w,strides=1,padding=[[0,0],[0,0],[0,0],[0,0]])# 输出张量的 shapeTensorShape([2, 3, 3, 4])</code></pre><ul><li><p>padding参数格式：<code>padding=[[0,0],[上,下],[左,右],[0,0]]</code></p><pre><code class="python">  # 上下左右各填充一个单位：  padding=[[0,0],[1,1],[1,1],[0,0]]</code></pre></li><li><p>特别地， 通过设置参数<code>padding=&#39;SAME&#39;</code>、<code>strides=1</code>可以直接得到输入、 输出同大小的卷积层</p></li><li><p>当<code>strides&gt;1</code>时， 设置<code>padding=&#39;SAME&#39;</code>将使得输出高、宽将成$\frac{1}{strides}$倍地减少</p><pre><code class="python">  &gt;&gt;&gt; x = tf.random.normal([2,5,5,3])  &gt;&gt;&gt; w = tf.random.normal([3,3,3,4])  # 高宽先 padding 成可以整除 3 的最小整数 6，然后 6 按 3 倍减少，得到 2x2  &gt;&gt;&gt; out = tf.nn.conv2d(x,w,strides=3,padding=&#39;SAME&#39;)  TensorShape([2, 2, 2, 4])</code></pre></li></ul><p>卷积神经网络层与全连接层一样，可以设置网络带偏置向量。<code>tf.nn.conv2d</code>函数是没有实现偏置向量计算的， 添加偏置需要手动累加偏置张量：</p><pre><code class="python"># 根据[cout]格式创建偏置向量&gt;&gt;&gt; b = tf.zeros([4])# 在卷积输出上叠加偏置向量，它会自动 broadcasting 为[b,h&#39;,w&#39;,cout]&gt;&gt;&gt; out = out + b</code></pre><h4 id="2-卷积层类"><a href="#2-卷积层类" class="headerlink" title="2.卷积层类"></a>2.卷积层类</h4><p>通过卷积层类<code>layers.Conv2D</code>可以直接调用类实例完成卷积层的前向计算（TensorFlow中，API的首字母大写的对象一般表示类，全部小写的一般表示函数）。使用类方式会自动创建（在创建类时或build时）需要的权值张量和偏置向量等， 用户不需要记忆卷积核张量的定义格式</p><p>在新建卷积层类时，只需要指定卷积核数量参数<code>filters</code>，卷积核大小<code>kernel_size</code>， 步长<code>strides</code>，填充 <code>padding</code> 等即可</p><pre><code class="python"># 创建了 4 个3 × 3大小的卷积核的卷积层，步长为 1，padding 方案为&#39;SAME&#39;layer = layers.Conv2D(4,kernel_size=3,strides=1,padding=&#39;SAME&#39;)</code></pre><p>如果卷积核高宽不等，步长行列方向不等，此时需要将kernel_size参数设计为元组格式$(k_h,k_w)$，strides参数设计为$(s_h,s_w)$</p><pre><code class="python"># 创建 4 个3 × 4大小的卷积核，竖直方向移动步长𝑠ℎ = 2，水平方向移动步长𝑠𝑤 = 1：layer = layers.Conv2D(4,kernel_size=(3,4),strides=(2,1),padding=&#39;SAME&#39;)</code></pre><p>创建完成后，通过调用实例(的<code>__call__</code>方法)即可完成前向计算：</p><pre><code class="python"># 创建卷积层类&gt;&gt;&gt; layer = layers.Conv2D(4,kernel_size=3,strides=1,padding=&#39;SAME&#39;)&gt;&gt;&gt; out = layer(x) # 前向计算&gt;&gt;&gt; out.shape # 输出张量的 shapeTensorShape([2, 5, 5, 4])</code></pre><p>在类<code>Conv2D</code>中，可以通过类成员<code>trainable_variables</code>直接返回𝑾和𝒃的列表：</p><pre><code class="python"># 返回所有待优化张量列表&gt;&gt;&gt; layer.trainable_variables[&lt;tf.Variable &#39;conv2d/kernel:0&#39; shape=(3, 3, 3, 4) dtype=float32, numpy= array([[[[ 0.13485974, -0.22861657, 0.01000655, 0.11988598],          [ 0.12811887, 0.20501086, -0.29820845, -0.19579397],          [ 0.00858489, -0.24469738, -0.08591779, -0.27885547]], ... &lt;tf.Variable &#39;conv2d/bias:0&#39; shape=(4,) dtype=float32, numpy=array([0., 0., 0., 0.], dtype=float32)&gt;]</code></pre><ul><li>可以直接调用类实例<code>layer.kernel</code>、<code>layer.bias</code>名访问𝑾和𝒃张量</li></ul><h3 id="4、LeNet-5实战"><a href="#4、LeNet-5实战" class="headerlink" title="4、LeNet-5实战"></a>4、LeNet-5实战</h3><p>1990 年代， Yann LeCun 等人提出了用于手写数字和机器打印字符图片识别的神经网络，被命名为 LeNet-5 [4]。 LeNet-5 的提出，使得卷积神经网络在当时能够成功被商用，广泛应用在邮政编码、支票号码识别等任务中</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200513020542762.png" alt="LeNet-5网络结构"></p><ul><li>接受32*32大小的数字、字符图片，经过第一个卷积层得到[b,28,28,6]形状的张量，经过一个向下采样层，张量尺寸缩小到[b,14,14,6]</li><li>经过第二个卷积层，得到[b,10,10,16]形状的张量，同样经过下采样层，张量尺寸缩小到[b,5,5,16]</li><li>在进入全连接层之前，先将张量打成[b,400]的张量</li><li>送入输出节点数分别为120、84的2个全连接层，得到[b,84]的张量</li><li>最后通过Gaussian connections层</li></ul><p>在上述基础上进行少许调整，使得它更容易在现代深度学习框架上实现：</p><p><img src="//NU-LL.github.io/2020/01/03/深度学习与TensorFlow2/image-20200513021054068.png" alt="调整后的网络结构"></p><ul><li>将输入𝑿形状由32 × 32调整为28 × 28</li><li>将 2 个下采样层实现为最大池化层(降低特征图的高、宽，后续会介绍)</li><li>利用全连接层替换掉Gaussian connections层</li></ul><p>加载MNIST数据集：进阶操作 -&gt; 7、经典数据集加载</p><p>创建网络：</p><pre><code class="python">from tensorflow.keras import Sequentialnetwork = Sequential([ # 网络容器    layers.Conv2D(6,kernel_size=3,strides=1), # 第一个卷积层, 6 个 3x3 卷积核    layers.MaxPooling2D(pool_size=2,strides=2), # 高宽各减半的池化层    layers.ReLU(), # 激活函数    layers.Conv2D(16,kernel_size=3,strides=1), # 第二个卷积层, 16 个 3x3 卷积核    layers.MaxPooling2D(pool_size=2,strides=2), # 高宽各减半的池化层    layers.ReLU(), # 激活函数    layers.Flatten(), # 打平层，方便全连接层处理    layers.Dense(120, activation=&#39;relu&#39;), # 全连接层， 120 个节点    layers.Dense(84, activation=&#39;relu&#39;), # 全连接层， 84 节点    layers.Dense(10) # 全连接层， 10 个节点])# build 一次网络模型，给输入 X 的形状，其中 4 为随意给的 batchsznetwork.build(input_shape=(4, 28, 28, 1))# 统计网络信息network.summary()</code></pre><p>网络信息如下：</p><pre><code class="python">Model: &quot;sequential&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d (Conv2D)              multiple                  60        _________________________________________________________________max_pooling2d (MaxPooling2D) multiple                  0         _________________________________________________________________re_lu (ReLU)                 multiple                  0         _________________________________________________________________conv2d_1 (Conv2D)            multiple                  880       _________________________________________________________________max_pooling2d_1 (MaxPooling2 multiple                  0         _________________________________________________________________re_lu_1 (ReLU)               multiple                  0         _________________________________________________________________flatten (Flatten)            multiple                  0         _________________________________________________________________dense (Dense)                multiple                  48120     _________________________________________________________________dense_1 (Dense)              multiple                  10164     _________________________________________________________________dense_2 (Dense)              multiple                  850       =================================================================Total params: 60,074Trainable params: 60,074Non-trainable params: 0_________________________________________________________________</code></pre><ul><li>显著降低网络参数量，同时增加网络深度</li></ul><h3 id="5、表示学习"><a href="#5、表示学习" class="headerlink" title="5、表示学习"></a>5、表示学习</h3>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow2 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32L476的IAP升级</title>
      <link href="/2019/11/12/%E5%9F%BA%E4%BA%8ESTM32L476%E7%9A%84IAP%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/11/12/%E5%9F%BA%E4%BA%8ESTM32L476%E7%9A%84IAP%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="基于STM32L476的IAP升级"><a href="#基于STM32L476的IAP升级" class="headerlink" title="基于STM32L476的IAP升级"></a>基于STM32L476的IAP升级</h1><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><blockquote><p>基本概念：</p><p>ICP/ISP： 即在线编程（in-circuit programming）有时也叫系统编程（In System Programming）在，用于通过JTAG、SWD协议或引导加载程序（BootLoader）将用户应用程序加载到微控制器中，从而更新flash的全部内容。 ICP提供了快速有效的设计迭代，并消除了不必要的封装处理或设备插槽。 </p><p>IAP： 即应用内编程（in-application programming）。与ICP方法相比，应用内编程（IAP）可以使用微控制器支持的任何通信接口（I / O，USB，CAN，UART，I2C，SPI等）将编程数据下载到存储器中。当应用程序（即IAP程序）运行时，用户能够对Flash存储器进行重新编程。 但是，应用程序（即IAP程序）的一部分必须事先通过ICP烧录在flash中。如果在flash操作期间发生设备复位，则不能保证flash中的内容。 </p></blockquote><p>发生复位时，程序计数器（PC指针）将设置为IAP驱动程序的地址。它应该是一个简洁的代码，用于检查特定状态，例如，按下了组合键。满足此条件后，IAP驱动程序要么去更新用户应用程序，要么直接（通常默认情况下）执行用户应用程序。</p><p>用户应用程序需要与IAP驱动程序分开。最实用的解决方案是将IAP驱动程序代码放在程序存储器（flash）的开头，并将用户代码放在下一个空闲Flash存储块、扇区或页面的开头，这样可以独立在两个区域上都将配置内存保护。本文中，IAP是通过USART而不是更高级的通信接口执行的，因此可以最大程度地减少内存占用。</p><p>用户应用程序可能具有独立的堆栈和中断向量（两者都是推荐的，但不是强制性的）（参见下图）。当IAP程序直接启动用户应用程序时：</p><ol><li>IAP程序将主堆栈指针设置为应用程序地址。</li><li>下一条指令执行就会跳转到应用程序（无条件分支）。</li><li>然后，应用程序将其自己的中断向量表设置为活动状态。 </li></ol><p><img src="//NU-LL.github.io/2019/11/12/基于STM32L476的IAP升级/1573571483770.png" alt="IAP程序"></p><p>用户应用程序（app）需注意事项：</p><ol><li>使用工具链链接程序文件将程序加载地址设置为0x08008000</li><li>使用“ NVIC_SetVectorTable”将向量表定位在地址0x08008000上<br>  功能。 <ol><li>这里在system_stm32l4xx.c中修改<code>VECT_TAB_OFFSET</code>宏即可，<code>VECT_TAB_OFFSET</code>宏必须为<strong>0x200的倍数</strong></li></ol></li></ol><h2 id="二、STM32L476的内部flash结构及其启动方式"><a href="#二、STM32L476的内部flash结构及其启动方式" class="headerlink" title="二、STM32L476的内部flash结构及其启动方式"></a>二、STM32L476的内部flash结构及其启动方式</h2><p>参考ST官方手册（RM0351），STM32L476内部1M的flash被划分为两个BANK：</p><p><img src="//NU-LL.github.io/2019/11/12/基于STM32L476的IAP升级/flash.jpg" alt="flash"></p><ul><li>当选择从Information block中的系统储存器（System memory）启动时，即启动利用串口下载代码的固件（Embedded boot loader，出厂后已经固化）</li><li>当选择从主储存器（Main memory）启动时，默认会从主存储器（Main memory）的<strong>BANK1</strong>启动</li><li>设置<code>FLASH_OPTR</code>寄存器的<code>BFB2</code>位为1，能够改变启动方式为主存储器（Main memory）的<strong>BANK2</strong><ul><li><code>FLASH_OPTR</code>寄存器的默认值来自Information block中的Option bytes（只读，默认固化为0xFFEF F8AA，其中BFB2位默认为0）</li><li>不管从BANK1还是BANK2启动，最后都会将BANK1或BANK2映射到0x0000 0000（这里是boot memory space，引导存储空间）去，系统会认为代码存放在0x0000 0000处</li></ul></li></ul><p>当从主存储器（Main memory）的<strong>BANK2</strong>启动时，BANK1和BANK2会进行交换，所以用户应用程序的初始化代码需要将NVIC异常向量表和偏移寄存器设置为BANK2交换后的地址，即原来BANK1所在的地址：0x0800 0000</p><h3 id="选项字节"><a href="#选项字节" class="headerlink" title="选项字节"></a>选项字节</h3><p>STM32L476中具体的选项字节（Information block中的Option bytes）：</p><p><img src="//NU-LL.github.io/2019/11/12/基于STM32L476的IAP升级/%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82.png" alt="选项字节"></p><p>其中USER OPT和RDP为：</p><p><img src="//NU-LL.github.io/2019/11/12/基于STM32L476的IAP升级/1573830570726.png" alt="USER OPT和RDP"></p><p>这里多留意USER OPT中的BFB2，后面需要用到</p><blockquote><p>HAL库中关于选项字节的编程：</p><ol><li>HAL_FLASH_Unlock解锁flash</li><li>HAL_FLASH_OB_Unlock解锁选项字节</li><li>HAL_FLASHEx_OBGetConfig获得系统中已经存在的选项字节参数</li><li>while(HAL_FLASHEx_OBProgram(&amp;obData) != HAL_OK)写入修改后的选项字节</li><li>HAL_FLASH_OB_Lock锁定选项字节</li><li>HAL_FLASH_Lock锁定flash</li></ol><p>FLASH_OBProgramInitTypeDef结构体参数：</p><ul><li>OptionType：设置选项字节的类型<ul><li>OPTIONBYTE_WRP：设置WRP</li><li>OPTIONBYTE_RDP：设置RDP</li><li>OPTIONBYTE_USER：设置USER</li><li>OPTIONBYTE_PCROP：设置PCROP</li></ul></li><li>WRPArea：设置WRP时，选择是BANKx的AREAA还是AREAB</li><li>WRPStartOffset</li><li>WRPEndOffset</li><li>RDPLevel：设置RDP时的度保护等级（OB_RDP_LEVEL_0、1、2三种等级）</li><li>USERType：设置USER时，设置的各种参数（如OB_USER_BFB2）</li><li>USERConfig：具体的USER配置（如OB_BFB2_ENABLE）</li><li>PCROPConfig：设置PCROP时使用</li><li>PCROPStartAddr</li><li>PCROPEndAddr</li></ul></blockquote><h2 id="三、基于双bank的IAP设计"><a href="#三、基于双bank的IAP设计" class="headerlink" title="三、基于双bank的IAP设计"></a>三、基于双bank的IAP设计</h2><p>优点：</p><ul><li>可以更新加载程序（IAP）代码</li><li>如果加载失败，则原始代码仍然有效（操作可以是“原子的”） </li><li>基于该方案的设备无需通过定义加载程序状态去启动app</li></ul><p>用户代码可访问STM32L4和STM32G4的<code>FB_MODE</code>寄存器或STM32L0的<code>UFB</code>的寄存器。 系统配置寄存器中的该位控制存储器映射（Remap）和别名（Alias）。 双存储区启动机制也使用它，并且在足够小心的情况下，它也可以用于实时现场升级。 </p><p><img src="//NU-LL.github.io/2019/11/12/基于STM32L476的IAP升级/%E6%98%A0%E5%B0%84%E5%92%8C%E5%88%AB%E5%90%8D.png" alt="映射和别名"></p><p>1、用户代码选择启动存储区</p><p>用户代码可以通过访修改SYSCFG寄存器修改存储区的映射关系（L0为SYSCFG_DFGR1中的<strong>UFB</strong>标志位，L4为SYSCFG_MEMRMP中的<strong>FB_MODE</strong>标志位），同时还能根据该标志位分辨出目前在使用哪个存储区。</p><blockquote><p>(Bit 8)FB_MODE: Flash Bank mode selection</p><p>0: Flash Bank 1 mapped at 0x0800 0000 (and aliased @0x0000 0000) and Flash Bank 2<br>mapped at 0x0808 0000 (and aliased at 0x0008 0000)<br>1: Flash Bank2 mapped at 0x0800 0000 (and aliased @0x0000 0000) and Flash Bank 1<br>mapped at 0x0808 0000 (and aliased at 0x0008 0000)  </p></blockquote><p><strong>注意</strong>：</p><ul><li>在修改FB_MODE改变映射关系后，必须<strong>重置向量表</strong></li><li></li></ul><p>2、自动选择启动存储区</p><p>复位后，如果FLASH_OPTR寄存器的<strong>BFB2</strong>位为1（BOOTx引脚设置为主存储区启动），将调用系统储存器（System memory）中的BootLoader来检测BANK2中的代码是否有效（检测BANK2中第一个字节是否包含有效的堆栈指针地址），若有效则从BANK2启动</p><blockquote><p>(Bit 20)BFB2: Dual-bank boot</p><p>0: Dual-bank boot disable<br>1: Dual-bank boot enable  </p></blockquote><p><strong>注意</strong>：</p><ul><li>修改该标志位必须通过<code>STM32 ST-LINK Utility</code>软件设置选项字节   <strong>坑啊</strong></li><li>同时，通过<code>STM32 ST-LINK Utility</code>软件设置BFB2标志位后会自动<strong>写保护BANK2</strong>  <strong>贼坑</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAP </tag>
            
            <tag> BootLoader </tag>
            
            <tag> dual bank </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xmanager远程Ubuntu系统图像化界面</title>
      <link href="/2019/11/08/Xmanager%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%83%8F%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
      <url>/2019/11/08/Xmanager%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%83%8F%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Xmanager远程Ubuntu系统图像化界面"><a href="#Xmanager远程Ubuntu系统图像化界面" class="headerlink" title="Xmanager远程Ubuntu系统图像化界面"></a>Xmanager远程Ubuntu系统图像化界面</h1><h2 id="一、安装Xmanager"><a href="#一、安装Xmanager" class="headerlink" title="一、安装Xmanager"></a>一、安装Xmanager</h2><h2 id="二、ubuntu配置"><a href="#二、ubuntu配置" class="headerlink" title="二、ubuntu配置"></a>二、ubuntu配置</h2><h3 id="安装软件ightdm"><a href="#安装软件ightdm" class="headerlink" title="安装软件ightdm"></a>安装软件ightdm</h3><pre><code class="bash">sudo apt install gdmsudo apt install lightdm</code></pre><p>配置<code>lightdm</code></p><p> 新建lightdm.conf配置文件 </p><pre><code class="bash">sudo vi /etc/lightdm/lightdm.conf</code></pre><p>内容填写入下：</p><pre><code class="bash">[SeatDefaults]greeter-show-manual-login=truexserver-allow-tcp=true[XDMCPServer]Enabled=truePort=177</code></pre><p>新建gdm.schemas配置文件：</p><pre><code class="bash">sudo vi /etc/lightdm/gdm.schemas</code></pre><p>内容填写如下：</p><pre><code class="bash">&lt;schema&gt;&lt;key&gt;xdmcp/Enable&lt;/key&gt;&lt;signature&gt;b&lt;/signature&gt;&lt;default&gt;true&lt;/default&gt;&lt;/schema&gt;</code></pre><h3 id="安装xubunt"><a href="#安装xubunt" class="headerlink" title="安装xubunt"></a>安装xubunt</h3><pre><code class="bash">sudo apt install xorg xubuntu-coresudo apt install xubuntu-desktop</code></pre><p>装不上xubuntu-desktop了 T_T  留个坑。。。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xmanager </tag>
            
            <tag> 远程链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言</title>
      <link href="/2019/10/23/Go%E8%AF%AD%E8%A8%80/"/>
      <url>/2019/10/23/Go%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="GO语言"><a href="#GO语言" class="headerlink" title="GO语言"></a>GO语言</h1><p>该笔记是本人学习《Go语言入门经典》和所记录的，便于以后查阅</p><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>go中的编码统一为utf-8，其中ascii的字符占一字节，汉字占三字节</p><p>GO语言中导入的包或声明的变量 若没有使用则会报错</p><pre><code class="go">//格式化源码gofmt -w main.go</code></pre><p><code>%T</code>输出数据的类型</p><p>格式：</p><pre><code class="go">//正确：main{}//错误：main{}</code></pre><p>标识符相关：</p><ul><li>下划线“_”本身在Go中是一个特殊的标识符,称为空标识符。可以代表任何其它的标识符,但是它对应的值会被忽略(比如:忽略某个返回值)。所以<strong>仅能被作为占位符使用</strong>,不能作为标识符使用</li><li>保留关键字（注意int、float32等均没有在这里边，不能使用这些作为命名）：<img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200102110401101.png" alt="保留关键字"></li><li>预定义标识符：<img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200102111410250.png" alt="预定义标识符"></li><li>尽量保持：包名和该文件所在目录的名字保持一致</li><li>首字母大写共有的，首字母小写是私有的（没有public、private等关键字）</li></ul><p>运算符相关：</p><ul><li>%运算的本质：$ a%b=a-a/b*b $</li><li>自增自减只能独立使用，不能和别的语句组合使用，有且仅有<code>i++</code>和<code>i--</code></li><li>没有三目运算符</li><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>！</code></li><li>位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code></li><li>优先级：<img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200102123004830.png" alt="优先级"><ul><li>只有单目运算符、赋值运算符是从右往左运算</li></ul></li></ul><h2 id="一、类型（1-4基本-5-end派生）"><a href="#一、类型（1-4基本-5-end派生）" class="headerlink" title="一、类型（1-4基本 5-end派生）"></a>一、类型（1-4基本 5-end派生）</h2><ul><li><strong>值类型</strong>：基本数据类型，int、float、bool、数组、结构体struct</li><li>变量直接存储，通常在<strong>栈</strong>中分配</li><li><strong>引用类型</strong>：指针、slice切片、map、管道chan、interface<ul><li>变量存储的是一个地址，这个地址对应的空间才是真正的存储数据（值），内存通常在堆上分配</li><li>当没有任何变量应引用这个地址时，改地址对应的数据空间就成为一个垃圾，由GC来回收</li></ul></li></ul><h3 id="1-布尔"><a href="#1-布尔" class="headerlink" title="1.布尔"></a>1.布尔</h3><ul><li>true</li><li>false（默认值）</li><li>占用一个字节</li></ul><p>注：Go不能用 1 和 0 代表 true 和 false，未赋值变量默认为false</p><p>定义：</p><pre><code class="go">var b bool</code></pre><h3 id="2-整数"><a href="#2-整数" class="headerlink" title="2.整数"></a>2.整数</h3><ul><li>默认值为0</li></ul><p>声明：</p><pre><code class="go">var i int = 3</code></pre><h3 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3.浮点数"></a>3.浮点数</h3><ul><li>float32：32位</li><li>float64：64位</li><li>默认值为0（float64）</li></ul><pre><code class="go">num1 := .123num2 := 5.12e2//512</code></pre><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h3><ul><li>默认值为””</li></ul><pre><code class="go">var s string =&quot;&quot;//双引号s += &quot;foo&quot;//反引号s := `asdfafasdf`</code></pre><ul><li>不能对字符串执行数学运算</li><li>字符串是不可变的（不能修改）</li><li>可以通过‘+’拼接字符串，过长时能够换行（必须以‘+’号结尾）</li><li>println直接输出byte时输出的是ASCII<strong>码值</strong></li></ul><h3 id="4-5基本数据类型的转换"><a href="#4-5基本数据类型的转换" class="headerlink" title="4.5基本数据类型的转换"></a>4.5基本数据类型的转换</h3><ul><li>不能自动转换，必须显式转换</li><li>表达式：<code>T(V)</code>，表示将值V转化为类型T</li><li>基本数据类型转成string<ul><li>fmt.Sprintf</li><li>strconv包函数<ul><li>func FormatBool(b bool) string</li><li>func Itoa(i int) string</li><li>func FormatInt(i int64, base int) string</li><li>func FormatUint(i uint64, base int) string</li><li>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</li></ul></li></ul></li><li>string转成基本数据类型<ul><li>strconv包函数<ul><li>func ParseBool(str string)(value bool, err error)</li><li>func ParseFloat(s string. bitSize int)(f float64, err error)</li><li>func ParseInt(s string, base int, bitSize int)(i int64, err error)</li><li>func ParseUint(s string, b int, bitSize int)(n uint64, err error)</li></ul></li><li>失败时，转换的结果为对应类型的默认值</li></ul></li></ul><h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h3><ul><li>声明后元素固定，不能增加删除</li><li>值类型</li><li>数组的地址为<code>&amp;数组名</code></li></ul><pre><code class="go">//var 数组名 [数组大小]数组类型var beatles [4]stringbeatles[0] = &quot;John&quot;beatles[1] = &quot;Paul&quot;beatles[2] = &quot;Ringo&quot;beatles[3] = &quot;George&quot;fmt.Println(beatles)//按顺序打印数组所有元素//其他初始化方式：var beatles [4]string = [4]string{&quot;John&quot;,&quot;Paul&quot;,&quot;Ringo&quot;,&quot;George&quot;}var beatles = [4]string{&quot;John&quot;,&quot;Paul&quot;,&quot;Ringo&quot;,&quot;George&quot;}var beatles = [...]string{&quot;John&quot;,&quot;Paul&quot;,&quot;Ringo&quot;,&quot;George&quot;}var beatles = [...]string{0:&quot;John&quot;,1:&quot;Paul&quot;,3:&quot;George&quot;,2:&quot;Ringo&quot;}beatles = [...]string{0:&quot;John&quot;,1:&quot;Paul&quot;,3:&quot;George&quot;,2:&quot;Ringo&quot;}</code></pre><p>遍历：</p><ul><li><p>常规遍历</p></li><li><p>for-range结构遍历</p><p>  基本语法：</p><pre><code class="go">  for index,value := range array01 {      ...  }</code></pre><ul><li>index：数组下标</li><li>value：该下标对应的值</li><li>他们都是仅在for循环内部可见的局部变量</li><li>遍历数组元素的时候,如果不想使用下标 index,可以直接把下标 index标为下划线 _</li><li>index,value不是固定的</li></ul></li></ul><p>注意事项：</p><ul><li>数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化</li><li>var arr []int这时arr就是一个slice切片</li><li>数组中的元素可以是任何数据类型,包括值类型和引用类型,但是<strong>不能混用</strong></li><li>数组创建后,如果没有赋值,有默认值<ul><li>数值类型数组：默认值为0</li><li>字符串数组：默认值为””</li><li>bool数组：默认值为 false</li></ul></li><li>使用数组的步骤<ul><li>1.声明数组并开辟空间</li><li>2给数组各个元素赋值</li><li>3使用数组</li></ul></li><li>数组的下标是从0开始的</li><li>数组下标必须在指定范围内使用,否则报 panic:数组越界</li><li>Go的数组属值类型,在默认情况下是值传递,因此会进行值拷贝。数组间不会相互影响</li><li>如想在其它函数中,去修改原来的数组,可以使用引用传递（指针方式）</li><li>长度是数组类型的一部分,在传递函数参数时需要考虑数组的长度</li></ul><h4 id="5-1切片slice"><a href="#5-1切片slice" class="headerlink" title="5.1切片slice"></a>5.1切片slice</h4><p>基本语法：</p><pre><code class="go">var 切片名 [] 类型</code></pre><ul><li><p>切片是数组的一个引用,因此切片是<strong>引用类型</strong>,在进行传递时,遵守引用传递机制。</p><ul><li><p>通过slice改变值后原始数据也会改变</p></li><li><p>slice作为形参时，在函数内部改变slice中的值也会改变元素数据中的值</p><pre><code class="go">  func test(slice []int) {      slice[0] = 100  //这里修改slice[0],会改变实参  }  func main() {      var slice = []int {1, 2, 3, 4}      fmt.Println(&quot;slice=&quot;, slice) // [1,2,3,4]      test(slice)      fmt.Println(&quot;slice=&quot;, slice) // [100, 2, 3, 4]  }</code></pre></li></ul></li><li><p>切片的使用和数组类似,遍历切片、访问切片的元素和求切片长度len(slice)都一样</p></li><li><p>切片的长度是可以变化的,因此切片是一个可以动态变化的数组</p></li></ul><hr><p>例子：</p><pre><code class="go">var intArr [5]int = [...]int{1, 22, 33, 66, 99}//声明/定义一个切片//slice := intArr[1:3]//1. slice 就是切片名//2. intArr[1:3] 表示 slice 引用到intArr这个数组//3. 引用intArr数组的起始下标为 1 , 最后的下标为3(但是不包含3)slice := intArr[1:3]fmt.Println(&quot;intArr=&quot;, intArr)fmt.Println(&quot;slice 的元素是 =&quot;, slice) //  22, 33fmt.Println(&quot;slice 的元素个数 =&quot;, len(slice)) // 2fmt.Println(&quot;slice 的容量 =&quot;, cap(slice)) // 切片的容量是可以动态变化</code></pre><p>slice从底层来说,其实就是一个数据结构(struct结构体)：</p><pre><code class="go">//上述例子中的slice的结构可以视为：type slice struct{    ptr *[2]int    len int    cap int}</code></pre><p>所以可以通过slice来更改原始数据。</p><p>上述例子的具体内存模型：</p><p><img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200103220708761.png" alt="slice的内存模型"></p><hr><p>切片的<strong>使用</strong>：</p><ul><li><p>定义一个切片,然后让切片去引用一个已经创建好的数组,如上述例子</p><ul><li>初始化：var slice = arr[startIndex:endIndex]<ul><li>从arr中的startIndex取到endIndex（不包含endIndex）：[startIndex,endIndex)</li><li>切片初始化时,仍然不能越界。范围在[0-len(arr)]之间,但是可以动态增长</li><li>var slice = arr[0:end] ==&gt; var slice = arr[:end]</li><li>var slice = arr[start:len(arr)] ==&gt; var slice = arr[start:]</li><li>var slice = arr[0:len(arr)] ==&gt; var slice = arr[:]</li></ul></li></ul></li><li><p>通过内置函数make创建切片</p><ul><li>语法：<code>var 切片名 []type = make([],len,[cap])</code><ul><li>type：数据类型</li><li>len：大小</li><li>cap：指定切片容量，可选</li></ul></li><li>如果没有给切片的各个元素赋值,那么就会使用默认值</li><li>通过make方式创建的切片对应的数组是由make底层维护,对外不可见,即只能通过slice去访问各个元素</li></ul></li><li><p>定义一个切片,直接就指定具体数组,使用原理类似make的方式</p><pre><code class="go">  var strSlice []string = []string{&quot;tom&quot;, &quot;jack&quot;, &quot;mary&quot;}  fmt.Println(&quot;strSlice=&quot;, strSlice)  fmt.Println(&quot;strSlice size=&quot;, len(strSlice)) //3  fmt.Println(&quot;strSlice cap=&quot;, cap(strSlice)) // ?</code></pre></li></ul><p>上述方式1和2的区别：</p><ul><li>方式1是直接引用数组,这个数组是事先存在的,程序员是可见的</li><li>方式2是通过mak来创建切片,make会创建一个数组,是由切片在底层进行维护,程序员是看不见的。</li></ul><p>切片的<strong>遍历</strong>：</p><ul><li>for循环常规遍历</li><li>for-range结构遍历</li></ul><p>注意事项：</p><ul><li><p><code>cap</code>是一个内置函数,用于统计切片的容量,即最大可以存放多少个元素</p></li><li><p>切片定义完后,还不能使用,因为本身是一个空的,需要让其引用到一个数组或者make一个空间供切片来使用</p></li><li><p>切片可以继续切片(此时可以不用考虑切片底层的数据结构，即是在切完之后的切片上继续再切，但是所有的这些都是操作的同一片内存空间)</p></li><li><p>使用内置不定参函数<code>append</code>，可以对切片进行动态追加，append会调整切片的长度</p><pre><code class="go">  var slice3 []int = []int{100, 200, 300}  //通过append直接给slice3追加具体的元素  slice3 = append(slice3, 400, 500, 600)  fmt.Println(&quot;slice3&quot;, slice3) //100, 200, 300,400, 500, 600  //通过append将切片slice3追加给slice3  slice3 = append(slice3, slice3...) // 100, 200, 300,400, 500, 600 100, 200, 300,400, 500, 600  fmt.Println(&quot;slice3&quot;, slice3)</code></pre><ul><li>切片 append操作的本质就是对数组扩容</li><li>go底层会创建一下新的数组 newArr(安装扩容后大小)</li><li>将slice原来包含的元素拷贝到新的数组 newArr</li><li>slice重新引用到 newArr</li><li>注意 newArr是在底层来维护的,程序员不可见</li></ul></li><li><p>使用内置函数<code>copy</code>复制切片中的元素，复制前需声明一个和目标切片类型一致的切片（切片长度没要求，按照小的算）</p><ul><li><p>copy(para1,para2)：para1和para2均为切片类型，从para2拷贝至para1</p><pre><code class="go">  var slice4 []int = []int{1, 2, 3, 4, 5}  var slice5 = make([]int, 10)  copy(slice5, slice4)  fmt.Println(&quot;slice4=&quot;, slice4)// 1, 2, 3, 4, 5  fmt.Println(&quot;slice5=&quot;, slice5) // 1, 2, 3, 4, 5, 0 , 0 ,0,0,0</code></pre></li><li><p>copy会创建一个新的副本</p></li></ul></li><li><p>使用内置不定参函数<code>append</code>删除元素，append会调整切片的长度，元素的排列顺序不会发生变化</p><ul><li>注意append删除最后的<code>...</code></li></ul></li></ul><pre><code class="go">//make(数据类型,长度)var cheeses = make([]string,2)cheeses[0] = &quot;hello&quot;cheeses[1] = &quot;world&quot;cheeses := append(cheeses,&quot;hi&quot;)//创建新的元素，索引为2cheeses := append(cheeses,&quot;hi1&quot;,&quot;hi2&quot;,&quot;hi3&quot;)fmt.Println(len(cheeses))//打印长度cheeses := append(cheeses[:2],cheeses[2+1:]...)//删除索引为2的元素fmt.Println(len(cheeses))//打印长度//开始复制var smellyCheeses = make([]string,2)copy(smellyCheeses,cheeses)</code></pre><h4 id="5-2string和slice"><a href="#5-2string和slice" class="headerlink" title="5.2string和slice"></a>5.2string和slice</h4><ul><li><p>string底层是一个byte数组,因此 string也可以进行切片处理</p></li><li><p>string和切片在内存的形式,以”abcd”画出内存示意图<img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200104225130095.png" alt="内存示意图"></p></li><li><p>string是不可变的,也就说<strong>不能</strong>通过str[0]=‘z’方式来修改字符串</p></li><li><p>如果需要修改出字符串,可以先将 string -&gt; []byte或者[]rune-&gt;修改-&gt;重写转成string.</p><pre><code class="go">  str := &quot;hello@atguigu&quot;  //&quot;hello@atguigu&quot; =&gt;改成 &quot;zello@atguigu&quot;  arr1 := []byte(str)  arr1[0] = &#39;z&#39;  str = string(arr1)  fmt.Println(&quot;str=&quot;, str)  // 细节，我们转成[]byte后，可以处理英文和数字，但是不能处理中文  // 原因是 []byte 字节来处理 ，而一个汉字，是3个字节，因此就会出现乱码  // 解决方法是 将  string 转成 []rune 即可， 因为 []rune是按字符处理，兼容汉字  arr1 := []rune(str)  arr1[0] = &#39;北&#39;  str = string(arr1)  fmt.Println(&quot;str=&quot;, str)</code></pre></li></ul><h4 id="5-3多维数组（二维数组）"><a href="#5-3多维数组（二维数组）" class="headerlink" title="5.3多维数组（二维数组）"></a>5.3多维数组（二维数组）</h4><p>使用：</p><ul><li><p>先声明在赋值</p><ul><li><p>语法：var 数组名 [大小][大小]类型</p><pre><code class="go">  /*  0 0 0 0 0 0  0 0 1 0 0 0  0 2 0 3 0 0  0 0 0 0 0 0  */  //定义/声明二维数组  var arr [4][6]int  //赋初值  arr[1][2] = 1  arr[2][1] = 2  arr[2][3] = 3  fmt.Println(arr)</code></pre></li></ul></li><li><p>直接初始化</p><ul><li><p>语法：var 数组名 [大小][大小]类型 = [大小][大小]类型{ {初值},{初值…} }</p><pre><code class="go">  //arr3 [2][3]int = [2][3]int{{1,2,3}, {4,5,6}}  arr3  := [2][3]int{{1,2,3}, {4,5,6}}  fmt.Println(&quot;arr3=&quot;, arr3)</code></pre></li></ul></li><li><p>其他几种写法（类似一维数组）</p><ul><li>var 数组名 [大小][大小]类型 = [大小][大小]类型{ {初值},{初值…} }</li><li>var 数组名 [大小][大小]类型 = […][大小]类型{ {初值},{初值…} }</li><li>var 数组名 = [大小][大小]类型{ {初值},{初值…} }</li><li>var 数组名 = […][大小]类型{ {初值},{初值…} }</li></ul></li></ul><p>内存布局：</p><pre><code class="go">var arr2 [2][3]int //以这个为例来分析arr2在内存的布局!!arr2[1][1] = 10fmt.Println(arr2)fmt.Printf(&quot;arr2[0]的地址%p\n&quot;, &amp;arr2[0])//第一行首地址fmt.Printf(&quot;arr2[1]的地址%p\n&quot;, &amp;arr2[1])//第二行首地址fmt.Printf(&quot;arr2[0][0]的地址%p\n&quot;, &amp;arr2[0][0])fmt.Printf(&quot;arr2[1][0]的地址%p\n&quot;, &amp;arr2[1][0])</code></pre><p><img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200105113017051.png" alt="二维数组内存布局示意图"></p><p>遍历：</p><ul><li><p>双层for循环</p></li><li><p>for-range方式遍历</p><pre><code class="go">  var arr3  = [2][3]int{{1,2,3}, {4,5,6}}  for i, v := range arr3 {//遍历行      for j, v2 := range v {//遍历行中的元素          fmt.Printf(&quot;arr3[%v][%v]=%v \t&quot;,i, j, v2)      }      fmt.Println()  }</code></pre></li></ul><h4 id="5-4映射map"><a href="#5-4映射map" class="headerlink" title="5.4映射map"></a>5.4映射map</h4><p>map是 key-value数据结构,又称为字段或者关联数组。类似其它编程语言的集合,在编程中是经常使用到。</p><p>map是一个无序的结构，不会按照keytype或者valuetype进行排序</p><p>可以通过内置函数<code>len</code>获取map的长度</p><p>语法：<code>var 变量名 map[keytype]valuetype</code></p><ul><li>keytype：可以是很多种类型,比如bool,数字, string,指针, channel,还可以是只包含前面几个类型的接口,结构体,数组（keytype通常为int、 string）<ul><li>注意:slice,map还有 function不可以,因为这几个没法用==来判断</li></ul></li><li>valuetype：类型和keytype基本一致（valuetype通常为数字（整数、浮点）、string、map、struct）</li></ul><p>声明：</p><ul><li>var a map[string]string</li><li>var a map[string]int</li><li>var a map[int]string</li><li>var a map[string]map[string]string</li><li>声明<strong>不会分配内存</strong>，初始化需要<strong>make</strong>，分配内存后才能赋值和使用<ul><li>make(数据类型，大小)</li><li>a = make(map[string]string, 10)</li></ul></li></ul><p>使用方式：</p><ul><li><p>先声明再make</p><pre><code class="go">  var a map[string]string  //在使用map前，需要先make , make的作用就是给map分配数据空间  a = make(map[string]string, 10)</code></pre></li><li><p>声明的同时make</p><pre><code class="go">  cities := make(map[string]string)  cities[&quot;no1&quot;] = &quot;北京&quot;  cities[&quot;no2&quot;] = &quot;天津&quot;</code></pre></li><li><p>声明时直接赋值</p><pre><code class="go">  heroes := map[string]string{      &quot;hero1&quot; : &quot;宋江&quot;,      &quot;hero2&quot; : &quot;卢俊义&quot;,      &quot;hero3&quot; : &quot;吴用&quot;,  }  heroes[&quot;hero4&quot;] = &quot;林冲&quot;</code></pre></li></ul><p>增删改查：</p><ul><li><p>增加和更新</p><ul><li>map[key] = value //如果key还没有,就是增加,如果key存在就是修改</li></ul></li><li><p>删除</p><ul><li>内置函数<code>delete</code>：<code>delete(map,&quot;key&quot;)</code>, 如果key存在,就删除该 key-value，如果key不存在，不操作，但是也不会报错</li><li>如果要删除所有元素：<ul><li>遍历后一一delete</li><li>map = make()，make一个新的，让原来的成为垃圾，被gc回收</li></ul></li></ul></li><li><p>查找</p><ul><li><p>直接找</p><pre><code class="go">  val, ok := cities[&quot;no2&quot;]  if ok {      fmt.Printf(&quot;有no1 key 值为%v\n&quot;, val)  } else {      fmt.Printf(&quot;没有no1 key\n&quot;)  }</code></pre></li></ul></li></ul><p>遍历（只能for-range）：</p><pre><code class="go">studentMap := make(map[string]map[string]string)studentMap[&quot;stu01&quot;] =  make(map[string]string, 3)studentMap[&quot;stu01&quot;][&quot;name&quot;] = &quot;tom&quot;studentMap[&quot;stu01&quot;][&quot;sex&quot;] = &quot;男&quot;studentMap[&quot;stu01&quot;][&quot;address&quot;] = &quot;北京长安街~&quot;studentMap[&quot;stu02&quot;] =  make(map[string]string, 3) //这句话不能少!!studentMap[&quot;stu02&quot;][&quot;name&quot;] = &quot;mary&quot;studentMap[&quot;stu02&quot;][&quot;sex&quot;] = &quot;女&quot;studentMap[&quot;stu02&quot;][&quot;address&quot;] = &quot;上海黄浦江~&quot;for k1, v1 := range studentMap {    fmt.Println(&quot;k1=&quot;, k1)//k1= stu01    for k2, v2 := range v1 {        fmt.Printf(&quot;\t k2=%v v2=%v\n&quot;, k2, v2)//k2=address v2=北京长安街~    }    fmt.Println()}</code></pre><p>注意事项：</p><ul><li>map是<strong>引用</strong>类型,遵守引用类型传递的机制,在一个函数接收map,修改后,会直接修改原来的map</li><li>map的容量达到后,再想map增加元素,会自动扩容（无需借助其他函数，也不用管make中指定的大小）,并不会发生 panic,也就是说map能<strong>动态</strong>的增长键值对( key-value）</li><li>map的value也经常使用 <strong>struct类型</strong>,更适合管理复杂的数据(比前面value是一个map更好),比如value为 Student结构体</li></ul><h4 id="5-5map切片及排序"><a href="#5-5map切片及排序" class="headerlink" title="5.5map切片及排序"></a>5.5map切片及排序</h4><p>map切片：</p><p>切片的数据类型如果是map,则我们称为 slice of map,map切片,这样使用则map的个数就可以动态变化（利用append）</p><pre><code class="go">//1. 声明一个map切片var monsters []map[string]stringmonsters = make([]map[string]string, 2) //准备放入两个妖怪//2. 增加第一个妖怪的信息if monsters[0] == nil {    monsters[0] = make(map[string]string, 2)    monsters[0][&quot;name&quot;] = &quot;牛魔王&quot;    monsters[0][&quot;age&quot;] = &quot;500&quot;}if monsters[1] == nil {    monsters[1] = make(map[string]string, 2)    monsters[1][&quot;name&quot;] = &quot;玉兔精&quot;    monsters[1][&quot;age&quot;] = &quot;400&quot;}// 下面这个写法越界。// if monsters[2] == nil {//     monsters[2] = make(map[string]string, 2)//     monsters[2][&quot;name&quot;] = &quot;狐狸精&quot;//     monsters[2][&quot;age&quot;] = &quot;300&quot;// }//这里我们需要使用到切片的append函数，可以动态的增加monster//1. 先定义个monster信息newMonster := map[string]string{    &quot;name&quot; : &quot;新的妖怪~火云邪神&quot;,    &quot;age&quot; : &quot;200&quot;,}monsters = append(monsters, newMonster)fmt.Println(monsters)</code></pre><p>map排序：</p><ul><li>先将map的key 放入到 切片中</li><li>对切片排序</li><li>遍历切片，然后按照key来输出map的值</li></ul><p>例子：</p><pre><code class="go">map1 := make(map[int]int, 10)map1[10] = 100map1[1] = 13map1[4] = 56map1[8] = 90fmt.Println(map1)//如果按照map的key的顺序进行排序输出//1. 先将map的key 放入到 切片中//2. 对切片排序//3. 遍历切片，然后按照key来输出map的值var keys []intfor k, _ := range map1 {    keys = append(keys, k)}//排序sort.Ints(keys)//需要引入sort包fmt.Println(keys)for _, k := range keys{    fmt.Printf(&quot;map1[%v]=%v \n&quot;, k, map1[k])}</code></pre><h3 id="6-检测变量类型"><a href="#6-检测变量类型" class="headerlink" title="6.检测变量类型"></a>6.检测变量类型</h3><ul><li>依赖<code>reflect</code>包</li></ul><pre><code class="go">var s string = &quot;string&quot;reflect.TypeOf(s)</code></pre><h3 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7.类型转换"></a>7.类型转换</h3><p>字符串和其他类型互换：</p><ul><li>依赖<code>strconv</code>包</li></ul><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><ul><li><p>使用关键字<code>var</code>声明</p></li><li><p>声明后不能再次声明，但是可以重新赋值</p></li><li><p>变量声明后若未给与指定值将会设为默认值，不同变量类型默认值不一样，这种默认值称为<strong>零值</strong></p></li></ul><h3 id="1-快捷声明"><a href="#1-快捷声明" class="headerlink" title="1.快捷声明"></a>1.快捷声明</h3><p>多个同类型变量：</p><pre><code class="go">var s,t string = &quot;foo&quot;,&quot;bar&quot;</code></pre><p>多个<strong>不</strong>同类型变量：</p><pre><code class="go">//全局var{    s string = &quot;foo&quot;    i int = 4}//或(函数内部)n1,name,n3 := 100,&quot;tom&quot;,80var n1,name,n3 := 100,&quot;tom&quot;,80</code></pre><h3 id="2-简短声明"><a href="#2-简短声明" class="headerlink" title="2.简短声明"></a>2.简短声明</h3><ul><li>编译器会自动推断变量类型</li><li>只能在<strong>函数</strong>中使用</li></ul><pre><code class="go">s := &quot;hello World&quot;</code></pre><h3 id="3-省略变量名声明"><a href="#3-省略变量名声明" class="headerlink" title="3.省略变量名声明"></a>3.省略变量名声明</h3><pre><code class="go">var s = &quot;hello World&quot;</code></pre><ul><li>一般来说在函数内使用简短声明，在函数外省略变量名声明</li></ul><h3 id="4-指针"><a href="#4-指针" class="headerlink" title="4.指针"></a>4.指针</h3><ul><li>&amp;：取地址</li><li>*变量名：指针，eg：*int：int类型指针</li><li>*指针：取指针中的值</li><li>详见第五章</li></ul><h3 id="5-常量"><a href="#5-常量" class="headerlink" title="5.常量"></a>5.常量</h3><ul><li>可以引用，但是不能修改</li><li>关键字<code>const</code>修饰</li><li>定义时就必须初始化</li><li>常量只能修饰bool、数字类型（int、float）、string类型</li></ul><pre><code class="go">const str string = &quot;hello&quot;</code></pre><p>注意事项：</p><pre><code class="go">//简洁的写法：const(    a = 1    b = 2)//专业的写法：const(    a = iota//a = 0    b//在上述基础上+1 b=1    c//在上述基础上+1 c=2)</code></pre><ul><li>golang中没有常量名必须字母大写的规定</li><li>仍然通过首字母的大小写来控制常量的访问范围</li></ul><h2 id="三、函数和包"><a href="#三、函数和包" class="headerlink" title="三、函数和包"></a>三、函数和包</h2><h3 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1.基本格式"></a>1.基本格式</h3><ul><li>关键字<code>func</code>修饰</li><li>函数签名：函数的第一行，即<code>func 函数名(变量类型1 参数1,变量类型2 参数2,...) 返回值类型</code></li></ul><pre><code class="go">func 函数名(参数1 变量类型1,参数2 变量类型2,...) (返回值类型) {    函数体    return 返回值列表}</code></pre><p>eg：</p><p>多个返回值：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)//输入为空，返回一个int一个stringfunc getPrice() (int,string) {    i := 2    s := &quot;goldfish&quot;    return i,s}func main() {    quantity,prize := getPrice()    fmt.Println(&quot;You won %v %v\n&quot;,quantity,prize)}</code></pre><p>注意事项：</p><ul><li>基本数据类型和<strong>数组</strong>都是<strong>值传递</strong>，在函数内修改不会影响到原来的值</li><li>如果希望函数内的变量能修改函数外的变量,可以传入变量的地址&amp;,函数内以指针的方式操作变量。从效果上看类似引用</li><li>不支持传统的函数重载</li><li>函数本身也是一种数据类型，可以作为形参并且调用</li><li>go支持自定义数据类型<ul><li>语法：<code>type 自定义数据类型名 数据类型</code></li></ul></li><li>支持函数返回值命名</li><li>使用<code>_</code><strong>标识符</strong>，忽略返回值</li><li>支持可变参数<ul><li>args是slice切片,通过args[index]可以访间到各个值。</li><li>可变参数需要放在形参列表的最后一个</li></ul></li></ul><h3 id="2-不定参数函数"><a href="#2-不定参数函数" class="headerlink" title="2.不定参数函数"></a>2.不定参数函数</h3><ul><li>使用<code>...</code>指定不定参</li></ul><p>eg：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)//numbers为一个包含所有参数的切片func sumNumbers(numbers... int) int {    total := 2    for _,number := range numbers{        total += number    }    return total}func main() {    result := sumNumbers(1,2,3,4)    fmt.Println(result)}</code></pre><h3 id="3-具名返回值"><a href="#3-具名返回值" class="headerlink" title="3.具名返回值"></a>3.具名返回值</h3><ul><li>函数返回前将赋值给具名变量</li><li>无需显示的返回相应的变量</li></ul><pre><code class="go">func sayHi() (x,y string) {    x := &quot;hello&quot;    y := &quot;world&quot;    return}</code></pre><h3 id="4-init函数"><a href="#4-init函数" class="headerlink" title="4.init函数"></a>4.init函数</h3><p>每一个源文件都可以包含一个init函数,该函数会在main函数执行前,被Go运行框架调用,也就是说init会在main函数前被调用。</p><p>注意事项：</p><ul><li>如果一个文件同时包含全局变量定义,init函数和main函数,则执行的流程是：<strong>全局变量定义-&gt;init函数-&gt;main函数</strong></li><li>init函数最主要的作用,就是完成一些初始化的工作</li><li>如果main.go和main包含的其他包中都有init函数，首先应优先执行包含包中的变量定义-&gt;init函数-&gt;main中变量定义-&gt;init函数-&gt;main函数</li></ul><h3 id="5-匿名函数"><a href="#5-匿名函数" class="headerlink" title="5.匿名函数"></a>5.匿名函数</h3><p>Go支持匿名函数,如果我们某个函数只是希望使用一次,可以考虑使用匿名函数,匿名函数也可以实现多次调用</p><p>全局匿名函数：如果将匿名函数赋给一个全局变量,那么这个匿名函数,就成为一个全局匿名函数,可以在程序有效。</p><p>使用方式：</p><ul><li><p>在定义匿名函数时就直接调用</p><pre><code class="go">  res := func(n1 int,n2 int) int {      return n1 + n2  }(10,20)</code></pre></li><li><p>将匿名函数赋给一个变量(函数变量),再通过该变量来调用匿名函数</p><pre><code class="go">  a := func(n1 int,n2 int) int {      return n1 + n2  }//a的数据类型就是函数类型  res := a(10,20)</code></pre></li></ul><h3 id="6-内置函数"><a href="#6-内置函数" class="headerlink" title="6.内置函数"></a>6.内置函数</h3><ul><li>len</li><li>new：用来分配内存,主要用来分配值类型,比如int、foat32、struct。返回的是指针</li><li>make：用来分配内存,主要用来分配引用类型,比如chan、map、 slice。</li></ul><h3 id="7-包"><a href="#7-包" class="headerlink" title="7.包"></a>7.包</h3><ul><li>包的本质实际上就是创建不同的文件夹,来存放程序文件。</li><li>基本概念：go的每一个文件都是属于一个包的,也就是说go是以包的形式来管理文件和项目目录结构的</li><li>作用：<ul><li>区分相同名字的函数、变量等标识符</li><li>当程序文件很多时,可以很好的管理项目</li><li>控制函数、变量等访问范围,即作用域（首字母大写共有，小写私有）</li></ul></li></ul><p>语法：</p><pre><code class="go">//打包：package 包名//引入包：import &quot;包的路径&quot;//调用包中的函数包名.函数名()</code></pre><p>细节说明：</p><ul><li><p>在给一个文件打包时,该包对应一个文件夹,比如这里的utis文件夹对应的包名就是 utils,文件的包名通常和文件所在的文件夹名一致,般为小写字母。</p><ul><li>不一致的话，调用包中的函数时，包名就得变更为具体的包名</li><li>import导入的在某种意义上相当于导入包所在的路径</li></ul></li><li><p>使用前需要先引用对应的包</p></li><li><p>打包指令应该在第一行然后才能是import指令</p></li><li><p>在import包时,路径从<code>$GOPATH</code>的src下开始,不用带src,编译器会自动从src下开始引入</p></li><li><p>首字母大写共有，小写私有</p></li><li><p>在访问其它包函数时,其语法是<code>包名.函数名</code></p></li><li><p>go支持给包取别名</p><ul><li><p>别名后只能通过<code>别名.函数名</code>访问</p><pre><code class="go">import(  &quot;fmt&quot;  util &quot;go_code/chapter06/fundemo01/utils&quot;//取别名为util)func main(){  util.Cal()//只能通过别名.函数名调用}</code></pre></li></ul></li><li><p>在<strong>同一包下</strong>（可以是不同文件）,不能有相同的函数名和全局变量名,否则报重复定义</p></li><li><p>如果你要编译成一个可执行程序文件,就需要将这个包声明为man,即 package main，这就是一个语法规范。如果你是写一个库,包名可以自定</p><ul><li>main包只有一个</li><li>编译后生成一个有默认名的可执行文件,在<code>$GOPATH</code>目录下,可以指定名字和目录,比如:放在bin目录下:<code>D: goproject&gt; gobuild -o bin/my.exe go_code/chapter06/fundemo01/main</code></li></ul></li></ul><h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h3><p>闭包就是<strong>一个函数</strong>和与其<strong>相关的引用环境</strong>组合的一个整体(实体)</p><pre><code class="go">func AddUpper() func (int) int {    var n int = 10    return func (x int) int {        n = n + x        return n    }}func main() {    f := AddUpper()//这里可以理解为初始化闭包中的一些变量 这里的传参是给闭包的    fmt.Println(f(1))//11 这里的传参是给闭包中的函数的    fmt.Println(f(2))//13    fmt.Println(f(3))//16}</code></pre><ul><li>返回的是一个匿名函数,但是这个匿名函数引用到函数外的n因此这个匿名函数就和n形成个整体,构成闭包</li><li>可以这样理解：闭包是类，函数是操作，n是字段。函数和它使用到的n构成闭包</li><li>当我们反复的调用f函数时,因为n<strong>只初始化一次</strong>,因此每调一次就进行累计<ul><li>闭包中的变量只会初始化一次且会一直保存</li></ul></li><li>我们要搞清楚闭包的关键,就是要分析出返回的函数它使用(引用)到哪些变量,因为函数和它引用到的变量共同构成闭包。</li></ul><h2 id="四、控制流程"><a href="#四、控制流程" class="headerlink" title="四、控制流程"></a>四、控制流程</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a>1.if</h3><ul><li>支持在if条件中直接定义一个变量</li><li>大括号不能省</li><li>条件可以用小括号，但是不推荐</li></ul><pre><code class="go">if 套件表达式 {    执行语句}//=======================if 套件表达式 {    执行语句a}else{    执行语句b}//=======================if 套件表达式1 {    执行语句a}else if 条件表达式2 {    执行语句b}</code></pre><h4 id="1-1运算符"><a href="#1-1运算符" class="headerlink" title="1.1运算符"></a>1.1运算符</h4><h5 id="1-1-1比较"><a href="#1-1-1比较" class="headerlink" title="1.1.1比较"></a>1.1.1比较</h5><ul><li>双方需要类型一致</li></ul><table><thead><tr><th>字符</th><th>运算符</th></tr></thead><tbody><tr><td>==</td><td></td></tr><tr><td>!=</td><td></td></tr><tr><td>&lt;</td><td></td></tr><tr><td>&lt;=</td><td></td></tr><tr><td>&gt;</td><td></td></tr><tr><td>&gt;=</td><td></td></tr></tbody></table><h5 id="1-1-2算术"><a href="#1-1-2算术" class="headerlink" title="1.1.2算术"></a>1.1.2算术</h5><ul><li>双方需要类型一致</li></ul><table><thead><tr><th>字符</th><th>运算符</th></tr></thead><tbody><tr><td>+</td><td></td></tr><tr><td>-</td><td></td></tr><tr><td>*</td><td></td></tr><tr><td>/</td><td></td></tr><tr><td>%</td><td>余（模）</td></tr></tbody></table><h5 id="1-1-3逻辑"><a href="#1-1-3逻辑" class="headerlink" title="1.1.3逻辑"></a>1.1.3逻辑</h5><table><thead><tr><th>字符</th><th>运算符</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td></tr><tr><td>||</td><td>或</td></tr><tr><td>!</td><td>非</td></tr></tbody></table><h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><pre><code class="go">switch 变量值 {    case 值1,值2:        相关操作    case 值:         相关操作    default:        相关操作}</code></pre><ul><li><code>fallthrough</code>：switch穿透，如果在case语句块后增加fallthrough,则会继续执行下一个case</li><li>Type Switch: switch语句还可以被用于 type-switch来判断某个 interface变量中实际指向的变量类型</li></ul><h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><p>语法格式：</p><pre><code class="go">for 循环变量初始化;循环条件;循环变量迭代 {    循环操作(语句)}</code></pre><ul><li>可以配合<strong>break</strong>退出循环</li><li>beak语句出现在多层嵌套的语句块中时,可以<strong>通过标签</strong>指明要终止的是哪层语句块</li><li>可以配合<strong>continue</strong>退出<strong>本次</strong>循环</li><li>continue语句出现在多层嵌套的语句块中时,可以<strong>通过标签</strong>指明要跳过的是哪层语句块</li><li>可以通过<strong>goto</strong>语句可以无条件地转移到程序中指定的行<ul><li>在Go程序设计中般不主张使用goto语句,以免造成程序流程的混乱,使理解和调试程序都产生困难</li></ul></li></ul><pre><code class="go">for i &lt; 10 {    i++    相关操作}</code></pre><p>初始化语句：</p><pre><code class="go">for i := 0;i &lt; 10; i++ {    相关操作}</code></pre><p>遍历数组：</p><pre><code class="go">for i,n := range numbers {    相关操作}</code></pre><p>遍历字符串：</p><pre><code class="go">for i := 0,n := len(str);i++ {//按照字节处理，如有中文会乱码    相关操作}//--------------------------------------str1 = []rune(str)//解决中文乱码，将str转成切片for i := 0,n := len(str1);i++ {    相关操作}//--------------------------------------for index,val := range str {//按照编码方式处理，中文不会有问题    相关操作}</code></pre><h3 id="4-defer"><a href="#4-defer" class="headerlink" title="4.defer"></a>4.defer</h3><p>在函数中,程序员经常需要创建资源比如:数据库连接、文件句柄、锁等),为了在函数执行完后及时的释放资源,Go的设计者提供 defer（延时机制）</p><ul><li>用于执行清理操作或者确保操作完成后<strong>再执行</strong>另一个函数<ul><li>即，在defer所在的函数执行完毕后<strong>执行另一个函数</strong></li></ul></li><li>多条defer语句的输出将按照与defer出现的顺序<strong>相反的顺序</strong>执行</li></ul><p>例子：</p><pre><code class="go">func sum(n1 int, n2 int) int {    //当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈(假设为defer栈)    //当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行    defer fmt.Println(&quot;ok1 n1=&quot;, n1) //defer 3. ok1 n1 = 10    defer fmt.Println(&quot;ok2 n2=&quot;, n2) //defer 2. ok2 n2= 20    //增加一句话    n1++ // n1 = 11    n2++ // n2 = 21    res := n1 + n2 // res = 32    fmt.Println(&quot;ok3 res=&quot;, res) // 1. ok3 res= 32    return res}func main() {    res := sum(10, 20)    fmt.Println(&quot;res=&quot;, res)  // 4. res= 32}</code></pre><p>注意：</p><ul><li>当go执行到一个 defer时,不会立即执行 defer后的语句,而是将defer后的语句压入到一个栈中[暂时称该栈为 defer栈]然后继续执行函数下一个语句</li><li>当函数执行完毕后,在从 defer栈中,依次从栈顶取出语句执行(注:遵守栈先入后出的机制)。</li><li>在 defer将语句放入到栈时,也会将相关的值拷贝同时入栈。</li></ul><h2 id="五、结构体和指针"><a href="#五、结构体和指针" class="headerlink" title="五、结构体和指针"></a>五、结构体和指针</h2><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h3><p>面向对象编程说明：</p><ul><li>Galang也支持面向对象编程(OOP),但是和传统的面向对象编程有区别,并不是纯粹的面向对象语言。所以我们说 Galang支持<strong>面向对象编程特性</strong>是比较准确的。</li><li>Galang没有类（class）,Go语言的结构体( struct)和其它编程语言的类（class）有同等的地位,你可以理解 Galang是基于 struct来实现OOP特性的</li><li>Galang面向对象编程非常简洁,<strong>去掉</strong>了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等等</li><li>Galang仍然有面向对象编程的继承,封装和多态的特性,只是实现的方式和其它OOP语言不一样,比如<strong>继承</strong>: Galang没有 extends关键字,继承是通过匿名字段来实现</li><li>Galang面向对象(OOP)很优雅,OOP本身就是语言类型系统( type system)的一部分,通过接口 (interface)关联,<strong>耦合性低</strong>,也非常灵活。也就是说在 Galang中<strong>面向接口编程</strong>是非常重要的特性</li></ul><p>结构体是<strong>值类型</strong>，其在内存中的布局如下所示：</p><p><img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200105163550051.png" alt="内存中的布局"></p><h4 id="1-1声明"><a href="#1-1声明" class="headerlink" title="1.1声明"></a>1.1声明</h4><pre><code class="go">type 结构体名称 struct{    字段名称 字段类型    ......}//结构体名称首字母大小：结构体能够在其他包中被使用//结构体中字段名称首字母大小：字段能够在其他包中被使用</code></pre><ul><li>字段/属性：结构体字段=属性= field，字段是结构体的一个组成部分,一般是基本数据类型、数组,也可是引用类型。<ul><li>字段声明同变量</li><li>在创建一个结构体变量后,如果没有给字段赋值,都对应一个零值(默认值),规则同前面讲的一样</li><li>同结构体变量的字段是独立,互不影响,一个结构体变量字段的更改,不影响另外一个。</li></ul></li><li>关键字<code>type</code>指定一种新类型</li><li>关键字<code>struct</code>指定为结构体</li><li>可以使用关键字<code>new</code>创建结构体实例</li><li>使用<code>.</code>访问结构体中的成员</li><li>声明或创建后不能再修改其成员的数据类型</li><li>每个字段独占一行时，最后一个字段结尾必须加逗号</li><li>结构体可以嵌套</li></ul><pre><code class="go">//声明type Movie struct{    Name string    Rating float32}//创建var m Moviem.Name = &quot;Metropoils&quot;m.Rating = 0.9918//new创建x := new(Movie)//返回的其实是个指针//(*x).Name = &quot;Metropoils&quot;//标准写法//(*x).Rating = 0.99x.Name = &quot;Metropoils&quot;//go的设计者 为了程序员使用方便，底层会对 x.Name = &quot;Metropoils&quot; 进行处理,会给 x 加上 取值运算 (*x).Name = &quot;Metropoils&quot;x.Rating = 0.99//使用简短变量赋值，可以省略newn := Movie{    Name:&quot;Citizen Kane&quot;,    Rating:10,//每个字段独占一行时，最后一个字段结尾必须加逗号}n := Movie{Name:&quot;Citizen Kane&quot;,Rating:10}//注意逗号n := Movie{&quot;Citizen Kane&quot;,10}//可以省略字段名，不推荐//另一种创建方式//var movie *Movie = &amp;Movie{&quot;Metropoils&quot;,0.45}//创建时直接赋值也是可以的var movie *Movie = &amp;Movie{}//返回结构体指针//(*movie).Name = &quot;Metropoils&quot;//标准写法movie.Name = &quot;Metropoils&quot;//输出fmt.Println(&quot;%+v\n&quot;,m)</code></pre><ul><li>结构体指针访问字段的标准方式应该是:<code>(*结构体指针).字段名</code></li><li>go做了一个简化,也支持<code>结构体指针.字段名</code>,更加符合程序员使用的习惯,go编译器底层对<code>结构体指针.字段名</code>做了<strong>转化</strong><code>(*结构体指针).字段名</code></li><li><code>(*结构体指针).字段名</code><strong>不能写成</strong><code>*结构体指针.字段名</code>：<code>.</code>的优先级高于<code>*</code></li></ul><h4 id="1-2自定义结构体字段的默认值"><a href="#1-2自定义结构体字段的默认值" class="headerlink" title="1.2自定义结构体字段的默认值"></a>1.2自定义结构体字段的默认值</h4><ul><li>可以利用自定义函数（构造函数）专门来给自定义的结构体赋自定义的默认值</li></ul><table><thead><tr><th>类型</th><th>零值（默认值）</th></tr></thead><tbody><tr><td>布尔型</td><td>flase</td></tr><tr><td>整形</td><td>0</td></tr><tr><td>浮点型</td><td>0.0</td></tr><tr><td>字符串</td><td>“”</td></tr><tr><td>指针</td><td>nil</td></tr><tr><td>函数</td><td>nil</td></tr><tr><td>接口</td><td>nil</td></tr><tr><td>切片slice</td><td>nil</td></tr><tr><td>通道</td><td>nil</td></tr><tr><td>映射map</td><td>nil</td></tr></tbody></table><h4 id="1-3结构体比较"><a href="#1-3结构体比较" class="headerlink" title="1.3结构体比较"></a>1.3结构体比较</h4><ul><li>只能比较字段均一致的结构体<ul><li>可以使用<code>reflect</code>包检查结构体类型</li></ul></li><li>只有==和!=</li><li>结构体或字段的首字母大写才能导出（公有值）</li></ul><h4 id="1-4结构体注意事项"><a href="#1-4结构体注意事项" class="headerlink" title="1.4结构体注意事项"></a>1.4结构体注意事项</h4><ul><li><p>结构体的所有字段在内存中是连续的</p></li><li><p>结构体是用户单独定义的类型,和其它类型进行转换时（利用强制类型转化）需要有<strong>完全</strong>相同的字段（名字、个数和类型）</p></li><li><p>结构体进行type重新定义(相当于取别名), Golang认为是新的数据类型,但是相互间可以<strong>强制类型转化</strong></p></li><li><p>struct的每个字段上,可以写上一个tag,该tag可以通过<strong>反射机制</strong>获取,常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong></p><pre><code class="go">  package main  import &quot;fmt&quot;  import &quot;encoding/json&quot;  type A struct {      Num int  }  type B struct {      Num int  }  type Monster struct{      Name string `json:&quot;name&quot;` // `json:&quot;name&quot;` 就是 struct tag      Age int `json:&quot;age&quot;`      Skill string `json:&quot;skill&quot;`  }  func main() {      var a A      var b B      a = A(b) // ? 可以转换，但是有要求，就是结构体的的字段要完全一样(包括:名字、个数和类型！)      fmt.Println(a, b)      //1. 创建一个Monster变量      monster := Monster{&quot;牛魔王&quot;, 500, &quot;芭蕉扇~&quot;}      //2. 将monster变量序列化为 json格式字串      //   json.Marshal 函数中使用反射，这个讲解反射时，会详细介绍      jsonStr, err := json.Marshal(monster)//若将Monster中的字段改成小写，就不能够调用（作用域限制），这里只能够用tag      if err != nil {          fmt.Println(&quot;json 处理错误 &quot;, err)      }      fmt.Println(&quot;jsonStr&quot;, string(jsonStr))  }</code></pre></li></ul><h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h3><pre><code class="go">type Movie struct{    Name string    Rating float32}a := Movie{    Name:&quot;Citizen Kane&quot;,    Rating:10,}b := a//值引用，拷贝副本到b中c := &amp;a//指针引用，c和a是一块内存区域，改变c，a也会变</code></pre><h2 id="六、方法和接口"><a href="#六、方法和接口" class="headerlink" title="六、方法和接口"></a>六、方法和接口</h2><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h3><ul><li>Galang中的<strong>方法</strong>是作用在<strong>指定的数据类型上</strong>的(即:和指定的数据类型绑定),因此<strong>自定义类型</strong>,都可以有方法,而不仅仅是 struct</li><li>与函数类似，有关键字<code>func</code>指定，会在func后添加另一个参数表</li><li>可以建立多个方法，构成方法集</li><li>方法和某个结构体紧密绑定，可以通过<code>结构体.方法名</code>的形式调用属于该结构体的方法</li><li>方法中的接受者类型类似<strong>一般用指针</strong>，以便直接修改结构体内部成员。如果不使用指针，修改后的值将不会保存，相当于拷贝了一份原结构体的副本来进行操作</li></ul><pre><code class="go">func (接受者参数 接受者类型) 方法名(参数列表) (返回值列表) {    函数体}//就相当于 该方法 和 接受者 进行了绑定</code></pre><ul><li>接受者类型type：表示这个方法和type这个类型进行绑定,或者说该方法作用于type类型</li><li>type可以是结构体,也可以其它的自定义类型</li><li>接受者参数：就是type的一个实例（变量）</li></ul><p>eg：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)type Sphere struct{    Radius float64    base float64}//SurfaceArea方法和*Sphere类型绑定//Sphere结构体的方法，指针类型，可以修改结构体中的值func (s *Sphere) SurfaceArea(f float64) float64 {    Sphere.base = f    return float64(4) * math.PI * (s.Radius * s.Radius)//s.Radius其实是(*s).Radius的简写}//Volume方法和Sphere类型绑定//Sphere结构体的方法，非指针类型，修改的是副本结构体中的值（结构体是值传递，会拷贝一份副本）func (s Sphere) Volume(f float64) {    Sphere.base = f    return}func main() {    s := Sphere{        Radius: 5,        base:3,    }    fmt.Println(s.SurfaceArea(4))//会修改s.base的值    //实际上是(&amp;s).SurfaceArea(4) 只不过编译器底层会将s.SurfaceArea(4)优化成(&amp;s).SurfaceArea(4)    s.Volume(4)//不会修改s.base的值}</code></pre><ul><li>方法的调用和传参机制和函数基本一样,不一样的地方是方法调用时会将<strong>调用方法的变量</strong>,当做实参也传递给方法。</li></ul><p>结构体创建及赋值：</p><pre><code class="go">//方式1//在创建结构体变量时，就直接指定字段的值var stu1 = Stu{&quot;小明&quot;, 19} // stu1---&gt; 结构体数据空间stu2 := Stu{&quot;小明~&quot;, 20}//在创建结构体变量时，把字段名和字段值写在一起, 这种写法，就不依赖字段的定义顺序.var stu3 = Stu{    Name :&quot;jack&quot;,    Age : 20,}stu4 := Stu{    Age : 30,    Name : &quot;mary&quot;,}fmt.Println(stu1, stu2, stu3, stu4)//方式2， 返回结构体的指针类型(!!!)var stu5 *Stu = &amp;Stu{&quot;小王&quot;, 29}  // stu5--&gt; 地址 ---》 结构体数据[xxxx,xxx]stu6 := &amp;Stu{&quot;小王~&quot;, 39}//在创建结构体指针变量时，把字段名和字段值写在一起, 这种写法，就不依赖字段的定义顺序.var stu7 = &amp;Stu{    Name : &quot;小李&quot;,    Age :49,}stu8 := &amp;Stu{    Age :59,    Name : &quot;小李~&quot;,}fmt.Println(*stu5, *stu6, *stu7, *stu8)</code></pre><p>注意事项：</p><ul><li>结构体类型是值类型,在方法调用中,遵守<strong>值类型</strong>的传递机制,是值拷贝传递方式</li><li>如程序员希望在方法中,修改结构体变量的值,可以通过<strong>结构体指针</strong>的方式来处理</li><li>Golang中的方法作用在<strong>指定的数据类型</strong>上的(即:和指定的数据类型绑定)因此<strong>自定义类型</strong>,都可以有方法,而不仅仅是 struct,比如int,foat32等都可以有方法</li><li>方法的访问范围控制的规则,和函数一样。方法名首字母小写,只能在本包访问,方法首字母大写,可以在本包和其它包访问。</li><li>如果一个变量实现了<strong>String()</strong>这个方法,那么 fmt.Println默认会调用这个变量的String()进行输出（这里的类型必须一样，若绑定的方法接受者类型为指针，则输入参数一定要加&amp;）</li></ul><p>方法和函数的区别：</p><ul><li><p>调用方式不一样</p><ul><li>函数：函数名(实参列表)</li><li>方法：变量.方法名(实参列表)</li></ul></li><li><p>对于普通函数,接收者为值类型时,不能将指针类型的数据直接传递,反之亦然</p></li><li><p>对于方法(如 struct的方法),接收者为值类型时,可以直接用指针类型的变量调用方法,反过来同样也可以。最终的决定权在方法的<strong>接受者类型</strong>上</p><pre><code class="go">  type Person struct {      Name string  }  //对于方法（如struct的方法），  //接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以  func (p Person) test03() {      p.Name = &quot;jack&quot;      fmt.Println(&quot;test03() =&quot;, p.Name) // jack  }  func (p *Person) test04() {      p.Name = &quot;mary&quot;      fmt.Println(&quot;test03() =&quot;, p.Name) // mary  }  func main() {      p := Person{&quot;tom&quot;}      p.test03()      fmt.Println(&quot;main() p.name=&quot;, p.Name) // tom      (&amp;p).test03() // 从形式上是传入地址，但是本质仍然是值拷贝      fmt.Println(&quot;main() p.name=&quot;, p.Name) // tom      (&amp;p).test04()      fmt.Println(&quot;main() p.name=&quot;, p.Name) // mary      p.test04() // 等价 (&amp;p).test04 , 从形式上是传入值类型，但是本质仍然是地址拷贝  }</code></pre></li></ul><h3 id="2-接口（详见十一章）"><a href="#2-接口（详见十一章）" class="headerlink" title="2.接口（详见十一章）"></a>2.接口（详见十一章）</h3><ul><li>使用关键字<code>interface</code>指定接口</li><li>可以理解为方法集的一个蓝本（充当了方法集的规范），描述了方法集中的所有方法，但并没有实现它</li><li>描述了方法集中的所有方法，并指定了每个方法的函数签名</li><li>使用接口前需要实现接口，即满足接口要求：<ul><li>实现接口指定方法集</li><li>函数签名正确无误</li></ul></li><li>接口是一种<strong>类型</strong>，可以<strong>作为参数</strong>传递给函数</li></ul><pre><code class="go">type 接口名称 interface {    方法1名称(参数1 变量类型1,参数2 变量类型2,...) 返回值类型    方法2名称(参数1 变量类型1,参数2 变量类型2,...) 返回值类型    ...}</code></pre><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><ul><li>字符串实际上是只读的字节切片</li></ul><h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h3><ul><li>与C语言类型，利用<strong>双引号</strong>括起来</li><li>可以使用基于反斜杠的各种转义字符</li></ul><h3 id="2-rune字面量"><a href="#2-rune字面量" class="headerlink" title="2.rune字面量"></a>2.rune字面量</h3><ul><li>使用<strong>反引号</strong><code>·</code>括起来（Esc键下的那个）</li><li>不能使用转义字符，是什么格式写在代码里就怎么输出</li></ul><h3 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3.拼接字符串"></a>3.拼接字符串</h3><ul><li>使用运算符<code>+</code>或<code>+=</code>拼接</li><li>只能拼接字符串型变量<ul><li>可以使用strconv包中的Itoa方法将整数转化为字符串</li></ul></li><li>拼接次数增多会导致效率边低<ul><li>可使用缓存区解决</li></ul></li></ul><h3 id="4-strings包处理字符串"><a href="#4-strings包处理字符串" class="headerlink" title="4.strings包处理字符串"></a>4.strings包处理字符串</h3><ul><li>strings.ToLower：将字符串转化为小写</li><li>strings.Index：在字符串中查找子串并返回索引</li><li>strings.TrimSpace：去除开头和结尾的空格</li></ul><h3 id="5-常用系统函数"><a href="#5-常用系统函数" class="headerlink" title="5.常用系统函数"></a>5.常用系统函数</h3><ul><li>统计字符串长度，按照字节：len(str)，内嵌函数，无需包</li><li>字符串遍历,同时处理有中文的间题 r := []rune(str)</li><li>字符串 转 整数:n,err := strconv.Atoi(“12”)</li><li>整数 转 字符串str = strconv.Itoa(12345)</li><li>字符串 转 []byte: var bytes = []byte(“hello go”)</li><li>[]byte 转 字符串:str = string([]byte{97,98,99})</li><li>10进制 转 2,8,16进制:str = strconv.FormatInt(123,2)</li><li>查找子串是否在指定的字符串中: strings.Contains(“seafood”,”foo”)//true</li><li>统计一个字符串有几个指定的子串: strings.Count(“cheese”,”e”)//4</li><li>不区大小写的字符串比较(==比较是区分字母大小写的): fmt.PrintIn( strings.EqualFold(“abc”,”Abc”)//true</li><li>返回子串在字符串第一次出现的index值,如果没有返回-1: strings.Index(“NTL_abc”,”abc”)//4</li><li>返回子串在字符串最后一次出现的index,如没有返回-1: strings.Lastlndex(“go golang”,”go”)//3</li><li>将指定的子串替换成另外一个子串: strings.Replace(“go go hello”,”go”,”go语言”,n)n可以指定你希望替换几个,如果n=-1表示全部替换</li><li>按照指定的某个字符,为分割标识,将一个字符串拆分成字符串数组：strings.Split(“hello,wrold,ok”,”,”)</li><li>将字符串的字母进行大小写的转换: strings.ToLower(“Go”)//go strings.ToUpper(“Go”)//Go</li><li>将字符串左右两边的空格去掉: strings.TrimSpacel(“ tn a lone gopher ntrn “)</li><li>将字符串左右两边指定的字符去掉: strings.Trim(“! hello!”,” !”)//[“hello”]//将左右两边!和” “去掉</li><li>将字符串左边指定的字符去掉: strings.TrimLeft(“! hello!”,” !”)//[“hello”]//将左边!和” “去掉</li><li>将字符串右边指定的字符去掉: strings.TrimRight(“! hello!”,” !”)//[“hello”]//将右边!和” “去掉</li><li>判断字符串是否以指定的字符串开头: strings.HasPrefix(“<a href="ftp://192.168.10.1&quot;,&quot;ftp&quot;)//true" target="_blank" rel="noopener">ftp://192.168.10.1&quot;,&quot;ftp&quot;)//true</a></li><li>判断字符串是否以指定的字符串结束: strings.HasSuffix(“NLT_abc. jpg”,”abc”)//false</li></ul><h2 id="八、处理错误"><a href="#八、处理错误" class="headerlink" title="八、处理错误"></a>八、处理错误</h2><h3 id="1-错误的处理机制"><a href="#1-错误的处理机制" class="headerlink" title="1.错误的处理机制"></a>1.错误的处理机制</h3><p>基本说明：</p><ul><li>Go语言追求简洁优雅,所以,Go语言不支持传统的try…catch…finally这种处理</li><li>Go中引入的处理方式为: <code>defer</code>, <code>panic</code>, <code>recover</code></li><li>这几个异常的使用场景可以这么简单描述：Go中可以抛出一个 panic的异常,然后在 defer中通过 <strong>recover捕获</strong>这个异常,然后正常处理</li></ul><p>例子：</p><pre><code class="go">//该函数调用后不会终止（会运行匿名函数），任然会正常运行func test() {    //使用defer + recover 来捕获和处理异常    defer func() {        err := recover()  // recover()内置函数，可以捕获到异常        if err != nil {  // 说明捕获到错误            fmt.Println(&quot;err=&quot;, err)            //这里就可以将错误信息发送给管理员....            fmt.Println(&quot;发送邮件给admin@sohu.com~&quot;)        }    }()    num1 := 10    num2 := 0    res := num1 / num2//这里会有异常    fmt.Println(&quot;res=&quot;, res)}</code></pre><h3 id="2-自定义错误"><a href="#2-自定义错误" class="headerlink" title="2.自定义错误"></a>2.自定义错误</h3><ul><li><p>没有错误，返回的错误值为nil</p></li><li><p>一般错误是通过返回给他的调用者处理的</p></li><li><p>错误是一个值，在标准库中声明了接口error</p><pre><code class="go">  type error interface {      Error() string  }</code></pre></li></ul><h4 id="1-1创建错误"><a href="#1-1创建错误" class="headerlink" title="1.1创建错误"></a>1.1创建错误</h4><ul><li><p>使用标准库中的<code>errors</code>包</p><pre><code class="go">err := errors.New(&quot;错误内容&quot;)if err != nil{    fmt.Println(err)    panic(err)}</code></pre></li><li><p>使用标准库中的<code>fmt</code>包中的<code>Errorf</code>方法灵活的创建</p><pre><code class="go">  role,name := &quot;Richard Jupp&quot;,&quot;Drummer&quot;  err := fmt.Errorf(&quot;The %v %v quit&quot;,role,name)  if err != nil{      fmt.Println(err)      panic(err)  }</code></pre></li></ul><h4 id="1-2-panic内置函数"><a href="#1-2-panic内置函数" class="headerlink" title="1.2 panic内置函数"></a>1.2 panic内置函数</h4><ul><li>慎用</li><li>内置函数,接收一个interface{}类型的值(也就是任何值了)作为参数。可以接收error类型的变量,输出错误信息,并退出程序</li><li>是go语言中的内置函数，能够终止正常的控制流程并引起恐慌，导致程序停止执行</li></ul><h2 id="九、Goroutine协程"><a href="#九、Goroutine协程" class="headerlink" title="九、Goroutine协程"></a>九、Goroutine协程</h2><ul><li>关键字<code>go</code>修饰</li><li>是一种支持并发编程的方式</li><li>用于处理需要并发的任务</li><li>占用内存极小，且创建和销毁效率也很高</li></ul><p>进程和线程：</p><ul><li>进程就是程序程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位</li><li>线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</li><li>一个进程可以创建核销毁多个线程，同一个进程中的多个线程可以并发执行</li><li>一个程序至少有一个进程，一个进程至少有一个线程</li></ul><p>并发和并行：</p><ul><li>多线程程序在单核上运行，就是并发</li><li>多线程程序在多核上运行，就是并行</li></ul><p>go协程和go主线程</p><ul><li>Go主线程（有程序员直接称为线程/也可以理解成进程一个Go线程上，可以起多个协程，你可以这样理解，协程是轻量级的线程</li><li>Go协程的特点<ul><li>有独立的栈空间</li><li>共享程序堆空间</li><li>调度由用户控制</li><li>协程是轻量级的线程</li></ul></li></ul><blockquote><p>例子：</p><pre><code class="go">func main() {    go test() // 开启了一个协程    for i := 1; i &lt;= 10; i++ {        fmt.Println(&quot; main() hello,golang&quot; + strconv.Itoa(i))        time.Sleep(time.Second)    }}</code></pre><ul><li>如果主线程退出了，则协程即使还没有执行完毕，也会退出</li><li>当然协程也可以在主线程没有退出前，就自己结束了，比如完成了自己的任务</li></ul></blockquote><p>协程的调度模型（MPG模式）：</p><ul><li>M：操作系统的主线程（是物理线程）</li><li>P：协程执行需要的上下文</li><li>G：协程</li></ul><p>设置Golang运行的cpu数：</p><pre><code class="go">import &quot;runtime&quot;runtime.NumCPU()//获取本地机器的逻辑cpuruntime.GOMAXPROCS(num)//设置Go可同时执行的最大cpu个数</code></pre><ul><li>go1.8后，默认让程序运行在多个核上可以不用设置了</li><li>go1.8前，还是要设置一下，可以更高效的利益cpu</li></ul><h3 id="1-多个协程之间的通信"><a href="#1-多个协程之间的通信" class="headerlink" title="1.多个协程之间的通信"></a>1.多个协程之间的通信</h3><p>在<strong>编译</strong>程序时，可以通过增加<code>-race</code>参数，即可查看是否存在资源竞争，如：</p><pre><code class="go">&gt; go build -race test.go&gt; test.exe</code></pre><p><code>sync</code>包提供了一些基本的同步元素，如互斥锁。大部分都是适用于低水平程序线程，高水平的同步使用channel通信更好一些。</p><blockquote><p>例子：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    _ &quot;time&quot;    &quot;sync&quot;)// 需求：现在要计算 1-200 的各个数的阶乘，并且把各个数的阶乘放入到map中。// 最后显示出来。要求使用goroutine完成 var (    myMap = make(map[int]int, 10)      //声明一个全局的互斥锁lock    lock sync.Mutex)// test 函数就是计算 n!, 让将这个结果放入到 myMapfunc test(n int) {    res := 1    for i := 1; i &lt;= n; i++ {        res *= i    }    //这里我们将 res 放入到myMap     lock.Lock()//加锁    myMap[n] = res //concurrent map writes?    lock.Unlock()//解锁}func main() {    // 我们这里开启多个协程完成这个任务[200个]    for i := 1; i &lt;= 20; i++ {        go test(i)    }    //休眠10秒钟【第二个问题 】    //time.Sleep(time.Second * 5)    lock.Lock()//这里加锁是为了让go底层知道（go底层可能仍会访问改资源）    for i, v := range myMap {        fmt.Printf(&quot;map[%d]=%d\n&quot;, i, v)    }    lock.Unlock()}</code></pre></blockquote><p>更好的通信机制应该是用到下一章的<strong>管道</strong></p><h2 id="十、channel通道"><a href="#十、channel通道" class="headerlink" title="十、channel通道"></a>十、channel通道</h2><ul><li>一种与Goroutine通信的方式</li><li>能够让数据进入和离开Goroutine，方便Goroutine之间进行通信</li><li>使用关键字<code>make</code>创建，使用关键字<code>chan</code>指定创建的是通道</li><li>channel的本质就是一个数据结构——队列<ul><li>先进先出</li></ul></li><li><strong>线程安全</strong>，多 goroutine访问时，不需要加锁，就是说 channel本身就是线程安全</li><li>channel是有类型的，一个 string的channel只能存放 string类型数据</li></ul><p>声明：</p><pre><code class="go">var 变量名 chan 数据类型</code></pre><ul><li>channel是<strong>引用类型</strong></li><li>channel必须初始化才能写入数据（即make后）</li><li>管道是有类型的</li></ul><p>初始化：</p><pre><code class="go">管道变量名字 = make(chan 通道存储的数据类型,管道中的容量)</code></pre><p>数据传输：</p><p>向通道发送消息（注意通道只能接受创建时指定的通道类型）：</p><pre><code class="go">var intChan chan intintChan = make(chan int, 3)intChan&lt;- 10num := 211intChan&lt;- numintChan&lt;- 50</code></pre><ul><li><code>len(intChan)</code>：获取到通道的长度，具体为传入通道中的数据</li><li><code>cap(intChan)</code>：获取通道的容量，具体为make创建时的大小</li><li>给管写入数据时，不能超过其容量</li></ul><p>从通道接收消息：</p><pre><code class="go">var num2 intnum2 = &lt;-intChan//10</code></pre><ul><li>在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报deadlock</li></ul><blockquote><p>注意：</p><pre><code class="go">type Cat struct {    Name string    Age int}func main() {    //定义一个存放任意数据类型的管道 3个数据    //var allChan chan interface{}    allChan := make(chan interface{}, 3)    allChan&lt;- 10    allChan&lt;- &quot;tom jack&quot;    cat := Cat{&quot;小花猫&quot;, 4}    allChan&lt;- cat    //我们希望获得到管道中的第三个元素，则先将前2个推出    &lt;-allChan    &lt;-allChan    newCat := &lt;-allChan //此时从管道中取出的Cat是一个空接口    fmt.Printf(&quot;newCat=%T , newCat=%v\n&quot;, newCat, newCat)//newCat=main.Cat , newCat=&lt;小花苗 4&gt;  此处能够打印出来是在运行的层面上    //下面的写法是错误的!编译不通过    //fmt.Printf(&quot;newCat.Name=%v&quot;, newCat.Name)//此处不能编译通过是在编译的层面上发现类型不匹配（接口中不能有字段）    //使用类型断言 强制转换    a := newCat.(Cat)     fmt.Printf(&quot;newCat.Name=%v&quot;, a.Name)}</code></pre></blockquote><p>管道关闭：</p><p>使用内置函数<code>close</code>可以关闭 channel，当 channel关闭后，就不能再向 channel写数据，但是仍然可以从该 channel读取数据。</p><pre><code class="go">intChan := make(chan int, 3)intChan&lt;- 100intChan&lt;- 200close(intChan) // close//这是不能够再写入数到channel//intChan&lt;- 300//当管道关闭后，读取数据是可以的n1 := &lt;-intChanfmt.Println(&quot;n1=&quot;, n1)</code></pre><p>管道关闭后，数据全部读取完毕后假设再次读取，此时会返回一个错误值：</p><pre><code class="go">n1,ok := &lt;-intChan//ok用于保存错误值</code></pre><p> 但是假设没有关闭就再次读，会发生<code>deadlock</code>，与下面的<code>for- range</code>遍历类似</p><ul><li>未关闭管道一直读会发生<code>deadlock</code>，但是关闭后读就只会返回正确与否，不会产生<code>deadlock</code>。可以理解为留下一个标志位，读到这个标志位就停止</li><li>在没有关闭管道前也可以读取管道中的内容</li></ul><p>管道遍历：</p><p>channel支持<code>for- range</code>的方式进行遍历，请注意两个细节</p><ul><li>1）在遍历时，如果 channel没有关闭，则会出现 <code>deadlock</code>的错误<ul><li>因为所有数据全部取出后，仍会再次取数据，此时会产生<code>deadlock</code>的错误</li><li>如果写的快，读得慢，写满后写入方会阻塞，但是只要有读取就不会发生<code>deadlock</code>。反之，编译器底层发现一直在写而没有读取就会发生<code>deadlock</code></li><li>总之，只要管道有流动就不会发生<code>deadlock</code></li></ul></li><li>2）在遍历时，如果 channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li></ul><pre><code class="go">intChan2 := make(chan int, 100)for i := 0; i &lt; 100; i++ {    intChan2&lt;- i * 2  //放入100个数据到管道}close(intChan2)for v := range intChan2 {    fmt.Println(&quot;v=&quot;, v)}</code></pre><h3 id="Goroutine协程＋channel管道"><a href="#Goroutine协程＋channel管道" class="headerlink" title="Goroutine协程＋channel管道"></a>Goroutine协程＋channel管道</h3><blockquote><p>协程＋管道例子：</p><p>同时读写协作问题</p><pre><code class="go">//write Datafunc writeData(intChan chan int) {    for i := 1; i &lt;= 50; i++ {        //放入数据        intChan&lt;- i //        fmt.Println(&quot;writeData &quot;, i)        //time.Sleep(time.Second)    }    close(intChan) //关闭}//read datafunc readData(intChan chan int, exitChan chan bool) {    for {        v, ok := &lt;-intChan        if !ok {            break        }        time.Sleep(time.Second)        fmt.Printf(&quot;readData 读到数据=%v\n&quot;, v)     }    //readData 读取完数据后，即任务完成    exitChan&lt;- true    close(exitChan)}func main() {    //创建两个管道    intChan := make(chan int, 10)    exitChan := make(chan bool, 1)    go writeData(intChan)    go readData(intChan, exitChan)    //time.Sleep(time.Second * 10)    for {        _, ok := &lt;-exitChan        if !ok {            break        }    }}</code></pre><p>阻塞问题</p><p>上述例子，如果只有写入数据而没有读取，就会出现阻塞而deadlock，原因是 intChan容量是10，而代码 writeData会写入50个数据阻塞在 writeData的ch&lt;-i</p><pre><code class="go">func main() {    //创建两个管道    intChan := make(chan int, 10)    exitChan := make(chan bool, 1)    go writeData(intChan)    //go readData(intChan, exitChan)    //等待readData协程完成    for {        _, ok := &lt;-exitChan        if !ok {            break        }    }}</code></pre></blockquote><p>写管道和读管道的<strong>频率不一致</strong>，<strong>无所谓</strong></p><p>注意细节：</p><ul><li><p>channel可以声明为只读或只写（默认为双向，可读可写）</p><pre><code class="go">  //声明为只写  var chan2 chan&lt;- int//chan&lt;-可以理解为属性，稍微修饰下，并不能通过make(chan&lt;- int)创建，下面同理  chan2 = make(chan int, 3)  chan2&lt;- 20  //num := &lt;-chan2 //error  fmt.Println(&quot;chan2=&quot;, chan2)  //声明为只读  var chan3 &lt;-chan int  num2 := &lt;-chan3  //chan3&lt;- 30 //err  fmt.Println(&quot;num2&quot;, num2)</code></pre></li><li><p>使用select可以解决从管道取数据的阻塞问题</p><ul><li><p>传统方法在遍历时，如果不关闭会因为阻塞而导致deadlock</p><pre><code class="go">  intChan := make(chan int, 10)  for i := 0; i &lt; 10; i++ {      intChan&lt;- i  }  //定义一个管道 5个数据string  stringChan := make(chan string, 5)  for i := 0; i &lt; 5; i++ {      stringChan &lt;- &quot;hello&quot; + fmt.Sprintf(&quot;%d&quot;, i)  }  //在实际开发中，可能我们不好确定什么关闭该管道.  //可以使用select 方式可以解决  for {      select {          //注意: 这里，如果intChan一直没有关闭，不会一直阻塞而deadlock          //会自动到下一个case匹配          case v := &lt;-intChan :           fmt.Printf(&quot;从intChan读取的数据%d\n&quot;, v)          time.Sleep(time.Second)          case v := &lt;-stringChan :          fmt.Printf(&quot;从stringChan读取的数据%s\n&quot;, v)          time.Sleep(time.Second)          default :          fmt.Printf(&quot;都取不到了，不玩了, 程序员可以加入逻辑\n&quot;)          time.Sleep(time.Second)          return      }  }</code></pre></li><li><p>协程中使用recover，可以解决因协程中出现panic而导致整个程序崩溃的问题</p><pre><code class="go">  func sayHello() {      for i := 0; i &lt; 10; i++ {          time.Sleep(time.Second)          fmt.Println(&quot;hello,world&quot;)      }  }  func test() {      //这里我们可以使用defer + recover      defer func() {          //捕获test抛出的panic          if err := recover(); err != nil {              fmt.Println(&quot;test() 发生错误&quot;, err)          }      }()      //定义了一个map      var myMap map[int]string      myMap[0] = &quot;golang&quot; //error  }  func main() {      go sayHello()      go test()      for i := 0; i &lt; 10; i++ {          fmt.Println(&quot;main() ok=&quot;, i)          time.Sleep(time.Second)      }  }</code></pre></li></ul></li></ul><h2 id="十一、面向对象编程"><a href="#十一、面向对象编程" class="headerlink" title="十一、面向对象编程"></a>十一、面向对象编程</h2><h3 id="1-构造函数（工厂模式间接实现）"><a href="#1-构造函数（工厂模式间接实现）" class="headerlink" title="1.构造函数（工厂模式间接实现）"></a>1.构造函数（工厂模式间接实现）</h3><p>Golang的结构体没有构造函数,通常可以使用<strong>工厂模式</strong>来解决这个问题</p><p>使用工厂模式实现跨包创建结构体实例(变量):</p><ul><li><p>如果 modle包的结构体变量首字母大写,引入后,直接使用,没有问题</p></li><li><p>如果mode包的结构体变量首字母小写,引入后,不能直接使用,可以工厂模式解决</p><pre><code class="go">  //main.go  func main() {      //创建要给Student实例      // var stu = model.Student{      //     Name :&quot;tom&quot;,      //     Score : 78.9,      // }      //定student结构体是首字母小写，我们可以通过工厂模式来解决      var stu = model.NewStudent(&quot;tom~&quot;, 98.8)      fmt.Println(*stu) //&amp;{....}      fmt.Println(&quot;name=&quot;, stu.Name, &quot; score=&quot;, stu.GetScore())  }  //student.go  package model  //定义一个结构体  type student struct{      Name string      score float64  }  //因为student结构体首字母是小写，因此是只能在model使用  //我们通过工厂模式来解决  func NewStudent(n string, s float64) *student {      return &amp;student{          Name : n,          score : s,      }  }  //如果score字段首字母小写，则，在其它包不可以直接方法，我们可以提供一个方法  func (s *student) GetScore() float64{      return s.score //ok  }</code></pre></li></ul><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>封装( encapsulation)就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只有通过被授权的操作(方法)，才能对字段进行操作</p><p>如何体现封装：</p><ul><li>对结构体中的属性进行封装</li><li>通过方法,包 实现封装</li></ul><p>步骤：</p><ul><li><p>将结构体、字段(属性)的<strong>首字母小写</strong>(不能导出了,其它包不能使用,类似 private)</p></li><li><p>结构体所在包提供一个工厂模式的函数,首字母大写。类似一个构造函数</p></li><li><p>提供一个首字母大写的Set方法(类似其它语言的 public),用于对属性判断并赋值</p><pre><code class="go">  func (var 结构体类型名) SetXxx(参数列表)(返回值列表){      //加入数据验证的业务逻辑  }</code></pre></li><li><p>提供一个首字母大写的Get方法(类似其它语言的public,用于获取属性的值</p><pre><code class="go">  func (var 结构体类型名) GetXxx(){      return var.字段  }</code></pre></li><li><p>特别说明:在 Golang开发中并没有特别强调封装,Galang本身对面向对象的特性做了简化</p></li></ul><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h3><p>继承可以解决<strong>代码复用</strong>，让我们的编程更加靠近人类思维。</p><p>当多个结构体存在相同的属性(字段)和方法时,可以从这些结构体中抽象出结构体，在该结构体中定义这些相同的属性和方法</p><p>其它的结构体不需要重新定义这些属性和方法,只需嵌套一个<strong>匿名结构体</strong>即可。</p><p>在 Golang中,如果一个 struct<strong>嵌套</strong>了另一个匿名结构体,那么这个结构体可以<strong>直接访问</strong>匿名结构体的<strong>字段和方法</strong>,从而实现了继承特性</p><pre><code class="go">type Student struct {    Name string    Age int    Score int}//将Pupil 和 Graduate 共有的方法也绑定到 *Studentfunc (stu *Student) ShowInfo() {    fmt.Printf(&quot;学生名=%v 年龄=%v 成绩=%v\n&quot;, stu.Name, stu.Age, stu.Score)}func (stu *Student) SetScore(score int) {    //业务判断    stu.Score = score}//给 *Student 增加一个方法，那么 Pupil 和 Graduate都可以使用该方法func (stu *Student) GetSum(n1 int, n2 int) int {    return n1 + n2}//小学生type Pupil struct {    Student //嵌入了Student匿名结构体}//显示他的成绩//这时Pupil结构体特有的方法，保留func (p *Pupil) testing() {    fmt.Println(&quot;小学生正在考试中.....&quot;)}//大学生type Graduate struct {    Student //嵌入了Student匿名结构体}//显示他的成绩//这时Graduate结构体特有的方法，保留func (p *Graduate) testing() {    fmt.Println(&quot;大学生正在考试中.....&quot;)}func main() {    //当我们对结构体嵌入了匿名结构体使用方法会发生变化    pupil := &amp;Pupil{}    pupil.Student.Name = &quot;tom~&quot;    pupil.Student.Age = 8    pupil.testing()    pupil.Student.SetScore(70)    pupil.Student.ShowInfo()    fmt.Println(&quot;res=&quot;, pupil.Student.GetSum(1, 2))    graduate := &amp;Graduate{}    graduate.Student.Name = &quot;mary~&quot;//可以简化为graduate.Name = &quot;mary~&quot;    graduate.Student.Age = 28    graduate.testing()    graduate.Student.SetScore(90)    graduate.Student.ShowInfo()    fmt.Println(&quot;res=&quot;, graduate.Student.GetSum(10, 20))}</code></pre><ul><li><p>结构体可以使用嵌套匿名结构体<strong>所有的字段和方法</strong>,即:首字母大写或者小写的字段、方法,都可以使用。</p></li><li><p>匿名结构休字段访问可以简化：<code>变量名.匿名结构体名.成员</code>–&gt;<code>变量名.成员</code></p></li><li><p>当结构体和匿名结构体有<strong>相同</strong>的字段或者方法时,编译器采用<strong>就近访问原则</strong>访问,如希望访问匿名结构体的字段和方法,可以通过匿名结构体名来区分</p></li><li><p>结枃体嵌入两个(或多个)匿名结构体,如两个匿名结构体有相同的字段和方法(同时<strong>结构体本身没有同名的字段和方法</strong>),在访问时,就<strong>必须明确指定</strong>匿名结构体名字,否则编译报错。</p></li><li><p>如果一个 struct嵌套了一个有名结构体,这种模式就是<strong>组合</strong>,如果是组合关系,那么在访问组合的结构体的字段或方式时,<strong>必须带上</strong>结构体的名字</p></li><li><p>嵌套匿名结构体后,也可以在创建结构体变量(实例)时,直接指定各个匿名结构体字段的值</p><pre><code class="go">  type Goods struct {      Name string      Price float64  }  type Brand struct {      Name string      Address string  }  type TV struct {      Goods      Brand  }  func main() {      //嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值      tv := TV{ Goods{&quot;电视机001&quot;, 5000.99},  Brand{&quot;海尔&quot;, &quot;山东&quot;}, }      tv2 := TV{          Goods{              Price : 5000.99,              Name : &quot;电视机002&quot;,          },            Brand{              Name : &quot;夏普&quot;,              Address :&quot;北京&quot;,          },      }  }</code></pre></li><li><p>结构体的匿名字段可以是基本数据类型</p><pre><code class="go">  type Monster struct  {      Name string      Age int  }  type E struct {      Monster      int      n int  }  func main() {      var e E      e.Name = &quot;狐狸精&quot;      e.Age = 300      e.int = 20      e.n = 40      fmt.Println(&quot;e=&quot;, e)  }</code></pre></li></ul><p>多重继承：</p><ul><li>如一个struct嵌套了多个匿名结构体,那么该结构体可以直接访问嵌套的匿名结构体的字段和方法,从而实现了多重继承<ul><li>上上个例子中的TV，嵌套了Goods和Brand结构体</li></ul></li><li>如嵌入的匿名结构体有<strong>相同的字段名或者方法名</strong>,则在访问时,需要通过<strong>匿名结构体类型名</strong>来区分</li><li>为了保证代码的简洁性,建议大家<strong>尽量不使用</strong>多重继承</li></ul><h3 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h3><p>interface类型可以定义一组方法,但是这些不需要实现。并且 <strong>interface不能包含任何变量</strong>。到自定义类型(比如结构体 Phone)要使用的时候,在根据具体情况把这些方法写出来</p><p>基本语法：</p><pre><code class="go">type 接口名 interface{    method1(参数列表) 返回值列表    method1(参数列表) 返回值列表    ...}</code></pre><ul><li>接口里的所有方法都没有方法体,即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想</li><li>Golang中的接口,不需要显式的实现。只要变量,含有接口类型中的<strong>所有方法</strong>,那变量就实现这个接口。因此, Galang中<strong>没有 implement</strong>这样的关键字</li></ul><p>注意事项：</p><ul><li><p>接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例)</p><pre><code class="go">  func (stu Stu) Say() {      fmt.Println(&quot;Stu Say()&quot;)  }  type AInterface interface {      Say()  }  func main() {      var stu Stu //结构体变量，实现了 Say() 实现了 AInterface      var a AInterface = stu      a.Say()  }</code></pre></li><li><p>接口中所有的方法都没有方法体,即都是没有实现的方法。</p></li><li><p>在 Golang中,一个自定义类型需要将某个接口的<strong>所有方法</strong>都实现,我们才说这个自定义类型实现了该接口。</p></li><li><p>一个自定义类型只有实现了某个接口,才能将该自定义类型的实例(变量)赋给接囗类型</p></li><li><p>只要是自定义数据类型,就可以实现接口,不仅仅是结构体类型</p><pre><code class="go">  type AInterface interface {      Say()  }  type integer int  func (i integer) Say() {      fmt.Println(&quot;integer Say i =&quot; ,i )  }  func main() {      var i integer = 10      var b AInterface = i      b.Say() // integer Say i = 10  }</code></pre></li><li><p>一个自定义类型可以实现多个接口</p></li><li><p>Golang接口中不能有任何变量</p></li><li><p>一个接口(比如A接口)可以<strong>继承</strong>多个别的接口(比如B,C接口),这时如果要实现A接口,也必须将B、C接口的方法也全部实现，但是<strong>不能够有相同的接口</strong></p></li><li><p>interface类型默认是一个指针（<strong>引用类型</strong>）,如果没有对 interface初始化就使用,那么会输出nil</p></li><li><p>空接囗 <code>interface{}</code>没有任何方法,所以所有类型都实现了空接口，即可以将<strong>任何一个变量赋值给空接口</strong></p></li></ul><h4 id="接口和继承的关系"><a href="#接口和继承的关系" class="headerlink" title="接口和继承的关系"></a>接口和继承的关系</h4><ul><li><p>接口是继承的补充</p></li><li><p>当A结构体继承了B结构体,那么A结构就自动的继承了B结构体的字段和方法,并且可以直接使用</p></li><li><p>当A结构体需要扩展功能,同时不希望去破坏继承关系,则可以去实现某个接口即可</p><p>  <img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200109151443437.png" alt="接口和继承的关系"></p></li><li><p>接口和继承解决的问题不同</p><ul><li>继承的价值主要在于:解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li><li>接口的价值主要在于:<strong>设计</strong>,设计好各种规范(方法),让其它自定义类型去实现这些方法</li></ul></li><li><p>接口比继承更加灵活</p><ul><li>继承是满足<code>is-a</code>的关系,而接口只需满足<code>like-a</code>的关系。</li></ul></li><li><p>接口在一定程度上实现代码解耦</p></li></ul><h3 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h3><p>变量(实例)具有多种形态。面向对象的第三大特征,在Go语言,多态特征是<strong>通过接口实现</strong>的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。</p><p>接口体现多态特性：</p><ul><li><p><strong>多态参数</strong>：在下面的Usb接口案例, Usb usb,即可以接收手机变量,又可以接收相机变量,就体现了Usb接口多态</p><ul><li><p>例子：</p><pre><code class="go">  //声明/定义一个接口  type Usb interface {      //声明了两个没有实现的方法      Start()      Stop()  }  type Phone struct {  }    //让Phone 实现 Usb接口的方法  func (p Phone) Start() {      fmt.Println(&quot;手机开始工作。。。&quot;)  }  func (p Phone) Stop() {      fmt.Println(&quot;手机停止工作。。。&quot;)  }  type Camera struct {  }  //让Camera 实现   Usb接口的方法  func (c Camera) Start() {      fmt.Println(&quot;相机开始工作~~~。。。&quot;)  }  func (c Camera) Stop() {      fmt.Println(&quot;相机停止工作。。。&quot;)  }  //计算机  type Computer struct {  }  //编写一个方法Working 方法，接收一个Usb接口类型变量  //只要是实现了 Usb接口 （所谓实现Usb接口，就是指实现了 Usb接口声明所有方法）  func (c Computer) Working(usb Usb) {      //通过usb接口变量来调用Start和Stop方法      usb.Start()      usb.Stop()  }  func main() {      //先创建结构体变量      computer := Computer{}      phone := Phone{}      camera := Camera{}      //关键点      computer.Working(phone)      computer.Working(camera) //  }</code></pre></li></ul></li><li><p><strong>多态数组</strong>：下面例子Usb数组中,存放 Phone结构体和 Camera结构体变量。Phone还有一个特有的方法call(),请遍历Usb数组,如果是 Phone变量,除了调用Usb接口声明的方法外,还需要调用 Phone特有方法call</p><ul><li><p>例子：</p><pre><code class="go">  //声明/定义一个接口  type Usb interface {      //声明了两个没有实现的方法      Start()      Stop()  }  type Phone struct {      name string  }  //让Phone 实现 Usb接口的方法  func (p Phone) Start() {      fmt.Println(&quot;手机开始工作。。。&quot;)  }  func (p Phone) Stop() {      fmt.Println(&quot;手机停止工作。。。&quot;)  }  type Camera struct {      name string  }  //让Camera 实现   Usb接口的方法  func (c Camera) Start() {      fmt.Println(&quot;相机开始工作。。。&quot;)  }  func (c Camera) Stop() {      fmt.Println(&quot;相机停止工作。。。&quot;)  }  func main() {      //定义一个Usb接口数组，可以存放Phone和Camera的结构体变量      //这里就体现出多态数组      var usbArr [3]Usb      usbArr[0] = Phone{&quot;vivo&quot;}      usbArr[1] = Phone{&quot;小米&quot;}      usbArr[2] = Camera{&quot;尼康&quot;}      fmt.Println(usbArr)  }</code></pre></li></ul></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言,由于接口是一般类型,不知道具体类型,如果要<strong>转成具体类型</strong>,就需要使用类型断言，如下：</p><pre><code class="go">var t float32var x interface{}x = t//空接口，可以接收任意类型y := x.(float32)//类型断言</code></pre><p>在进行类型断言时,如果类型不匹配,就会报 panic因此进行类型断言时,要确保原来的空接口指向的就是断言的类型</p><p>带检测的类型断言：</p><pre><code class="go">var x interface{}var b2 float32 = 2.1x = b2  //空接口，可以接收任意类型// x=&gt;float32 [使用类型断言]//类型断言(带检测的)if y, ok := x.(float32); ok {    fmt.Println(&quot;convert success&quot;)    fmt.Printf(&quot;y 的类型是 %T 值是=%v&quot;, y, y)} else {    fmt.Println(&quot;convert fail&quot;)}fmt.Println(&quot;继续执行...&quot;)</code></pre><p>可以通过这种方法判断输入参数的类型：</p><pre><code class="go">type Student struct {}//编写一个函数，可以判断输入的参数是什么类型func TypeJudge(items... interface{}) {    for index, x := range items {        switch x.(type) {            case bool :            fmt.Printf(&quot;第%v个参数是 bool 类型，值是%v\n&quot;, index, x)            case float32 :            fmt.Printf(&quot;第%v个参数是 float32 类型，值是%v\n&quot;, index, x)            case float64 :            fmt.Printf(&quot;第%v个参数是 float64 类型，值是%v\n&quot;, index, x)            case int, int32, int64 :            fmt.Printf(&quot;第%v个参数是 整数 类型，值是%v\n&quot;, index, x)            case string :            fmt.Printf(&quot;第%v个参数是 string 类型，值是%v\n&quot;, index, x)            case Student :            fmt.Printf(&quot;第%v个参数是 Student 类型，值是%v\n&quot;, index, x)            case *Student :            fmt.Printf(&quot;第%v个参数是 *Student 类型，值是%v\n&quot;, index, x)            default :            fmt.Printf(&quot;第%v个参数是  类型 不确定，值是%v\n&quot;, index, x)        }    }}</code></pre><h2 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h2><p>文件在程序中是以流的形式来操作的</p><ul><li>流:数据在数据源(文件)和程序(内存)之间经历的路径</li><li>输入流:数据从数据源(文件)到程序(内存)的路径</li><li>输出流:数据从程序(内存)到数据源(文件)的路径</li></ul><p><code>os.File</code>封装所有文件相关操作,<code>File</code>是一个结构体。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><pre><code class="go">func Open(name string) (file *File, err error)</code></pre><p>另外一种打开文件的方式：</p><pre><code class="go">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</code></pre><p>OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。（一般用于文件写入时的打开函数）</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><pre><code class="go">func (f *File) Close() error</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul><li><p>带缓冲的读取：</p><ul><li><p>采取<code>bufio.NewReader(file)</code>新建缓存，缓存大小默认为4096</p><pre><code class="go">//NewReader创建一个具有默认大小缓冲、从r读取的*Reader。func NewReader(rd io.Reader) *Reader//ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。func (b *Reader) ReadString(delim byte) (line string, err error)</code></pre><p>例子：</p><pre><code class="go">file , err := os.Open(&quot;d:/test.txt&quot;)if err != nil {    fmt.Println(&quot;open file err=&quot;, err)}//当函数退出时，要及时的关闭filedefer file.Close() //要及时关闭file句柄，否则会有内存泄漏.// 创建一个 *Reader  ，是带缓冲的/*const (defaultBufSize = 4096 //默认的缓冲区为4096)*/reader := bufio.NewReader(file)//循环的读取文件的内容for {    str, err := reader.ReadString(&#39;\n&#39;) // 读到一个换行就结束    if err == io.EOF { // io.EOF表示文件的末尾        break    }    //输出内容    fmt.Printf(str)}fmt.Println(&quot;文件读取结束...&quot;)</code></pre></li></ul></li><li><p>一次性读取（适合文件不大的情况下，效率低）</p><ul><li><p>利用函数<code>ioutil.ReadFile</code>一次性读取（无需打开文件，直接读取）</p><pre><code class="go">  //使用ioutil.ReadFile一次性将文件读取到位  file := &quot;d:/test.txt&quot;  content, err := ioutil.ReadFile(file)  if err != nil {      fmt.Printf(&quot;read file err=%v&quot;, err)  }  //把读取到的内容显示到终端  //fmt.Printf(&quot;%v&quot;, content) // []byte  fmt.Printf(&quot;%v&quot;, string(content)) // []byte  //我们没有显式的Open文件，因此也不需要显式的Close文件  //因为，文件的Open和Close被封装到 ReadFile 函数内部</code></pre></li></ul></li></ul><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>通过缓存，即<code>bufio</code>中的<code>bufio.NewWriter</code>写文件</p><pre><code class="go">//NewWriter创建一个具有默认大小缓冲、写入w的*Writer。func NewWriter(w io.Writer) *Writer</code></pre><p>例子：</p><pre><code class="go">//创建一个新文件，写入内容 5句 &quot;hello, Gardon&quot;//1 .打开文件 d:/abc.txtfilePath := &quot;d:/abc.txt&quot;file, err := os.OpenFile(filePath, os.O_WRONLY | os.O_CREATE, 0666)if err != nil {    fmt.Printf(&quot;open file err=%v\n&quot;, err)    return}//及时关闭file句柄defer file.Close()//准备写入5句 &quot;hello, Gardon&quot;str := &quot;hello,Gardon\r\n&quot; // \r\n 表示换行//写入时，使用带缓存的 *Writerwriter := bufio.NewWriter(file)for i := 0; i &lt; 5; i++ {    writer.WriteString(str)}//因为writer是带缓存，因此在调用WriterString方法时，其实//内容是先写入到缓存的,所以需要调用Flush方法，将缓冲的数据//真正写入到文件中， 否则文件中会没有数据!!!writer.Flush()</code></pre><p>通过<code>ioutil.WriteFile</code>写文件（无需打开文件，直接写入）：</p><pre><code class="go">func WriteFile(filename string, data []byte, perm os.FileMode) error</code></pre><p>函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p><h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><p>golang判断文件或文件夹是否存在的方法为使用 os.Stat()函数返回的错误值进行判断</p><ul><li>1）如果返回的错误为nil，说明文件或文件夹存在</li><li>2）如果返回的错误类型使用 os.IsNotExist()判断为true，说明文件或文件夹不存在</li><li>3）如果返回的错误为其它类型则不确定是否在存在</li></ul><pre><code class="go">func Stat(name string) (fi FileInfo, err error)</code></pre><p>Stat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为*PathError类型。</p><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>io包中的Copy函数：</p><pre><code class="go">func Copy(dst Writer, src Reader) (written int64, err error)</code></pre><p>将src的数据拷贝到dst，直到在src上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。</p><p>对成功的调用，返回值err为nil而非EOF，因为Copy定义为从src读取直到EOF，它不会将读取到EOF视为应报告的错误。如果src实现了WriterTo接口，本函数会调用src.WriteTo(dst)进行拷贝；否则如果dst实现了ReaderFrom接口，本函数会调用dst.ReadFrom(src)进行拷贝。</p><p>注意：dst为Writer类型，src为Reader类型，需要NewWriter和NewReader函数进行创建</p><p>例子：</p><pre><code class="go">func CopyFile(dstFileName string, srcFileName string) (written int64, err error) {    srcFile, err := os.Open(srcFileName)    if err != nil {        fmt.Printf(&quot;open file err=%v\n&quot;, err)    }    defer srcFile.Close()    //通过srcfile ,获取到 Reader    reader := bufio.NewReader(srcFile)    //打开dstFileName    dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY | os.O_CREATE, 0666)    if err != nil {        fmt.Printf(&quot;open file err=%v\n&quot;, err)        return    }    //通过dstFile, 获取到 Writer    writer := bufio.NewWriter(dstFile)    defer dstFile.Close()    return io.Copy(writer, reader)}func main() {    //将d:/flower.jpg 文件拷贝到 e:/abc.jpg    //调用CopyFile 完成文件拷贝    srcFile := &quot;d:/flower.jpg&quot;    dstFile := &quot;e:/abc.jpg&quot;    _, err := CopyFile(dstFile, srcFile)    if err == nil {        fmt.Printf(&quot;拷贝完成\n&quot;)    } else {        fmt.Printf(&quot;拷贝错误 err=%v\n&quot;, err)    }}</code></pre><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p><code>os.Args</code>是一Ar个 string的切片，用来存储所有的命令行参数</p><pre><code class="go">fmt.Println(&quot;命令行的参数有&quot;, len(os.Args))//遍历os.Args切片，就可以得到所有的命令行输入参数值for i, v := range os.Args {    fmt.Printf(&quot;args[%v]=%v\n&quot;, i, v)}//调用及结果test.exe tom d:/bbb/init.log 909命令行的参数有 4args[0]=test.exeargs[1]=tomargs[2]=d:/bbb/init.logargs[3]=909</code></pre><p>用<strong>flag包</strong>解析命令行参数：</p><pre><code class="go">func (f *FlagSet) Int64(name string, value int64, usage string) *int64</code></pre><p>Int64用指定的名称、默认值、使用信息注册一个int64类型flag。返回一个保存了该flag的值的指针。</p><pre><code class="go">func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</code></pre><p>StringVar用指定的名称、默认值、使用信息注册一个string类型flag，并将flag的值保存到p指向的变量。</p><pre><code class="go">func Parse()</code></pre><p>从os.Args[1:]中解析注册的flag。必须在所有flag都注册好而未访问其值时执行。未注册却使用flag -help时，会返回ErrHelp。</p><p>例子：</p><pre><code class="go">//定义几个变量，用于接收命令行的参数值var user stringvar pwd stringvar host stringvar port int//&amp;user 就是接收用户命令行中输入的 -u 后面的参数值//&quot;u&quot; ,就是 -u 指定参数//&quot;&quot; , 默认值//&quot;用户名,默认为空&quot; 说明flag.StringVar(&amp;user, &quot;u&quot;, &quot;&quot;, &quot;用户名,默认为空&quot;)flag.StringVar(&amp;pwd, &quot;pwd&quot;, &quot;&quot;, &quot;密码,默认为空&quot;)flag.StringVar(&amp;host, &quot;h&quot;, &quot;localhost&quot;, &quot;主机名,默认为localhost&quot;)flag.IntVar(&amp;port, &quot;port&quot;, 3306, &quot;端口号，默认为3306&quot;)//这里有一个非常重要的操作,转换， 必须调用该方法flag.Parse()//go build -o main.exe main.go编译为exe可执行文件后：//执行命令：main.exe -u root -pwd 123456 -h 127.0.0.5 -port 8080//该处会输出对应的结果fmt.Printf(&quot;user=%v pwd=%v host=%v port=%v&quot;,           user, pwd, host, port)</code></pre><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON易于机器解析和生成，并有效地提升网络传输效率，通常程序在网络传输时会先将数据（结构体、map等）序列化成json字符串，到接收方得到json字符串时，在反序列化恢复成原来的数据类型（结构体、map等）。这种方式已然成为各个语言的标准。</p><p>JSON键值对是用来保存数据一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值</p><p>任何数据类型都可以转换成JSON格式（对基本数据类型（int、float64等）序列化一般意义不大）</p><p><a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a>网站可以验证一个json格式的数据是否正确</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p><code>encoding/json</code>包中<code>Marshal</code>函数：</p><pre><code class="go">func Marshal(v interface{}) ([]byte, error)</code></pre><p>返回v的json编码。</p><p>例子：</p><pre><code class="go">//序列化Structtype Monster struct {    Name string `json:&quot;monster_name&quot;` //反射机制    Age int `json:&quot;monster_age&quot;`    Birthday string //....    Sal float64    Skill string}monster := Monster{    Name :&quot;牛魔王&quot;,    Age : 500 ,    Birthday : &quot;2011-11-11&quot;,    Sal : 8000.0,    Skill : &quot;牛魔拳&quot;,}//将monster 序列化data, err := json.Marshal(&amp;monster) //..if err != nil {    fmt.Printf(&quot;序列号错误 err=%v\n&quot;, err)}//输出序列化后的结果fmt.Printf(&quot;monster序列化后=%v\n&quot;, string(data))</code></pre><pre><code class="go">//序列化Mapvar a map[string]interface{}//使用map,需要makea = make(map[string]interface{})a[&quot;name&quot;] = &quot;红孩儿&quot;a[&quot;age&quot;] = 30a[&quot;address&quot;] = &quot;洪崖洞&quot;//将a这个map进行序列化//将monster 序列化data, err := json.Marshal(a)if err != nil {    fmt.Printf(&quot;序列化错误 err=%v\n&quot;, err)}//输出序列化后的结果fmt.Printf(&quot;a map 序列化后=%v\n&quot;, string(data))</code></pre><pre><code class="go">//序列化slicevar slice []map[string]interface{}var m1 map[string]interface{}//使用map前，需要先makem1 = make(map[string]interface{})m1[&quot;name&quot;] = &quot;jack&quot;m1[&quot;age&quot;] = &quot;7&quot;m1[&quot;address&quot;] = &quot;北京&quot;slice = append(slice, m1)var m2 map[string]interface{}//使用map前，需要先makem2 = make(map[string]interface{})m2[&quot;name&quot;] = &quot;tom&quot;m2[&quot;age&quot;] = &quot;20&quot;m2[&quot;address&quot;] = [2]string{&quot;墨西哥&quot;,&quot;夏威夷&quot;}slice = append(slice, m2)//将切片进行序列化操作data, err := json.Marshal(slice)if err != nil {    fmt.Printf(&quot;序列化错误 err=%v\n&quot;, err)}//输出序列化后的结果fmt.Printf(&quot;slice 序列化后=%v\n&quot;, string(data))</code></pre><ul><li>对于结构体的序列化，如果我们希望序列化后的key的名字，由我们自己重新制定，那么可以给 struct指定一个tag标签</li></ul><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p><code>encoding/json</code>包中<code>Unmarshal</code>函数：</p><pre><code class="go">func Unmarshal(data []byte, v interface{}) error</code></pre><p>解析json编码的数据并将结果存入v指向的值</p><p>例子：</p><pre><code class="go">//反序列化structtype Monster struct {    Name string      Age int    Birthday string //....    Sal float64    Skill string}str := &quot;{\&quot;Name\&quot;:\&quot;牛魔王~~~\&quot;,\&quot;Age\&quot;:500,\&quot;Birthday\&quot;:\&quot;2011-11-11\&quot;,\&quot;Sal\&quot;:8000,\&quot;Skill\&quot;:\&quot;牛魔拳\&quot;}&quot;//定义一个Monster实例var monster Monstererr := json.Unmarshal([]byte(str), &amp;monster)if err != nil {    fmt.Printf(&quot;unmarshal err=%v\n&quot;, err)}fmt.Printf(&quot;反序列化后 monster=%v monster.Name=%v \n&quot;, monster, monster.Name)</code></pre><pre><code class="go">//反序列化mapstr := &quot;{\&quot;address\&quot;:\&quot;洪崖洞\&quot;,\&quot;age\&quot;:30,\&quot;name\&quot;:\&quot;红孩儿\&quot;}&quot;//定义一个mapvar a map[string]interface{}//反序列化//注意：反序列化map,不需要make,因为make操作被封装到 Unmarshal函数err := json.Unmarshal([]byte(str), &amp;a)if err != nil {    fmt.Printf(&quot;unmarshal err=%v\n&quot;, err)}fmt.Printf(&quot;反序列化后 a=%v\n&quot;, a)</code></pre><pre><code class="go">//反序列化slicestr := &quot;[{\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:\&quot;7\&quot;,\&quot;name\&quot;:\&quot;jack\&quot;},&quot; +&quot;{\&quot;address\&quot;:[\&quot;墨西哥\&quot;,\&quot;夏威夷\&quot;],\&quot;age\&quot;:\&quot;20\&quot;,\&quot;name\&quot;:\&quot;tom\&quot;}]&quot;//定义一个slicevar slice []map[string]interface{}//反序列化，不需要make,因为make操作被封装到 Unmarshal函数err := json.Unmarshal([]byte(str), &amp;slice)if err != nil {    fmt.Printf(&quot;unmarshal err=%v\n&quot;, err)}fmt.Printf(&quot;反序列化后 slice=%v\n&quot;, slice)</code></pre><ul><li>在反序列化串时，要确保<strong>反序列化后的数据类型</strong>和原来<strong>序列化前的数据类型</strong>一致</li><li>如果json字符串是通过程序获取到的，则不需要再对json字符串转义处理</li></ul><h2 id="十三、单元测试"><a href="#十三、单元测试" class="headerlink" title="十三、单元测试"></a>十三、单元测试</h2><p>Go语言中自带有一个轻量级的测试框架 testing和自带的 go test命令来实现单元测试和性能测试， testing框架和其他语言中的测试框架类似，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试可以解决如下问题</p><ul><li>1）确保每个函数是可运行，并且运行结果是正确的</li><li>2）确保写出来的代码性能是好的</li><li>3）单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定</li></ul><p>testing框架测试原理：</p><p><img src="//NU-LL.github.io/2019/10/23/Go语言/image-20200114104332453.png" alt="testing框架测试原理"></p><p>注意：</p><ul><li>测试用例文件名_test.go结尾。比如 cal_test. go,cal不是固定的</li><li>测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，比如TestAddUpper<ul><li>其中 Xxx 可以是任何字母数字字符串（但第一个字母不能是 [a-z]），用于识别测试例程</li></ul></li><li>TestAddUpper(t* tesing.T)的形参类型必须是<code>* testing.T</code>【看一下手册】</li><li>测试用例文件中，可以有多个测试用例函数，如 TestAddUpper、 TestSub</li><li>运行测试用例指令<ul><li>（1） <code>cmd&gt;go test</code>【如果运行正确，无日志，错误时，会输出日志】</li><li>（2） <code>cmd&gt;go test -v</code>【运行正确或是错误，都输出日志】</li></ul></li><li>当出现错误时，可以使用 <code>t.Fatalf</code>来格式化输出错误信息，并退出程序</li><li><code>t.Logf</code>方法可以输出相应的日志</li><li>测试用例函数，并没有放在main函数中，也执行了，这就是测试用例的方便之处</li><li>PASS表示测试用例运行成功，FAIL表示测试用例运行失败</li><li>测试单个文件，一定要带上被测试的原文件：<code>go test -v cal_test.go(测试文件名) cal.go(测试文件所需要的函数)</code><ul><li>默认扫描整个目录下的所有测试文件</li></ul></li><li>测试单个方法：<code>go test -v -test.run TestAddUpper(待测试的方法名)</code></li></ul><h2 id="十四、反射"><a href="#十四、反射" class="headerlink" title="十四、反射"></a>十四、反射</h2><p>基本介绍：</p><ul><li>反射可以在<strong>运行时</strong>动态获取变量的各种信息，比如变量的类型（type），类别（kind），kind范围大于type</li><li>如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</li><li>通过反射，可以使修改变量的值，可以调用关联的方法</li><li>使用反射需要<code>import (&quot;reflect&quot;)</code></li></ul><p>反射重要函数和概念：</p><ul><li><code>reflect.Type(变量名)</code>，获取变量的类型，返回 <code>reflect.Type</code>类型</li><li><code>reflect.Valueof(变量名)</code>，获取变量的值，返回 <code>reflect.Value</code>类型， <code>reflect.Value</code>是一结构体类型。通过 <code>reflect.Value</code>，可以获取到关于该变量的很多信息</li><li>变量、空接口<code>interface{}</code>、<code>reflect.Value</code>是可以相互转换的</li></ul><p>例子：</p><p>对基本数据类型、<code>interface{}</code>、<code>reflect.Value</code>进行反射</p><pre><code class="go">func reflectTest01(b interface{}) {    //通过反射获取的传入的变量的 type类型 , kind类别, 值    //1. 先获取到 reflect.Type    rTyp := reflect.TypeOf(b)    fmt.Println(&quot;rType=&quot;, rTyp)//rType=int    //2. 获取到 reflect.Value    rVal := reflect.ValueOf(b)    fmt.Println(&quot;rVal=&quot;, rTyp)//rVal=100    //此处需要转成int才能用于计算，上面能够直接输出是因为运行时存在值，为100。    //此处如果不转化，会因为interface{}类型和2相加 而在编译阶段报错    n2 := 2 + rVal.Int()    //n3 := rVal.Float()    fmt.Println(&quot;n2=&quot;, n2)//n2=102    //fmt.Println(&quot;n3=&quot;, n3)    fmt.Printf(&quot;rVal=%v rVal type=%T\n&quot;, rVal, rVal)//rVal=100 rVal type=reflect.Value    //下面我们将 rVal 转成 interface{}    iV := rVal.Interface()    //将 interface{} 通过断言转成需要的类型    num2 := iV.(int)    fmt.Println(&quot;num2=&quot;, num2)//num2=100}func main() {    //定义一个int    var num int = 100    reflectTest01(num)}</code></pre><p>对结构体、<code>interface{}</code>、<code>reflect.Value</code>进行反射</p><pre><code class="go">func reflectTest02(b interface{}) {    //通过反射获取的传入的变量的 type , kind, 值    //1. 先获取到 reflect.Type 类型    rTyp := reflect.TypeOf(b)    fmt.Println(&quot;rType=&quot;, rTyp)//rType=main.Student    //2. 获取到 reflect.Value    rVal := reflect.ValueOf(b)    //3. 获取 变量对应的Kind 类别    //(1) rVal.Kind() ==&gt; 返回的就是一个常量    kind1 := rVal.Kind()    //(2) rTyp.Kind() ==&gt; 返回的也是常量，和上述方法一致    kind2 := rTyp.Kind()    fmt.Printf(&quot;kind =%v kind=%v\n&quot;, kind1, kind2)//kind =struct kind=struct    //下面我们将 rVal 转成 interface{}    iV := rVal.Interface()    fmt.Printf(&quot;iv=%v iv type=%T \n&quot;, iV, iV)//iv=&lt;tom 20&gt; iv type=main.Student    //和上述例子一样，这里能够通过%v在运行时取出值，但是在编译时会因为类型问题不能够通过iV.Name或iV.Age取出变量值    //将 interface{} 通过断言转成需要的类型可以解决上述问题    //可以使用 swtich 的断言形式来做的更加的灵活    stu, ok := iV.(Student)//防止同字段的别的结构体干扰，如Monster    if ok {        fmt.Printf(&quot;stu.Name=%v\n&quot;, stu.Name)//stu.Name=tom    }}type Student struct {    Name string    Age int}type Monster struct {    Name string    Age int}func main() {    //定义一个Student的实例    stu := Student{        Name : &quot;tom&quot;,        Age : 20,    }    reflectTest02(stu)}</code></pre><p>注意事项和细节：</p><ul><li><code>reflect.Value.Kind</code>，获取变量的类别，返回的是一个常量</li><li>Type是类型，Kind是类别，Type和Kind<strong>可能是相同的</strong>，也可能是不同的<ul><li>比如：var num int=10 num的Type是int,Kind也是int</li><li>比如：var stu Student stu的type是 包名.Student , Kind是 struct</li></ul></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言入门经典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NanoPi_Neo_Core底层开发</title>
      <link href="/2019/10/18/NanoPi_Neo_Core%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/"/>
      <url>/2019/10/18/NanoPi_Neo_Core%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="NanoPi-Neo-Core底层开发"><a href="#NanoPi-Neo-Core底层开发" class="headerlink" title="NanoPi Neo Core底层开发"></a>NanoPi Neo Core底层开发</h1><h2 id="一、编译下载镜像"><a href="#一、编译下载镜像" class="headerlink" title="一、编译下载镜像"></a>一、编译下载镜像</h2><p>各个部分编译后的文件都在对应的文件夹中，如编译friendlycore-xenial_4.14_armhf系统，对应的各个镜像就都在<code>friendlycore-xenial_4.14_armhf</code>文件夹中</p><p>最后生成的img文件会在<code>out</code>文件夹中</p><h3 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h3><h4 id="1-1编译uboot"><a href="#1-1编译uboot" class="headerlink" title="1.1编译uboot"></a>1.1编译uboot</h4><pre><code class="bash">UBOOT_SRC=../UBOOT/u-boot-sunxi-v2017.x ./build-uboot.sh friendlywrt_4.14_armhf</code></pre><h4 id="1-2编译Linux内核"><a href="#1-2编译Linux内核" class="headerlink" title="1.2编译Linux内核"></a>1.2编译Linux内核</h4><pre><code class="bash">KERNEL_SRC=../LINUX/linux-sunxi-4.14.y ./build-kernel.sh friendlycore-xenial_4.14_armhf</code></pre><p>编译内核时会自动编译设备树，如果想重新单独编译设备树，则有：</p><h5 id="单独编译设备树"><a href="#单独编译设备树" class="headerlink" title="单独编译设备树"></a>单独编译设备树</h5><pre><code class="bash">make distcleantouch .scmversionmake ARCH=arm sunxi_defconfigmake dtbs ARCH=arm CROSS_COMPILE=arm-linux- -j8</code></pre><h5 id="反编译设备树"><a href="#反编译设备树" class="headerlink" title="反编译设备树"></a>反编译设备树</h5><pre><code class="bash">./scripts/dtc/dtc -I dtb -O dts -o ../sun8i-h3-nanopi-neo-core.dts ./arch/arm/boot/dts/sun8i-h3-nanopi-neo-core.dtb</code></pre><h4 id="1-3编译根文件系统"><a href="#1-3编译根文件系统" class="headerlink" title="1.3编译根文件系统"></a>1.3编译根文件系统</h4><pre><code class="bash">echo hello &gt; friendlycore-xenial_4.14_armhf/rootfs/root/welcome.txt./build-rootfs-img.sh friendlycore-xenial_4.14_armhf/rootfs friendlycore-xenial_4.14_armhf</code></pre><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2. 下载"></a>2. 下载</h3><h4 id="2-1生成img镜像"><a href="#2-1生成img镜像" class="headerlink" title="2.1生成img镜像"></a>2.1生成img镜像</h4><h5 id="生成SD卡的img镜像"><a href="#生成SD卡的img镜像" class="headerlink" title="生成SD卡的img镜像"></a>生成SD卡的img镜像</h5><pre><code class="bash">sudo ./mk-sd-image.sh friendlycore-xenial_4.14_armhf [h3-sd-friendlycore.img(镜像名字，默认按照时间命名)]</code></pre><h5 id="烧录img镜像到SD卡"><a href="#烧录img镜像到SD卡" class="headerlink" title="烧录img镜像到SD卡"></a>烧录img镜像到SD卡</h5><pre><code class="bash">sudo dd if=out/h3-sd-friendlycore.img bs=1M of=/dev/sdX</code></pre><h4 id="2-2直接烧录"><a href="#2-2直接烧录" class="headerlink" title="2.2直接烧录"></a>2.2直接烧录</h4><pre><code class="bash">sudo ./fusing.sh /dev/sdX friendlycore-xenial_4.14_armhf</code></pre><h3 id="3-分区情况"><a href="#3-分区情况" class="headerlink" title="3.分区情况"></a>3.分区情况</h3><table><thead><tr><th>分区名字</th><th>文件系统</th><th>起始地址</th><th>长度</th><th>镜像名字</th><th>内容</th></tr></thead><tbody><tr><td>boot0</td><td>raw</td><td>0x2000</td><td>0x17FE000(24M-8k)</td><td>u-boot-sunxi-with-spl.bin</td><td>uboot</td></tr><tr><td>boot</td><td>fat</td><td>0x1800000</td><td>0x2800000(40M)</td><td>boot.img</td><td>kernel(zImage)+dtb</td></tr><tr><td>rootfs</td><td>ext4</td><td>0x4000000</td><td>0x48400000(1156M)</td><td>rootfs.img</td><td>根文件系统</td></tr><tr><td>userdata</td><td>ext4</td><td>0x4c400000</td><td>0x0</td><td>userdata.img</td><td></td></tr></tbody></table><h4 id="3-1自己创建img镜像文件"><a href="#3-1自己创建img镜像文件" class="headerlink" title="3.1自己创建img镜像文件"></a>3.1自己创建img镜像文件</h4><pre><code class="bash">dd if=/dev/zero of=镜像文件 bs=1024 count=0 seek=镜像大小#单位：k，uboot+kernel(zImage)+dtb+rootfs=1220M，脚本中默认(7800*1000*1000)/1024#sfdisk ： 查看分区信息#将MBR扇区签名写入到镜像sfdisk -u S -L -q 镜像文件 2&gt;/dev/null &lt;&lt; EOF2048,,0x0C,-EOF# 找到一个loop设备losetup -f# 将镜像文件虚拟成块设备sudo losetup 找到的loop设备 镜像文件#eg: losetup /dev/loop1 floppy.img# 利用友善之臂的工具sd_update，将分区表同目录下的uboot.bin、boot.img、rootfs.img、userdata.img拷贝到loop设备中并生成img镜像sudo ./tools/sd_update -d 找到的loop设备 -p ./friendlycore-xenial_4.14_armhf/partmap.txt(分区表)# 读取 找到的loop设备 分区信息sudo partprobe 找到的loop设备 -s 2&gt;/dev/null# 调整文件系统的大小，这里是p3，意为第三个分区，即userdata分区sudo resize2fs -f 找到的loop设备p3;# 卸载loop设备sudo losetup -d 找到的loop设备</code></pre><p>例子：</p><pre><code class="bash">dd if=/dev/zero of=out/busyboxflash.img bs=1024 count=0 seek=1331200#1331200k -&gt; 1300M ==&gt; 留给userdata 80M，修改partmap.txt中userdata大小为0x500 0000# 实测貌似最少需要8G才能用ubuntucore文件系统#sfdisk ： 查看分区信息#将MBR扇区签名写入到镜像sfdisk -u S -L -q out/busyboxflash.img 2&gt;/dev/null &lt;&lt; EOF2048,,0x0C,-EOF# 找到一个loop设备losetup -f# 将镜像文件虚拟成块设备sudo losetup /dev/loop17 out/busyboxflash.img# 利用友善之臂的工具sd_update，将分区表同目录下的uboot.bin、boot.img、rootfs.img、userdata.img拷贝到loop设备中并生成img镜像sudo ./tools/sd_update -d /dev/loop17 -p ./friendlycore-xenial_4.14_armhf/partmap.txt(分区表)# 读取/dev/loop17分区信息sudo partprobe /dev/loop17 -s 2&gt;/dev/null# 调整文件系统的大小，这里是p3，意为第三个分区，即userdata分区sudo resize2fs -f /dev/loop17p3;# 卸载loop设备sudo losetup -d /dev/loop17</code></pre><h5 id="dd命令详解"><a href="#dd命令详解" class="headerlink" title="dd命令详解"></a>dd命令详解</h5><p> dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 </p><ul><li><code>if</code>=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt;if=inputfile&gt;</li><li><code>of</code>=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li><li>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>  obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>  <code>bs</code>=bytes：同时设置读入/输出的块大小为bytes个字节。</li><li>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li><li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li><li><code>seek</code>=blocks：从输出文件开头跳过blocks个块后再开始复制。<br>  （注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li><li><code>count</code>=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li><li>conv=conversion：用指定的参数转换文件。<ul><li>ascii：转换ebcdic为ascii</li><li>ebcdic：转换ascii为ebcdic</li><li>ibm：转换ascii为alternateebcdic</li><li>block：把每一行转换为长度为cbs，不足部分用空格填充</li><li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>swab：交换输入的每对字节</li><li>noerror：出错时不停止</li><li>notrunc：不截短输出文件</li><li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ul></li></ul><h5 id="dev-null和-dev-zero的区别"><a href="#dev-null和-dev-zero的区别" class="headerlink" title="/dev/null和/dev/zero的区别"></a>/dev/null和/dev/zero的区别</h5><ul><li><code>/dev/null</code>，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ </li><li><code>/dev/zero</code>，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。 </li></ul><h2 id="二、开发环境搭建"><a href="#二、开发环境搭建" class="headerlink" title="二、开发环境搭建"></a>二、开发环境搭建</h2><h3 id="使用官方提供ubuntucore文件系统"><a href="#使用官方提供ubuntucore文件系统" class="headerlink" title="使用官方提供ubuntucore文件系统"></a>使用官方提供ubuntucore文件系统</h3><p>切换成root用户：</p><pre><code class="bash">su root</code></pre><p>普通用户： </p><pre><code class="bash">用户名: pi密码: pi</code></pre><p>Root用户： </p><pre><code class="bash">用户名: root密码: fa</code></pre><p>可能会遇到无法切换的行为，此时可以修改默认登录账号为root：</p><pre><code class="bash">cd /etc/systemd/system/serial-getty@ttyS0.service.d/vi autologin.conf修改前：[Service]ExecStart=ExecStart=-/sbin/agetty --autologin pi --keep-baud 115200,38400,9600 %I $TERM修改后：[Service]ExecStart=ExecStart=-/sbin/agetty --autologin root --keep-baud 115200,38400,9600 %I $TERM</code></pre><p>更新软件包</p><pre><code class="bash">apt-get update</code></pre><h3 id="自己制作根文件系统"><a href="#自己制作根文件系统" class="headerlink" title="自己制作根文件系统"></a>自己制作根文件系统</h3><p>详见另一篇博客——《构造根文件系统》</p><pre><code class="bash"># 拷贝lib库sudo cp ../Toolchain/4.9.3/arm-cortexa9-linux-gnueabihf/lib/*so* ./lib/ -dsudo cp ../Toolchain/4.9.3/arm-cortexa9-linux-gnueabihf/lib/*.a ./lib/ -d# 拷贝lib库sudo cp ../Toolchain/4.9.3/arm-cortexa9-linux-gnueabihf/sys-root/usr/lib/*so* ./usr/lib/ -dsudo cp ../Toolchain/4.9.3/arm-cortexa9-linux-gnueabihf/sys-root/usr/lib/*.a ./usr/lib/ -d# 查看lib文件大小du ./lib/ ./usr/lib/ -sh</code></pre><p>etc/init.d/rcS文件：</p><pre><code class="bash">#!/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/libexport PATH LD_LIBRARY_PATH runlevelmount -amkdir /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s</code></pre><p>chmod 777 rcS</p><p>etc/fstab文件：</p><pre><code class="bash">#device mount-point     type    options         dump    passproc    /proc           proc    defaults        0       0tmpfs   /tmp            tmpfs   defaults        0       0sysfs   /sys            sysfs   defaults        0       0tmpfs   /dev            tmpfs   defaults        0       0</code></pre><p>etc/inittab文件：</p><pre><code class="bash">#etc/inittab::sysinit:/etc/init.d/rcSconsole::askfirst:-/bin/sh::restart:/sbin/init::ctrlaltdel:/sbin/reboot::shutdown:/bin/umount -a -r::shutdown:/sbin/swapoff -a</code></pre><h4 id="打包成img镜像"><a href="#打包成img镜像" class="headerlink" title="打包成img镜像"></a>打包成img镜像</h4><pre><code class="bash"># 获得待打包成img镜像的rootfs文件夹大小du -s -B 1 friendlycore-xenial_4.14_armhf/rootfs | cut -f1# 利用友善之臂提供的工具make_ext4fs制作临时的ext4格式文件系统./tools/make_ext4fs  -s -l 最大镜像大小 -a root -L rootfs /dev/null 待打包成img镜像的rootfs文件夹 &gt; tempfile# 获得镜像大小cat tempfile | grep &quot;Suggest size:&quot; | cut -f2 -d &#39;:&#39; | awk &#39;{gsub(/^\s+|\s+$/, &quot;&quot;);print}&#39;# 注意：获得待打包成img镜像的rootfs文件夹大小 &lt; 获得镜像大小# 真正制作ext4格式文件系统./tools/make_ext4fs  -s -l 刚刚获得的镜像大小 -a root -L rootfs 镜像文件.img 待打包成img镜像的rootfs文件夹</code></pre><p>上述这一系列操作已经被友善之臂写入脚本<code>build-rootfs-img.sh</code>中，具体调用方面为：</p><pre><code class="bash">./build-rootfs-img rootfs文件夹所在目录 生成img的镜像文件所在的目录</code></pre><pre><code class="bash">eg：./build-rootfs-img.sh friendlycore-xenial_4.14_armhf/rootfs friendlycore-xenial_4.14_armhf或./build-rootfs-img.sh ~/nfs_root ~/nfs_root</code></pre><p><strong>注：</strong>重新配置文件系统后后，需要重新运行友善之臂的脚本<code>build-kernel.sh</code>编译一次内核，该脚本会将内核中的模块安装至该文件系统镜像中</p><p>自己做的rootfs平台，build-kernel.sh中需要注释一个平台检测的代码块，同时在./tools/update_kernel_bin_to_img.sh脚本中第122行需要将<code>echo &quot;IMG_SIZE=${IMG_SIZE}&quot; &gt; ${OUT}/${TARGET_OS}_rootfs-img.info</code>改为<code>echo &quot;IMG_SIZE=${IMG_SIZE}&quot;</code></p><pre><code class="bash">KERNEL_SRC=../LINUX/linux-sunxi-4.14.y ./build-kernel-others.sh 放rootfs.img和放生成的boot.img的文件夹</code></pre><p>参考前文，下载img镜像方法如下：</p><pre><code class="bash">dd if=/dev/zero of=out/busyboxflash.img bs=1024 count=0 seek=133120#133120k -&gt; 130M 删除partmap.txt中userdata分区#sfdisk ： 查看分区信息#将MBR扇区签名写入到镜像sfdisk -u S -L -q out/busyboxflash.img 2&gt;/dev/null &lt;&lt; EOF2048,,0x0C,-EOF# 找到一个loop设备losetup -f# 将镜像文件虚拟成块设备sudo losetup /dev/loop17 out/busyboxflash.img# 利用友善之臂的工具sd_update，将分区表同目录下的uboot.bin、boot.img、rootfs.img、userdata.img拷贝到loop设备中并生成img镜像sudo ./tools/sd_update -d /dev/loop17 -p ./busybox_rootfs/partmap_no_userdata.txt# 读取/dev/loop17分区信息sudo partprobe /dev/loop17 -s 2&gt;/dev/null# 卸载loop设备sudo losetup -d /dev/loop17</code></pre><p>经测试，没有重新编译内核会导致内核启动失败，错误信息：</p><pre><code class="bash">U-Boot SPL 2017.11 (Oct 12 2019 - 17:03:15)DRAM: 512 MiB(408MHz)CPU Freq: 408MHzmemory test: 1Pattern 55aa  Writing...Reading...OKTrying to boot from MMC1Boot device: sdU-Boot 2017.11 (Oct 12 2019 - 17:03:15 +0800) Allwinner TechnologyCPU:   Allwinner H3 (SUN8I 1680)Model: FriendlyElec NanoPi H3DRAM:  512 MiBCPU Freq: 1008MHzMMC:   SUNXI SD/MMC: 0, SUNXI SD/MMC: 1*** Warning - bad CRC, using default environmentIn:    serialOut:   serialErr:   serialNet:   No ethernet found.BOARD: nanopi-neo-corestarting USB...No controllers foundHit any key to stop autoboot:  0 ** Unrecognized filesystem type **## Executing script at 43100000Wrong image format for &quot;source&quot; command=&gt;</code></pre><p>根据日志分析貌似是在43100000地址处找不到脚本，但是这个地址是在rootfs中的。。。。。。</p><p>不会搞了，留个坑以后来填。。。。。。</p><h2 id="三、驱动编写"><a href="#三、驱动编写" class="headerlink" title="三、驱动编写"></a>三、驱动编写</h2><p>暂时采用官方镜像，镜像名字为<code>nanopi-neo-core_sd_friendlycore-xenial_4.14_armhf_20190823.img</code>，该镜像中采用的rootfs为<code>UbuntuCore 18.04</code></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="内核版本查看方法"><a href="#内核版本查看方法" class="headerlink" title="内核版本查看方法"></a>内核版本查看方法</h4><pre><code class="bash">cat /proc/versionuname -a</code></pre><h4 id="挂载pc上文件系统"><a href="#挂载pc上文件系统" class="headerlink" title="挂载pc上文件系统"></a>挂载pc上文件系统</h4><pre><code class="bash">mount -t nfs -o nolock 192.168.2.101:/home/null/Code/NanoPi_NEO_Core/nfs /mntmount -t nfs -o nolock 192.168.2.101:/home/null/nfs_root /mnt</code></pre><p>挂载报错尝试安装<code>nfs-common</code></p><blockquote><p>报错：</p><pre><code class="bash">mount: wrong fs type, bad option, bad superblock on 192.168.2.101:/home/null/nfs_root,       missing codepage or helper program, or other error       (for several filesystems (e.g. nfs, cifs) you might       need a /sbin/mount.&lt;type&gt; helper program)       In some cases useful info is found in syslog - try       dmesg | tail or so.</code></pre><p>安装nfs-common：</p><pre><code class="bash">sudo apt-get install nfs-common</code></pre></blockquote><p>pc端检查是否配置成功（自己挂接自己）（绝对路径）</p><pre><code class="bash">sudo mount -t nfs -o nolock localhost://home/null/Code/NanoPi_NEO_Core/nfs /mnt/nfs#挂接sudo mount -t nfs -o nolock localhost://home/null/nfs_root /mnt/nfs_root#挂接ls -l /mnt/nfs#检查ls -l /mnt/nfs_root#检查sudo umount /mnt/nfs#卸载sudo umount /mnt/nfs_root#卸载</code></pre><h5 id="一键挂载脚本"><a href="#一键挂载脚本" class="headerlink" title="一键挂载脚本"></a>一键挂载脚本</h5><pre><code class="bash">#!/bin/bashif [ $(id -u) -ne 0 ]; then    echo &quot;Re-running script under sudo...&quot;    sudo &quot;$0&quot; &quot;$@&quot;    exitfimount -t nfs -o nolock 192.168.2.101:/home/null/Code/NanoPi_NEO_Core/nfs /mntecho &quot;mount -&gt; /mnt&quot;</code></pre><p>记得chmod +x </p><h5 id="卸载脚本"><a href="#卸载脚本" class="headerlink" title="卸载脚本"></a>卸载脚本</h5><pre><code class="bash">#!/bin/bashif [ $(id -u) -ne 0 ]; then    echo &quot;Re-running script under sudo...&quot;    sudo &quot;$0&quot; &quot;$@&quot;    exitfiumount /mntecho &quot;umount /mnt OK&quot;</code></pre><p>记得chmod +x </p><h4 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h4><p>参考： <a href="http://mirrors.ustc.edu.cn/help/ubuntu-ports.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/ubuntu-ports.html</a></p><p>修改 <code>/etc/apt/sources.list</code> 文件中镜像源服务器地址 <a href="http://ports.ubuntu.com/" target="_blank" rel="noopener">http://ports.ubuntu.com/</a> 为 <a href="http://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/ubuntu-ports/</a></p><pre><code class="bash">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-security main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-updates main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-backports main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-backports main restricted universe multiverse</code></pre><p>更新源：</p><pre><code class="bash">sudo apt update</code></pre><h3 id="1-按键驱动程序"><a href="#1-按键驱动程序" class="headerlink" title="1.按键驱动程序"></a>1.按键驱动程序</h3><h4 id="1-1修改设备树"><a href="#1-1修改设备树" class="headerlink" title="1.1修改设备树"></a>1.1修改设备树</h4><h5 id="编译设备树"><a href="#编译设备树" class="headerlink" title="编译设备树"></a>编译设备树</h5><pre><code class="bash">make dtbs ARCH=arm CROSS_COMPILE=arm-linux- -j8</code></pre><h5 id="查看系统中是否存在对应节点"><a href="#查看系统中是否存在对应节点" class="headerlink" title="查看系统中是否存在对应节点"></a>查看系统中是否存在对应节点</h5><pre><code class="bash">ls /proc/device-tree/cat /proc/device-tree/key/compatible# 注意：hexdump查看的是dtb文件原始数据，其中的数据是按照大字节序排放的（低地址放高位）hexdump /proc/device-tree/key/key-gpiobusybox hexdump /proc/device-tree/key/key-gpio</code></pre><h5 id="设备树中的GPIO节点"><a href="#设备树中的GPIO节点" class="headerlink" title="设备树中的GPIO节点"></a>设备树中的GPIO节点</h5><p>假设PA6和PA7上接入两个LED，通过编写一个GPIO的驱动程序来控制LED的亮灭，在设备树文件sun8i-h3-nanopi-m1.dts的根节点增加一个myleds子节点  ：</p><pre><code>myleds {           compatible = &quot;usr,myleds&quot;;             led-gpios = &lt;&amp;pio 0  7  GPIO_ACTIVE_HIGH&gt;,&lt;&amp;pio 0  6  GPIO_ACTIVE_HIGH&gt;;/* 0表示PA组的io口, 因h3里第0组的io口就是以PA开始命名的 */          };</code></pre><p> 节点中的led-gpios属性，引用了pinctrl信息，sunxi-h3-h5.dtsi中有关于该控制器的描述， </p><pre><code>pio: pinctrl@01c20800 {    /* compatible is in per SoC .dtsi file */    reg = &lt;0x01c20800 0x400&gt;;    interrupts = &lt;GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH&gt;,    &lt;GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH&gt;;    clocks = &lt;&amp;ccu CLK_BUS_PIO&gt;, &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;    clock-names = &quot;apb&quot;, &quot;hosc&quot;, &quot;losc&quot;;    gpio-controller;    #gpio-cells = &lt;3&gt;;    interrupt-controller;    #interrupt-cells = &lt;3&gt;;    ......};</code></pre><p>myleds子节点描述了两个GPIO信息，具有多个gpio口信息的属性值: <code>&lt;&amp;gpio控制器节点名 具体gpio口的标识符&gt;,&lt;&amp;gpio控制器节点名 具体gpio口的标识符&gt; …;</code>具体gpio口的标识符是由多个数字组成, 数字的个数由所用的gpio控制器节点里的#gpio-cells属性值指定.。全志H3 共有七组GPIO ，也即七个bank，分别为PA (PA0-21),PC(PC0-16) PD (PD0-17), PE(PE0-15),PF(PF0-6) PG(PG0-13) ,PL(PL0-PL11),在内核中PA-PG是一个pinctrl控制器，而PL是另一个pinctrl控制器 。</p><p>由#gpio-cells = &lt;3&gt;可以推出GPIO属性需要用3个u32的数据描述，第一个参数代表该GPIO位于哪个bank，第二个参数代表该bank下的序号，第三个参数代表默认电平，myleds节点下的GPIO_ACTIVE_HIGH这个宏就定义于include/dt-bindings/gpio/gpio.h</p><h4 id="1-2编写驱动"><a href="#1-2编写驱动" class="headerlink" title="1.2编写驱动"></a>1.2编写驱动</h4><h5 id="1-2-1检查注册的驱动"><a href="#1-2-1检查注册的驱动" class="headerlink" title="1.2.1检查注册的驱动"></a>1.2.1检查注册的驱动</h5><ul><li><p>驱动安装好后，会在<code>/dev/</code>目录下创建同名目录</p></li><li><p>或者通过<code>cat /proc/devices</code>命令查看多出来的驱动</p></li></ul><h5 id="1-2-2gpiolib及gpio操作"><a href="#1-2-2gpiolib及gpio操作" class="headerlink" title="1.2.2gpiolib及gpio操作"></a>1.2.2gpiolib及gpio操作</h5><h6 id="经典接口"><a href="#经典接口" class="headerlink" title="经典接口"></a>经典接口</h6><ul><li><code>gpio_request</code>:驱动中要想使用某一个gpio，就必须先调用gpio_request接口来向内核申请，得到允许后才可以去使用这个gpio</li><li><code>gpio_free</code>: 对应gpio_request，用来释放申请后用完了的gpio</li><li><code>gpiochip_is_requested</code>: 接口用来判断某一个gpio是否已经被申请了</li><li><code>gpio_direction_input</code>/<code>gpio_direction_output</code>: 接口用来设置GPIO为输入/输出模式（不推荐直接设置寄存器）</li></ul><blockquote><ul><li>一般来说，gpio的资源申请和释放操作应该放在驱动模块的加载与卸载函数内</li><li>gpio_request的第一个参数是需要申请的gpio号。第二个参数是我们给该gpio起个名字</li><li>申请完了之后对这个gpio进行模式设置，我们这里用gpio_direction_output 设置成输出模式，并且默认输出1让led灭 </li></ul></blockquote><h6 id="新接口"><a href="#新接口" class="headerlink" title="新接口"></a>新接口</h6><ul><li><code>devm_gpio_request_one</code>： 自带初始化电平功能，并且会在模块卸载时自动释放gpio，十分简便 </li></ul><h6 id="读写gpio"><a href="#读写gpio" class="headerlink" title="读写gpio"></a>读写gpio</h6><ul><li><code>gpio_get_value</code>：读gpio</li><li><code>gpio_set_value</code>：写gpio</li></ul><h6 id="控制台中查看当前gpio占用情况的方法"><a href="#控制台中查看当前gpio占用情况的方法" class="headerlink" title="控制台中查看当前gpio占用情况的方法"></a>控制台中查看当前gpio占用情况的方法</h6><p>内核中提供了虚拟文件系统debugfs，里面有一个gpio文件，提供了gpio的使用信息</p><ul><li>使用 <code>mount -t debugfs debugfs /tmp</code> 把debugfs挂接到/tmp下，再重新进入/tmp后就能看到一个名为gpio的文件</li><li><code>cat /tmp/gpio</code>即可得到gpio的所有信息，使用完后<code>umount /tmp</code>卸载掉debugfs</li></ul><h4 id="1-3调试"><a href="#1-3调试" class="headerlink" title="1.3调试"></a>1.3调试</h4><h5 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h5><ul><li><p>查看<code>printk</code>输出的日志：</p><p>  通过<code>dmesg</code>和 <code>more</code>、<code>tail</code>、<code>less</code>、<code>grep</code>的结合查看日志</p><pre><code class="bash">#输出全部信息dmesg#输出前20行dmesg | head -20#输出后20行dmesg | tail -20#输出包含usb的信息（-i：忽略大小写）dmesg | grep -i usb#清空dmesg环形缓冲区中的日志dmesg -c    ```</code></pre></li><li><p>或者直接设置日志的输出的等级：</p><pre><code class="bash">  echo $level &gt; /proc/sys/kernel/printk#默认为4 4 1 7  #如：  echo 8 4 1 7 &gt; /proc/sys/kernel/printk#所有级别日志均可打印输出</code></pre><blockquote><p>/proc/sys/kernel/printk中对应的四个数分别对应于：</p><ul><li><p>①控制台日志级别：优先级高于该值的消息将被打印至控制台。</p></li><li><p>②缺省的消息日志级别：将用该值来打印没有优先级的消息。</p></li><li><p>③最低的控制台日志级别：控制台日志级别可能被设置的最小值。</p></li><li><p>④缺省的控制台：控制台日志级别的缺省值。</p><p>日志缓冲区的每一行文本开头具有级别标记, 级别值<strong>越小</strong>则优先级<strong>越高</strong>.  </p><p>系统定义了8个消息级别, 级别号从0到7分别为：</p></li><li><p>致命级(KERN_EMESG), </p></li><li><p>警戒级(KERN_ALERT), </p></li><li><p>临界级(KERN_CRIT),</p></li><li><p>错误级(KERN_ERR), </p></li><li><p>告警级(KERN_WARN), </p></li><li><p>注意级(KERN_NOTICE), </p></li><li><p>通知级(KERN_INFO),</p></li><li><p>调试级(KERN_DEBUG).</p></li></ul></blockquote></li></ul><h5 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h5><ul><li><p>&amp;</p><p>   当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh test.sh &amp;</p><p>  当成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(<code>ps -ef | grep 进程号</code> 或者 <code>kill -9 进程号</code>）</p></li><li><p>nohup  </p><p> 使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p><pre><code class="bash"> nohup command &amp;</code></pre><p> 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><pre><code class="bash"> nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></pre><p> 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p></li><li><p>ctrl + z </p><p> 可以将一个正在前台执行的命令放到后台，并且处于暂停状态。 </p></li><li><p>jobs<br>  查看当前有多少在后台运行的命令。<br>  <code>jobs -l</code>选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。 </p></li></ul><h3 id="2-内核定时器"><a href="#2-内核定时器" class="headerlink" title="2.内核定时器"></a>2.内核定时器</h3><h3 id="3-中断"><a href="#3-中断" class="headerlink" title="3.中断"></a>3.中断</h3><h4 id="上半部和下半部"><a href="#上半部和下半部" class="headerlink" title="上半部和下半部"></a>上半部和下半部</h4><ul><li><p>软中断</p><p>  软中断必须在编译的时候静态注册</p><ul><li>open_sotfirq：打开软中断</li><li>raise_sotfirq：触发软中断</li></ul></li><li><p>tasklet：利用软中断来实现的另一种下半部机制，在软中断和tasklet之间建议选tasklet</p><ul><li>tasklet_init：初始化tasklet_struct结构体，或直接使用宏DECLARE_TASKLET定义＋初始化</li><li>tasklet_schedule：一般在上半部中调用，使要调度的tasklet在合适的时候运行</li></ul></li><li><p>工作队列：在<strong>进程</strong>上下文执行，允许睡眠或重新调度（下半部可以睡眠就可以交给工作队列），要执行的工作会交给一个内核工作者线程去执行</p><ul><li>宏INIT_WORK：初始化工作</li><li>宏DECLARE_WORK：定义+初始化工作</li><li>schedule_work：类似tasklet_schedule，调度传入的工作</li></ul></li></ul><h4 id="3-1修改设备树"><a href="#3-1修改设备树" class="headerlink" title="3.1修改设备树"></a>3.1修改设备树</h4><p>参考内核绑定信息：Documentation/devicetree/bindings/arm/gic.txt</p><p>对于一般的ARM处理器来说，<code>#interrupt-cells=&lt;3&gt;</code>对应的三个cell分别为：</p><ol><li>中断类型<ul><li>0：SPI中断</li><li>1：PPI中断</li></ul></li><li>中断号<ul><li>SPI：0~987</li><li>PPI：0~15</li></ul></li><li>标志<ul><li>bit[3:0]：中断触发类型<ul><li>1：上升沿</li><li>2：下降沿</li><li>4：高电平</li><li>8：低电平</li></ul></li><li>bit[15:8]：PPI中断的CPU掩码</li></ul></li></ol><h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>irq_of_parse_and_map：从设备树中中断节点中的interrupts属性提取对应的中断号</li><li>gpio_to_irq：获取gpio对应的中断号</li></ul><h5 id="编译设备树-1"><a href="#编译设备树-1" class="headerlink" title="编译设备树"></a>编译设备树</h5><pre><code class="bash">make dtbs ARCH=arm CROSS_COMPILE=arm-linux- -j8</code></pre><h5 id="查看系统中是否存在对应节点-1"><a href="#查看系统中是否存在对应节点-1" class="headerlink" title="查看系统中是否存在对应节点"></a>查看系统中是否存在对应节点</h5><pre><code class="bash">ls /proc/device-tree/cat /proc/device-tree/key/compatible# 注意：hexdump查看的是dtb文件原始数据，其中的数据是按照大字节序排放的（低地址放高位）hexdump /proc/device-tree/key/interruptsbusybox hexdump /proc/device-tree/key/interrupts</code></pre><h5 id="设备树中的中断节点"><a href="#设备树中的中断节点" class="headerlink" title="设备树中的中断节点"></a>设备树中的中断节点</h5><ul><li>interrupt-parent = &lt;&amp;pio&gt;;//属于pio中断控制器</li><li>interrupts = &lt;0 7 IRQ_TYPE_EDGE_BOTH&gt;;<ul><li>第一个参数：第几个GPIO（这里是GPIOA）</li><li>第二个参数：第几个外部中断</li><li>第三个参数：触发沿</li></ul></li></ul><h4 id="3-2编写驱动"><a href="#3-2编写驱动" class="headerlink" title="3.2编写驱动"></a>3.2编写驱动</h4><h4 id="3-3调试"><a href="#3-3调试" class="headerlink" title="3.3调试"></a>3.3调试</h4><p>中断注册成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">cat /proc/interrupts</code></pre><h3 id="4-input子系统"><a href="#4-input子系统" class="headerlink" title="4.input子系统"></a>4.input子系统</h3><h4 id="4-1修改设备树"><a href="#4-1修改设备树" class="headerlink" title="4.1修改设备树"></a>4.1修改设备树</h4><p>如果需要使用内核自带的<code>gpio_keys.c</code>驱动，可以参考内核中<code>Documentation/devicetree/bindings/input/gpio-keys.txt</code>，需要设备树中的节点满足以下要求：</p><ul><li><p>节点名字为<code>“gpio-keys”</code></p></li><li><p>gpio-keys节点的compatible属性必须为<code>“gpio-keys”</code></p></li><li><p>所有的按键都是gpio-keys的子节点，并可以使用如下属性描述自己：</p><ul><li>gpios：按键连接的gpio信息</li><li>interrupts：按键使用的中断信息（可选）</li><li>lable：按键名字</li><li>linux,code：要模拟的按键值</li></ul></li><li><p>如果要支持连按的话需要加入<code>autorepeat</code>属性</p><p>  例子：</p><pre><code>  gpio_keys {      compatible = &quot;gpio-keys&quot;;      autorepeat;//支持连按      k1 {          label = &quot;k1&quot;;//按键名称          linux,code = &lt;KEY_POWER&gt;;//要模拟的按键值          gpios = &lt;&amp;pio 0 7 GPIO_ACTIVE_LOW&gt;;//按键连接的gpio信息          interrupts = &lt;0 7 IRQ_TYPE_EDGE_BOTH&gt;;//中断信息 PA7 --&gt; EINT7      };  };</code></pre></li></ul><h4 id="4-2编写驱动"><a href="#4-2编写驱动" class="headerlink" title="4.2编写驱动"></a>4.2编写驱动</h4><p>Linux中已经实现了input输入子系统框架，因此无需再次注册设备，系统中input框架中的所有设备的主设备号均为13</p><ul><li>input设备结构体<code>input_dev</code><ul><li>evbit成员：输入事件类型，可选事件见下文</li><li>keybit成员：按键值</li><li>relbit成员：相对坐标</li><li>absbit成员：绝对坐标</li><li>…</li></ul></li></ul><p>设置input_dev结构体中成员的方法：</p><ul><li>__set_bit</li><li>BIT_MASK宏</li><li>input_set_capability：仅仅设置keybit成员</li></ul><h5 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>input_allocate_device：申请一个input_dev结构体</li><li>input_free_device：释放申请到的input_dev结构体</li><li>input_register_device：向内核注册input_dev结构体</li><li>input_unregister_device：注销input_dev结构体</li><li>input_event：上报指定事件及对应的值<ul><li>input_report_key：封装一层，专门上报按键事件</li><li>input_report_rel</li><li>input_report_abs</li><li>input_report_ff_status</li><li>input_report_switch</li><li>input_mt_sync</li></ul></li><li>input_sync：同步事件</li></ul><h5 id="input-dev的相关事件"><a href="#input-dev的相关事件" class="headerlink" title="input_dev的相关事件"></a>input_dev的相关事件</h5><ul><li>EV_SYN：同步</li><li>EV_KEY：按键</li><li>EV_REL：相对坐标</li><li>EV_ABS：绝对坐标</li><li>EV_MSC：杂项（其他）</li><li>EV_SW：开关</li><li>EV_LED：LED</li><li>EV_SND：声音（sound）</li><li>EV_REP：重复事件</li><li>EV_FF：压力</li><li>EV_PWR：电源</li><li>EV_FF_STATUS：压力状态</li></ul><h4 id="4-3调试"><a href="#4-3调试" class="headerlink" title="4.3调试"></a>4.3调试</h4><p>input设备注册成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">ls /dev/input/ -l</code></pre><p>通过以下命令查看是否有效：</p><pre><code>busybox hexdump /dev/input/event1</code></pre><h3 id="5-IIC框架驱动"><a href="#5-IIC框架驱动" class="headerlink" title="5.IIC框架驱动"></a>5.IIC框架驱动</h3><h4 id="5-1设备树"><a href="#5-1设备树" class="headerlink" title="5.1设备树"></a>5.1设备树</h4><ul><li><code>clock-frequency</code>属性：iic总线的速度（默认100000，即100k）</li><li>status：是否使能该总线<ul><li>okay</li><li>disabled</li></ul></li><li>iic设备节点需要写到iic总线节点中，作为总线节点的子节点</li><li>总线节点需要利用<code>pinctrl-names = &quot;default&quot;;</code>和<code>pinctrl-0</code>指定iic引脚（已经设置好）</li><li>iic控制器节点<code>compatible</code>属性必须为allwinner,sun6i-a31-i2c或allwinner,sun4i-a10-i2c，这里在sunxi-h3-h5.dtsi中已经设置好，无需再次设置</li></ul><p>设备树修改成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">#查看设备节点，该目录下放着所有的i2c设备#节点是以i2c地址结尾的文件夹ls /sys/bus/i2c/devices/</code></pre><h4 id="5-2驱动"><a href="#5-2驱动" class="headerlink" title="5.2驱动"></a>5.2驱动</h4><h5 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><ul><li>IIC总线结构体<code>i2c_bus_type</code><ul><li>match函数：驱动和设备匹配是调用该函数来决定是否匹配</li></ul></li><li>IIC适配器（控制器）驱动结构体<code>i2c_adapter</code><ul><li>algo：总线访问算法成员<ul><li>master_xfer：IIC适配器的传输函数</li><li>smbus_xfer：SMBUS总线传输函数</li></ul></li></ul></li><li>IIC设备结构体<code>i2c_client</code><ul><li>addr：芯片地址，存在低7位</li><li>name：名字</li><li>adapter：对应的IIC适配器</li><li>dev：设备结构体</li><li>irq：中断</li></ul></li><li>IIC设备驱动结构体<code>i2c_driver</code><ul><li>probe函数：IIC设备和驱动匹配后调用，初始化用</li><li>remove函数：同理，卸载用</li><li>id_table：传统方式匹配ID列表</li><li>driver：<ul><li>owner：所有者，一般为宏THIS_MODULE</li><li>name：名字</li><li>of_match_table：设备树匹配列表</li></ul></li></ul></li><li>IIC发送数据结构体<code>i2c_msg</code><ul><li>addr：从机地址</li><li>flags：标志</li><li>len：消息长度</li><li>buf：消息数据</li></ul></li></ul><h5 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>IIC适配器（控制器）<ul><li>i2c_add_adapter：向系统注册i2c_adapter成员，使用动态总线号</li><li>i2c_add_numbered_adapter：向系统注册i2c_adapter成员，使用静态总线号</li><li>i2c_del_adapter：删除IIC适配器</li></ul></li><li>SPI设备<ul><li>i2c_register_driver / i2c_add_driver：注册i2c_driver</li><li>i2c_del_driver：卸载i2c_driver</li></ul></li><li>传输数据<ul><li>i2c_transfer：传输i2c_msg类型数据</li><li>i2c_master_send：IIC发送缓存中的数据，最后会调用i2c_transfer</li><li>i2c_master_recv：IIC接收数据到缓存中，最后会调用i2c_transfer</li></ul></li></ul><h4 id="5-3调试"><a href="#5-3调试" class="headerlink" title="5.3调试"></a>5.3调试</h4><h5 id="i2c-tools工具"><a href="#i2c-tools工具" class="headerlink" title="i2c-tools工具"></a>i2c-tools工具</h5><p>得益于ubuntucore，直接运行<code>sudo apt install i2c-tools</code>安装i2c-tools工具</p><ul><li>查询i2c总线<code>sudo i2cdetect -l</code></li><li>检测i2c地址<code>sudo i2cdetect -r -y 0</code>（最后的0为i2c-0总线）</li></ul><h3 id="6-SPI框架驱动"><a href="#6-SPI框架驱动" class="headerlink" title="6.SPI框架驱动"></a>6.SPI框架驱动</h3><h4 id="6-1设备树"><a href="#6-1设备树" class="headerlink" title="6.1设备树"></a>6.1设备树</h4><ul><li><code>spi-max-frequency</code>属性：spi总线的最大速度（默认100000，即100k）</li><li>status：是否使能该总线<ul><li>okay</li><li>disabled</li></ul></li><li>spi设备节点需要写到spi总线节点中，作为总线节点的子节点</li><li>通过<code>cs-gpios</code>属性指定CS引脚</li><li>spi设备节点中<code>reg</code>和节点<code>@</code>后的数字均为该设备所使用的spi通道（一般0即可）</li><li>总线节点需要利用<code>pinctrl-names = &quot;default&quot;;</code>和<code>pinctrl-0</code>指定spi引脚（已经设置好）</li><li>spi控制器节点<code>compatible</code>属性必须为allwinner,sun8i-h3-spi或allwinner,sun6i-a31-spi，这里在sunxi-h3-h5.dtsi中已经设置好，无需再次设置</li></ul><p>设备树修改成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">#查看设备节点，该目录下放着所有的i2c设备#节点是以i2c地址结尾的文件夹ls /sys/bus/spi/devices/</code></pre><h4 id="6-2驱动"><a href="#6-2驱动" class="headerlink" title="6.2驱动"></a>6.2驱动</h4><h5 id="基本数据结构-1"><a href="#基本数据结构-1" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><ul><li>SPI总线结构体<code>spi_bus_type</code><ul><li>match函数：驱动和设备匹配是调用该函数来决定是否匹配</li></ul></li><li>SPI主机驱动结构体<code>spi_master</code><ul><li>transfer函数：控制器数据传输函数</li><li>transfer_one_message函数：控制器数据传输函数，一次发一个spi_message包</li></ul></li><li>SPI设备驱动结构体<code>spi_driver</code><ul><li>probe函数：SPI设备和驱动匹配后调用，初始化用</li><li>remove函数：同理，卸载用</li><li>id_table：传统方式匹配ID列表</li><li>driver：<ul><li>owner：所有者，一般为宏THIS_MODULE</li><li>name：名字</li><li>of_match_table：设备树匹配列表</li></ul></li></ul></li><li>SPI传输信息结构体<code>spi_transfer</code><ul><li>tx_buf：发送数据</li><li>rx_buf：接收数据</li><li>len：数据长度</li></ul></li><li>SPI消息结构体<code>spi_message</code>，由<code>spi_transfer</code>组成<ul><li>complete函数：异步传输完成时调用</li></ul></li></ul><h5 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>SPI主机<ul><li>spi_alloc_master：申请spi_master结构体</li><li>spi_master_put：释放spi_master结构体</li><li>spi_register_master：注册</li><li>spi_unregister_master：注销</li></ul></li><li>SPI设备<ul><li>spi_register_driver：注册</li><li>spi_unregister_driver：卸载</li></ul></li><li>数据传输<ul><li>spi_message_init：初始化spi_message结构体</li><li>spi_message_add_tail：将spi_transfer添加到spi_message队列中</li><li>spi_sync：同步传输（会阻塞并等待SPI数据传输完成）</li><li>spi_async：异步传输（传输完成后会调用spi_message.complete函数）</li></ul></li></ul><h4 id="6-3调试"><a href="#6-3调试" class="headerlink" title="6.3调试"></a>6.3调试</h4>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NanoPi Neo Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiCheePi_Zero底层开发</title>
      <link href="/2019/10/18/LiCheePi_Zero%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/"/>
      <url>/2019/10/18/LiCheePi_Zero%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LiCheePi-Zero底层开发"><a href="#LiCheePi-Zero底层开发" class="headerlink" title="LiCheePi Zero底层开发"></a>LiCheePi Zero底层开发</h1><p> <img src="//NU-LL.github.io/2019/10/18/LiCheePi_Zero底层开发/fb63cd12ae1def9dd50710d2a32dc5c1_1095x740.png" alt="GPIO引脚图"> </p><h2 id="各种文件"><a href="#各种文件" class="headerlink" title="各种文件"></a>各种文件</h2><p>烧录工具：sunxi-tools-spi-rebase.zip</p><p>根文件系统：buildroot-2019.08.tar.bz2</p><p>交叉编译器：gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz</p><p>Uboot：u-boot-3s-current.zip</p><ul><li>spi nor flash启动：u-boot-3s-spi-experimental.zip</li></ul><p>主线Linux内核：linux-zero-4.10.y.zip、linux-zero-4.13.y.zip </p><p>BSP内核：v3s_lichee.zip（ camdriod ，需要从中剥离出内核）</p><h2 id="一、编译下载镜像"><a href="#一、编译下载镜像" class="headerlink" title="一、编译下载镜像"></a>一、编译下载镜像</h2><h3 id="1-编译及相关配置"><a href="#1-编译及相关配置" class="headerlink" title="1. 编译及相关配置"></a>1. 编译及相关配置</h3><h4 id="1-1编译uboot"><a href="#1-1编译uboot" class="headerlink" title="1.1编译uboot"></a>1.1编译uboot</h4><pre><code class="bash">#480x272LCD：LicheePi_Zero_480x272LCD_defconfig#800x480LCD：LicheePi_Zero_800x480LCD_defconfig#make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_480x272LCD_defconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfigmake ARCH=arm menuconfig#配置make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8</code></pre><p> 编译完成后，在当前目录下生成了<code>u-boot-sunxi-with-spl.bin</code> </p><blockquote><p>自定义uboot配置</p><p>该部分属于自定义部分，可以直接采用默认配置</p><ul><li>Architecture select架构选择：ARM架构 </li><li>ARM architecture<ul><li>DDR相关配置</li><li>LCD相关配置</li></ul></li><li>Boot images<ul><li>CPU clock frequency：时钟频率配置</li></ul></li><li>delay in seconds before automatically booting：开机等待时间的秒数</li><li>SPL/TPL<ul><li>MMC raw mode: by sector                       按扇区</li><li>Address on the MMC to load U-Boot from  mmc加载uboot的地址</li><li>Support GPIO                                 支持GPIO</li><li>Support I2C                                 支持I2C</li><li>Support common libraries                    支持通用lib</li><li>Support disk paritions                      支持分区</li><li>Support generic libraries                   支持一般lib库</li><li>Support MMC                                 支持MMC</li><li>Support power drivers                  支持电源驱动</li><li>Support serial                               支持串口</li></ul></li></ul></blockquote><h5 id="修改代码支持SD卡"><a href="#修改代码支持SD卡" class="headerlink" title="修改代码支持SD卡"></a>修改代码支持SD卡</h5><p>源码：u-boot-3s-current</p><p>增加uboot源码中<code>include/configs/sun8i.h</code> ：</p><pre><code class="c">#define CONFIG_BOOTCOMMAND      &quot;load mmc 0:1 0x41000000 zImage;&quot;  \                            &quot;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero.dtb;&quot; \                            &quot;bootz 0x41000000 - 0x41800000;&quot;#define CONFIG_BOOTARGS      &quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot;</code></pre><h5 id="修改代码支持SPI-FLASH"><a href="#修改代码支持SPI-FLASH" class="headerlink" title="修改代码支持SPI FLASH"></a>修改代码支持SPI FLASH</h5><p>源码：u-boot-3s-spi-experimental</p><p>如果flash大于16M，需要修改uboot配置，勾选flash bank支持选项（ CONFIG_SPI_FLASH_BAR ）</p><p>增加uboot源码中<code>include/configs/sun8i.h</code> ：</p><pre><code class="c">#define CONFIG_BOOTCOMMAND   &quot;sf probe 0; &quot;                           \                             &quot;sf read 0x41800000 0x100000 0x10000; &quot;  \/*从flash0x100000（1MB）位置读取dtb放到内存0x41800000偏移处。 //如果是bsp的bin，则是0x41d00000*/                             &quot;sf read 0x41000000 0x110000 0x400000; &quot; \                             &quot;bootz 0x41000000 - 0x41800000&quot;#define CONFIG_BOOTARGS      &quot;console=ttyS0,115200 earlyprintk panic=5 rootwait &quot; \                             &quot;mtdparts=spi32766.0:1M(uboot)ro,64k(dtb)ro,4M(kernel)ro,-(rootfs) root=31:03 rw rootfstype=jffs2&quot;</code></pre><h4 id="1-2编译Linux内核"><a href="#1-2编译Linux内核" class="headerlink" title="1.2编译Linux内核"></a>1.2编译Linux内核</h4><h5 id="1-2-1-主线内核"><a href="#1-2-1-主线内核" class="headerlink" title="1.2.1 主线内核"></a>1.2.1 主线内核</h5><pre><code class="bash">#bsp内核中用到是arm-linux-gnueabi-，工具链为自带的4.6.3make ARCH=arm licheepi_zero_defconfigmake ARCH=arm menuconfig   #add bluethooth, etc.make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 modules#INSTALL_MOD_PATH：把指定为M的驱动安装到指定文件系统根目录下面的/lib/modules目录下面make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 INSTALL_MOD_PATH=指定文件系统根目录 modules_install</code></pre><p>编译完成后，zImage在<code>arch/arm/boot/</code>下，驱动模块在INSTALL_MOD_PATH指定的目录下 </p><h6 id="使用SPI的uboot时需要配置"><a href="#使用SPI的uboot时需要配置" class="headerlink" title="使用SPI的uboot时需要配置"></a>使用SPI的uboot时需要配置</h6><pre><code>Device Drivers    &lt;*&gt; Memory Technology Device (MTD) support  ---&gt;        &lt;*&gt;   Command line partition table parsing//解析uboot传递过来的flash分区信息。        &lt;*&gt;   SPI-NOR device support  ---&gt;//支持SPI-NOR 设备File systems    [*] Miscellaneous filesystems  ---&gt;        &lt;*&gt;   Journalling Flash File System v2 (JFFS2) support//添加对jffs2文件系统的支持</code></pre><p>设备树中添加spi flash节点信息</p><pre><code>&amp;spi0 {        status =&quot;okay&quot;;        xt25f128b:xt25f128b@0 {                compatible = &quot;jedec,spi-nor&quot;;                reg = &lt;0x0&gt;;                spi-max-frequency = &lt;50000000&gt;;                #address-cells = &lt;1&gt;;                #size-cells = &lt;1&gt;;        };};</code></pre><p>内核代码<code>drivers/mtd/devices/m25p80.c</code>中添加flash型号</p><pre><code class="c">static const struct spi_device_id m25p_ids[] = {    ...    {&quot;w25q80bl&quot;},    {&quot;w25q128&quot;},/* add xt25f128b --by jz */{&quot;xt25f128b&quot;},/* add xt25f128b --by jz */    {&quot;w25q256&quot;},    ...    { },};</code></pre><p>内核代码<code>drivers/mtd/spi-nor/spi-nor.c</code>中添加flash型号</p><pre><code class="c">static const struct flash_info spi_nor_ids[] = {    ...    { &quot;w25q128&quot;, INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },    {&quot;xt25f128b&quot;,INFO(0x0b4018, 0, 64 * 1024, 256, 0) },/*add xt25f128b   by j.z.*/    { &quot;w25q256&quot;, INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },    ...    { },};</code></pre><ul><li>mkfs.jffs2 使用的最小擦除尺寸是8KB，而spi flash的扇区大小是4KB，所以按照扇区擦除的话，会无法使用，所以必须使用块擦除。 所以这里应该去掉SECT_4K</li></ul><h6 id="wifi使能配置"><a href="#wifi使能配置" class="headerlink" title="wifi使能配置"></a>wifi使能配置</h6><p>linux-zero-4.10.y.zip 内核才有<code>rtl8723bs</code>wifi的驱动（默认支持，编译成模块）</p><pre><code>-&gt; Device Drivers    -&gt; Staging drivers (STAGING [=y])        &lt;M&gt;   Realtek RTL8723BS SDIO Wireless LAN NIC driver (CONFIG_RTL8723BS)//尝试去支持ov2640 但是貌似不起效 先记着-&gt; Device Drivers    -&gt; Multimedia support (MEDIA_SUPPORT [=y])        [*]   Cameras/video grabbers support        [*]   V4L platform devices  ---&gt;        [ ]   Autoselect ancillary drivers (tuners, sensors, i2c, spi, frontends)        -&gt; I2C Encoders, decoders, sensors and other helper chips            &lt;M&gt; OmniVision OV2640 sensor support (CONFIG_VIDEO_OV2640)            &lt;M&gt; OmniVision OV2659 sensor support            &lt;M&gt; OmniVision OV7640 sensor support            &lt;M&gt; OmniVision OV7670 sensor support//尝试去支持lcd-&gt; Device Drivers    Graphics support  ---&gt;        [*] Backlight &amp; LCD device support  ---&gt;//LCD和背光控制            Console display driver support  ---&gt;//控制台Framebuffer支持                [*]   Framebuffer Console Rotation        [*] Bootup logo  ---&gt;//linux启动的开机界面</code></pre><p>使能之后还需要<code>rtl8723bs_nic.bin</code>wifi固件，放到 <code>/lib/firmware/rtlwifi/</code> 中，没有的话要自己建立。</p><h5 id="1-2-2-BSP内核"><a href="#1-2-2-BSP内核" class="headerlink" title="1.2.2 BSP内核"></a>1.2.2 BSP内核</h5><ul><li><p>解压v3s_lichee.zip， BSP内核源码在lichee/linux-3.4下</p><ul><li><p>采用WhyCan上大佬的配置文件lichee_BSP_config ：<code>cp lichee_BSP_config .config</code> </p></li><li><p>配置内核 <code>make ARCH=arm menuconfig</code> （下面这些均基于默认配置）</p><ul><li><p>使能USB摄像头驱动（已经使能）：</p><pre><code>  -&gt; Device Drivers      -&gt; Multimedia support (MEDIA_SUPPORT [=y])          -&gt; Video capture adapters (VIDEO_CAPTURE_DRIVERS [=y])              -&gt; V4L USB devices (V4L_USB_DRIVERS [=y])                  -&gt;&lt;M&gt;   USB Video Class (UVC)  CONFIG_USB_VIDEO_CLASS</code></pre></li><li><p>使能DVP/MIPI摄像头（需选上ov2640）：</p><pre><code>  -&gt; Device Drivers      -&gt; Multimedia support (MEDIA_SUPPORT [=y])          -&gt; Video capture adapters (VIDEO_CAPTURE_DRIVERS [=y])              -&gt; V4L platform devices (V4L_PLATFORM_DRIVERS [=y])                  -&gt; SoC camera support (SOC_CAMERA [=y])                      &lt;M&gt;     ov2640 camera support（默认没有选上）                      &lt;M&gt;     ov5642 camera support                      &lt;M&gt;   sunxi video front end (camera and etc)driver                      &lt;M&gt;     v4l2 driver for SUNXI          &lt;*&gt;   sunxi video encoder and decoder support</code></pre></li><li><p>由于camdriod原始的内核配置是为了在spi nor flash上运行而配置的，没有ext4支持，所以需要额外添加ext4支持（已经使能）：</p><pre><code> File systems  ---&gt;     &lt;*&gt; The Extended 4 (ext4) filesystem     [*]   Use ext4 for ext2/ext3 file systems (NEW)     [*]   Ext4 extended attributes (NEW)     [ ]     Ext4 POSIX Access Control Lists (NEW)     [ ]     Ext4 Security Labels (NEW)     [ ]   EXT4 debugging support (NEW)     [ ] JBD2 (ext4) debugging support (NEW) #支持大文件，以便于挂载文件系统 [*] Enable the block layer  ---&gt;     [*]   Support for large (2TB+) block devices and files #加上CGROUPS支持 -&gt; General setup      [*] Control Group support  ---&gt; #开启SWAP -&gt; General setup      [*] Support for paging of anonymous memory (swap)</code></pre></li><li><p>开启 FHANDLE 特性（ 否则debian下会出现报错）（已经使能）：</p><pre><code>  -&gt; General setup      [*] open by fhandle syscalls (EXPORTFS [=y])</code></pre></li><li><p>开启wifi功能（AW_RF_PM功能未使能）</p><pre><code>  #开启RTL8723BS的支持  -&gt; Device Drivers      -&gt; Network device support (NETDEVICES [=y])          -&gt; Wireless LAN (WLAN [=y])              &lt;M&gt;   Realtek 8723B SDIO WiFi  #开启AW_RF_PM功能  -&gt; Device Drivers      -&gt; Misc devices          [*] Allwinner rf module pm driver</code></pre></li></ul></li></ul></li><li><p>编译并提取bsp内核</p><ul><li><p>解压buildroot/dl/gcc-linaro.tar.bz2到lichee/out/sun8iw8p1/linux/common/buildroot/external-toolchain</p><pre><code class="bash">#在lichee目录下mkdir -p out/sun8iw8p1/linux/common/buildroot/external-toolchaintar --strip-components=1 -jxf buildroot/dl/gcc-linaro.tar.bz2 -C out/sun8iw8p1/linux/common/buildroot/external-toolchaintouch out/sun8iw8p1/linux/common/buildroot/external-toolchain/.installedmv out/sun8iw8p1/linux/common/buildroot/external-toolchain/gcc-linaro/* out/sun8iw8p1/linux/common/buildroot/external-toolchain/rm -rf out/sun8iw8p1/linux/common/buildroot/external-toolchain/gcc-linaro/</code></pre></li><li><p>安装<code>lib32z1</code>解决64位的操作系统中没有32位的类库的问题</p><pre><code class="bash">sudo apt-get updatesudo apt-get install lib32z1</code></pre></li><li><p>在linux-3.4目录下执行：</p><pre><code class="bash">#使用解压的工具链export PATH=../out/sun8iw8p1/linux/common/buildroot/external-toolchain/bin:../tools/pack/pctools/linux/android:$PATH#清除上次编译./scripts/build_tiger-cdr.sh clean#直接编译#后面的选项根据lichee\linux-3.4\arch\arm\configs\sun8iw8p1smp_defconfig来配置make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j16make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j16 modulesmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j16 INSTALL_MOD_PATH=/home/null/Code/LiCheePi_Zero/Image/cam_image/rootfs modules_install#LICHEE_JLEVEL：-j${LICHEE_JLEVEL}#LICHEE_JLEVEL=8 ./scripts/build_tiger-cdr.sh#./scripts/build_sun8iw8p1.sh all</code></pre></li></ul></li></ul><h5 id="1-2-3-单独编译设备树"><a href="#1-2-3-单独编译设备树" class="headerlink" title="1.2.3 单独编译设备树"></a>1.2.3 单独编译设备树</h5><pre><code class="bash">make ARCH=arm licheepi_zero_defconfigmake dtbs ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8#bsp内核编译设备树：dtc -I dts -O dtb -o ../sun8i-v3s-blueberrypi-csi-ov2640-480x272LCD.dtb ../sun8i-v3s-blueberrypi-csi-ov2640-480x272LCD.dts./scripts/dtc/dtc -I dts -O dtb -o ../sun8i-v3s-blueberrypi-csi-ov2640-480x272LCD.dtb ./arch/arm/boot/dts/sun8i-v3s-blueberrypi-csi-ov2640-480x272LCD.dts</code></pre><p>如果设备树中有include包含关系，是不能够直接用dtc编译的，会报include相关的错。</p><p>DTC本身不支持#include语法，其正确语法为<code>/include/</code>。 </p><p>对于以下稍微复杂一点（包含#include，宏，*.h等）的设备树，以上的方法不免有些笨拙。 </p><p>由于“#include”“宏”等都是C的特征，因此可以使用CPP(C Preprocessor)命令对dts源文件进行处理，完成文件包含与宏置换的工作。 </p><p>用下面的脚本dts2dtb.sh可以实现目的：</p><pre><code class="bash">#/bin/bash#set -vxdevice=&quot;your_device_name&quot;src_dts=$device.dtstmp_dts=$device.tmp.dtsdst_dtb=$device.dtbcpp -nostdinc -I. -undef -x assembler-with-cpp $src_dts &gt; $tmp_dtsdtc -O dtb -b 0 -o $dst_dtb $tmp_dtsrm $tmp_dts</code></pre><h5 id="1-2-4-反编译设备树"><a href="#1-2-4-反编译设备树" class="headerlink" title="1.2.4 反编译设备树"></a>1.2.4 反编译设备树</h5><pre><code class="bash">./scripts/dtc/dtc -I dtb -O dts -o ../sun8i-v3s-licheepi-zero.dts ./arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb./scripts/dtc/dtc -I dtb -O dts -o ../sun8i-v3s-licheepi-zero-dock.dts ./arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb#bsp内核反汇编：dtc -I dtb -O dts -o ../sun8i-v3s-blueberrypi-csi-ov2640.dts ../sun8i-v3s-blueberrypi-csi-ov2640.dtb</code></pre><h4 id="1-3buildroot编译根文件系统"><a href="#1-3buildroot编译根文件系统" class="headerlink" title="1.3buildroot编译根文件系统"></a>1.3buildroot编译根文件系统</h4><pre><code class="bash">make menuconfig</code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><pre><code>target options     -&gt; Target Architecture = ARM (little endian)    -&gt; Target Binary Format = ELF    -&gt; Target Architecture Variant = cortex-A7    -&gt; Target ABI = EABIhf    -&gt; Floating point strategy = VFPv4    -&gt; ARM instruction set = ARMToolchain    -&gt; Toolchain type = External toolchain    -&gt; Toolchain = Custom toolchain //用户自己的交叉编译器    -&gt; Toolchain origin = Pre-installed toolchain //预装的编译器    -&gt; Toolchain path =/home/null/Toolchain/6.3.1/    -&gt; Toolchain prefix = $(ARCH)-linux-gnueabihf //前缀    -&gt; External toolchain gcc version = 6.x    -&gt; External toolchain kernel headers series = 4.6.x//可在内核文件夹根目录Makefile文件中查看相应内核版本    -&gt; External toolchain C library = glibc/eglibc    -&gt; [*] Toolchain has SSP support? (NEW) //选中    -&gt; [*] Toolchain has RPC support? (NEW) //选中    -&gt; [*] Toolchain has C++ support? //选中    -&gt; [*] Enable MMU support (NEW) //选中System configuration    -&gt; System hostname = LiCheePiZero //平台名字，自行设置    -&gt; System banner = Welcome to Buildroot //欢迎语    -&gt; Init system = BusyBox //使用 busybox    -&gt; /dev management = Dynamic using devtmpfs + mdev //使用 mdev    -&gt; [*] Enable root login with password (NEW) //使能登录密码    -&gt; Root password = 55555 //登录密码为 55555Filesystem images    -&gt; [*] ext2/3/4 root filesystem //如果是 EMMC 或 SD 卡的话就用 ext3/ext4        -&gt; ext2/3/4 variant = ext4 //选择 ext4 格式    -&gt; [*] ubi image containing an ubifs root filesystem //如果使用 NAND 的话就用 ubifs</code></pre><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><pre><code class="bash">sudo make -j8</code></pre><p>编译完成后会在 buildroot/output/images 下生成根文件系统</p><h5 id="修改控制台颜色"><a href="#修改控制台颜色" class="headerlink" title="修改控制台颜色"></a>修改控制台颜色</h5><p>编辑<code>/etc/profile</code>文件，修改如下语句</p><pre><code class="bash">if [ &quot;$PS1&quot; ]; then        if [ &quot;`id -u`&quot; -eq 0 ]; then                export PS1=&#39;# &#39;        else                export PS1=&#39;$ &#39;        fifi#改为if [ &quot;$PS1&quot; ]; then        if [ &quot;`id -u`&quot; -eq 0 ]; then                export PS1=&#39;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\# &#39;        else                export PS1=&#39;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;        fifi</code></pre><p>使能配置</p><pre><code class="bash">source /etc/profile</code></pre><h5 id="构建完后，想要取消登录密码"><a href="#构建完后，想要取消登录密码" class="headerlink" title="构建完后，想要取消登录密码"></a>构建完后，想要取消登录密码</h5><p>（在buildroot的menuconfig中可以配置取消密码，这里是假设是配置完毕后想要取消）</p><ul><li>方法一（参考官方手册）</li></ul><p>修改/etc/inittab:</p><pre><code class="bash">ttyS0::respawn:/root/logintest -L ttyS0 115200 vt100</code></pre><p>新建logintest：</p><pre><code class="bash">#!/bin/sh/bin/login -f root</code></pre><p>自启动任务在/etc/init.d/rcS中加入即可</p><p>export 相关环境变量在/etc/profile中加入。 </p><ul><li>方法二</li></ul><p>找到 <code>/etc/inittab</code> 文件的</p><pre><code class="bash">console::respawn:/sbin/getty -L console 0 vt100 # GENERIC_SERIAL</code></pre><p>修改为:</p><pre><code class="bash">console::respawn:-/bin/sh</code></pre><h5 id="flash启动"><a href="#flash启动" class="headerlink" title="flash启动"></a>flash启动</h5><p>flash启动时需要jffs2格式的文件系统， 所以需要使用此rootfs制作jffs2文件系统镜像</p><p>下载jffs2文件系统制作工具</p><pre><code class="bash">apt-get install mtd-utils</code></pre><p>解压 rootfs.tar</p><pre><code class="bash">mkdir rootfstar xvf rootfs.tar -C rootfs</code></pre><p>安装内核模块</p><pre><code class="bash">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 modules#INSTALL_MOD_PATH：把指定为M的驱动安装到指定文件系统根目录下面的/lib/modules目录下面make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 INSTALL_MOD_PATH=/home/null/Code/LiCheePi_Zero/Image/spi_image_10_28/rootfs modules_install</code></pre><p>计算好jffs的大小，总空间是16M-1M-64K-4M=0xAF0000</p><pre><code class="bash">#页大小0x100 256字节#块大小0x10000 64k#jffs2分区总空间0xAF0000=16M-1M-64K-4M#jffs2.img是生成的文件系统镜像du -h ./rootfs#测试文件夹大小mkfs.jffs2 -s 0x100 -e 0x10000 -p 0xAF0000 -d rootfs/ -o jffs2.img</code></pre><p>删除rootfs文件夹</p><pre><code class="bash">rm -rf rootfs/</code></pre><p>或者重新打包回rootfs.tar</p><pre><code class="bash">tar -cvf rootfs.tar ./rootfs</code></pre><h5 id="添加wifi工具库（这里有好几个库，推荐用buildroot-）"><a href="#添加wifi工具库（这里有好几个库，推荐用buildroot-）" class="headerlink" title="添加wifi工具库（这里有好几个库，推荐用buildroot ）"></a>添加wifi工具库（这里有好几个库，推荐用buildroot ）</h5><h6 id="单独编译wireless-tools工具集"><a href="#单独编译wireless-tools工具集" class="headerlink" title="单独编译wireless tools工具集"></a>单独编译wireless tools工具集</h6><p>修改Makefile中的  CC、 AR 和 RANLIB 这三个变量：</p><pre><code class="makefile">## Compiler to use (modify this for cross compile).CC = arm-linux-gnueabihf-gcc## Other tools you need to modify for cross compile (static lib only).AR = arm-linux-gnueabihf-arRANLIB = arm-linux-gnueabihf-ranlib</code></pre><ul><li><p>清理：make clean</p></li><li><p>编译：make</p></li></ul><p>编译完成以后就会在当前目录下生成 iwlist、 iwconfig、 iwspy、 iwpriv、 ifrename 这 5 个工<br>具，另外还有很重要的 libiw.so.29 这个库文件。将这 5 个工具拷贝到开发板根文件系统下的<br>/usr/bin 目录中  ，将 libiw.so.29 这个库文件拷贝到开发板根文件系统下的/usr/lib 目录中</p><pre><code class="bash">sudo cp iwlist iwconfig iwspy iwpriv ifrename /home/null/Code/LiCheePi_Zero/Image/spi_image_wifi/rootfs/usr/bin -fsudo cp libiw.so.29 /home/null/Code/LiCheePi_Zero/Image/spi_image_wifi/rootfs/usr/lib -f</code></pre><h6 id="编译。。。。工具集（以后再写）"><a href="#编译。。。。工具集（以后再写）" class="headerlink" title="编译。。。。工具集（以后再写）"></a>编译。。。。工具集（以后再写）</h6><h6 id="buildroot-编译"><a href="#buildroot-编译" class="headerlink" title="buildroot 编译"></a>buildroot 编译</h6><p>配置使能</p><pre><code>-&gt; make menuconfig  -&gt; Target packages      -&gt; Networking applications      [*] wireless tools//其目录下全选中      [*] wpa_supplicant//其目录下全选中</code></pre><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2. 下载"></a>2. 下载</h3><h4 id="2-1-SD卡"><a href="#2-1-SD卡" class="headerlink" title="2.1 SD卡"></a>2.1 SD卡</h4><h5 id="2-1-1-修改uboot源码设置启动命令"><a href="#2-1-1-修改uboot源码设置启动命令" class="headerlink" title="2.1.1 修改uboot源码设置启动命令"></a>2.1.1 修改uboot源码设置启动命令</h5><p>参考1.1节修改uboot源码后可以直接启动，无需boot.scr和script.bin这两个文件</p><h5 id="2-1-2-利用boot-scr和script-bin"><a href="#2-1-2-利用boot-scr和script-bin" class="headerlink" title="2.1.2 利用boot.scr和script.bin"></a>2.1.2 利用boot.scr和script.bin</h5><p>在不修改uboot源码的情况下，可以通过两个启动参数文件：<code>boot.scr</code>和<code>script.bin</code>来配置</p><h6 id="boot-src是什么"><a href="#boot-src是什么" class="headerlink" title="boot.src是什么"></a>boot.src是什么</h6><p> 根据资料描述 <a href="https://github.com/linux-sunxi/u-boot-sunxi/wiki#bootscr-support" target="_blank" rel="noopener">https://github.com/linux-sunxi/u-boot-sunxi/wiki#bootscr-support</a>，u-boot在启动的时候会在第一个分区（FAT/extX格式）寻找/boot.scr或者/boot/boot.scr文件，boot.scr中可以包含用于载入script.bin，kernel，initrd（可选）以及设置内核启动参数的uboot命令。  （相当于uboot的bootcmd启动命令）</p><h6 id="boot-src如何生成"><a href="#boot-src如何生成" class="headerlink" title="boot.src如何生成"></a>boot.src如何生成</h6><p> 在工作目录新建 <code>boot.cmd</code> 文件，添加以下内容（即uboot启动命令）：</p><pre><code class="bash">setenv bootargs console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0setenv bootm_boot_mode secsetenv machid 1029load mmc 0:1 0x41000000 zImage#以下两句二选一#load mmc 0:1 0x41d00000 script.bin#13M偏移load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb#8M偏移#bootm 0x41000000bootz 0x41000000 - 0x41800000#fatload mmc 0 0x43000000 boot/script.bin#fatload mmc 0 0x48000000 boot/uImage#也可以不用这么麻烦，用以下命令直接写死在uboot中也行setenv bootcmd &#39;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-blueberrypi-csi-ov2640-480x272LCD.dtb;bootz 0x41000000 - 0x41800000;&#39;saveenv</code></pre><p>详细解释： </p><p>1.上述第一行设置uboot的bootargs启动参数，格式为 参数=值，不同参数使用空格分开，其中 </p><ul><li>console=ttyS0,115200 含义为使用特定的串口ttyS0，波特率为 115200</li><li>noinitrd 含义为不使用ramdisk（内存磁盘）</li><li>init=/init 含义为内核启起来后，进入系统中运行的第一个脚本</li><li>root=/dev/mmcblk0p2 含义为指定rootfs的位置为TF卡第二个分区</li><li>rootfstype=ext4 含义为根文件系统类型</li><li>rootwait 含义为等待设备/dev/mmcblk0p2就绪后才尝试挂载rootfs</li><li>panic=5 传递内核参数，当遇到panic（内核严重错误）时等待5秒后重启</li></ul><p>更多的参数可以通过查看Linux内核源码目录下<code>Documentation/kernel-parameters.txt</code>文件了解 </p><p>2.第二行和第三行为将<code>script.bin</code>和内核<code>uImage</code>加载到指定内存地址。fatload是U-Boot中装载linux kernel 到内存的指令（这里用到oad）。 </p><p>基本用法：fatload &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt; </p><ul><li>interface：所用到接口，如：MMC、USB</li><li>dev [:part]: 文件存放的设备 如：ide 0:1</li><li>addr: 装载到内存的开始地址。</li><li>filename: 装载的文件名称。</li><li>bytes: copy的字节数. </li></ul><p>3.第四行bootm 用于将内核映像加载到指定的地址 </p><p>保存文件后，执行以下命令生成boot.scr： </p><pre><code class="bash">mkimage -C none -A arm -T script -d boot.cmd boot.scr#-C ==&gt; set compression type &#39;comp&#39;#-A ==&gt; set architecture to &#39;arch&#39;#-T ==&gt; set image type to &#39;type&#39;#-d ==&gt; use image data from &#39;datafile&#39;</code></pre><h6 id="script-bin是什么"><a href="#script-bin是什么" class="headerlink" title="script.bin是什么"></a>script.bin是什么</h6><p>script.bin是被全志SOC内核驱动或LiveSuit使用的针对特定目标板的二进制配置文件，包含如何设置基于芯片的各种外设，端口，I/O针脚信息。 （相当于设备树，有该信息后就不需要设备树文件了，具体由script.bin还是设备树指定由boot.src中的命令决定）</p><p>其对应的可读文本文件格式为FEX，可以利用 Sunxi-tools在二进制和文本文件之间进行转换。更多关于FEX配置的信息可以参考 <a href="http://linux-sunxi.org/Fex_Guide" target="_blank" rel="noopener">http://linux-sunxi.org/Fex_Guide</a></p><h6 id="script-bin如何生成"><a href="#script-bin如何生成" class="headerlink" title="script.bin如何生成"></a>script.bin如何生成</h6><p>首先需要编译sunxi-tools，得到<code>fex2bin</code>、<code>bin2fex</code>等文件，其中<code>fex2bin</code>能把 *.fex 文件生成 *.bin文件。反之<code>bin2fex</code>可以将得到的*.bin文件生成可读的*.fex文件。 </p><pre><code class="bash">fex2bin sys_config.fex script.bin</code></pre><h5 id="2-1-3-分区及下载"><a href="#2-1-3-分区及下载" class="headerlink" title="2.1.3 分区及下载"></a>2.1.3 分区及下载</h5><p>ubuntu上商店中下载 <code>gparted</code> ，利用该软件对SD卡进行格式化并分区</p><p>如果SD卡上已经有分区需要先umount卸载文件系统，再格式整个SD卡后才能确保操作无误</p><ul><li><p>将uboot写入到sd卡8k偏移处：</p><pre><code class="bash">  sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</code></pre></li><li><p>建立第一个分区，大小32M（可以随意填写），格式FAT16，把zImage，sun8i-v3s-licheepi-zero.dtb， boot.src（如果有），script.bin（如果有） 拷贝到这个分区</p></li><li><p>建立第二个分区，用尽剩余空间，格式ext4，把buildroot产生的rootfs.tar解压到该分区根目录</p><pre><code class="bash">  sudo tar -xvf output/images/rootfs.tar -C /挂载的tf卡第二个分区目录  #如：  sudo tar -xvf output/images/rootfs.tar -C /media/null/rootfs/</code></pre></li></ul><h4 id="2-2-SPI-FLASH"><a href="#2-2-SPI-FLASH" class="headerlink" title="2.2 SPI FLASH"></a>2.2 SPI FLASH</h4><h5 id="分区情况"><a href="#分区情况" class="headerlink" title="分区情况"></a>分区情况</h5><table><thead><tr><th>分区序号</th><th>起始地址</th><th>长度</th><th>镜像名字</th><th>内容</th></tr></thead><tbody><tr><td>mtd0</td><td>0x0</td><td>0x0100000(1M)</td><td>u-boot-sunxi-with-spl.bin</td><td>uboot</td></tr><tr><td>mtd1</td><td>0x0100000</td><td>0x0010000(64k)</td><td>sun8i-v3s-licheepi-zero.dtb</td><td>dtb</td></tr><tr><td>mtd2</td><td>0x0110000</td><td>0x0400000(4M)</td><td>zImage</td><td>kernel</td></tr><tr><td>mtd3</td><td>0x0510000</td><td>0x100 0000-0x0510000=0xAF 0000剩余</td><td>jffs2.img</td><td>rootfs</td></tr></tbody></table><h5 id="生成img镜像"><a href="#生成img镜像" class="headerlink" title="生成img镜像"></a>生成img镜像</h5><pre><code class="bash"># !/bin/sh#生成一个空文件，大小是32MBdd if=/dev/zero of=flashimg.bin bs=1M count=32#将uboot添加到文件开头dd if=u-boot-sunxi-with-spl.bin of=flashimg.bin bs=1K conv=notrunc#将dtb放到1M偏移处dd if=sun8i-v3s-licheepi-zero.dtb of=flashimg.bin bs=1K seek=1024  conv=notrunc#将kernel放到1M+64K偏移处dd if=zImage of=flashimg.bin bs=1K seek=1088  conv=notrunc#将rootfs放到1M+64K+4M偏移处dd if=jffs2.img of=flashimg.bin  bs=1K seek=5184  conv=notrunc</code></pre><p> 执行完毕后生成镜像文件 <em>flashimg.bin</em> </p><h5 id="烧写镜像"><a href="#烧写镜像" class="headerlink" title="烧写镜像"></a>烧写镜像</h5><h6 id="安装sunxiflash烧写工具"><a href="#安装sunxiflash烧写工具" class="headerlink" title="安装sunxiflash烧写工具"></a>安装sunxiflash烧写工具</h6><ul><li><p>下载</p><pre><code class="bash">  git clone -b spi-rebase https://github.com/Icenowy/sunxi-tools.git</code></pre></li><li><p>编译安装</p><pre><code class="bash">  #安装 libusb-1.0-0-dev 以防止报错  sudo apt-get install libusb-1.0-0-dev  make &amp;&amp; sudo make install</code></pre></li></ul><h6 id="进入下载（fel）模式"><a href="#进入下载（fel）模式" class="headerlink" title="进入下载（fel）模式"></a>进入下载（fel）模式</h6><p> Zero有一个usb下载模式称为fel模式，进入fel模式有下面几种方式： </p><ul><li>TF卡和spi flash 同时没有可启动镜像; </li><li>TF卡中有进入fel模式的特殊固件 <em>fel-sdboot.sunxi</em> <ul><li>如果spiflash已经有了启动镜像，那么需要在TF卡中烧入一个sunxi提供的启动工具 （ <code>dd if=fel-sdboot.sunxi of=/dev/mmcblk0 bs=1024 seek=8</code> ）， 插入TF卡后就会启动会进入fel模式； </li></ul></li><li>上电时SPI_MISO拉低到地（记得松开，否则一直检测不到flash）</li></ul><h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><pre><code class="bash">sudo sunxi-fel version              #查看连接的cpu信息sudo sunxi-fel spiflash-info        #显示flash信息sudo sunxi-fel -p spiflash-write 0 flashimg.bin #烧写镜像flashimg.bin# -p 显示进度条#   spiflash-info                   Retrieves basic information#   spiflash-hex[dump] addr length  Dumps SPI flash region in hex#   spiflash-read addr length file  Write SPI flash contents into file#   spiflash-write addr file        Store file contents into SPI flash#   clear address length            Clear memory#   fill address length value       Fill memory</code></pre><h6 id="dd命令详解"><a href="#dd命令详解" class="headerlink" title="dd命令详解"></a>dd命令详解</h6><p> dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 </p><ul><li><code>if</code>=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt;if=inputfile&gt;</li><li><code>of</code>=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li><li>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>  obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>  <code>bs</code>=bytes：同时设置读入/输出的块大小为bytes个字节。</li><li>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li><li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li><li><code>seek</code>=blocks：从输出文件开头跳过blocks个块后再开始复制。<br>  （注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li><li><code>count</code>=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li><li>conv=conversion：用指定的参数转换文件。<ul><li>ascii：转换ebcdic为ascii</li><li>ebcdic：转换ascii为ebcdic</li><li>ibm：转换ascii为alternateebcdic</li><li>block：把每一行转换为长度为cbs，不足部分用空格填充</li><li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>swab：交换输入的每对字节</li><li>noerror：出错时不停止</li><li>notrunc：不截短输出文件</li><li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ul></li></ul><h6 id="dev-null和-dev-zero的区别"><a href="#dev-null和-dev-zero的区别" class="headerlink" title="/dev/null和/dev/zero的区别"></a>/dev/null和/dev/zero的区别</h6><ul><li><code>/dev/null</code>，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ </li><li><code>/dev/zero</code>，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。 </li></ul><h2 id="二、开发环境搭建"><a href="#二、开发环境搭建" class="headerlink" title="二、开发环境搭建"></a>二、开发环境搭建</h2><p>Root用户： </p><pre><code class="bash">用户名: root密码: 55555</code></pre><p>存储空间查看</p><pre><code class="bash">df -hdu -h 要查看的文件夹或文件</code></pre><h3 id="rtl8723bs无线网卡搭建"><a href="#rtl8723bs无线网卡搭建" class="headerlink" title="rtl8723bs无线网卡搭建"></a>rtl8723bs无线网卡搭建</h3><p>前提条件：</p><ul><li><code>rtl8723bs_nic.bin</code>wifi固件</li><li>wifi工具库</li><li><code>r8723bs.ko</code>驱动（4.13主线内核自带，默认以模块方式安装）</li></ul><p>步骤：</p><ul><li><p><code>ifconfig -a</code>命令查看当前系统中的全部网卡</p></li><li><p>安装驱动后执行 <code>ifconfig wlan0 up</code>  启动网卡</p></li><li><p>修改或创建配置文件 <code>/etc/wpa_supplicant.conf</code> </p><pre><code class="bash">  ctrl_interface=/var/run/wpa_supplicant   ctrl_interface_group=0   ap_scan=1   network={      #wifi名字      ssid=&quot;debugdump&quot;      scan_ssid=1      key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE      pairwise=TKIP CCMP      group=CCMP TKIP WEP104 WEP40      #wifi秘密      psk=&quot;13800138000&quot;      priority=5  }</code></pre></li><li><p>使能配置<code>wpa_supplicant -B -d -i wlan0 -c /etc/wpa_supplicant.conf</code></p></li><li><p>开启wifi<code>udhcpc -i wlan0</code></p></li></ul><h2 id="三、移植OPENCV（3-4-1）"><a href="#三、移植OPENCV（3-4-1）" class="headerlink" title="三、移植OPENCV（3.4.1）"></a>三、移植OPENCV（3.4.1）</h2><p>默认使用的是6.3.1的gcc</p><p>下载烧录V3s_linux_4_2_0_ov2640_debugdump.bin镜像</p><pre><code class="bash">sudo dd of=/dev/sdX if=V3s_linux_4_2_0_ov2640_debugdump.bin</code></pre><p>用户名root，密码root</p><p>该镜像中rootfs只有90M左右，需要用到linux主机下gparted 软件将rootfs进行扩展</p><p>测试相机</p><pre><code class="bash">#ov2640可用fswebcam -d /dev/video0 --no-banner -p UYVY -S 10 -r 800x600 capture.jpg#-d配置使用哪个摄像设备#–no-banner不添加水印#-p摄像头输出格式#-r图片大小（本人手上的ov2640貌似只支持800x600的格式）#-S曝光度设置，越大越不刺眼#开启web服务器mjpg_streamer -i &quot;input_uvc.so -d /dev/video0 -r 640x480&quot; -o &quot;output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www&quot;mjpg_streamer -i &quot;input_uvc.so -f 10 -r 320*240 -y&quot; -o &quot;output_http.so -c &quot;ruoyun:liufeng&quot; -w www -p 8888&quot; -o &quot;output_file.so -d 1000 -f /mnt &quot;mjpg_streamer -i &quot;input_uvc.so -d /dev/video0 -r QVGA&quot; -o &quot;output_http.so -p 8080 -w /usr/local/www&quot;</code></pre><h3 id="配置编译OPENCV"><a href="#配置编译OPENCV" class="headerlink" title="配置编译OPENCV"></a>配置编译OPENCV</h3><ul><li><p>linux主机下打开cmake的gui</p><pre><code class="bash">  sudo cmake-gui</code></pre></li><li><p>填写配置信息</p><ul><li>取消<code>WITH_GTK</code></li><li>取消<code>WITH_TIFF</code></li><li>修改安装路径<code>CMAKE_INSTALL_PREFIX</code>为/home/null/Code/OpenCV/install_opencv</li><li>配置 <code>CMAKE_EXE_LINKER_FLAGS</code> 为 -lpthread -lrt -ldl </li><li>其他详见<a href="https://blog.csdn.net/Guet_Kite/article/details/78667175" target="_blank" rel="noopener">https://blog.csdn.net/Guet_Kite/article/details/78667175</a></li></ul></li><li><p><code>sudo make</code>编译 </p></li><li><p><code>make install</code>将opencv编译出的库文件安装到CMAKE_INSTALL_PREFIX设置的目录下</p></li><li><p>将安装目录下的/lib/下的所有lib文件拷贝至开发板/lib下</p><pre><code class="bash">  cp -a /home/null/Code/OpenCV/nfs_code/opencvlib/* /home/null/Code/LiCheePi_Zero/Image/cam_image/rootfs/lib  #-a ：相当于 -pdr 的意思（参数pdr分别为：保留权限，复制软链接本身，递归复制）；  #-p ：连同档案的属性一起复制过去，而非使用预设属性；  #-d ：若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身；  #-r ：递归持续复制，用于目录的复制行为；</code></pre></li></ul><h3 id="OPENCV开发"><a href="#OPENCV开发" class="headerlink" title="OPENCV开发"></a>OPENCV开发</h3><p><strong>makefile</strong></p><pre><code class="makefile">CC  = arm-linux-gnueabihf-g++LFLAGS  = -Wno-psabi#lib库位置LIBS    = -L/home/null/Code/OpenCV/install_opencv/lib/#各种库#-libopencv_imgcodecs -lopencv_features2d -std=c++11 -fopenmpCPPFLAGS    = -lpthread -lopencv_core -lopencv_highgui -lrt -lopencv_imgproc -lopencv_imgcodecs#包含的头文件目录LINC     += -I/home/null/Code/OpenCV/install_opencv/include/#输入文件名objs := opencvout := opencv$(out):$(objs).cpp    ${CC} ${LFLAGS} ${LIBS} ${LINC} ${CPPFLAGS} -o $@ $^clean:    rm $(out)</code></pre><p><strong>测试文件</strong></p><pre><code class="c++">#include&lt;opencv2/core/core.hpp&gt;  #include&lt;opencv2/highgui/highgui.hpp&gt;  #include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt;using namespace cv;  using namespace std;int main( )  {       //载入图片      Mat image= imread(&quot;girl.jpg&quot;);      Mat logo= imread(&quot;fly.jpg&quot;);       //定义一个Mat类型，用于存放，图像的ROI      Mat imageROI;    imageROI= image(Rect(10,10,logo.cols,logo.rows));//定义一个左上角点坐标为(_x, _y)的cols*rows矩形窗口    //将logo加到原图    //参数：图、权重、图、权重、添加的常数项、输出图    addWeighted(imageROI,0.5,logo,0.3,0.,imageROI);         cout &lt;&lt; &quot;start add picture......\n&quot; &lt;&lt; endl;        //输出一张jpg图片到工程目录下      imwrite(&quot;fly_girl.jpg&quot;,image);      //waitKey();      return 0;  }</code></pre><ul><li>由于编译的时候没有加入<code>WITH_GTK</code>选项，因而在板卡上执行的程序无法使用函数<code>imshow</code>、<code>waitKey</code>等函数。 </li></ul><p>上面例子中的girl.jpg：</p><p><img src="//NU-LL.github.io/2019/10/18/LiCheePi_Zero底层开发/girl.jpg" alt="girl"></p><p>fly.jpg：</p><p><img src="//NU-LL.github.io/2019/10/18/LiCheePi_Zero底层开发/fly.jpg" alt="fly"></p><p>合成后的图片：</p><p><img src="//NU-LL.github.io/2019/10/18/LiCheePi_Zero底层开发/fly_girl.jpg" alt="fly_girl"></p><h2 id="四、驱动编写"><a href="#四、驱动编写" class="headerlink" title="四、驱动编写"></a>四、驱动编写</h2><p>暂时采用官方镜像，镜像名字为<code>nanopi-neo-core_sd_friendlycore-xenial_4.14_armhf_20190823.img</code>，该镜像中采用的rootfs为<code>UbuntuCore 18.04</code></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="内核版本查看方法"><a href="#内核版本查看方法" class="headerlink" title="内核版本查看方法"></a>内核版本查看方法</h4><pre><code class="bash">cat /proc/versionuname -a</code></pre><h4 id="挂载pc上文件系统"><a href="#挂载pc上文件系统" class="headerlink" title="挂载pc上文件系统"></a>挂载pc上文件系统</h4><pre><code class="bash">mount -t nfs -o nolock 192.168.2.101:/home/null/Code/NanoPi_NEO_Core/nfs /mntmount -t nfs -o nolock 192.168.2.101:/home/null/nfs_root /mntmount -t nfs -o nolock 192.168.2.101:/home/null/Code/OpenCV/nfs_code /mntmount -t nfs -o nolock 192.168.2.101:/home/null/Code/LiCheePi_Zero/nfs /mnt</code></pre><p>挂载报错尝试安装<code>nfs-common</code></p><blockquote><p>报错：</p><pre><code class="bash">mount: wrong fs type, bad option, bad superblock on 192.168.2.101:/home/null/nfs_root,       missing codepage or helper program, or other error       (for several filesystems (e.g. nfs, cifs) you might       need a /sbin/mount.&lt;type&gt; helper program)       In some cases useful info is found in syslog - try       dmesg | tail or so.</code></pre><p>安装nfs-common：</p><pre><code class="bash">sudo apt-get install nfs-common</code></pre></blockquote><p>pc端检查是否配置成功（自己挂接自己）（绝对路径）</p><pre><code class="bash">sudo mount -t nfs -o nolock localhost://home/null/Code/NanoPi_NEO_Core/nfs /mnt/nfs#挂接sudo mount -t nfs -o nolock localhost://home/null/nfs_root /mnt/nfs_root#挂接ls -l /mnt/nfs#检查ls -l /mnt/nfs_root#检查sudo umount /mnt/nfs#卸载sudo umount /mnt/nfs_root#卸载</code></pre><h5 id="一键挂载脚本"><a href="#一键挂载脚本" class="headerlink" title="一键挂载脚本"></a>一键挂载脚本</h5><pre><code class="bash">#!/bin/bashif [ $(id -u) -ne 0 ]; then    echo &quot;Re-running script under sudo...&quot;    sudo &quot;$0&quot; &quot;$@&quot;    exitfimount -t nfs -o nolock 192.168.2.101:/home/null/Code/NanoPi_NEO_Core/nfs /mntecho &quot;mount -&gt; /mnt&quot;</code></pre><p>记得chmod +x </p><h5 id="卸载脚本"><a href="#卸载脚本" class="headerlink" title="卸载脚本"></a>卸载脚本</h5><pre><code class="bash">#!/bin/bashif [ $(id -u) -ne 0 ]; then    echo &quot;Re-running script under sudo...&quot;    sudo &quot;$0&quot; &quot;$@&quot;    exitfiumount /mntecho &quot;umount /mnt OK&quot;</code></pre><p>记得chmod +x </p><h4 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h4><p>参考： <a href="http://mirrors.ustc.edu.cn/help/ubuntu-ports.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/ubuntu-ports.html</a></p><p>修改 <code>/etc/apt/sources.list</code> 文件中镜像源服务器地址 <a href="http://ports.ubuntu.com/" target="_blank" rel="noopener">http://ports.ubuntu.com/</a> 为 <a href="http://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/ubuntu-ports/</a></p><pre><code class="bash">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-security main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-updates main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse#deb http://ports.ubuntu.com/ bionic-backports main restricted universe multiverse# deb-src http://ports.ubuntu.com/ xenial-backports main restricted universe multiverse</code></pre><p>更新源：</p><pre><code class="bash">sudo apt update</code></pre><h3 id="1-按键驱动程序"><a href="#1-按键驱动程序" class="headerlink" title="1.按键驱动程序"></a>1.按键驱动程序</h3><h4 id="1-1修改设备树"><a href="#1-1修改设备树" class="headerlink" title="1.1修改设备树"></a>1.1修改设备树</h4><h5 id="编译设备树"><a href="#编译设备树" class="headerlink" title="编译设备树"></a>编译设备树</h5><pre><code class="bash">make dtbs ARCH=arm CROSS_COMPILE=arm-linux- -j8</code></pre><h5 id="查看系统中是否存在对应节点"><a href="#查看系统中是否存在对应节点" class="headerlink" title="查看系统中是否存在对应节点"></a>查看系统中是否存在对应节点</h5><pre><code class="bash">ls /proc/device-tree/cat /proc/device-tree/key/compatible# 注意：hexdump查看的是dtb文件原始数据，其中的数据是按照大字节序排放的（低地址放高位）hexdump /proc/device-tree/key/key-gpiobusybox hexdump /proc/device-tree/key/key-gpio</code></pre><h5 id="设备树中的GPIO节点"><a href="#设备树中的GPIO节点" class="headerlink" title="设备树中的GPIO节点"></a>设备树中的GPIO节点</h5><p>假设PA6和PA7上接入两个LED，通过编写一个GPIO的驱动程序来控制LED的亮灭，在设备树文件sun8i-h3-nanopi-m1.dts的根节点增加一个myleds子节点  ：</p><pre><code>myleds {           compatible = &quot;usr,myleds&quot;;             led-gpios = &lt;&amp;pio 0  7  GPIO_ACTIVE_HIGH&gt;,&lt;&amp;pio 0  6  GPIO_ACTIVE_HIGH&gt;;/* 0表示PA组的io口, 因h3里第0组的io口就是以PA开始命名的 */          };</code></pre><p> 节点中的led-gpios属性，引用了pinctrl信息，sunxi-h3-h5.dtsi中有关于该控制器的描述， </p><pre><code>pio: pinctrl@01c20800 {    /* compatible is in per SoC .dtsi file */    reg = &lt;0x01c20800 0x400&gt;;    interrupts = &lt;GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH&gt;,    &lt;GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH&gt;;    clocks = &lt;&amp;ccu CLK_BUS_PIO&gt;, &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;    clock-names = &quot;apb&quot;, &quot;hosc&quot;, &quot;losc&quot;;    gpio-controller;    #gpio-cells = &lt;3&gt;;    interrupt-controller;    #interrupt-cells = &lt;3&gt;;    ......};</code></pre><p>myleds子节点描述了两个GPIO信息，具有多个gpio口信息的属性值: <code>&lt;&amp;gpio控制器节点名 具体gpio口的标识符&gt;,&lt;&amp;gpio控制器节点名 具体gpio口的标识符&gt; …;</code>具体gpio口的标识符是由多个数字组成, 数字的个数由所用的gpio控制器节点里的#gpio-cells属性值指定.。全志H3 共有七组GPIO ，也即七个bank，分别为PA (PA0-21),PC(PC0-16) PD (PD0-17), PE(PE0-15),PF(PF0-6) PG(PG0-13) ,PL(PL0-PL11),在内核中PA-PG是一个pinctrl控制器，而PL是另一个pinctrl控制器 。</p><p>由#gpio-cells = &lt;3&gt;可以推出GPIO属性需要用3个u32的数据描述，第一个参数代表该GPIO位于哪个bank，第二个参数代表该bank下的序号，第三个参数代表默认电平，myleds节点下的GPIO_ACTIVE_HIGH这个宏就定义于include/dt-bindings/gpio/gpio.h</p><h4 id="1-2编写驱动"><a href="#1-2编写驱动" class="headerlink" title="1.2编写驱动"></a>1.2编写驱动</h4><h5 id="1-2-1检查注册的驱动"><a href="#1-2-1检查注册的驱动" class="headerlink" title="1.2.1检查注册的驱动"></a>1.2.1检查注册的驱动</h5><ul><li><p>驱动安装好后，会在<code>/dev/</code>目录下创建同名目录</p></li><li><p>或者通过<code>cat /proc/devices</code>命令查看多出来的驱动</p></li></ul><h5 id="1-2-2gpiolib及gpio操作"><a href="#1-2-2gpiolib及gpio操作" class="headerlink" title="1.2.2gpiolib及gpio操作"></a>1.2.2gpiolib及gpio操作</h5><h6 id="经典接口"><a href="#经典接口" class="headerlink" title="经典接口"></a>经典接口</h6><ul><li><code>gpio_request</code>:驱动中要想使用某一个gpio，就必须先调用gpio_request接口来向内核申请，得到允许后才可以去使用这个gpio</li><li><code>gpio_free</code>: 对应gpio_request，用来释放申请后用完了的gpio</li><li><code>gpiochip_is_requested</code>: 接口用来判断某一个gpio是否已经被申请了</li><li><code>gpio_direction_input</code>/<code>gpio_direction_output</code>: 接口用来设置GPIO为输入/输出模式（不推荐直接设置寄存器）</li></ul><blockquote><ul><li>一般来说，gpio的资源申请和释放操作应该放在驱动模块的加载与卸载函数内</li><li>gpio_request的第一个参数是需要申请的gpio号。第二个参数是我们给该gpio起个名字</li><li>申请完了之后对这个gpio进行模式设置，我们这里用gpio_direction_output 设置成输出模式，并且默认输出1让led灭 </li></ul></blockquote><h6 id="新接口"><a href="#新接口" class="headerlink" title="新接口"></a>新接口</h6><ul><li><code>devm_gpio_request_one</code>： 自带初始化电平功能，并且会在模块卸载时自动释放gpio，十分简便 </li></ul><h6 id="读写gpio"><a href="#读写gpio" class="headerlink" title="读写gpio"></a>读写gpio</h6><ul><li><code>gpio_get_value</code>：读gpio</li><li><code>gpio_set_value</code>：写gpio</li></ul><h6 id="控制台中查看当前gpio占用情况的方法"><a href="#控制台中查看当前gpio占用情况的方法" class="headerlink" title="控制台中查看当前gpio占用情况的方法"></a>控制台中查看当前gpio占用情况的方法</h6><p>内核中提供了虚拟文件系统debugfs，里面有一个gpio文件，提供了gpio的使用信息</p><ul><li>使用 <code>mount -t debugfs debugfs /tmp</code> 把debugfs挂接到/tmp下，再重新进入/tmp后就能看到一个名为gpio的文件</li><li><code>cat /tmp/gpio</code>即可得到gpio的所有信息，使用完后<code>umount /tmp</code>卸载掉debugfs</li></ul><h4 id="1-3调试"><a href="#1-3调试" class="headerlink" title="1.3调试"></a>1.3调试</h4><h5 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h5><ul><li><p>查看<code>printk</code>输出的日志：</p><p>  通过<code>dmesg</code>和 <code>more</code>、<code>tail</code>、<code>less</code>、<code>grep</code>的结合查看日志</p><pre><code class="bash">#输出全部信息dmesg#输出前20行dmesg | head -20#输出后20行dmesg | tail -20#输出包含usb的信息（-i：忽略大小写）dmesg | grep -i usb#清空dmesg环形缓冲区中的日志dmesg -c    ```</code></pre></li><li><p>或者直接设置日志的输出的等级：</p><pre><code class="bash">  echo $level &gt; /proc/sys/kernel/printk#默认为4 4 1 7  #如：  echo 8 4 1 7 &gt; /proc/sys/kernel/printk#所有级别日志均可打印输出</code></pre><blockquote><p>/proc/sys/kernel/printk中对应的四个数分别对应于：</p><ul><li><p>①控制台日志级别：优先级高于该值的消息将被打印至控制台。</p></li><li><p>②缺省的消息日志级别：将用该值来打印没有优先级的消息。</p></li><li><p>③最低的控制台日志级别：控制台日志级别可能被设置的最小值。</p></li><li><p>④缺省的控制台：控制台日志级别的缺省值。</p><p>日志缓冲区的每一行文本开头具有级别标记, 级别值<strong>越小</strong>则优先级<strong>越高</strong>.  </p><p>系统定义了8个消息级别, 级别号从0到7分别为：</p></li><li><p>致命级(KERN_EMESG), </p></li><li><p>警戒级(KERN_ALERT), </p></li><li><p>临界级(KERN_CRIT),</p></li><li><p>错误级(KERN_ERR), </p></li><li><p>告警级(KERN_WARN), </p></li><li><p>注意级(KERN_NOTICE), </p></li><li><p>通知级(KERN_INFO),</p></li><li><p>调试级(KERN_DEBUG).</p></li></ul></blockquote></li></ul><h5 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h5><ul><li><p>&amp;</p><p>   当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上&amp; 实现后台运行。例如：sh test.sh &amp;</p><p>  当成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。(<code>ps -ef | grep 进程号</code> 或者 <code>kill -9 进程号</code>）</p></li><li><p>nohup  </p><p> 使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p><pre><code class="bash"> nohup command &amp;</code></pre><p> 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><pre><code class="bash"> nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code></pre><p> 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p></li><li><p>ctrl + z </p><p> 可以将一个正在前台执行的命令放到后台，并且处于暂停状态。 </p></li><li><p>jobs<br>  查看当前有多少在后台运行的命令。<br>  <code>jobs -l</code>选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。 </p></li></ul><h3 id="2-内核定时器"><a href="#2-内核定时器" class="headerlink" title="2.内核定时器"></a>2.内核定时器</h3><h3 id="3-中断"><a href="#3-中断" class="headerlink" title="3.中断"></a>3.中断</h3><h4 id="上半部和下半部"><a href="#上半部和下半部" class="headerlink" title="上半部和下半部"></a>上半部和下半部</h4><ul><li><p>软中断</p><p>  软中断必须在编译的时候静态注册</p><ul><li>open_sotfirq：打开软中断</li><li>raise_sotfirq：触发软中断</li></ul></li><li><p>tasklet：利用软中断来实现的另一种下半部机制，在软中断和tasklet之间建议选tasklet</p><ul><li>tasklet_init：初始化tasklet_struct结构体，或直接使用宏DECLARE_TASKLET定义＋初始化</li><li>tasklet_schedule：一般在上半部中调用，使要调度的tasklet在合适的时候运行</li></ul></li><li><p>工作队列：在<strong>进程</strong>上下文执行，允许睡眠或重新调度（下半部可以睡眠就可以交给工作队列），要执行的工作会交给一个内核工作者线程去执行</p><ul><li>宏INIT_WORK：初始化工作</li><li>宏DECLARE_WORK：定义+初始化工作</li><li>schedule_work：类似tasklet_schedule，调度传入的工作</li></ul></li></ul><h4 id="3-1修改设备树"><a href="#3-1修改设备树" class="headerlink" title="3.1修改设备树"></a>3.1修改设备树</h4><p>参考内核绑定信息：Documentation/devicetree/bindings/arm/gic.txt</p><p>对于一般的ARM处理器来说，<code>#interrupt-cells=&lt;3&gt;</code>对应的三个cell分别为：</p><ol><li>中断类型<ul><li>0：SPI中断</li><li>1：PPI中断</li></ul></li><li>中断号<ul><li>SPI：0~987</li><li>PPI：0~15</li></ul></li><li>标志<ul><li>bit[3:0]：中断触发类型<ul><li>1：上升沿</li><li>2：下降沿</li><li>4：高电平</li><li>8：低电平</li></ul></li><li>bit[15:8]：PPI中断的CPU掩码</li></ul></li></ol><h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>irq_of_parse_and_map：从设备树中中断节点中的interrupts属性提取对应的中断号</li><li>gpio_to_irq：获取gpio对应的中断号</li></ul><h5 id="编译设备树-1"><a href="#编译设备树-1" class="headerlink" title="编译设备树"></a>编译设备树</h5><pre><code class="bash">make dtbs ARCH=arm CROSS_COMPILE=arm-linux- -j8</code></pre><h5 id="查看系统中是否存在对应节点-1"><a href="#查看系统中是否存在对应节点-1" class="headerlink" title="查看系统中是否存在对应节点"></a>查看系统中是否存在对应节点</h5><pre><code class="bash">ls /proc/device-tree/cat /proc/device-tree/key/compatible# 注意：hexdump查看的是dtb文件原始数据，其中的数据是按照大字节序排放的（低地址放高位）hexdump /proc/device-tree/key/interruptsbusybox hexdump /proc/device-tree/key/interrupts</code></pre><h5 id="设备树中的中断节点"><a href="#设备树中的中断节点" class="headerlink" title="设备树中的中断节点"></a>设备树中的中断节点</h5><ul><li>interrupt-parent = &lt;&amp;pio&gt;;//属于pio中断控制器</li><li>interrupts = &lt;0 7 IRQ_TYPE_EDGE_BOTH&gt;;<ul><li>第一个参数：第几个GPIO（这里是GPIOA）</li><li>第二个参数：第几个外部中断</li><li>第三个参数：触发沿</li></ul></li></ul><h4 id="3-2编写驱动"><a href="#3-2编写驱动" class="headerlink" title="3.2编写驱动"></a>3.2编写驱动</h4><h4 id="3-3调试"><a href="#3-3调试" class="headerlink" title="3.3调试"></a>3.3调试</h4><p>中断注册成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">cat /proc/interrupts</code></pre><h3 id="4-input子系统"><a href="#4-input子系统" class="headerlink" title="4.input子系统"></a>4.input子系统</h3><h4 id="4-1修改设备树"><a href="#4-1修改设备树" class="headerlink" title="4.1修改设备树"></a>4.1修改设备树</h4><p>如果需要使用内核自带的<code>gpio_keys.c</code>驱动，可以参考内核中<code>Documentation/devicetree/bindings/input/gpio-keys.txt</code>，需要设备树中的节点满足以下要求：</p><ul><li><p>节点名字为<code>“gpio-keys”</code></p></li><li><p>gpio-keys节点的compatible属性必须为<code>“gpio-keys”</code></p></li><li><p>所有的按键都是gpio-keys的子节点，并可以使用如下属性描述自己：</p><ul><li>gpios：按键连接的gpio信息</li><li>interrupts：按键使用的中断信息（可选）</li><li>lable：按键名字</li><li>linux,code：要模拟的按键值</li></ul></li><li><p>如果要支持连按的话需要加入<code>autorepeat</code>属性</p><p>  例子：</p><pre><code>  gpio_keys {      compatible = &quot;gpio-keys&quot;;      autorepeat;//支持连按      k1 {          label = &quot;k1&quot;;//按键名称          linux,code = &lt;KEY_POWER&gt;;//要模拟的按键值          gpios = &lt;&amp;pio 0 7 GPIO_ACTIVE_LOW&gt;;//按键连接的gpio信息          interrupts = &lt;0 7 IRQ_TYPE_EDGE_BOTH&gt;;//中断信息 PA7 --&gt; EINT7      };  };</code></pre></li></ul><h4 id="4-2编写驱动"><a href="#4-2编写驱动" class="headerlink" title="4.2编写驱动"></a>4.2编写驱动</h4><p>Linux中已经实现了input输入子系统框架，因此无需再次注册设备，系统中input框架中的所有设备的主设备号均为13</p><ul><li>input设备结构体<code>input_dev</code><ul><li>evbit成员：输入事件类型，可选事件见下文</li><li>keybit成员：按键值</li><li>relbit成员：相对坐标</li><li>absbit成员：绝对坐标</li><li>…</li></ul></li></ul><p>设置input_dev结构体中成员的方法：</p><ul><li>__set_bit</li><li>BIT_MASK宏</li><li>input_set_capability：仅仅设置keybit成员</li></ul><h5 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>input_allocate_device：申请一个input_dev结构体</li><li>input_free_device：释放申请到的input_dev结构体</li><li>input_register_device：向内核注册input_dev结构体</li><li>input_unregister_device：注销input_dev结构体</li><li>input_event：上报指定事件及对应的值<ul><li>input_report_key：封装一层，专门上报按键事件</li><li>input_report_rel</li><li>input_report_abs</li><li>input_report_ff_status</li><li>input_report_switch</li><li>input_mt_sync</li></ul></li><li>input_sync：同步事件</li></ul><h5 id="input-dev的相关事件"><a href="#input-dev的相关事件" class="headerlink" title="input_dev的相关事件"></a>input_dev的相关事件</h5><ul><li>EV_SYN：同步</li><li>EV_KEY：按键</li><li>EV_REL：相对坐标</li><li>EV_ABS：绝对坐标</li><li>EV_MSC：杂项（其他）</li><li>EV_SW：开关</li><li>EV_LED：LED</li><li>EV_SND：声音（sound）</li><li>EV_REP：重复事件</li><li>EV_FF：压力</li><li>EV_PWR：电源</li><li>EV_FF_STATUS：压力状态</li></ul><h4 id="4-3调试"><a href="#4-3调试" class="headerlink" title="4.3调试"></a>4.3调试</h4><p>input设备注册成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">ls /dev/input/ -l</code></pre><p>通过以下命令查看是否有效：</p><pre><code>busybox hexdump /dev/input/event1</code></pre><h3 id="5-IIC框架驱动"><a href="#5-IIC框架驱动" class="headerlink" title="5.IIC框架驱动"></a>5.IIC框架驱动</h3><h4 id="5-1设备树"><a href="#5-1设备树" class="headerlink" title="5.1设备树"></a>5.1设备树</h4><ul><li><code>clock-frequency</code>属性：iic总线的速度（默认100000，即100k）</li><li>status：是否使能该总线<ul><li>okay</li><li>disabled</li></ul></li><li>iic设备节点需要写到iic总线节点中，作为总线节点的子节点</li><li>总线节点需要利用<code>pinctrl-names = &quot;default&quot;;</code>和<code>pinctrl-0</code>指定iic引脚（已经设置好）</li><li>iic控制器节点<code>compatible</code>属性必须为allwinner,sun6i-a31-i2c或allwinner,sun4i-a10-i2c，这里在sunxi-h3-h5.dtsi中已经设置好，无需再次设置</li></ul><p>设备树修改成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">#查看设备节点，该目录下放着所有的i2c设备#节点是以i2c地址结尾的文件夹ls /sys/bus/i2c/devices/</code></pre><h4 id="5-2驱动"><a href="#5-2驱动" class="headerlink" title="5.2驱动"></a>5.2驱动</h4><h5 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><ul><li>IIC总线结构体<code>i2c_bus_type</code><ul><li>match函数：驱动和设备匹配是调用该函数来决定是否匹配</li></ul></li><li>IIC适配器（控制器）驱动结构体<code>i2c_adapter</code><ul><li>algo：总线访问算法成员<ul><li>master_xfer：IIC适配器的传输函数</li><li>smbus_xfer：SMBUS总线传输函数</li></ul></li></ul></li><li>IIC设备结构体<code>i2c_client</code><ul><li>addr：芯片地址，存在低7位</li><li>name：名字</li><li>adapter：对应的IIC适配器</li><li>dev：设备结构体</li><li>irq：中断</li></ul></li><li>IIC设备驱动结构体<code>i2c_driver</code><ul><li>probe函数：IIC设备和驱动匹配后调用，初始化用</li><li>remove函数：同理，卸载用</li><li>id_table：传统方式匹配ID列表</li><li>driver：<ul><li>owner：所有者，一般为宏THIS_MODULE</li><li>name：名字</li><li>of_match_table：设备树匹配列表</li></ul></li></ul></li><li>IIC发送数据结构体<code>i2c_msg</code><ul><li>addr：从机地址</li><li>flags：标志</li><li>len：消息长度</li><li>buf：消息数据</li></ul></li></ul><h5 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>IIC适配器（控制器）<ul><li>i2c_add_adapter：向系统注册i2c_adapter成员，使用动态总线号</li><li>i2c_add_numbered_adapter：向系统注册i2c_adapter成员，使用静态总线号</li><li>i2c_del_adapter：删除IIC适配器</li></ul></li><li>SPI设备<ul><li>i2c_register_driver / i2c_add_driver：注册i2c_driver</li><li>i2c_del_driver：卸载i2c_driver</li></ul></li><li>传输数据<ul><li>i2c_transfer：传输i2c_msg类型数据</li><li>i2c_master_send：IIC发送缓存中的数据，最后会调用i2c_transfer</li><li>i2c_master_recv：IIC接收数据到缓存中，最后会调用i2c_transfer</li></ul></li></ul><h4 id="5-3调试"><a href="#5-3调试" class="headerlink" title="5.3调试"></a>5.3调试</h4><h5 id="i2c-tools工具"><a href="#i2c-tools工具" class="headerlink" title="i2c-tools工具"></a>i2c-tools工具</h5><p>得益于ubuntucore，直接运行<code>sudo apt install i2c-tools</code>安装i2c-tools工具</p><ul><li>查询i2c总线<code>sudo i2cdetect -l</code></li><li>检测i2c地址<code>sudo i2cdetect -r -y 0</code>（最后的0为i2c-0总线）</li></ul><h3 id="6-SPI框架驱动"><a href="#6-SPI框架驱动" class="headerlink" title="6.SPI框架驱动"></a>6.SPI框架驱动</h3><h4 id="6-1设备树"><a href="#6-1设备树" class="headerlink" title="6.1设备树"></a>6.1设备树</h4><ul><li><code>spi-max-frequency</code>属性：spi总线的最大速度（默认100000，即100k）</li><li>status：是否使能该总线<ul><li>okay</li><li>disabled</li></ul></li><li>spi设备节点需要写到spi总线节点中，作为总线节点的子节点</li><li>通过<code>cs-gpios</code>属性指定CS引脚</li><li>spi设备节点中<code>reg</code>和节点<code>@</code>后的数字均为该设备所使用的spi通道（一般0即可）</li><li>总线节点需要利用<code>pinctrl-names = &quot;default&quot;;</code>和<code>pinctrl-0</code>指定spi引脚（已经设置好）</li><li>spi控制器节点<code>compatible</code>属性必须为allwinner,sun8i-h3-spi或allwinner,sun6i-a31-spi，这里在sunxi-h3-h5.dtsi中已经设置好，无需再次设置</li></ul><p>设备树修改成功后可以通过以下命令来查看是否注册到系统中：</p><pre><code class="bash">#查看设备节点，该目录下放着所有的i2c设备#节点是以i2c地址结尾的文件夹ls /sys/bus/spi/devices/</code></pre><h4 id="6-2驱动"><a href="#6-2驱动" class="headerlink" title="6.2驱动"></a>6.2驱动</h4><h5 id="基本数据结构-1"><a href="#基本数据结构-1" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><ul><li>SPI总线结构体<code>spi_bus_type</code><ul><li>match函数：驱动和设备匹配是调用该函数来决定是否匹配</li></ul></li><li>SPI主机驱动结构体<code>spi_master</code><ul><li>transfer函数：控制器数据传输函数</li><li>transfer_one_message函数：控制器数据传输函数，一次发一个spi_message包</li></ul></li><li>SPI设备驱动结构体<code>spi_driver</code><ul><li>probe函数：SPI设备和驱动匹配后调用，初始化用</li><li>remove函数：同理，卸载用</li><li>id_table：传统方式匹配ID列表</li><li>driver：<ul><li>owner：所有者，一般为宏THIS_MODULE</li><li>name：名字</li><li>of_match_table：设备树匹配列表</li></ul></li></ul></li><li>SPI传输信息结构体<code>spi_transfer</code><ul><li>tx_buf：发送数据</li><li>rx_buf：接收数据</li><li>len：数据长度</li></ul></li><li>SPI消息结构体<code>spi_message</code>，由<code>spi_transfer</code>组成<ul><li>complete函数：异步传输完成时调用</li></ul></li></ul><h5 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h5><ul><li>SPI主机<ul><li>spi_alloc_master：申请spi_master结构体</li><li>spi_master_put：释放spi_master结构体</li><li>spi_register_master：注册</li><li>spi_unregister_master：注销</li></ul></li><li>SPI设备<ul><li>spi_register_driver：注册</li><li>spi_unregister_driver：卸载</li></ul></li><li>数据传输<ul><li>spi_message_init：初始化spi_message结构体</li><li>spi_message_add_tail：将spi_transfer添加到spi_message队列中</li><li>spi_sync：同步传输（会阻塞并等待SPI数据传输完成）</li><li>spi_async：异步传输（传输完成后会调用spi_message.complete函数）</li></ul></li></ul><h4 id="6-3调试"><a href="#6-3调试" class="headerlink" title="6.3调试"></a>6.3调试</h4><h3 id="7-RGBLCD驱动"><a href="#7-RGBLCD驱动" class="headerlink" title="7.RGBLCD驱动"></a>7.RGBLCD驱动</h3><p>Zero默认支持800x480和480x272这两种常见分辨率的的RGB屏幕。这两种分辨率的屏幕，直接在编译时候选择对应的分辨率即可。如果需要修改，可以参考官方手册 <a href="https://www.kancloud.cn/lichee/lpi0/519472" target="_blank" rel="noopener">https://www.kancloud.cn/lichee/lpi0/519472</a> 修改uboot。这里采用的是480*242的RGBLCD。</p><p>前提条件：Uboot中需要配置好LCD驱动。设备树种会规定chose节点用于uboot和linux之间传递参数，simple-fb的参数也是在这里传递。 所以只需要uboot中设置屏幕没问题，内核即可正常显示</p><h4 id="7-1设备树"><a href="#7-1设备树" class="headerlink" title="7.1设备树"></a>7.1设备树</h4><h5 id="1-添加framebuffer"><a href="#1-添加framebuffer" class="headerlink" title="1.添加framebuffer"></a>1.添加framebuffer</h5><p>参考内核中的设备树绑定文件：<code>\Documentation\devicetree\bindings\display\simple-framebuffer-sunxi.txt</code></p><p>需要写到<code>chosen</code>节点中</p><p>必要属性：</p><ul><li>compatible: “allwinner,simple-framebuffer”</li><li>allwinner,pipeline为以下几个中的一个<ul><li>“de_be0-lcd0”</li><li>“de_be1-lcd1”</li><li>“de_be0-lcd0-hdmi”</li><li>“de_be1-lcd1-hdmi”</li></ul></li></ul><p>例子：</p><ol><li><p>官方例子</p><pre><code> chosen {     #address-cells = &lt;1&gt;;     #size-cells = &lt;1&gt;;     ranges;     framebuffer@0 {         compatible = &quot;allwinner,simple-framebuffer&quot;, &quot;simple-framebuffer&quot;;         allwinner,pipeline = &quot;de_be0-lcd0-hdmi&quot;;         clocks = &lt;&amp;pll5 1&gt;, &lt;&amp;ahb_gates 36&gt;, &lt;&amp;ahb_gates 43&gt;,              &lt;&amp;ahb_gates 44&gt;;         status = &quot;disabled&quot;;     }; };</code></pre></li><li><p>zero例子</p><pre><code> chosen {         #address-cells = &lt;1&gt;;         #size-cells = &lt;1&gt;;         ranges;         simplefb_lcd: framebuffer@0 {                 compatible = &quot;allwinner,simple-framebuffer&quot;,                              &quot;simple-framebuffer&quot;;                 allwinner,pipeline = &quot;de0-lcd0&quot;;                 clocks = &lt;&amp;ccu CLK_BUS_TCON0&gt;, &lt;&amp;display_clocks 0&gt;,                          &lt;&amp;display_clocks 6&gt;, &lt;&amp;ccu CLK_TCON0&gt;;                 status = &quot;disabled&quot;;         }; };</code></pre></li></ol><h5 id="2-添加屏幕节点"><a href="#2-添加屏幕节点" class="headerlink" title="2.添加屏幕节点"></a>2.添加屏幕节点</h5><p>不知道从哪个版本开始，linux内核需要专门的 panel 节点（在根节点下）才行，具体的配置文件的选取可以从 <code>linux ‣ drivers ‣ gpu ‣ drm ‣ panel</code> 文件夹下选取，具体的 compatible 属性从上述文件夹下的<code>panel-simple.c</code>文件中的匹配表<code>platform_of_match</code>中选取</p><p>具体的配置可以参考内核帮助文档：<code>\Documentation\devicetree\bindings\display\panel\simple-panel.txt</code>、<code>\Documentation\devicetree\bindings\display\panel\panel-common.txt</code>、<code>\Documentation\devicetree\bindings\graph.txt</code></p><p>这里用的是480*272的分辨率的屏幕，具体的 panel 节点配置如下：</p><pre><code>panel: panel {    compatible = &quot;qiaodian,qd43003c0-40&quot;, &quot;simple-panel&quot;;//480*272的屏    //compatible = “lg,lb070wv8”, “simple-panel”;//800X480的屏    #address-cells = &lt;1&gt;;    #size-cells = &lt;0&gt;;    enable-gpios = &lt;&amp;pio 4 6 GPIO_ACTIVE_HIGH&gt;;//使能引脚 PB4脚为高使能 这里为pwm信号    port@0 {        reg = &lt;0&gt;;        #address-cells = &lt;1&gt;;        #size-cells = &lt;0&gt;;        panel_input: endpoint@0 {            reg = &lt;0&gt;;            remote-endpoint = &lt;&amp;tcon0_out_lcd&gt;;        };    };};</code></pre><blockquote><p>这里解释下ports、port和endpoint（\Documentation\devicetree\bindings\graph.txt）</p><p>Ports are described by child ‘port’ nodes contained in the device node.<br>Each port node contains an ‘endpoint’ subnode for each remote device port connected to this port. If a single port is connected to more than one remote device, an ‘endpoint’ child node must be provided for each link.<br>If more than one port is present in a device node or there is more than one endpoint at a port, or a port node needs to be associated with a selected hardware interface, a common scheme using ‘#address-cells’, ‘#size-cells’ and ‘reg’ properties is used to number the nodes.</p><p>端口s由设备节点中包含的子“端口”节点描述。<br>每个端口节点都为连接到该端口的每个远程设备端口包含一个“端点”子节点。如果单个端口连接到多个远程设备，则必须为每个链接提供一个“端点”子节点。<br>如果设备节点中存在多个端口，或者某个端口处有多个端点，或者需要将端口节点与选定的硬件接口相关联，则使用“＃address-cells”，“＃size-cells”和’reg’属性的通用方案用于编号节点。 </p><p>All ‘port’ nodes can be grouped under an optional ‘ports’ node, which allows to specify #address-cells, #size-cells properties for the ‘port’ nodes independently from any other child device nodes a device might have.</p><p>所有“端口”节点都可以分组在一个可选的“端口s”节点下，该节点允许独立于设备可能具有的任何其他子设备节点，为“端口”节点指定＃address-cells，＃size-cells属性。 </p></blockquote><p>tcon0_out_lcd节点：</p><pre><code>//tcon0_out节点是液晶控制器节点tcon0的一个输出端口（port）&amp;tcon0_out {    tcon0_out_lcd: endpoint@0 {        reg = &lt;0&gt;;        remote-endpoint = &lt;&amp;panel_input&gt;;    };};</code></pre><p>同时这里的<code>tcon</code>节点需要绑定上lcd对应的io口</p><pre><code>&amp;tcon0 {    pinctrl-names = &quot;default&quot;;    pinctrl-0 = &lt;&amp;lcd_rgb666_pins&gt;;//绑定到lcd_rgb666_pins    status = &quot;okay&quot;;};</code></pre><p>lcd_rgb666_pins节点：</p><pre><code>pio: pinctrl@1c20800 {    compatible = &quot;allwinner,suniv-pinctrl&quot;;    ......    lcd_rgb666_pins: lcd-rgb666-pins {        pins =    &quot;PE4&quot;, &quot;PE5&quot;, &quot;PE6&quot;, &quot;PE7&quot;, &quot;PE8&quot;, &quot;PE9&quot;,                &quot;PE10&quot;, &quot;PE11&quot;, &quot;PE12&quot;, &quot;PE13&quot; , &quot;PE14&quot;, &quot;PE15&quot;,                &quot;PE16&quot;, &quot;PE17&quot;, &quot;PE18&quot;, &quot;PE19&quot;, &quot;PE23&quot;, &quot;PE24&quot;,//data信号                &quot;PE3&quot;,//VSYNC                &quot;PE2&quot;,//HSYNC                &quot;PE1&quot;,//DE                &quot;PE0&quot;;//CLK        function = &quot;lcd&quot;;    };    ......};</code></pre><h4 id="7-3调试"><a href="#7-3调试" class="headerlink" title="7.3调试"></a>7.3调试</h4><p>设备树可以通过以下方式检测：</p><pre><code class="bash">#会发现framebuffer节点后面被填充了实际地址ls /proc/device-tree/chosen/#framebuffer节点一般在：ls /dev/fb0</code></pre><p>屏幕测试方法：</p><ol><li><p>linux系统启动后，存在/dev/fb0节点：</p><pre><code class="bash"> cat /dev/urandom &gt; /dev/fb0</code></pre></li><li><p>改变uboot的启动参数<code>bootargs</code>，从屏幕输出启动信息</p><pre><code class="bash"> setenv bootargs &#39;console=tty1 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&#39; boot</code></pre></li></ol><ol start="3"><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiCheePi Zero </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树</title>
      <link href="/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
      <url>/2019/10/13/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><p>内核相关文档：</p><p>Documentation/devicetree/bindings/</p><blockquote><p>相关约定如下：</p><p>dts：device tree source，设备树源文件</p><p>dtb：device tree blob，设备树二进制文件, 由dts编译得来</p><p>dtc：设备树编译工具</p><p>blob：binary large object</p></blockquote><h2 id="一、设备树的规范-dts和dtb"><a href="#一、设备树的规范-dts和dtb" class="headerlink" title="一、设备树的规范(dts和dtb)"></a>一、设备树的规范(dts和dtb)</h2><h3 id="1-DTS格式"><a href="#1-DTS格式" class="headerlink" title="1. DTS格式"></a>1. DTS格式</h3><p>参考文档：<a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">官方文档</a></p><h4 id="DTS文件布局-layout"><a href="#DTS文件布局-layout" class="headerlink" title="DTS文件布局(layout)"></a>DTS文件布局(layout)</h4><pre><code class="c">/dts-v1/;//设备树版本[memory reservations]    // 保留该处的内存（一般这里就是存放设备树文件的地方），内核不会使用该处内存，格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;//address和length均为64位，如：/memreserve/ 0x33f00000 0x100000/ {    [property definitions]    [child nodes]};</code></pre><p>相关规定：</p><ul><li><p>一般来说一些公共部分会组合起来写成<code>.dtsi</code>文件</p></li><li><p>普通的<code>.dts</code>文件可以包含这些<code>.dtsi</code>文件（类似C语言）</p><pre><code class="c">  #include&quot;XXXX.dtsi&quot;</code></pre></li><li><p>普通的<code>.dts</code>文件可以通过重写所包含的<code>.dtsi</code>文件中的属性来进行覆盖操作</p></li><li><p>编译<code>.dts</code>文件为<code>.dtb</code></p><pre><code class="bash">#Linux内核源码下操作#编译所有改动过的设备树make dtbs#编译指定设备树make xxxx.dtb</code></pre></li><li><p>反汇编<code>.dtb</code>文件为<code>.dts</code></p><pre><code class="bash">  ./scripts/dtc/dtc -I dtb -O dts -o 输出文件.dts 输入文件.dtb</code></pre></li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>Devicetree node（设备节点）格式:</p><pre><code class="c">[label:] node-name[@unit-address] {    [properties definitions]    [child nodes]};</code></pre><ul><li><p>同一级别下，node-name[@unit-address]不能一样，不同级别可以一样</p></li><li><p>每个属性后必须加上分号，每个节点大括号后必须加上分号</p></li></ul><p>Property 格式1:</p><pre><code class="c">[label:] property-name = value;</code></pre><p>Property 格式2(没有值):</p><pre><code class="c">[label:] property-name;</code></pre><p>Property取值只有3种:</p><ul><li>arrays of cells(1个或多个32位数据, 64位数据使用2个32位数据表示)</li><li>string(字符串)</li><li>bytestring(1个或多个字节)</li></ul><h5 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h5><p>a. Arrays of cells : cell就是一个32位的数据</p><pre><code class="c">interrupts = &lt;17 0xc&gt;;</code></pre><p>b. 64bit数据使用2个cell来表示:</p><pre><code class="c">clock-frequency = &lt;0x00000001 0x00000000&gt;;</code></pre><p>c. A null-terminated string (有结束符的字符串):</p><pre><code class="c">compatible = &quot;simple-bus&quot;;</code></pre><p>d. A bytestring(字节序列) :</p><pre><code class="c">local-mac-address = [00 00 12 34 56 78];  // 每个byte使用2个16进制数来表示local-mac-address = [000012345678];       // 每个byte使用2个16进制数来表示</code></pre><p>e. 可以是各种值的组合, 用逗号隔开:</p><pre><code class="c">compatible = &quot;ns16550&quot;, &quot;ns8250&quot;;example = &lt;0xf00f0000 19&gt;, &quot;a strange property format&quot;;</code></pre><h4 id="特殊以及默认属性"><a href="#特殊以及默认属性" class="headerlink" title="特殊以及默认属性"></a>特殊以及默认属性</h4><h5 id="a-（根节点"><a href="#a-（根节点" class="headerlink" title="a. /（根节点)"></a>a. /（根节点)</h5><p>这部分可以理解为<strong>通用属性</strong></p><pre><code class="c">#address-cells   // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)#size-cells      // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)compatible       // 兼容性列表。通过定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备                 // 即这个板子兼容哪些平台                 // 内核会通过该属性找到对应平台的machine_desc结构体初始化该板卡                 //（该属性可以有很多个字符串组成，内核会按照先后顺序依次查找，直到找到为止）model            // 描述设备模块信息。可以理解为相同板卡的不同软件版本，即使用的板卡是采用那个版本的配置文件初始化的                 // 比如有2款板子配置基本一致, 它们的compatible是一样的                 // 那么就通过model来分辨这2款板子</code></pre><blockquote><p>注意：只有在<code>/</code>节点下，<code>compatible</code>中的字符串才需要和machine_desc结构体进行匹配。</p><p>在其余节点中，<code>compatible</code>一般用于将设备和驱动绑定起来</p></blockquote><h5 id="b-memory节点"><a href="#b-memory节点" class="headerlink" title="b. /memory节点"></a>b. /memory节点</h5><pre><code class="c">device_type = &quot;memory&quot;;// 约定俗成，必须加该属性reg             // 根据上层的#address-cells、#size-cells来指定内存的地址、大小</code></pre><h5 id="c-chosen节点"><a href="#c-chosen节点" class="headerlink" title="c. /chosen节点"></a>c. /chosen节点</h5><pre><code class="c">bootargs        // 内核command line参数, 跟u-boot中设置的bootargs作用一样</code></pre><ul><li>该参数由uboot根据启动参数bootargs自行设置，一般无需自己处理</li></ul><h5 id="d-cpus节点"><a href="#d-cpus节点" class="headerlink" title="d. /cpus节点"></a>d. /cpus节点</h5><p><code>/cpus</code>节点下有1个或多个cpu子节点, cpu子节点中用reg属性用来标明自己是哪一个cpu，所以 <code>/cpus</code> 中有以下2个属性：</p><pre><code class="c">#address-cells   // 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述地址(address)#size-cells      // 在它的子节点（即/cpus/cpu*）的reg属性中, 使用多少个u32整数来描述大小(size)，必须设置为 0</code></pre><h5 id="e-cpus-cpu"><a href="#e-cpus-cpu" class="headerlink" title="e. /cpus/cpu*"></a>e. /cpus/cpu*</h5><pre><code class="c">device_type = &quot;cpu&quot;;reg             // 表明自己是哪一个cpu</code></pre><h4 id="引用其他节点"><a href="#引用其他节点" class="headerlink" title="引用其他节点"></a>引用其他节点</h4><h5 id="a-phandle属性"><a href="#a-phandle属性" class="headerlink" title="a. phandle属性"></a>a. phandle属性</h5><p>节点中的phandle属性, 它的取值必须是唯一的(不要跟其他的phandle值一样)</p><pre><code class="c">pic@10000000 {    phandle = &lt;1&gt;;            //phandle属性必须唯一    interrupt-controller;    //该属性表明这是中断控制器};another-device-node {    interrupt-parent = &lt;1&gt;;   // 引用phandle值为1的节点};</code></pre><h5 id="b-label属性"><a href="#b-label属性" class="headerlink" title="b. label属性"></a>b. label属性</h5><p>通过<code>&amp;</code>进行引用，底层原理和phandle属性的方法是一样的，只是phandle属性部分由编译器将替我们完成了</p><pre><code class="c">PIC: pic@10000000 {    interrupt-controller;    //该属性表明这是中断控制器};another-device-node {    interrupt-parent = &lt;&amp;PIC&gt;;   // 使用label来引用上述节点,                                 // 使用lable时实际上也是使用phandle来引用,                                 // 在编译dts文件为dtb文件时, 编译器dtc会在dtb中插入phandle属性};</code></pre><p>label属性可以在<strong><code>/</code>节点外</strong>直接引用并修改对应节点中的值</p><pre><code class="c">//以下为XXXX.dtsi文件内容：/ {    ......    PIC: pic@10000000 {        pin = &lt;XXX&gt;;        interrupt-controller;    //该属性表明这是中断控制器    };    ......};</code></pre><pre><code class="c">#include&quot;XXXX.dtsi&quot;&amp;PIC {    pin = &lt;XXXXXXX&gt;;//直接修改};</code></pre><h3 id="2-DTB二进制文件的格式"><a href="#2-DTB二进制文件的格式" class="headerlink" title="2. DTB二进制文件的格式"></a>2. DTB二进制文件的格式</h3><p><a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">官方文档</a></p><p>内核文档路径：<code>Documentation/devicetree/booting-without-of.txt</code></p><p>dtb文件是由dts文件编译而来</p><h4 id="DTB文件布局"><a href="#DTB文件布局" class="headerlink" title="DTB文件布局"></a>DTB文件布局</h4><p>dtb文件以<code>大字节序</code>存储（低地址放高位）。根据官方说明，dtb文件结构如下所示：</p><pre><code class="c">             ------------------------------     base -&gt; |  struct boot_param_header  | //头部信息，包含后几个部分的指针             ------------------------------             |      (alignment gap) (*)   |             ------------------------------             |      memory reserve map    |//保留给自己使用的内存，即dts中格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;的地方             ------------------------------             |      (alignment gap)       |             ------------------------------             |                            |             |    device-tree structure   |//设备数的二进制文件             |                            |             ------------------------------             |      (alignment gap)       |             ------------------------------             |                            |             |     device-tree strings    |//设备数节点中的属性名字字符串             |                            |      -----&gt; ------------------------------      |      |      --- (base + totalsize)</code></pre><p>具体格式可见下图：</p><p><img src="//NU-LL.github.io/2019/10/13/设备树/DTB%E6%A0%BC%E5%BC%8F.jpg" alt="DTB格式"></p><h3 id="3-通用函数"><a href="#3-通用函数" class="headerlink" title="3. 通用函数"></a>3. 通用函数</h3><p>device_node结构体与property结构体内容可以看下文中 <code>第二章第4节</code></p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li><p>通过名字查找</p><pre><code class="c"> struct device_node *of_find_node_by_name(struct device_node *from, const char *name);</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>name：要查找的节点名字（不是table和name属性）。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li></ul></li><li><p>通过device_type 属性查找</p><pre><code class="c"> struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>type：要查找的节点对应的 type 字符串，即 device_type 属性值。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败。  </li></ul></li><li><p>根据 device_type 和 compatible查找</p><pre><code class="c"> struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>type：要查找的节点对应的 type 字符串，即 device_type 属性值（若为 NULL则表示忽略 device_type 属性）</li><li>compatible： 要查找的节点所对应的 compatible 属性列表。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败  </li></ul></li><li><p>通过 of_device_id 匹配表来查找</p><pre><code class="c"> struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</code></pre><ul><li>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</li><li>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</li><li>match： 找到的匹配的 of_device_id。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败</li></ul></li><li><p>通过路径查找</p><pre><code class="c"> inline struct device_node *of_find_node_by_path(const char *path)</code></pre><ul><li>path：带有全路径的节点名，可以使用节点的别名。</li><li>返回值： 找到的节点，如果为 NULL 表示查找失败</li></ul></li><li><p>查找指定节点的父节点</p><pre><code class="c"> struct device_node *of_get_parent(const struct device_node *node)</code></pre><ul><li>node：要查找的父节点的节点。</li><li>返回值： 找到的父节点。</li></ul></li><li><p>查找指定节点的子节点</p><pre><code class="c"> struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)</code></pre><ul><li>node：父节点。</li><li>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</li><li>返回值： 找到的下一个子节点。</li></ul></li></ol><h4 id="提取属性"><a href="#提取属性" class="headerlink" title="提取属性"></a>提取属性</h4><ol><li><p>查找节点中的指定属性</p><pre><code class="c"> property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code></pre><ul><li>np：设备节点。</li><li>name： 属性名字。</li><li>lenp：属性值的字节数，一般为NULL</li><li>返回值： 找到的属性。</li></ul></li><li><p>获取属性中元素的数量</p><pre><code class="c"> int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size)</code></pre><ul><li>np：设备节点。</li><li>proname： 需要统计元素数量的属性名字。</li><li>elem_size：每个元素的长度。（如果元素为u32类型则此处填sizeof(u32)）</li><li>返回值： 得到的属性元素数量。</li></ul></li><li><p>从属性中获取指定标号的 u32 类型数据值</p><pre><code class="c"> int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>index：要读取的值标号。</li><li>out_value：读取到的值</li><li>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取属性中 u8、 u16、 u32 和 u64 类型的数组数据</p><pre><code class="c"> int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz) int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz) int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz) int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_values：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</li><li>sz： 要读取的数组元素数量。</li><li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取只有一个整形值的属性</p><pre><code class="c"> int of_property_read_u8(const struct device_node *np,const char *propname, u8 *out_value) int of_property_read_u16(const struct device_node *np, const char *propname, u16 *out_value) int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value) int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_value：读取到的数组值。</li><li>返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</li></ul></li><li><p>读取属性中字符串值</p><pre><code class="c"> int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)</code></pre><ul><li>np：设备节点。</li><li>proname： 要读取的属性名字。</li><li>out_string：读取到的字符串值。</li><li>返回值： 0，读取成功，负值，读取失败。</li></ul></li><li><p>获取#address-cells 属性值</p><pre><code class="c"> int of_n_addr_cells(struct device_node *np)</code></pre><ul><li>np：设备节点。</li><li>返回值： 获取到的#address-cells 属性值。</li></ul></li><li><p>获取#size-cells 属性值</p><pre><code class="c"> int of_n_size_cells(struct device_node *np)</code></pre><ul><li>np：设备节点。</li><li>返回值： 获取到的#size-cells 属性值。</li></ul></li></ol><h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><ol><li><p>查看节点的 compatible 属性是否有包含指定的字符串</p><pre><code class="c"> int of_device_is_compatible(const struct device_node *device, const char *compat)</code></pre><ul><li>device：设备节点。</li><li>compat：要查看的字符串。</li><li>返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的compatible属性中包含 compat 指定的字符串。</li></ul></li><li><p>获取地址相关属性</p><p> 主要是“reg”或者“assigned-addresses”属性值</p><pre><code class="c"> const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags)</code></pre><ul><li>dev：设备节点。</li><li>index：要读取的地址标号。</li><li>size：地址长度。</li><li>flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</li><li>返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</li></ul></li><li><p>将从设备树读取到的地址转换为物理地址</p><pre><code class="c"> u64 of_translate_address(struct device_node *dev, const __be32 *in_addr)</code></pre><ul><li>dev：设备节点。</li><li>in_addr：要转换的地址。</li><li>返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败。</li></ul></li><li><p>从设备树里面提取资源值</p><p> 本质上是将 reg 属性值转换为 resource 结构体类型</p><pre><code class="c"> int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</code></pre><ul><li>dev：设备节点。</li><li>index：地址资源标号。</li><li>r：得到的 resource 类型的资源值。</li><li>返回值： 0，成功；负值，失败。</li></ul></li><li><p>直接内存映射（获取内存地址所对应的虚拟地址  ）</p><p> 本质上是将 reg 属性中地址信息转换为虚拟地址（将原来的先提取属性在映射结合起来），如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段</p><pre><code class="c"> void __iomem *of_iomap(struct device_node *np, int index)</code></pre><ul><li>np：设备节点。</li><li>index： reg 属性中要完成内存映射的段，如果 reg 属性只有一段的话 index 就设置为0。（从0开始，一次映射一对，即一个地址一个长度）</li><li>返回值： 经过内存映射后的虚拟内存首地址，如果为 NULL 的话表示内存映射失败。</li></ul></li></ol><h2 id="二、内核对设备树的处理"><a href="#二、内核对设备树的处理" class="headerlink" title="二、内核对设备树的处理"></a>二、内核对设备树的处理</h2><p>根据内核文档中的描述，内核对设备数的处理大概分为以下三个部分：</p><ol><li>platform identification，平台识别信息</li><li>runtime configuration，运行时配置信息</li><li>device population，设备信息</li></ol><h3 id="1-内核head-S对dtb的简单处理"><a href="#1-内核head-S对dtb的简单处理" class="headerlink" title="1. 内核head.S对dtb的简单处理"></a>1. 内核head.S对dtb的简单处理</h3><p>uboot启动后，会设置r0 r1 r2 三个寄存器，将参数传给linux内核：</p><ul><li>r0一般设置为0;</li><li>r1一般设置为machine id (机器ID，在使用设备树时该参数没有被使用); </li><li>r2一般设置ATAGS或DTB的开始地址</li></ul><p>inux内核启动后会运行head.S文件，head.S和head-common.S文件一起将传入的这几个参数又传给了内核中的C语言变量：</p><ul><li>把bootloader传来的r1值, 赋给了C变量: <code>__machine_arch_type</code></li><li>把bootloader传来的r2值, 赋给了C变量: <code>__atags_pointer</code>     // dtb首地址</li></ul><p>之后会调用start_kernel启动内核。</p><h3 id="2-对设备树中平台信息的处理-选择machine-desc结构体"><a href="#2-对设备树中平台信息的处理-选择machine-desc结构体" class="headerlink" title="2. 对设备树中平台信息的处理(选择machine_desc结构体)"></a>2. 对设备树中平台信息的处理(选择machine_desc结构体)</h3><p>大概流程如下：</p><ul><li><p>a. 设备树根节点的<code>compatible</code>属性列出了一系列的字符串,表示它兼容的单板名,从”最兼容”到次之</p></li><li><p>b. 内核中有多个machine_desc,其中有<code>dt_compat</code>成员, 它指向一个字符串数组, 里面表示该machine_desc支持哪些单板</p><blockquote><p>没有用设备树的时候，uboot向linux内核传递ATAGS，此时是根据machine_desc.nr成员来匹配机器id是否相等进而选取的</p></blockquote></li><li><p>c. 使用<code>compatile</code>属性的值，跟每一个<code>machine_desc.dt_compat</code>比较，如若多项均匹配上，<code>compatile</code>属性中越靠前的字符串优先级越高</p></li></ul><p>函数调用过程如下：</p><hr><ul><li><p>start_kernel   // init/main.c</p><ul><li><p>setup_arch(&amp;command_line);  （先尝试将__atags_pointer处的数据认为是dtb并进行分析，如若出错就将其当做ATAGS分析）// arch/arm/kernel/setup.c</p><ul><li><p>mdesc = setup_machine_fdt(__atags_pointer);  // arch/arm/kernel/devtree.c</p><ul><li><p>early_init_dt_verify(phys_to_virt(dt_phys)  // 检查头部信息，判断是否有效的dtb, drivers/of/ftd.c</p><ul><li>initial_boot_params = params;//保存在全局变量initial_boot_params中</li></ul></li><li><p>mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);  // 找到最匹配的machine_desc，arch_get_next_mach为一个函数指针，该函数每调用一次就会返回一个machine_desc.dt_compat, drivers/of/ftd.c</p><ul><li><pre><code class="c">  while ((data = get_next_compat(&amp;compat))) {      score = of_flat_dt_match(dt_root, compat);      if (score &gt; 0 &amp;&amp; score &lt; best_score) {          best_data = data;          best_score = score;      }  }</code></pre></li></ul></li></ul></li><li><p>machine_desc = mdesc;</p></li></ul></li></ul></li></ul><hr><h3 id="3-对设备树中运行时配置信息的处理"><a href="#3-对设备树中运行时配置信息的处理" class="headerlink" title="3. 对设备树中运行时配置信息的处理"></a>3. 对设备树中运行时配置信息的处理</h3><p>大致流程如下：</p><ul><li>a. /chosen节点中bootargs属性的值, 存入全局变量： boot_command_line</li><li>b. 确定根节点的这2个属性的值: #address-cells, #size-cells存入全局变量: dt_root_addr_cells, dt_root_size_cells</li><li>c. 解析/memory中的reg属性, 提取出”base, size”, 最终调用memblock_add(base, size);</li></ul><p>函数调用过程如下：</p><hr><ul><li><p>start_kernel // init/main.c</p><ul><li><p>setup_arch(&amp;command_line);  // arch/arm/kernel/setup.c</p><ul><li><p>mdesc = setup_machine_fdt(__atags_pointer);  // arch/arm/kernel/devtree.c</p><ul><li><p>early_init_dt_scan_nodes();      // drivers/of/ftd.c</p><ul><li><pre><code class="c">  /* Retrieve various information from the /chosen node */  of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);//将bootargs属性的值, 存入全局变量boot_command_line  /* Initialize {size,address}-cells info */  of_scan_flat_dt(early_init_dt_scan_root, NULL);//处理并保存 根节点信息中的#address-cells, #size-cells属性  /* Setup memory, calling early_init_dt_add_memory_arch */  of_scan_flat_dt(early_init_dt_scan_memory, NULL);//取出/memory节点reg属性中的&quot;base, size&quot;并告诉内核</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h3 id="4-dtb转换为device-node-unflatten-device-tree函数"><a href="#4-dtb转换为device-node-unflatten-device-tree函数" class="headerlink" title="4. dtb转换为device_node(unflatten_device_tree函数)"></a>4. dtb转换为device_node(unflatten_device_tree函数)</h3><p>大致过程：</p><ul><li><p>a. 在DTB文件中, 每一个节点都以TAG(FDT_BEGIN_NODE, 0x00000001)开始, 节点内部可以嵌套其他节点,每一个属性都以TAG(FDT_PROP, 0x00000003)开始</p></li><li><p>b. 每一个节点最后都会转换为一个device_node结构体:</p><pre><code class="c">  struct device_node {      const char *name;  // 来自节点中的name属性, 如果没有该属性, 则设为&quot;NULL&quot;      const char *type;  // 来自节点中的device_type属性, 如果没有该属性, 则设为&quot;NULL&quot;      phandle phandle;      const char *full_name;  // 节点的名字, node-name[@unit-address]      struct fwnode_handle fwnode;      struct  property *properties;  // 节点的属性      struct  property *deadprops;    /* removed properties */      struct  device_node *parent;   // 节点的父亲      struct  device_node *child;    // 节点的孩子(子节点)      struct  device_node *sibling;  // 节点的兄弟(同级节点)  #if defined(CONFIG_OF_KOBJ)      struct  kobject kobj;  #endif      unsigned long _flags;      void    *data;  #if defined(CONFIG_SPARC)      const char *path_component_name;      unsigned int unique_id;      struct of_irq_controller *irq_trans;  #endif  };</code></pre></li><li><p>c. device_node结构体中有properties, 用来表示该节点的属性，每一个属性对应一个property结构体:</p><pre><code class="c">  struct property {      char    *name;    // 属性名字, 指向dtb文件中的字符串      int length;       // 属性值的长度，按字节计算      void    *value;   // 属性值, 指向dtb文件中value所在位置, 数据仍以big endian存储      struct property *next;  #if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)      unsigned long _flags;  #endif  #if defined(CONFIG_OF_PROMTREE)      unsigned int unique_id;  #endif  #if defined(CONFIG_OF_KOBJ)      struct bin_attribute attr;  #endif  };</code></pre></li><li><p>d. 这些device_node构成一棵树, 根节点为: <code>of_root</code></p></li></ul><p>函数调用过程：</p><hr><ul><li><p>start_kernel // init/main.c</p><ul><li><p>setup_arch(&amp;command_line);  // arch/arm/kernel/setup.c</p><ul><li><p>arm_memblock_init(mdesc);   // arch/arm/kernel/setup.c</p><ul><li>early_init_fdt_reserve_self();//将DTB所占区域保留下来, 最后会调用: memblock_reserve</li><li>early_init_fdt_scan_reserved_mem();  // 根据dtb中的memreserve信息, 调用memblock_reserve保留其他区域</li></ul></li><li><p>unflatten_device_tree();    // arch/arm/kernel/setup.c//开始分配设置device_node结构体</p><ul><li><p>__unflatten_device_tree(initial_boot_params, NULL, &amp;of_root,early_init_dt_alloc_memory_arch, false);            // drivers/of/fdt.c</p><ul><li><pre><code class="c">  /* First pass, scan for size */  size = unflatten_dt_nodes(blob, NULL, dad, NULL);  /* Allocate memory for the expanded device tree */  mem = dt_alloc(size + 4, __alignof__(struct device_node));  /* Second pass, do actual unflattening */  unflatten_dt_nodes(blob, mem, dad, mynodes);</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h3 id="5-device-node结构体转换为platform-device"><a href="#5-device-node结构体转换为platform-device" class="headerlink" title="5. device_node结构体转换为platform_device"></a>5. device_node结构体转换为platform_device</h3><p>基本流程：dts -&gt; dtb -&gt; device_node -&gt; platform_device</p><ul><li><p>转化为platform_device的只有一部分device_node </p><blockquote><p>条件：</p><ol><li>一般来说<u>根节点下</u>包含compatile属性的<u>子节点</u>都会转化为platform_device。而其他子节点不应该转化为platform_device。如：i2c, spi等总线节点下的子节点, 应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device</li><li>特殊情况：如果一个节点的compatile属性含有这些特殊的值（<code>simple-bus</code>、<code>simple-mfd</code>、<code>isa</code>、<code>arm,amba-bus</code>）（由drivers\of\platform.c中的of_default_bus_match_table表定义）之一, 那么它的子节点（也需含compatile属性。详见下面of_platform_bus_create的实现）也可以转换为platform_device</li></ol><p>附：</p><p>根节点下的iic、spi总线节点一般都会转化为platform_device结构体，这些总线节点下的子节点一般不再会转换为platform_device，而是交给bus的probe函数去注册为i2c_client、spi_device等设备结构体</p></blockquote></li></ul><p>转化过程：</p><ul><li>利用device_node中的reg, interrupts属性设置platform_device中的<code>resource</code>数组</li><li>将device_node结构体挂载在<code>platform_device.dev.of_node</code>上</li></ul><p>函数调用过程：</p><hr><p>核心函数：of_platform_default_populate_init</p><blockquote><p>注：</p><p>该函数不会直接调用，会通过do_initcall_level(level);函数间接调用，of_platform_default_populate_init函数通过一个宏将其放到了.initcall3s.init段处。do_initcall_level(3)会调用.initcall3s.init段的所有函数。</p></blockquote><p>调用of_platform_default_populate_init：</p><ul><li><p>start_kernel     // init/main.c</p><ul><li><p>rest_init();</p><ul><li><p>pid = kernel_thread(kernel_init, NULL, CLONE_FS);//启动线程kernel_init</p><ul><li><p>kernel_init线程中：</p></li><li><p>kernel_init_freeable();</p><ul><li><p>do_basic_setup();</p><ul><li><p>do_initcalls();</p><ul><li><pre><code class="c">  for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++)      do_initcall_level(level);  // 比如 do_initcall_level(3)</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>生成platform_device:</p><ul><li><p>of_platform_default_populate_init//遍历所有节点并生成platform_device结构体</p><ul><li><p>of_platform_default_populate(NULL, NULL, NULL);</p><ul><li><p>of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL)</p><ul><li><pre><code class="c">  for_each_child_of_node(root, child) {      rc = of_platform_bus_create(child, matches, lookup, parent, true);  // 调用过程看下面      dev = of_device_alloc(np, bus_id, parent);   // 根据device_node节点的属性设置platform_device的resource      if (rc) {          of_node_put(child);          break;      }  }</code></pre></li></ul></li></ul></li></ul></li></ul><p>of_platform_bus_create创建总线节点（处理bus节点生成platform_devie, 并决定是否处理它的子节点）</p><ul><li><p>of_platform_bus_create</p><ul><li><pre><code class="c">  dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);  // 生成bus节点的platform_device结构体  if (!dev || !of_match_node(matches, bus))  // 如果bus节点的compatile属性不吻合matches成表, 就不处理它的子节点      return 0;  for_each_child_of_node(bus, child) {    // 取出每一个子节点      pr_debug(&quot;   create child: %pOF\n&quot;, child);      rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);   // 处理它的子节点, of_platform_bus_create是一个递归调用      if (rc) {          of_node_put(child);          break;      }  }</code></pre></li></ul></li></ul><h3 id="6-platform-device跟platform-driver的匹配"><a href="#6-platform-device跟platform-driver的匹配" class="headerlink" title="6. platform_device跟platform_driver的匹配"></a>6. platform_device跟platform_driver的匹配</h3><p>匹配时通过platform_bus_type的match成员函数实现的，即platform_match</p><p>匹配的优先级如下：</p><ul><li>比较 platform_dev.driver_override 和 platform_driver.drv-&gt;name</li><li>比较 platform_dev.dev.of_node的compatible属性 和 platform_driver.drv-&gt;of_match_table</li><li>比较 platform_dev.name 和 platform_driver.id_table</li><li>比较 platform_dev.name 和 platform_driver.drv-&gt;name</li></ul><h3 id="7-内核中设备树的操作函数"><a href="#7-内核中设备树的操作函数" class="headerlink" title="7. 内核中设备树的操作函数"></a>7. 内核中设备树的操作函数</h3><ul><li><p>a. 处理DTB<br>  of_fdt.h           // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)</p></li><li><p>b. 处理device_node<br>  of.h               // 提供设备树的一般处理函数, 比如 of_property_read_u32(读取某个属性的u32值), of_get_child_count(获取某个device_node的子节点数)<br>  of_address.h       // 地址相关的函数, 比如 of_get_address(获得reg属性中的addr, size值)<br>  of_match_device(从matches数组中取出与当前设备最匹配的一项)<br>  of_dma.h           // 设备树中DMA相关属性的函数<br>  of_gpio.h          // GPIO相关的函数<br>  of_graph.h         // GPU相关驱动中用到的函数, 从设备树中获得GPU信息<br>  of_iommu.h         // 很少用到<br>  of_irq.h           // 中断相关的函数<br>  of_mdio.h          // MDIO (Ethernet PHY) API<br>  of_net.h           // OF helpers for network devices.<br>  of_pci.h           // PCI相关函数<br>  of_pdt.h           // 很少用到<br>  of_reserved_mem.h  // reserved_mem的相关函数</p></li><li><p>c. 处理设备相关的信息 platform_device<br>  of_platform.h      // 把device_node转换为platform_device时用到的函数, </p><pre><code>                 // 比如of_device_alloc(根据device_node分配设置platform_device),                  //     of_find_device_by_node (根据device_node查找到platform_device),                 //     of_platform_bus_probe (处理device_node及它的子节点)</code></pre><p>  of_device.h        // 设备相关的函数, 比如 of_match_device</p></li></ul><h3 id="8-在根文件系统中查看设备树-有助于调试"><a href="#8-在根文件系统中查看设备树-有助于调试" class="headerlink" title="8. 在根文件系统中查看设备树(有助于调试)"></a>8. 在根文件系统中查看设备树(有助于调试)</h3><ul><li><p>a. <code>/sys/firmware/fdt</code>        // 原始dtb文件</p><pre><code class="bash">  #打印设备数文件（dtb文件）  hexdump -C /sys/firmware/fdt</code></pre></li><li><p>b. <code>/sys/firmware/devicetree</code> // 以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件</p></li><li><p>c. <code>/sys/devices/platform</code>    // 系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的</p><pre><code> 对于来自设备树的platform_device,可以进入 `/sys/devices/platform/&lt;设备名&gt;/of_node` 查看它的设备树属性</code></pre></li><li><p>d.  <code>/proc/device-tree</code> 是链接文件, 指向 /sys/firmware/devicetree/base</p></li></ul><h2 id="三、u-boot对设备树的支持"><a href="#三、u-boot对设备树的支持" class="headerlink" title="三、u-boot对设备树的支持"></a>三、u-boot对设备树的支持</h2><h3 id="1-传递dtb给内核（r2）"><a href="#1-传递dtb给内核（r2）" class="headerlink" title="1. 传递dtb给内核（r2）"></a>1. 传递dtb给内核（r2）</h3><ul><li><p>u-boot中内核启动命令</p><pre><code class="bash">  bootm &lt;uImage_addr&gt;                            // 无设备树,bootm 0x30007FC0  bootm &lt;uImage_addr&gt; &lt;initrd_addr&gt; &lt;dtb_addr&gt;   // 有设备树</code></pre><p>  eg：</p><pre><code class="bash">  nand read.jffs2 0x30007FC0 kernel;     // 读内核uImage到内存0x30007FC0  nand read.jffs2 32000000 device_tree;  // 读dtb到内存32000000  bootm 0x30007FC0 - 0x32000000          // 启动, 没有initrd时对应参数写为&quot;-&quot;</code></pre></li><li><p>设备数的存放地址 <code>dtb_addr</code> 的选取原则</p><ul><li>不要破坏u-boot本身</li><li>不要挡内核的路: 内核本身的空间不能占用, 内核要用到的内存区域也不能占用内核启动时一般会在它所处位置的下边放置页表, 这块空间(一般是0x4000即16K字节)不能被占用</li></ul></li></ul><blockquote><p>JZ2440内存使用情况:</p><pre><code>                     ------------------------------  0x33f80000       -&gt;|    u-boot                  |                     ------------------------------                     |    u-boot所使用的内存(栈等)|                     ------------------------------                     |                            |                     |                            |                     |        空闲区域            |                     |                            |                     |                            |                     |                            |                     |                            |                     ------------------------------  0x30008000       -&gt;|      zImage                |                     ------------------------------  uImage = 64字节的头部+zImage  0x30007FC0       -&gt;|      uImage头部            |                     ------------------------------  0x30004000       -&gt;|      内核创建的页表        |  head.S                     ------------------------------                     |                            |                     |                            |              -----&gt; ------------------------------              |              |              --- (内存基址 0x30000000)</code></pre><ul><li><p>正常启动linux：</p><pre><code class="bash">  nand read.jffs2 30000000 device_tree  nand read.jffs2 0x30007FC0 kernel  bootm 0x30007FC0 - 30000000</code></pre></li><li><p>启动错误：</p><pre><code class="bash">  #设备数放到内核创建的页表处，会导致linux启动后设备树文件缺失  nand read.jffs2 30004000 device_tree  nand read.jffs2 0x30007FC0 kernel  bootm 0x30007FC0 - 30004000</code></pre></li></ul></blockquote><h3 id="2-uboot中对dtb文件修改的原理"><a href="#2-uboot中对dtb文件修改的原理" class="headerlink" title="2. uboot中对dtb文件修改的原理"></a>2. uboot中对dtb文件修改的原理</h3><ul><li><p>修改属性的值</p><ul><li>a. 把原属性val所占空间从len字节扩展为newlen字节，把老值之后的所有内容向后移动(newlen - len)字节</li><li>b. 把新值写入val所占的newlen字节空间</li><li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li><li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li><li>e. 修改dtb头部信息中的总长度: totalsize</li></ul></li><li><p>添加一个全新的属性</p><ul><li>a. 如果在string block中没有这个属性的名字，就在string block尾部添加一个新字符串: 属性的名。并且修改dtb头部信息中string block的长度: size_dt_strings，修改dtb头部信息中的总长度: totalsize</li><li>b. 找到属性所在节点, 在节点尾部扩展一块空间, 内容及长度为: <pre><code> TAG      // 4字节, 对应0x00000003 len      // 4字节, 表示属性的val的长度 nameoff  // 4字节, 表示属性名的offset val      // len字节, 用来存放val</code></pre></li><li>c. 修改dtb头部信息中structure block的长度: size_dt_struct</li><li>d. 修改dtb头部信息中string block的偏移值: off_dt_strings</li><li>e. 修改dtb头部信息中的总长度: totalsize</li></ul></li></ul><h3 id="3-uboot中dtb修改命令fdt的移植"><a href="#3-uboot中dtb修改命令fdt的移植" class="headerlink" title="3.uboot中dtb修改命令fdt的移植"></a>3.uboot中dtb修改命令fdt的移植</h3><p><strong>使用：</strong></p><ol><li><p>配置交叉编译工具链 <code>gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabi</code></p></li><li><p>解压</p><pre><code class="bash"> tar xjf u-boot-1.1.6.tar.bz2</code></pre></li><li><p>打补丁</p><pre><code class="bash"> patch -p1 &lt; ../u-boot-1.1.6_device_tree_for_jz2440_add_fdt_20181022.patch   // 打补丁 make 100ask24x0_config                                                      // 配置 make                                                                        // 编译, 可以得到u-boot.bin</code></pre></li></ol><p><strong>移植：</strong></p><p>高版本中已经存在，无需移植</p><h4 id="创建补丁文件"><a href="#创建补丁文件" class="headerlink" title="创建补丁文件"></a>创建补丁文件</h4><pre><code class="bash">diff -urN 原始未修改文件夹 修改后文件夹 &gt; 补丁文件.patch</code></pre><h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><pre><code class="bash">patch -p1 &lt; ../补丁文件.patch</code></pre><h2 id="四、中断系统中的设备树"><a href="#四、中断系统中的设备树" class="headerlink" title="四、中断系统中的设备树"></a>四、中断系统中的设备树</h2><h3 id="1-Linux对中断处理的框架及代码流程简述"><a href="#1-Linux对中断处理的框架及代码流程简述" class="headerlink" title="1. Linux对中断处理的框架及代码流程简述"></a>1. Linux对中断处理的框架及代码流程简述</h3><p>如图：</p><p><img src="//NU-LL.github.io/2019/10/13/设备树/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%A1%86%E6%9E%B6.jpg" alt="Linux中断处理的框架"></p><h3 id="2-中断号的演变与irq-domain"><a href="#2-中断号的演变与irq-domain" class="headerlink" title="2. 中断号的演变与irq_domain"></a>2. 中断号的演变与irq_domain</h3><h4 id="之前的irq"><a href="#之前的irq" class="headerlink" title="之前的irq"></a>之前的irq</h4><ul><li>以前中断号(virq)跟硬件密切相关，现在的趋势是中断号跟硬件无关, 仅仅是一个标号而已</li><li>以前, 对于每一个硬件中断(hwirq)都预先确定它的中断号(virq),这些中断号一般都写在一个头文件里, 比如arch\arm\mach-s3c24xx\include\mach\irqs.h使用时：<ul><li>执行 request_irq(virq, my_handler) :内核根据virq可以知道对应的硬件中断, 然后去设置、使能中断等</li><li>发生硬件中断时,内核读取硬件信息, 确定hwirq, 反算出virq,然后调用 irq_desc[virq].handle_irq, 最终会用到用户注册的my_handler函数</li></ul></li></ul><h4 id="现在的irq"><a href="#现在的irq" class="headerlink" title="现在的irq"></a>现在的irq</h4><ul><li><p>hwirq跟virq之间不再通过代码绑定，而是进行动态绑定：</p><ul><li><p>每一个hwirq会去irq_desc全局表中从hwirq项开始向后查找，直到找到空闲项就进行绑定：</p><ul><li>每一个中断控制器都有一个对应的<code>irq_domain</code>（域）</li></ul></li><li><p>绑定信息保存在<code>irq_domain</code>（域）中</p></li><li><p><code>irq_domain</code>中有个<code>linear_revmap</code>数组成员用于保存hwirq到virq的关系：</p><pre><code class="c">  irq_domain.linear_revmap[hwirq] = virq;</code></pre></li><li><p>不难看出<code>linear_revmap</code>数组成员中用到的项比较少，大部分为空闲项</p></li><li><p><code>irq_domain</code>对之前的irq的兼容：</p><ul><li><code>irq_domain</code>中有<code>linear_revmap</code>成员用于保存之前irq架构中的hwirq到预先设置好的virq之间的对应关系</li><li><code>linear_revmap</code>成员中基本上都使用了，很少的空闲项</li></ul></li></ul></li></ul><blockquote><p>例子：子中断控制器中的中断发生：</p><ol><li>进入中断入口，再跳转到C语言入口，执行相应的保存现场等动作</li><li>总中断控制器通过hwirq和irq_domain.linear_revmap查到具体的virq</li><li>通过virq查到全局表中具体的中断函数irq_desc[virq].handle_irq，发现是分发函数（s3c_irq_demux）</li><li>接着查询子中断控制器的hwirq，并找到对应的virq：irq_domain.linear_revmap[hwirq]</li><li>找到新的全局表中的中断函数irq_desc[virq].handle_irq并执行</li><li>该函数是用户通过request_irq(virq, my_handler)向系统注册的用户函数my_handler，真正交给用户<ol><li>此时request_irq中的virq不再通过固定文件获得，而是通过设备树中相互约定得来的。</li></ol></li></ol></blockquote><h4 id="设备树中irq的设置"><a href="#设备树中irq的设置" class="headerlink" title="设备树中irq的设置"></a>设备树中irq的设置</h4><p>设备树中应该对中断节点设置对应的中断控制器（决定使用哪个<code>irq_domain</code>）和hwirq（硬件中断号）</p><p>设备树中的设置会被irq_domain中的xlate成员函数解析，得到相应的virq和irq_type</p><p>irq_domain中的map成员函数会建立hwirq和virq之间的联系（详细分析见后文）</p><h3 id="3-设备树中对中断的描述"><a href="#3-设备树中对中断的描述" class="headerlink" title="3. 设备树中对中断的描述"></a>3. 设备树中对中断的描述</h3><p>ARM中顶层的中断控制器一般为<code>intc: interrupt-controller@xxxxxxxx</code>，其余节点均为其子节点</p><h4 id="中断节点"><a href="#中断节点" class="headerlink" title="中断节点"></a>中断节点</h4><ul><li><p><code>interrupts</code>属性：指定要使用的硬件中断号, 中断的触发类型等等，具体格式由对应的中断控制器决定</p></li><li><p><code>interrupt-parent</code>属性：指定该节点所在的中断控制器节点（若该节点中没有，在该节点的父节点中肯定已经包含）</p><ul><li>phandle属性指定</li><li>label属性指定</li></ul></li><li><p><code>interrupt-extended</code>属性（可选）：通过该属性可以解决一个节点产生多个中断的问题，其具体格式为：</p><p>  &lt;phandle&gt; &lt;prop-encoded-array&gt;</p><p>  其中：</p><ul><li><p>&lt;phandle&gt;：具体的发给那个中断控制器</p></li><li><p>&lt;prop-encoded-array&gt;：相关的中断描述，取决于中断控制器中的<code>#interrupt-cells</code>属性</p></li></ul></li></ul><h4 id="中断控制器节点"><a href="#中断控制器节点" class="headerlink" title="中断控制器节点"></a>中断控制器节点</h4><p>官方文档：<code>Documentation/devicetree/bindings/arm/gic.txt</code></p><ul><li><code>interrupt-controller</code>属性：表明自己是中断控制器</li><li><code>#interrupt-cells</code>属性：表明对应的子设备里interrupts属性应该用几个u32的数据来描述</li></ul><blockquote><p>对于 ARM 处理的 GIC（通用中断控制器）来说，一般<code>#interrupt-cells</code>为 3，其子节点<code>interrupts</code>属性中cells一般为：</p><ul><li>第一个 cells：中断类型， 0 表示 SPI 中断， 1 表示 PPI 中断</li><li>第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 0<del>987，对于 PPI 中断来说中断号的范围为 0</del>15</li><li>第三个 cells：标志， bit[3:0]表示中断触发类型，为 1 的时候表示上升沿触发，为 2 的时候表示下降沿触发，为 4 的时候表示高电平触发，为 8 的时候表示低电平触发。 bit[15:8]为 PPI 中断的 CPU 掩码。  </li></ul></blockquote><ul><li><code>interrupt-parent</code>属性（可选）：指定该节点所在的中断控制器节点（除去最顶层的<code>intc</code>节点之外，其他所有中断节点中若没有，则在该节点的父节点中肯定已经包含）</li></ul><h3 id="4-使用设备树描述按键中断"><a href="#4-使用设备树描述按键中断" class="headerlink" title="4.使用设备树描述按键中断"></a>4.使用设备树描述按键中断</h3><ul><li>一般来说，一个节点会生成一个platform_device结构体，通过设备树中的compatible属性与platform_driver驱动结构体中的of_math_table结构体成员进行匹配，匹配上后会调用其下的probe函数，在该函数中会通过platform_get_resource函数来获取到platform_device对应的设备树中定义的相关资源（自定义属性的话需要利用of_XXXX系列函数自己转换），此时需要在这里保存下节点中的中断相关信息，以便于之后使用request_irq函数注册中断</li></ul><h3 id="5-内核对设备树中断信息的处理过程"><a href="#5-内核对设备树中断信息的处理过程" class="headerlink" title="5.内核对设备树中断信息的处理过程"></a>5.内核对设备树中断信息的处理过程</h3><ul><li>在Linux内核初始化时，会首先创建并初始化总中断控制器中的irq_domain结构体</li><li>各个子中断控制器会在各个设备节点所对应的platform_driver驱动结构体中的probe函数中对irq_domain结构体初始化</li><li>中断节点中，各个和中断相关的资源均会在内核初始化阶段（具体为of_device_alloc函数中，详见第二章第五节），将其初始化为platform_driver的resource结构体</li><li>各种中断数据的解析和处理均利用到了irq_domain-&gt;ops-&gt;xlate或者irq_domain-&gt;ops-&gt;map函数，此处不做详解，了解即可</li></ul><h2 id="五、实践操作"><a href="#五、实践操作" class="headerlink" title="五、实践操作"></a>五、实践操作</h2><h3 id="1-使用设备树给DM9000网卡-触摸屏指定中断"><a href="#1-使用设备树给DM9000网卡-触摸屏指定中断" class="headerlink" title="1. 使用设备树给DM9000网卡_触摸屏指定中断"></a>1. 使用设备树给DM9000网卡_触摸屏指定中断</h3><h3 id="2-在设备树中时钟的简单使用"><a href="#2-在设备树中时钟的简单使用" class="headerlink" title="2. 在设备树中时钟的简单使用"></a>2. 在设备树中时钟的简单使用</h3><p>参考文档：</p><ol><li>内核 Documentation/devicetree/bindings/clock/clock-bindings.txt</li><li>内核 Documentation/devicetree/bindings/clock/samsung,s3c2410-clock.txt</li></ol><h4 id="Clock-providers节点"><a href="#Clock-providers节点" class="headerlink" title="Clock providers节点"></a>Clock providers节点</h4><ul><li>这种节点属于内核中时钟树的提供者，用于提供时钟给别的模块</li><li><code>#clock-cells</code>属性：指定引用该节点的子节点中时钟的参数结构是由几个u32位数据描述的</li><li></li></ul><h4 id="Clock-consumers节点"><a href="#Clock-consumers节点" class="headerlink" title="Clock consumers节点"></a>Clock consumers节点</h4><ul><li><p><code>clocks</code>属性：通过该属性指定具体的Clock providers节点和需要用到的时钟信号，其具体格式为：</p><p>  &lt;Clock providers节点id&gt; &lt;相关时钟参数&gt;</p><p>  其中：</p><ul><li><p>&lt;Clock providers节点id&gt;：具体的Clock providers节点，通过lable或phandle属性引用均可</p></li><li><p>&lt;相关时钟参数&gt;：相关的中断描述，取决于Clock providers节点中的<code>#clock-cells</code>属性</p></li></ul></li></ul><h4 id="以前时钟驱动写法"><a href="#以前时钟驱动写法" class="headerlink" title="以前时钟驱动写法"></a>以前时钟驱动写法</h4><ol><li>clk=clk_get(NULL,”时钟名”)：通过时钟名字获得相应时钟</li><li>clk_prepare_enable(clk)：使能相关时钟</li></ol><h4 id="用上设备树后"><a href="#用上设备树后" class="headerlink" title="用上设备树后"></a>用上设备树后</h4><ol><li>of_count_phandle_with_args函数获取设备树中时钟的个数</li><li>of_clk_get函数获取具体的时钟</li><li>clk_prepare_enable使能时钟</li><li>clk_disable_unprepare禁止时钟</li></ol><p>eg:</p><pre><code class="c">// 确定时钟个数int nr_pclks = of_count_phandle_with_args(dev-&gt;of_node, &quot;clocks&quot;,                                          &quot;#clock-cells&quot;);// 获得时钟for (i = 0; i &lt; nr_pclks; i++) {    struct clk *clk = of_clk_get(dev-&gt;of_node, i);}// 使能时钟clk_prepare_enable(clk);// 禁止时钟clk_disable_unprepare(clk);</code></pre><h3 id="3-在设备树中pinctrl的简单使用"><a href="#3-在设备树中pinctrl的简单使用" class="headerlink" title="3. 在设备树中pinctrl的简单使用"></a>3. 在设备树中pinctrl的简单使用</h3><p>参考文档：内核 Documentation/devicetree/bindings/pinctrl/samsung-pinctrl.txt</p><p><code>Bank</code>：以引脚名为依据, 这些引脚分为若干组, 每组称为一个Bank。比如s3c2440里有GPA、GPB、GPC等Bank，每个Bank中有若干个引脚, 比如GPA0,GPA1, …, GPC0, GPC1,…等引脚</p><p><code>Group</code>：以功能为依据, 具有相同功能的引脚称为一个Group。比如s3c2440中串口0的TxD、RxD引脚使用 GPH2,GPH3, 那这2个引脚可以列为一组。比如s3c2440中串口0的流量控制引脚使用 GPH0,GPH1, 那这2个引脚也可以列为一组</p><p><code>State</code>：设备的某种状态, 比如内核自己定义的”default”,”init”,”idel”,”sleep”状态。也可以是其他自己定义的状态, 比如串口的”flow_ctrl”状态(使用流量控制)</p><h4 id="pinctrl节点"><a href="#pinctrl节点" class="headerlink" title="pinctrl节点"></a>pinctrl节点</h4><ul><li><p>节点中会定义各种pin bank节点，比如s3c2440有GPA,GPB,GPC,…,GPB各种BANK, 每个BANK中有若干引脚</p><ul><li><p>bank节点</p><ul><li><p><code>gpio-controller</code>属性：表明是gpio的控制器</p></li><li><p><code>#gpio-cells</code>属性：以后想使用bank中的引脚时, 需要用该属性来表明用多少个u32数据指定引脚</p></li><li><p>eg：</p><pre><code>  pinctrl_0: pinctrl@56000000 {      reg = &lt;0x56000000 0x1000&gt;;      gpa: gpa {          gpio-controller;          #gpio-cells = &lt;2&gt;;  /* 以后想使用gpa bank中的引脚时, 需要2个u32来指定引脚 */      };  };</code></pre></li></ul></li></ul></li><li><p>pinctrl节点中也会有各种group(组合)子节点</p><ul><li><p>group节点（这里以samsung为例，具体属性由每家平台的驱动决定）</p><ul><li><p>属性依平台不一致而有所变化</p></li><li><p><code>samsung,pins</code>属性：该组内要使用到的gpio</p></li><li><p><code>samsung,pin-function</code>属性：在对应的gpio控制寄存器中，每个组中引脚对应的复用功能。</p></li><li><p><code>samsung,pin-val</code>属性：初始电平</p></li><li><p>eg：</p><pre><code>  uart0_data: uart0-data {      samsung,pins = &quot;gph-0&quot;, &quot;gph-0&quot;;      samsung,pin-function = &lt;2&gt;;   /* 在GPHCON寄存器中gph0,gph1可以设置以下值:                                      0 --- 输入功能                                      1 --- 输出功能                                      2 --- 串口功能                                      我们要使用串口功能,                                        samsung,pin-function 设置为2                                      */  };</code></pre></li></ul></li></ul></li><li><p>一般来说一个设备节点引用pin group时才有可能涉及到<code>State</code>：</p><ul><li><code>pinctrl-names</code>属性：定义各种<code>State</code>，可以多个一起使用</li></ul></li><li><p><code>pinctrl-x</code>属性：每个<code>State</code>都需要一个对应的<code>pinctrl-x</code>属性指定使用哪一个或多个group节点</p></li><li><p>设备树中若指定了pinctrl节点，在对应的probe函数被调用之前，内核会先”bind pins”, 即先绑定、设置引脚</p><ul><li><p>会优先设置”init”状态的引脚</p><ul><li>如果没有”init”状态, 则设置”default”状态的引脚</li></ul><p>eg：</p><pre><code>serial@50000000 {......  pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;  /* 既是名字, 也称为state(状态) */  pinctrl-0 = &lt;&amp;uart0_data&gt;;pinctrl-1 = &lt;&amp;uart0_sleep&gt;;};</code></pre></li><li><p>pinctrl-names中定义了2种state: default 和 sleep</p><ul><li>default 对应的引脚是: pinctrl-0, 它指定了使用哪些pin group: uart0_data</li><li>sleep   对应的引脚是: pinctrl-1, 它指定了使用哪些pin group: uart0_sleep</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设备树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSC插件之markdownlint规则详细介绍</title>
      <link href="/2019/09/17/markdownlint%E8%A7%84%E5%88%99%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/09/17/markdownlint%E8%A7%84%E5%88%99%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="VSC插件之markdownlint规则详细介绍"><a href="#VSC插件之markdownlint规则详细介绍" class="headerlink" title="VSC插件之markdownlint规则详细介绍"></a>VSC插件之markdownlint规则详细介绍</h1><p>本文主要参考markdownlint的<a href="https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md#md002---first-heading-should-be-a-top-level-heading" target="_blank" rel="noopener">rules文档</a>，对每一个规则都进行了说明，指明了一些规则中可以设置的参数，便于用户设置相应的规则。</p><h2 id="MD001-Heading-levels-should-only-increment-by-one-level-at-a-time"><a href="#MD001-Heading-levels-should-only-increment-by-one-level-at-a-time" class="headerlink" title="MD001 - Heading levels should only increment by one level at a time"></a>MD001 - Heading levels should only increment by one level at a time</h2><p>标题级数每次只能扩大1, 也就是不能隔级创建标题（从1级到6级的顺序）</p><h2 id="MD002-First-heading-should-be-a-top-level-heading"><a href="#MD002-First-heading-should-be-a-top-level-heading" class="headerlink" title="MD002 - First heading should be a top level heading"></a>MD002 - First heading should be a top level heading</h2><p>文档的第一个标题必须是最高级的标题（标题等级1级到6级逐渐降低）</p><p>参数：<br> “level”：指定最高级标题的级数，默认是1</p><h2 id="MD003-Heading-style"><a href="#MD003-Heading-style" class="headerlink" title="MD003 - Heading style"></a>MD003 - Heading style</h2><p>整篇文档要采用一致的标题格式</p><p>参数：<br> “style”：字符串，指定文档标题的格式，有(“consistent”, “atx”, “atx_closed”, “setext”,  “setext_with_atx”, “setext_with_atx_closed”)五种，默认是”consistent”，也就是整篇文档一致</p><p>标题格式必须统一，一般不能混用，但”setext_with_atx”, “setext_with_atx_closed”格式可以在”setext”格式二级标题后接着使用”atx”或”atx_closed”格式的标题</p><h2 id="MD004-Unordered-list-style"><a href="#MD004-Unordered-list-style" class="headerlink" title="MD004 - Unordered list style"></a>MD004 - Unordered list style</h2><p>整篇文档定义无序列表的格式要一致</p><p>参数：<br> “style”：字符串，指定无序列表的定义格式，有(“consistent”, “asterisk”, “plus”, “dash”,  “sublist”)五种，分别表示“定义时符号前后一致”，“用星号定义”，“用加号定义”，“用减号定义”，“定义多重列表时用不同的符号定义”，默认是”consistent”</p><h2 id="MD005-Inconsistent-indentation-for-list-items-at-the-same-level"><a href="#MD005-Inconsistent-indentation-for-list-items-at-the-same-level" class="headerlink" title="MD005 - Inconsistent indentation for list items at the same level"></a>MD005 - Inconsistent indentation for list items at the same level</h2><p>同一级的列表缩进必须一致<br> 在有序列表中，前面的数字序号可以左对齐，也可以右对齐</p><h2 id="MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line"><a href="#MD006-Consider-starting-bulleted-lists-at-the-beginning-of-the-line" class="headerlink" title="MD006 - Consider starting bulleted lists at the beginning of the line"></a>MD006 - Consider starting bulleted lists at the beginning of the line</h2><p>1级列表不能缩进</p><h2 id="MD007-Unordered-list-indentation"><a href="#MD007-Unordered-list-indentation" class="headerlink" title="MD007 - Unordered list indentation"></a>MD007 - Unordered list indentation</h2><p>无序列表嵌套缩进时默认采用两个空格</p><p>参数：<br> “ident”：指定无序列表嵌套时缩进的空格数，默认是2</p><h2 id="MD009-Trailing-spaces"><a href="#MD009-Trailing-spaces" class="headerlink" title="MD009 - Trailing spaces"></a>MD009 - Trailing spaces</h2><p>行尾最多可以添加两个空格，超过会给出警告，两个空格正好可以用于换行</p><p>参数：<br> “br_spaces”：指定在行尾可以添加的空格数目，空格数目建议大于等于2，如果小于2，会默认为0，也就是不允许任何行尾的空格<br> “list_item_empty_lines”：字符串，指定在列表中是否(true or false)用默认的空格数缩进空行，有的解释器会要求列表中的空行要缩进</p><h2 id="MD010-Hard-tabs"><a href="#MD010-Hard-tabs" class="headerlink" title="MD010 - Hard tabs"></a>MD010 - Hard tabs</h2><p>不能使用tab键缩进，要使用空格</p><p>参数：<br> “code_blocks”：指定本条规则在代码块里是否(true or false)生效</p><h2 id="MD011-Reversed-link-syntax"><a href="#MD011-Reversed-link-syntax" class="headerlink" title="MD011 - Reversed link syntax"></a>MD011 - Reversed link syntax</h2><p>检查内联形式的链接的创建方式是否错误，中括号和圆括号是否用对</p><h2 id="MD012-Multiple-consecutive-blank-lines"><a href="#MD012-Multiple-consecutive-blank-lines" class="headerlink" title="MD012 - Multiple consecutive blank lines"></a>MD012 - Multiple consecutive blank lines</h2><p>文档中不能有连续的空行，在代码块中此规则不会生效</p><p>参数：<br> “maximum”：指定文档中可以连续的最多空行数，默认值是1</p><h2 id="MD013-Line-length"><a href="#MD013-Line-length" class="headerlink" title="MD013 - Line length"></a>MD013 - Line length</h2><p>默认行的最大长度是80，此规则对代码块、表格、标题也生效</p><p>参数：<br> “line_length”：指定行的最大长度，默认是80<br> “heading_line_length”：指定标题行的最大长度，默认是80<br> “code_blocks”：指定规则是否(true or false)对代码块生效，默认true<br> “tables”：指定规则是否(true or false)对表格生效，默认true<br> “hesdings”：指定规则是否(true or false)对标题生效，默认true</p><h2 id="MD014-Dollar-signs-used-before-commands-without-showing-output"><a href="#MD014-Dollar-signs-used-before-commands-without-showing-output" class="headerlink" title="MD014 - Dollar signs used before commands without showing output"></a>MD014 - Dollar signs used before commands without showing output</h2><p>在代码块中，终端命令前不需要有美元符号($)<br> 如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)，如：</p><pre><code class="ruby">$ lsfoo bar$ cat foohello world</code></pre><h2 id="MD018-No-space-after-hash-on-atx-style-heading"><a href="#MD018-No-space-after-hash-on-atx-style-heading" class="headerlink" title="MD018 - No space after hash on atx style heading"></a>MD018 - No space after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间需用一个空格隔开</p><h2 id="MD019-Multiple-spaces-after-hash-on-atx-style-heading"><a href="#MD019-Multiple-spaces-after-hash-on-atx-style-heading" class="headerlink" title="MD019 - Multiple spaces after hash on atx style heading"></a>MD019 - Multiple spaces after hash on atx style heading</h2><p>在”atx”格式的标题中，#号和文字间只能用一个空格隔开，不能有多余的空格</p><h2 id="MD020-No-space-inside-hashes-on-closed-atx-style-heading"><a href="#MD020-No-space-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD020 - No space inside hashes on closed atx style heading"></a>MD020 - No space inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间需用一个空格隔开</p><h2 id="MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading"><a href="#MD021-Multiple-spaces-inside-hashes-on-closed-atx-style-heading" class="headerlink" title="MD021 - Multiple spaces inside hashes on closed atx style heading"></a>MD021 - Multiple spaces inside hashes on closed atx style heading</h2><p>在”closed_atx”格式的标题中，文字和前后的#号之间只能用一个空格隔开，不能有多余的空格</p><h2 id="MD022-Headings-should-be-surrounded-by-blank-lines"><a href="#MD022-Headings-should-be-surrounded-by-blank-lines" class="headerlink" title="MD022 - Headings should be surrounded by blank lines"></a>MD022 - Headings should be surrounded by blank lines</h2><p>标题行的上下行必须都是空行</p><p>参数：<br> “lines_above”：指定标题行上方的空行数，默认为1，可以设为更大或0<br> “lines_below”：指定标题行下方的空行数，默认为1，可以设为更大或0</p><p>注意当此处的空行设为比1大的数时，规则MD012的设置也要改</p><h2 id="MD023-Headings-must-start-at-the-beginning-of-the-line"><a href="#MD023-Headings-must-start-at-the-beginning-of-the-line" class="headerlink" title="MD023 - Headings must start at the beginning of the line"></a>MD023 - Headings must start at the beginning of the line</h2><p>标题行不能缩进</p><h2 id="MD024-Multiple-headings-with-the-same-content"><a href="#MD024-Multiple-headings-with-the-same-content" class="headerlink" title="MD024 - Multiple headings with the same content"></a>MD024 - Multiple headings with the same content</h2><p>文档不能有内容重复的标题</p><p>参数：<br> “siblings_only”：默认为false，设为true时，不同标题下的子标题内容可以重复</p><h2 id="MD025-Multiple-top-level-headings-in-the-same-document"><a href="#MD025-Multiple-top-level-headings-in-the-same-document" class="headerlink" title="MD025 - Multiple top level headings in the same document"></a>MD025 - Multiple top level headings in the same document</h2><p>同一文档只能有一个最高级的标题，默认是只能有一个1级标题</p><p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front  matter中的标题，这个标题将作为整篇文档的最高级标题，如果文档中再次出现最高级标题，将会给出警告，另外，如果不想在front  matter中指定标题，就把本参数的值设置为””</p><h2 id="MD026-Trailing-punctuation-in-heading"><a href="#MD026-Trailing-punctuation-in-heading" class="headerlink" title="MD026 - Trailing punctuation in heading"></a>MD026 - Trailing punctuation in heading</h2><p>标题行末尾不能有以下标点符号：”.,;:!?”</p><p>参数：<br> “punctuation”：字符串，指定标题行尾不能有的标点符号，默认是”.,;:!?”</p><p>此规则默认的是英文的标点符号，中文标点符号不在规则之内</p><h2 id="MD027-Multiple-spaces-after-blockquote-symbol"><a href="#MD027-Multiple-spaces-after-blockquote-symbol" class="headerlink" title="MD027 - Multiple spaces after blockquote symbol"></a>MD027 - Multiple spaces after blockquote symbol</h2><p>创建引用区块时，右尖括号 ( &gt; ) 和文字之间有且只能有一个空格</p><h2 id="MD028-Blank-line-inside-blockquote"><a href="#MD028-Blank-line-inside-blockquote" class="headerlink" title="MD028 - Blank line inside blockquote"></a>MD028 - Blank line inside blockquote</h2><p>两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用&gt;开头</p><h2 id="MD029-Ordered-list-item-prefix"><a href="#MD029-Ordered-list-item-prefix" class="headerlink" title="MD029 - Ordered list item prefix"></a>MD029 - Ordered list item prefix</h2><p>有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字(“one_or_ordered”)</p><p>参数：<br> “style”：字符串，指定前缀序号的格式，(“one”,”ordered”,”one_or_ordered”,”zero”)，分别表示只用1做前缀，用从1开始的加1递增数字做前缀，只用1或者从1开始的加1递增数字做前缀，只用0做前缀，默认值是”one_or_ordered”</p><p>本条规则支持在前缀序号中补0，以实现对齐，如：</p><pre><code class="undefined">...08.  one09.  two10.  three...</code></pre><h2 id="MD030-Spaces-after-list-markers"><a href="#MD030-Spaces-after-list-markers" class="headerlink" title="MD030 - Spaces after list markers"></a>MD030 - Spaces after list markers</h2><p>列表（有序、无序）的前缀符号和文字之间用1个空格隔开<br> 在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格</p><p>参数：<br> “ul_single”,”ol_single”,”ul_multi”,”ol_multi”：分别规定无序列表单个段落，有序列表单个段落，无序列表多个段落，有序列表多个段落的前缀符号和文字之间的空格数，默认是1</p><h2 id="MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines"><a href="#MD031-Fenced-code-blocks-should-be-surrounded-by-blank-lines" class="headerlink" title="MD031 - Fenced code blocks should be surrounded by blank lines"></a>MD031 - Fenced code blocks should be surrounded by blank lines</h2><p>单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块</p><h2 id="MD032-Lists-should-be-surrounded-by-blank-lines"><a href="#MD032-Lists-should-be-surrounded-by-blank-lines" class="headerlink" title="MD032 - Lists should be surrounded by blank lines"></a>MD032 - Lists should be surrounded by blank lines</h2><p>列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表<br> 列表的缩进必须一致，否则会警告</p><h2 id="MD033-Inline-HTML"><a href="#MD033-Inline-HTML" class="headerlink" title="MD033 - Inline HTML"></a>MD033 - Inline HTML</h2><p>文档中不允许使用HTML语句</p><p>参数：<br> “allowed_elements”：自定义允许的元素，是一个字符串数组，默认是空(empty)</p><h2 id="MD034-Bare-URL-used"><a href="#MD034-Bare-URL-used" class="headerlink" title="MD034 - Bare URL used"></a>MD034 - Bare URL used</h2><p>单纯的链接地址需要用尖括号 (&lt;&gt;) 包裹，否则有些解释器不会解释为链接</p><h2 id="MD035-Horizontal-rule-style"><a href="#MD035-Horizontal-rule-style" class="headerlink" title="MD035 - Horizontal rule style"></a>MD035 - Horizontal rule style</h2><p>创建水平线时整篇文档要统一(consistent)，要和文档中第一次创建水平线使用的符号一致</p><p>参数：<br> “style”：字符串，指定创建水平线的方式，值有：(“consistent”,”***”,”—“,”___”)，默认是”consistent”</p><h2 id="MD036-Emphasis-used-instead-of-a-heading"><a href="#MD036-Emphasis-used-instead-of-a-heading" class="headerlink" title="MD036 - Emphasis used instead of a heading"></a>MD036 - Emphasis used instead of a heading</h2><p>不能用强调代替标题</p><p>参数：<br> “punctuation”：字符串，指定用于结尾的标点符号，以此符号结尾的强调不会被视为以强调代替标题，默认值是”.,;:!?”</p><p>此规则会检查只包含强调的单行段落，如果这种段落不是以指定的标点符号结尾，则会被视为以强调代替标题，会给出警告</p><h2 id="MD037-Spaces-inside-emphasis-markers"><a href="#MD037-Spaces-inside-emphasis-markers" class="headerlink" title="MD037 - Spaces inside emphasis markers"></a>MD037 - Spaces inside emphasis markers</h2><p>用于创建强调的符号和强调的的文字之间不能有空格</p><h2 id="MD038-Spaces-inside-code-span-elements"><a href="#MD038-Spaces-inside-code-span-elements" class="headerlink" title="MD038 - Spaces inside code span elements"></a>MD038 - Spaces inside code span elements</h2><p>当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格<br> 如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开</p><h2 id="MD039-Spaces-inside-link-text"><a href="#MD039-Spaces-inside-link-text" class="headerlink" title="MD039 - Spaces inside link text"></a>MD039 - Spaces inside link text</h2><p>链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格，如：</p><pre><code class="csharp">[百 度](http://www.baidu.com &quot;百 度&quot;)</code></pre><h2 id="MD040-Fenced-code-blocks-should-have-a-language-specified"><a href="#MD040-Fenced-code-blocks-should-have-a-language-specified" class="headerlink" title="MD040 - Fenced code blocks should have a language specified"></a>MD040 - Fenced code blocks should have a language specified</h2><p>单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮</p><h2 id="MD041-First-line-in-file-should-be-a-top-level-heading"><a href="#MD041-First-line-in-file-should-be-a-top-level-heading" class="headerlink" title="MD041 - First line in file should be a top level heading"></a>MD041 - First line in file should be a top level heading</h2><p>文档的第一个非空行应该是文档最高级的标题，默认是1级标题</p><p>参数：<br> “level”：指定文档最高级的标题，默认是1<br> “front_matter_title”：字符串，指定在文档开头处的front matter中的标题，这个标题将作为整篇文档的最高级标题，另外，如果不想在front matter中指定标题，就把本参数的值设置为””</p><h2 id="MD042-No-empty-links"><a href="#MD042-No-empty-links" class="headerlink" title="MD042 - No empty links"></a>MD042 - No empty links</h2><p>链接的地址不能为空</p><h2 id="MD043-Required-heading-structure"><a href="#MD043-Required-heading-structure" class="headerlink" title="MD043 - Required heading structure"></a>MD043 - Required heading structure</h2><p>要求标题遵循一定的结构，默认是没有规定的结构(“null”)</p><p>参数：<br> “headings”：字符串数组，指定标题需要遵循的结构，默认是”null”，可以自行指定结构，如；</p><pre><code class="json">[    &quot;# head&quot;,    &quot;## item&quot;,    &quot;### detail&quot;,    &quot;*&quot;]</code></pre><p>星号(*)表示对应的标题是可选的，没有强制要求，本条具体可以参照<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDavidAnson%2Fmarkdownlint%2Fblob%2Fmaster%2Fdoc%2FRules.md%23md043---required-heading-structure" target="_blank" rel="noopener">MD043</a></p><h2 id="MD044-Proper-names-should-have-the-correct-capitalization"><a href="#MD044-Proper-names-should-have-the-correct-capitalization" class="headerlink" title="MD044 - Proper names should have the correct capitalization"></a>MD044 - Proper names should have the correct capitalization</h2><p>指定一些名称，会检查它是否有正确的大写</p><p>参数：<br> “names”：字符串数组，指定要检查需要大写的名称，默认是空(“null”)<br> “code_blocks”：指定本规则是否(true or false)对代码块生效，默认是true<br> 一些经常使用的名称可以使用本规则防止其拼写错误，比如JavaScript中字母J和S需要大写，就可以写到参数”names”中，防止写错</p><h2 id="MD045-Images-should-have-alternate-text-alt-text"><a href="#MD045-Images-should-have-alternate-text-alt-text" class="headerlink" title="MD045 - Images should have alternate text (alt text)"></a>MD045 - Images should have alternate text (alt text)</h2><p>图片链接必须包含描述文本（alt text）</p><h2 id="MD046-Code-block-style"><a href="#MD046-Code-block-style" class="headerlink" title="MD046 - Code block style"></a>MD046 - Code block style</h2><p>整篇文档采用一致的代码格式</p><p>参数：<br> “style”: 字符串，指定代码块定义格式，有（”consistent”,”fenced”,”indented”）三种，分别代表：文档上下文一致，使用三个反引号隔开，使用缩进，默认是上下文一致</p><h2 id="MD047-Files-should-end-with-a-single-newline-character"><a href="#MD047-Files-should-end-with-a-single-newline-character" class="headerlink" title="MD047 - Files should end with a single newline character"></a>MD047 - Files should end with a single newline character</h2><p>文档需用一个空行结尾</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdownlint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2019/09/17/git/"/>
      <url>/2019/09/17/git/</url>
      
        <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h2 id="一、SVN与Git的最主要的区别"><a href="#一、SVN与Git的最主要的区别" class="headerlink" title="一、SVN与Git的最主要的区别"></a>一、SVN与Git的最主要的区别</h2><p>　　说起git自然想到SVN，我刚接触到的版本控制工具是SVN，SVN是集中式版本控制系统，版本库是集中放在中央服务器的，干活的时候，先要从中央服务器哪里得到最新的版本，干完活后，需要把自己做完的活推送到中央服务器。中央服务器就好比是一个图库，你要改一本书，必须先从图库借出来，然后回到家自己改，改完了，再放回图库。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就耽误事了。<br>　　Git是分布式版本控制系统，它没有中央服务器的，每个人的电脑就是一个完整的版本库，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br>　　和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。<br>Git基本常用命令如下：</p><h2 id="二、常用的git命令"><a href="#二、常用的git命令" class="headerlink" title="二、常用的git命令"></a>二、常用的git命令</h2><h3 id="–文件目录操作命令"><a href="#–文件目录操作命令" class="headerlink" title="–文件目录操作命令"></a>–文件目录操作命令</h3><pre><code class="bash">mkdir *   创建一个空目录 *指目录名pwd       显示当前目录的路径。cat *     查看*文件内容git rm *  删除**文件</code></pre><h3 id="–git初始化操作"><a href="#–git初始化操作" class="headerlink" title="–git初始化操作"></a>–git初始化操作</h3><pre><code class="bash">git init                   把当前的目录变成git仓库，生成隐藏.git文件。git remote add origin url  设定远程GitHub仓库的地址git remote set-url origin url  重设远程GitHub仓库origin的地址git remote remove origin   删除远程GitHub仓库origingit clone git@url/test.git 从远程库克隆git add *                  把x文件添加到暂存区去。git commit –m &quot;*&quot;          提交文件 –m 后面的是注释。  </code></pre><h3 id="–git-克隆分支"><a href="#–git-克隆分支" class="headerlink" title="–git 克隆分支"></a>–git 克隆分支</h3><pre><code class="bash">git clone xxx.git                最简单直接的命令git clone xxx.git &quot;指定目录&quot;      clone到指定目录git clone -b branchname xxx.git  clone时创建新的分支替代默认Origin HEAD（master）</code></pre><h3 id="–clone-远程分支"><a href="#–clone-远程分支" class="headerlink" title="–clone 远程分支"></a>–clone 远程分支</h3><p>　　git clone 命令默认的只会建立<strong>master分支</strong>，如果你想clone指定的某一远程分支(如：dev)的话，可以如下：</p><p>　　1. 查看所有分支(包括隐藏的)  git branch -a 显示所有分支  </p><pre><code class="bash">* master  remotes/origin/HEAD -&gt; origin/master  remotes/origin/dev  remotes/origin/master</code></pre><p>　　2. 在本地新建同名的(“dev”)分支，并切换到该分支</p><pre><code class="bash">git checkout -t origin/dev 该命令等同于：git checkout -b dev origin/dev</code></pre><h3 id="–查看命令"><a href="#–查看命令" class="headerlink" title="–查看命令"></a>–查看命令</h3><pre><code class="bash">git status        查看仓库状态git diff  *       查看X文件修改了那些内容  git log           查看历史记录git reflog        查看历史记录的版本号id（记录你的每一次命令,不论是否提交）git log --pretty=oneline 如果信息量太多可以进行比较好的列表显示  </code></pre><h3 id="–版本回退"><a href="#–版本回退" class="headerlink" title="–版本回退"></a>–版本回退</h3><pre><code class="bash">git reset --hard HEAD^       回退到上一个版本git reset --hard HEAD~第几个 如果想回退到第3个版本，使用git reset –hard HEAD~3git reset --hard 057d       回退到某一个具体的版本号</code></pre><h3 id="–撤销修改"><a href="#–撤销修改" class="headerlink" title="–撤销修改"></a>–撤销修改</h3><pre><code class="bash">git checkout file-name 恢复某个已修改的文件（撤销未提交的修改）：git revert HEAD        还原最近一次提交的修改：git revert commit-id   还原指定版本的修改</code></pre><h3 id="–分支管理"><a href="#–分支管理" class="headerlink" title="–分支管理"></a>–分支管理</h3><pre><code class="bash">git branch                   查看本地所有的分支git branch -a                查看远程所有的分支git branch name              创建分支git branch –d dev            删除dev分支git push origin --delete dev 删除远程的dev分支git branch -m dev develop    重命名分支git checkout –b dev          创建dev分支 并切换到dev分支上git merge dev                在当前分支上合并dev分支代git push origin zyf-dev      把当前新加的zyf-dev分支推送到远程库(远程仓库没有给分支则会新建立该分支)git push origin zyf-dev -f   强制push，这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。git checkout — *                     把XX文件在工作区的修改全部撤销。git checkout master                  切换回master分支git push --set-upstream origin dev   提交修改并创建远程分支dev</code></pre><h3 id="–tag相关操作"><a href="#–tag相关操作" class="headerlink" title="–tag相关操作"></a>–tag相关操作</h3><pre><code class="bash">git tag         列出所有的taggit tag name    打轻量标签 namegit tag -d name 删除本地的taggit push origin --delete tag name  删除远程的taggit show name        查看tag信息git push origin name 将tag提交到远程</code></pre><h3 id="–隐藏的文件"><a href="#–隐藏的文件" class="headerlink" title="–隐藏的文件"></a>–隐藏的文件</h3><pre><code class="bash">git stash       把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list  查看所有被隐藏的文件列表git stash apply 恢复被隐藏的文件，但是内容不删除git stash drop  删除文件git stash pop   恢复文件的同时 也删除文件</code></pre><h3 id="–查看远程库信息-git-remote的用法"><a href="#–查看远程库信息-git-remote的用法" class="headerlink" title="–查看远程库信息(git  remote的用法)"></a>–查看远程库信息(git  remote的用法)</h3><pre><code class="bash">git remote       查看远程库的信息git remote –v    查看远程库的详细信息git remote add  name url          添加远程仓库git remote rename oldname newname 重命名仓库git remote rm                     删除仓库</code></pre><h3 id="–将远程分支拉取到本地"><a href="#–将远程分支拉取到本地" class="headerlink" title="–将远程分支拉取到本地"></a>–将远程分支拉取到本地</h3><pre><code class="bash">1 方法一：git checkout -b 本地分支名x origin/远程分支名x2 方式二：git fetch origin 远程分支名x:本地分支名x</code></pre><h3 id="–git-pull操作"><a href="#–git-pull操作" class="headerlink" title="–git pull操作"></a>–git pull操作</h3><pre><code class="bash"># git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并，基本的格式如下。$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 取回origin主机的next分支，与本地的master分支合并，需要写成下面这样$ git pull origin next:master# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。$ git pull origin next# 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。$ git fetch origin$ git merge origin/next# 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。# Git也允许手动建立追踪关系。git branch --set-upstream master origin/next# 上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。$ git pull origin</code></pre><h3 id="–git-设置大小写敏感"><a href="#–git-设置大小写敏感" class="headerlink" title="–git 设置大小写敏感"></a>–git 设置大小写敏感</h3><p>Windows上的Git默认是大小写不敏感的，这样多平台写作就可能会出现问题。Win上的Git设置为大小写敏感的命令如下</p><pre><code class="bash">git config core.ignorecase false  </code></pre><h3 id="–git-设置忽略文件或文件夹权限修改"><a href="#–git-设置忽略文件或文件夹权限修改" class="headerlink" title="–git 设置忽略文件或文件夹权限修改"></a>–git 设置忽略文件或文件夹权限修改</h3><pre><code class="bash">git config core.filemode false</code></pre><h3 id="–创建追踪分支"><a href="#–创建追踪分支" class="headerlink" title="–创建追踪分支"></a>–创建追踪分支</h3><p>不带任何参数的git  push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git  2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><pre><code class="bash">$ git config --global push.default matching# 或者$ git config --global push.default simple (最好使用这种方式)</code></pre><p>  $ git branch –track  master origin/master //在使用 git branch 命令时加上 ‘–track’ 参数, 来手动创建一个追踪分支</p><h3 id="–切换git-命令提示中文到英文"><a href="#–切换git-命令提示中文到英文" class="headerlink" title="–切换git 命令提示中文到英文"></a>–切换git 命令提示中文到英文</h3><pre><code class="bash">// ubuntu装的git不知道怎么就出现全中文的提示,不太好,果断切换到中文了,切换方法如下:// 1:写入echo &quot;alias git=&#39;LANG=en_GB git&#39;&quot; &gt;&gt; ~/.bashrc// 2:生效source ~/.bashrc</code></pre><h3 id="–git-删除未添加到版本中的文件或者文件夹"><a href="#–git-删除未添加到版本中的文件或者文件夹" class="headerlink" title="–git 删除未添加到版本中的文件或者文件夹"></a>–git 删除未添加到版本中的文件或者文件夹</h3><p>git checkout 只能回退在版本中的修改或者删除, 对于新添加的文件是没有作用的, 也就是说, 新建的文件或者文件夹是:Untracked files, 要删除或者清理掉这些文件,需要使用 git clean 命令:</p><pre><code class="bash">// 删除 untracked filesgit clean -f// 连 untracked 的目录也一起删掉git clean -fd// 连 gitignore的untrack 文件/目录也一起删掉 （一般这个是用来删掉编译出来的 .o一类的文件）git clean -xfd// 在使用清理 git clean之前，建议加上 -n 来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd</code></pre><h3 id="–流程"><a href="#–流程" class="headerlink" title="–流程"></a>–流程</h3><pre><code class="bash">#初始化git init                     把当前的目录变成git仓库，生成隐藏.git文件。git remote add origin url    设定远程GitHub仓库的地址git remote –v    查看远程库的详细信息#克隆远程库git branch -a                显示本地和远程的所有分支git checkout -b dev origin/dev 在本地新建同名的&quot;dev&quot;分支，并切换到该分支#若已经有本地分支 则拉取git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  取回远程主机某个分支的更新，再与本地的指定分支合并#上传git status                   获取当前状态git add *                    把x文件添加到暂存区去。git commit –m &quot;*&quot;            提交文件 –m 后面的是注释。注释不能是中文git push origin zyf-dev      把当前新加的zyf-dev分支推送到远程库origin(远程仓库没有给分支则会新建立该分支)git push origin zyf-dev -f   强制push 不推荐#一旦有任何问题，回退版本：git reset --hard HEAD^       回退到上一个版本#切换本地分支git checkout master          切换回master分支</code></pre><h2 id="三、常出错误"><a href="#三、常出错误" class="headerlink" title="三、常出错误"></a>三、常出错误</h2><h3 id="1：There-is-no-tracking-information-for-the-current-branch"><a href="#1：There-is-no-tracking-information-for-the-current-branch" class="headerlink" title="1：There is no tracking information for the current branch"></a>1：There is no tracking information for the current branch</h3><p>​    则说明本地分?支和远程分?支的链接关系没有创建，用命令：<br>​    git branch –set-upstream branch-name origin/branch-name。</p><h3 id="2-rejected-dev-gt-dev-non-fast-forward-…-Updates-were-rejected-because-the-tip-of-your-current-branch"><a href="#2-rejected-dev-gt-dev-non-fast-forward-…-Updates-were-rejected-because-the-tip-of-your-current-branch" class="headerlink" title="2: ![rejected] dev -&gt; dev (non-fast-forward)  … Updates were rejected because the tip of your current branch"></a>2: ![rejected] dev -&gt; dev (non-fast-forward)  … Updates were rejected because the tip of your current branch</h3><p>​    推送失败，因为远程代码的最新提交和你试图推送的提交有冲突，解决办法也很简单，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送</p><h3 id="3：CONFLICT-content-Merge-conflict-in"><a href="#3：CONFLICT-content-Merge-conflict-in" class="headerlink" title="3：CONFLICT (content): Merge conflict in"></a>3：CONFLICT (content): Merge conflict in</h3><p>​    这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突一样。解决后，提交，再push：</p><h3 id="4-You-are-not-currently-on-a-branch-so-I-cannot-use-any"><a href="#4-You-are-not-currently-on-a-branch-so-I-cannot-use-any" class="headerlink" title="4: You are not currently on a branch, so I cannot use any"></a>4: You are not currently on a branch, so I cannot use any</h3><p>   解决办法：git checkout master</p><h3 id="5：Your-branch-is-behind-‘origin-master’-by-1-commit-and-can-be-fast-forwarded"><a href="#5：Your-branch-is-behind-‘origin-master’-by-1-commit-and-can-be-fast-forwarded" class="headerlink" title="5：Your branch is behind ‘origin/master’ by 1 commit, and can be fast-forwarded"></a>5：Your branch is behind ‘origin/master’ by 1 commit, and can be fast-forwarded</h3><p>6：在执行 git push 时可能会看到如下消息:</p><pre><code class="bash">warning: push.default is unset; its implicit value is changing inGit 2.0 from &#39;matching&#39; to &#39;simple&#39;. To squelch this messageand maintain the current behavior after the default changes, use:git config --global push.default matchingTo squelch this message and adopt the new behavior now, use:  git config --global push.default simpl</code></pre><p>解决办法：‘matching’  参数是 Git 1.x 的默认行为，如果你执行 git push 但没有指定分支，它将 push  所有你本地的分支到远程仓库中对应匹配的分支。而 Git 2.x 默认的是 simple，意味着执行 git push  没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。<br> 根据提示，修改git push:</p><pre><code class="bash">git config --global push.default matching</code></pre><p> 再次执行git push 就行了。</p><h3 id="7：You-asked-to-pull-from-the-remote-‘origin’-but-did-not-specify-a-branch-Because-this-is-not-the-default-configured-remote-for-your-current-branch-you-must-specify-a-branch-on-the-command-line"><a href="#7：You-asked-to-pull-from-the-remote-‘origin’-but-did-not-specify-a-branch-Because-this-is-not-the-default-configured-remote-for-your-current-branch-you-must-specify-a-branch-on-the-command-line" class="headerlink" title="7：You asked to pull from the remote ‘origin’, but did not specify: a branch. Because this is not the default configured remote for your current branch, you must specify a branch on the command line"></a>7：You asked to pull from the remote ‘origin’, but did not specify: a branch. Because this is not the default configured remote for your current branch, you must specify a branch on the command line</h3><p>解决办法：找到：<code>.git/config  修改如下</code></p><pre><code class="bash">[branch &quot;master&quot;]  remote = origin  merge = refs/heads/master</code></pre><h3 id="8：ERROR-Permission-to-user1-test-git-denied-to-user2-fatal-The-remote-end-hung-up-unexpectedly"><a href="#8：ERROR-Permission-to-user1-test-git-denied-to-user2-fatal-The-remote-end-hung-up-unexpectedly" class="headerlink" title="8：ERROR: Permission to user1/test.git denied to user2   fatal: The remote end hung up unexpectedly"></a>8：ERROR: Permission to user1/test.git denied to user2   fatal: The remote end hung up unexpectedly</h3><p>　账户冲突，下面有针对讲解</p><h3 id="9-添加的ssh不起作用"><a href="#9-添加的ssh不起作用" class="headerlink" title="9: 添加的ssh不起作用"></a>9: 添加的ssh不起作用</h3><p>   ssh 的添加一定要在root用户权限在添加，其他的权限不起作用，切记！</p><h2 id="四、经验之谈"><a href="#四、经验之谈" class="headerlink" title="四、经验之谈"></a>四、经验之谈</h2><h3 id="1：git-revert-和-git-reset的区别"><a href="#1：git-revert-和-git-reset的区别" class="headerlink" title="1：git revert 和 git reset的区别"></a>1：git revert 和 git reset的区别</h3><p>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，<br>只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p><p>　　这样在版本回退的时候就比较的好，比如本地dev分支，远程master分支，某一次的上线发现线上有重大的bug，然后你reset本地代码到前一个版本，在你git  push 的时候git会报一个错误：“说你的本地分支版本低于远程master分支的版本，让你先去pull  下来代码，再提交”，这就不行了，你pull下来的代码还是最新版有bug的代码，不进行pull代码，master分支又不让你提交。解决这个问题还得使用  revert 来进行  “回退”操作，为什么加引号呢，是因为这种回退是向前提交一次中和了上次的修改，这就比较好了，这样你revert之后相当于指针向前移动一次，本地版本dev高于远程master版本，这时你就可以git  push 本地代码到远程了。也就是说，git reset 对未提交到（git  push）远程的修改做回滚比较好，如果要回滚本地，同时想远程也回滚，就要用到revert</p><h2 id="五、常用修改"><a href="#五、常用修改" class="headerlink" title="五、常用修改"></a>五、常用修改</h2><h3 id="1：避免每次提交都输入用户名和密码"><a href="#1：避免每次提交都输入用户名和密码" class="headerlink" title="1：避免每次提交都输入用户名和密码"></a>1：避免每次提交都输入用户名和密码</h3><p>​    原因是使用了https方式 puh 在termail里边 输入  <code>git remote -v</code> 可以看到形如一下的返回结果</p><pre><code class="bash">origin https://github.com/git/librarysystem.git(fetch)origin https://github.com/git/librarysystem.git(push)</code></pre><p>​    下面把它换成ssh方式的。</p><pre><code class="bash">git remote rm origingit remote add origin git@github.com:yu/demo.gitgit push origin</code></pre><h3 id="2：添加忽略文件-gitignore"><a href="#2：添加忽略文件-gitignore" class="headerlink" title="2：添加忽略文件 .gitignore"></a>2：添加忽略文件 .gitignore</h3><p>​    .gitignore配置文件用于配置不需要加入版本管理的文件。<br>​    配置语法： “/“  开头表示目录；  “*”  通配多个字符；  “?”  通配单个字符   “[]” 包含单个字符的匹配列表；  “!”  表示不忽略(跟踪)匹配到的文件或目录；<br>​    说明：git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；<br>​    示例：（1） foder/*     忽略目录foder下的全部内容,不管是根目录下的 /foder/ 目录，还是某个子目录 /list/foder/ 目录，都会被忽略。<br>​    　　   （2） /foder/*   说明：忽略根目录下的 /foder/ 目录的全部内容；<br>​    　　   （3） /*!.gitignore<br>​                          !/fw/bin/<br>​                          !/fw/sf/<br>​                          说明：忽略全部内容，但是不忽略 .gitignore文件,根目录下的 /fw/bin/ 和 /fw/sf/<br>​    注意问题： .gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把要忽略的文件纳入了版本库，就不起作用了。</p><h3 id="3：如何在同一台电脑上使用两个git账户"><a href="#3：如何在同一台电脑上使用两个git账户" class="headerlink" title="3：如何在同一台电脑上使用两个git账户"></a>3：如何在同一台电脑上使用两个git账户</h3><p>　　问题描述：作为程序员有时候是有多个的项目，而且每个项目git的用户名，邮箱等，都不一样。就我来说，我在github上有一个账号，自己开发一些东西，同时我参与的也有项目需要连接别人的github账号，在我电脑上只有一个git客户端，本地一个身份用户，开始的时候我自己开发是用ssh方式，参与的项目的是用https连接，但是https每次都需要输入密码，非常不方便，所以想转成ssh连接，利用命令：</p><pre><code class="bash">git remote rm origingit remote add origin git@github.com:yu/demo.gitgit push origin</code></pre><p>转换成功，不幸的是push的时候出错了：ERROR: Permission to user1 denied to<br>这种情况的解决方式是方法，使用本地托管多个个ssh的密钥，不同的账号是用不同的密匙。</p><h4 id="第一步：生成SSH-Key"><a href="#第一步：生成SSH-Key" class="headerlink" title="第一步：生成SSH Key"></a>第一步：生成SSH Key</h4><p>具体说明：</p><pre><code class="bash">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;  Creates a new ssh key using the provided email Generating public/private rsa key pair.  #输入将要保存的路径，我的默认为当前路径（/c/Users/zhaoyafei/.ssh/id_rsa）,但是不能使用默认文件id_rsa，要添加新账户就要生起一个成新的好记的名字，例如id_rsa_work  Enter file in which to save the key (/c/Users/zhaoyafei/.ssh/id_rsa):  #输入回车后提示输入一个类似于密码的号，直接回车就行  Enter passphrase (empty for no passphrase):  Enter same passphrase again:</code></pre><h4 id="第二步：识别新的私钥"><a href="#第二步：识别新的私钥" class="headerlink" title="第二步：识别新的私钥"></a>第二步：识别新的私钥</h4><p>​    默认SSH只会读取id_rsa，所以为了让SSH识别新的私钥，需要将其添加到SSH agent　　</p><pre><code class="bash">1 ssh-add ～/.ssh/id_rsa_work2  //该命令如果报错：Could not open a connection to your authentication agent.可执行 ssh-agent bash 命令后再执行ssh-add -l 看是否成功。</code></pre><h4 id="第三步：修改config文件"><a href="#第三步：修改config文件" class="headerlink" title="第三步：修改config文件"></a>第三步：修改config文件</h4><p>​    该文件用于配置私钥对应的服务器。内容如下:</p><pre><code class="bash"># Default github （默认的）      Host github.com      HostName github.com      User git      IdentityFile ~/.ssh/id_rsa# second user(work@gmail.com)      Host github_work      HostName github.com      User git      IdentityFile ~/.ssh/id_rsa_work</code></pre><p>这样配置，也就是使用hostname为github.com会根据用户名的不同，去使用不用的private   key。github上，也可以添加对应的公钥。其实这个配置是关于ssh的与git无关，只是git使用的方式是ssh的方式。Host可随意，方便自己记忆，后续在添加remote是还需要用到。</p><h4 id="第四步：将SSH-key输入到GitHub网站中"><a href="#第四步：将SSH-key输入到GitHub网站中" class="headerlink" title="第四步：将SSH key输入到GitHub网站中"></a>第四步：将SSH key输入到GitHub网站中</h4><p>​      将生成的id_rsa_work.pub输入到GitHub网站中就可以了，输入完成后单击Add  key后，会看到git-tutorial已经被添加进去了。  配置完成后，在连接非默认帐号的github仓库时，远程库的地址要对应地做一些修改，比如现在添加abc帐号下的一个仓库test，则需要这样添加：git remote add test git@github-work:abc/test.git #并非原来的<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:abc/test.git 这样每次连接都会使用id_rsa_abc与服务器进行连接。</p><p>　　<strong>注意：</strong>github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(<a href="mailto:work@mail.com" target="_blank" rel="noopener">work@mail.com</a>)。我遇到的问题是本地单一用户，链接不同的github账号，所以用户配置可以采用全局配置。如果不同本地用户（不同的身份标识，即需要本地使用不同的用户名），那么git就不要使用有–global的配置，可以按照下面的方法：</p><pre><code class="bash"># 1)设置局部的user.name和user.emailgit config user.name &quot;xxxxxx&quot;git config user.email &quot;xxx@xxx.com&quot;# 2)设置全局的user.name和user.emailgit config --global user.name &quot;xxxxxx&quot;git config –-global user.email &quot;&quot;</code></pre><h2 id="六、题外话（相关概念）"><a href="#六、题外话（相关概念）" class="headerlink" title="六、题外话（相关概念）"></a>六、题外话（相关概念）</h2><h3 id="Git-版本控制工具"><a href="#Git-版本控制工具" class="headerlink" title="Git - 版本控制工具"></a>Git - 版本控制工具</h3><p>　　Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Torvalds  开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux  内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此  Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux  内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop  的项目也迁移到了 Git 上。</p><h3 id="Github-一个网站，提供给用户空间创建git仓储，保存用户的一些数据文档或者代码等"><a href="#Github-一个网站，提供给用户空间创建git仓储，保存用户的一些数据文档或者代码等" class="headerlink" title="Github - 一个网站，提供给用户空间创建git仓储，保存用户的一些数据文档或者代码等"></a>Github - 一个网站，提供给用户空间创建git仓储，保存用户的一些数据文档或者代码等</h3><p>　　作为开源代码库以及版本控制系统，Github目前拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。GitHub可以托管各种git库，并提供一个web界面，但与其它像  SourceForge或Google  Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按  钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull  request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。</p><h3 id="GitLab-基于Git的项目管理软件"><a href="#GitLab-基于Git的项目管理软件" class="headerlink" title="GitLab - 基于Git的项目管理软件"></a>GitLab - 基于Git的项目管理软件</h3><p>GitLab 是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。三者都是基于git的，可以说是git的衍生品。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex排版全解</title>
      <link href="/2019/08/19/Latex%E6%8E%92%E7%89%88%E5%85%A8%E8%A7%A3/"/>
      <url>/2019/08/19/Latex%E6%8E%92%E7%89%88%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Latex排版全解"><a href="#Latex排版全解" class="headerlink" title="Latex排版全解"></a>Latex排版全解</h1><p> LATEX（英语发音：/ˈleɪtɛk/ LAY-tek或英语发音：/ˈlɑːtɛk/ LAH-tek，音译“拉泰赫”），是一种基于TEX的排版系统，由美国电脑学家莱斯利•兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的邮件到完整书籍的所有其他种类的文档。</p><p>​      和Microsoft Office Word 等所见即所得的办公软件不同，用LATEX 排版文档，首先要用文本编辑器编辑好tex 文档，然后通过各种程序编译，得到pdf 文档用于打印或者阅读。基本的排版流程如下图：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261440574876739.png" alt="排版流程图"></p><p>​      一般我们经常用pdflatex 或者xelatex 程序直接从tex 文件生成pdf 文件。如果是中文tex 文档，优先使用xelatex 程序编译。</p><p>​      WinEdt是一款Microsoft Windows平台下的文本编辑器。它主要是用来创建TeX（或者LaTeX）文档，但是同时也能处理HTML或者其他文本文档。它被很多TeX系统如MiKTeX用来当作输入前端，且无缝整合。<br>本文利用WinEdt来实现对latex的学习与应用。</p><p>​    TeX被普遍认为是一个很好的排版工具，特别是在处理复杂的数学公式时。<strong>CTeX</strong>是利用TeX排版系统的CTeX中文套装的简称。它集成了编辑器 、WinEdt、PostScript处理软件、Ghostscript和GSview等主要工具。简言之，CTex就是一个电子排版系统。</p><h2 id="第一部分-软件安装"><a href="#第一部分-软件安装" class="headerlink" title="第一部分 软件安装"></a>第一部分 软件安装</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>下载地址：<a href="http://www.ctex.org/CTeXDownload。安装CTeX_2.9.2.164_Full.exe" target="_blank" rel="noopener">http://www.ctex.org/CTeXDownload。安装CTeX_2.9.2.164_Full.exe</a> (1.31G) 即可。</p><p>注：该软件有BUG，在windows上会有几率将系统环境变量Paht覆盖，记得提前备份。</p><blockquote><ol><li>在”计算机“上右键，找到”属性“，然后点击高级系统设置。</li><li>点击“环境变量”，找到“系统变量”中的path，将里面的值拷贝出来，随手新建记事本备份。</li></ol><p>若没有备份但是没有关机：</p><ol><li><p>按 win +R，进入C:\Windows\System32 ，输入regedt32.exe 以打开注册表。<br> 找到如下目录:<code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment</code></p></li><li><p>在注册表中右侧找到名为Path文件名的文件，选中Path文件，右键选择修改，在编辑字符串窗口中，复制【数值数据】，复制好后</p></li><li><p>回到桌面右键我的电脑，选择属性，进入控制面板中的高级系统设置，选择高级菜单中的【环境变量】，在环境变量中选择系统变量 Path ：将复制过来的数值数据粘贴进去 点确定</p></li></ol><p>倘若不幸关机重启了，以下是windows10的默认path变量：</p><pre><code>%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;</code></pre></blockquote><h3 id="WinEdt的一些TIPS"><a href="#WinEdt的一些TIPS" class="headerlink" title="WinEdt的一些TIPS"></a>WinEdt的一些TIPS</h3><ol><li>大小写敏感</li><li>设置编辑区代码行数：View-&gt;Line Numbers(或Ctrl+=);</li></ol><h2 id="第二部分-LaTex排版"><a href="#第二部分-LaTex排版" class="headerlink" title="第二部分 LaTex排版"></a>第二部分 LaTex排版</h2><h3 id="一、英文文档"><a href="#一、英文文档" class="headerlink" title="一、英文文档"></a>一、英文文档</h3><h4 id="1-最简单的LATEX-英文文档"><a href="#1-最简单的LATEX-英文文档" class="headerlink" title="1.最简单的LATEX 英文文档"></a>1.最简单的LATEX 英文文档</h4><pre><code class="latex">% hello.tex\documentclass[a4paper]{article}\usepackage{hyperref}\begin{document}Hello World!\end{document}</code></pre><p>①<code>%</code> 符号后面的内容都表示注释</p><p>②在LATEX 文档中，用\ 开始的字母串来表示一个命令。命令后面用花括号{} 包含的内容是该命令的参数，必不可少。</p><p>③这里的<code>\documentclass</code> 是LATEX 文档的基本命令，用于指明文档类。</p><blockquote><p><code>\documentclass[选项]{文档类}</code>：</p><p><strong>文档类</strong></p><p><strong><em>article</em></strong>    排版科技期刊、短报告、程序文档、邀请函等。<br><strong><em>report</em></strong>    排版多章节的长报告、短篇的书籍、博士论文等。<br><strong><em>book</em></strong>    排版书籍。<br><strong><em>slides</em></strong>    排版幻灯片。其中使用了较大的 sans serif 字体。也可以考虑使用 FoilTEX 来得到相同的效果。</p><p><strong>文档类的选项</strong></p><p><strong><em>纸张大小</em></strong>（a4paper，a5paper，b4paper，letterpaper，legalpaper，executivepaper）：<br>默认的letterpaper 纸张常见于美国，和国内常用的A4 纸张的大小稍有差别，建议自己指定。</p><p><strong><em>字体大小</em></strong>（10pt，11pt，12pt）：默认为10pt。</p><p><strong><em>纸张方向</em></strong>（portrait，landscape）：默认为portrait（纵向），在屏幕阅读也许landscape（横向）更方便。</p><p><strong><em>草稿定稿</em></strong>（draft，final）：默认为final（定稿）；如果是draft（草稿），页面内容有溢出时会显示粗黑条。</p><p><strong><em>单面双面</em></strong>（oneside，twoside）：对于article 和report 文档类，默认设置为单面，页码总是在右边；对于book 文档类，默认设置为双面，奇数页页码在右边，偶数页页码在左边，这样双面打印时页码总在外侧。</p><p><strong><em>新章开始</em></strong>（openright，openany）：仅对book 文档类有效，默认值为openright，即每章都从奇数页开始；如果设置为openany，则每章仅从新的一页开始，不管奇偶页。</p></blockquote><p>④<code>\usepackage</code> 命令也是LATEX 的基本命令，用于载入LATEX 宏包。LATEX 系统中包含了各种各样的宏包，对LATEX 的基本功能作了各种扩展。</p><p>⑤<code>\begin{document}</code> 和<code>\end{document}</code>之间的部分我们称为<strong>正文区</strong>，一般用于正文内容的撰写。这个例子的正文内容只有简单的Hello World!。对应的，在<code>\documentclass</code> 和<code>\begin{document}</code> 命令之间的部分我们称为<strong>导言区</strong>，一般用于载入宏包，定义命令和调整格式。</p><p>⑥LaTeX 的命令也有不同的类型，形如<code>\begin{环境名}...\end{环境名}</code>的命令组合我们称为<strong>环境</strong>。</p><p>LATEX 文档把格式和内容部分分开，是一种良好的设计准则。</p><h3 id="二-中文文档"><a href="#二-中文文档" class="headerlink" title="二.中文文档"></a>二.中文文档</h3><p>LaTeX 中文文档的排版有各种方式，例如CCT，CJK，xeCJK 等等。目前最优秀的方式是用CTex 文档类来排版中文文档，它在其它各种方式的基础上以一致的方式解决了中文排版的问题。例如：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}中文内容测试！\end{document}</code></pre><p>使用这种方式，只需要将文档类从英文的<code>article</code> 改成<code>ctexart</code>，所有中文环境和章节编号等等都已经按照中文习惯设置好了，简单易行。另外，对于<code>book</code> 和<code>report</code> 文档类，也有对应的<code>ctexbook</code> 和<code>ctexrep</code> 中文文档类，其用法类似。</p><p>例子中的UTF8 这个可选参数指明了中文文档的编码。编码主要有这两种：<code>GBK</code> 和<code>UTF8</code>，而不同的LaTeX 编辑器对中文文档的默认编码不同。WinEdt 编辑器的默认中文编码为GBK，而TeXworks 编辑器的默认中文编码为UTF8。</p><h3 id="三-主要编辑（使用图形加快编辑）"><a href="#三-主要编辑（使用图形加快编辑）" class="headerlink" title="三.主要编辑（使用图形加快编辑）"></a>三.主要编辑（使用图形加快编辑）</h3><h4 id="1-输入特殊字符"><a href="#1-输入特殊字符" class="headerlink" title="1.输入特殊字符"></a>1.输入特殊字符</h4><table><thead><tr><th align="center">输入</th><th align="center">#</th><th align="center">$</th><th align="center">%</th><th align="center">&amp;</th><th align="center">{</th><th align="center">}</th><th align="center">\ _</th><th align="center">^{}</th><th align="center">~{}</th><th align="center">\textless</th><th align="center">\textgreater</th><th align="center">\textbar</th><th align="center">\textbackslash</th></tr></thead><tbody><tr><td align="center">输出</td><td align="center">#</td><td align="center">$</td><td align="center">%</td><td align="center">&amp;</td><td align="center">{</td><td align="center">}</td><td align="center">_</td><td align="center">^</td><td align="center">~</td><td align="center">&lt;</td><td align="center">&gt;</td><td align="center">|</td><td align="center">\</td></tr></tbody></table><h4 id="2-段落换行"><a href="#2-段落换行" class="headerlink" title="2.段落换行"></a>2.段落换行</h4><p>用一个空行或者<code>\par</code> 命令可以开始新的段落，同时会有默认的首行缩进。用<code>\</code> 或者<code>\newline</code> 可以强制换行在下一行继续，且在下一行不会有缩进。</p><h4 id="3-列表环境"><a href="#3-列表环境" class="headerlink" title="3.列表环境"></a>3.列表环境</h4><p>列表环境有三种：无序列表（itemize）、有序列表（enumerate）和描述列表（description）。</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\begin{itemize}  \item javascript  \item html  \item css\end{itemize}\begin{enumerate}  \item javascript  \item html  \item css\end{enumerate}\begin{description}  \item[javascript] javascript  \item[html] html  \item[css] css\end{description}\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441226127315.png" alt="列表"></p><h4 id="4-标题摘要"><a href="#4-标题摘要" class="headerlink" title="4.标题摘要"></a>4.标题摘要</h4><p>用下面的代码可以加入文章的标题、作者、日期信息和内容摘要：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\title{Latex与Winedt}\author{jingwhale}\date{January 25, 2015}\maketitle\begin{abstract}LATEX（英语发音：/ˈleɪtɛk/ LAY-tek或英语发音：/ˈlɑːtɛk/ LAH-tek，音译“拉泰赫”），是一种基于TEX的排版系统，由美国电脑学家莱斯利•兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的邮件到完整书籍的所有其他种类的文档。\end{abstract}\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441260976147.png" alt="标题摘要"></p><p>如果<code>\date{}</code> 命令的参数为空，则不显示日期信息。如果不出现<code>\date</code> 命令，则默认显示当前的日期。</p><h4 id="5-章节目录"><a href="#5-章节目录" class="headerlink" title="5.章节目录"></a>5.章节目录</h4><p>在book 和report 文档类中，可以使用\part、\chapter、\section 、\subsection、\subsubsection、\paragraph、\subparagraph 这些章节命令，在article 文档类中，除了\chapter 不能用，其它的都可以用。</p><p>用\tableofcontents 命令可以自动从各章节标题生成目录。</p><p>在导言区中用下面的命令载入hyperref 宏包\usepackage{hyperref}就可以让生成的文章目录有链接，点击时会自动跳转到该章节。而且也会使得生成的pdf 文件带有目录书签。<br>例如下面的代码：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{hyperref}\begin{document}\tableofcontents\part{部分标题}%\chapter{章标题}这一章我们介绍这些内容。\section{节标题}这一节我们介绍这些内容。\subsection{小节标题}这一小节我们介绍这些内容。\subsubsection{子节标题}这一子节我们介绍这些内容。\paragraph{段标题}这一段我们介绍这些内容。\subparagraph{小段标题}这一小段我们介绍这些内容。\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441302691122.png" alt="章节目录"></p><p>要调整章节标题在目录页中的格式，可以用<code>titletoc</code> 宏包。该宏包的基本命令参数如下:</p><pre><code class="latex">\titlecontents{标题层次}[左间距]{整体格式}{标题序号}{标题内容}{指引线和页码}[下间距]</code></pre><h4 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h4><p>引用文献的基本环境是：</p><pre><code class="latex">\begin{thebibliography}{}\bibitem[显示符号]{引用标签} Book Title, Author\end{thebibliography}</code></pre><p>其中：</p><ul><li><code>\begin{thebibliography}{}</code>的大括号内填入的数字表示最大标号值。</li><li><code>\bibitem</code>表示一条文献记录。其中：<ul><li>[显示符号]表示在参考文献区域显示的标号，可不填，默认使用数字1,2,3进行编号。</li><li>[引用标签]则是在正文中引用的标签。参考文献的引用和其他的引用有点不同，需要用<code>\cite{引用标签}</code>来引用。</li></ul></li></ul><p>在LaTeX 中使用参考文献很容易，代码如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\begin{thebibliography}{123456}\bibitem {JW1}Jingwhale, T.A.O.C.P. , Yunlong Zhang , 2015,Vol. 1.\bibitem {JW2}Jingwhale, T.A.O.C.P. , Yunlong Zhang , 2015,Vol. 6.\bibitem {JW2}Jingwhale, T.A.O.C.P. , Yunlong Zhang , 2015,Vol. 8.\end{thebibliography}\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441333626666.png" alt="参考文献"></p><blockquote><p><strong>TIPS：</strong></p><ul><li><p>默认<code>thebibliography</code>会自动添加标题Reference，所以无需重复添加</p></li><li><p>默认参考文献的行间距为一行，这有时候显得太大了。可以在<code>\begin{thebibliography}{}</code>后添加<code>\addtolength{\itemsep}{-1.5ex}</code>来缩小行间距。<code>-1.5ex</code>表示每行缩小1.5ex。其实细心观察可以发现，<code>thebibliography</code>其实是一个枚举环境，因此对于<code>itemize</code>和<code>enumerate</code>，可以用同样的方法缩小行间距</p></li><li><p><code>thebibliography</code>是十分繁琐的。因为你还需要把作者等信息一个个地填上去。有没有什么更好的方法呢？答案是：有的。那就是<code>bibtex</code>！</p><ul><li><code>bibtex</code>是一个引用数据库，一般以<code>bib</code>后缀结尾。各大论文网站都会提供<code>bibtex</code>格式的文献引用。这里不做详解，可以到网上搜所一下。</li></ul></li></ul></blockquote><h4 id="7-插入表格"><a href="#7-插入表格" class="headerlink" title="7.插入表格"></a>7.插入表格</h4><p>插入表格经常使用的是tabular 环境，这个环境是LaTeX 中预先定义好的。</p><h5 id="①-tabular-环境插入表格"><a href="#①-tabular-环境插入表格" class="headerlink" title="①.tabular 环境插入表格"></a>①.tabular 环境插入表格</h5><p>在WinEdt中点击<img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441349099640-1566204771843.png" alt="表格图标">，选择Tabular，选择3行3列表格，代码如下：</p><pre><code class="latex">\begin{tabular}{| | | |}  \hline  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...    &amp;   &amp;   \\    &amp;   &amp;   \\    &amp;   &amp;   \\  \hline\end{tabular}</code></pre><blockquote><ul><li>首先，tabular 环境的参数<code>|l|c|r|</code> 指明了各列的对齐方式，<strong>l</strong>、<strong>c</strong> 和<strong>r</strong> 分别表示<strong>左对齐</strong>、<strong>居中对齐</strong>和<strong>右对齐</strong>。中间的<strong>竖线|</strong> 指明各列之间有竖线分隔，如果在某些地方不需要竖线，去掉相应位置的| 即可。</li><li>表格各行的元素之间用<code>&amp;</code> 号分隔，两行内容用<code>\</code> 分隔。<code>\hline</code> 表示两行之间的横线；你可以用连续两个<code>\hline</code> 得到双横线，或者去掉<code>\hline</code> 以不显示该横线。</li><li>如果需要在某个单元格中填写多行内容，不能直接用<code>\</code> 或<code>\newline</code> 命令，而应该将它们放在一个盒子里面（比如<code>\parbox</code> 盒子）。</li></ul></blockquote><p>修改代码如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\begin{tabular}{|l|c|r|}  \hline  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...  左列 &amp; 中列 &amp; 右列 \\  \hline  2行1列 &amp; 2行2列 &amp; 2行3列 \\  \hline  3行1列 &amp; 3行2列 &amp; 3行3列 \\  \hline  4行1列 &amp; 4行2列 &amp; 4行3列 \\  \hline\end{tabular}\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441371125811.png" alt="表格"></p><h5 id="②-跨列表格"><a href="#②-跨列表格" class="headerlink" title="②.跨列表格"></a>②.跨列表格</h5><p>复杂的表格经常需要跨行和跨列，在tabular 环境中，我们可以用命令<code>\multicolumn</code> 得到跨列表格，而跨行表格需要使用<code>multirow</code> 宏包，我们暂不介绍。</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\begin{tabular}{|l|c|r|}  \hline  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...  左列 &amp; 中列 &amp; 右列 \\  \hline  2行1列 &amp; 2行2列 &amp; 2行3列 \\  \hline  \multicolumn{2}{|c|}{跨越2015} &amp; 3行3列 \\  \hline  4行1列 &amp; 4行2列 &amp; 4行3列 \\  \hline\end{tabular}\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441385973299.png" alt="跨列表格"></p><p><code>\multicolumn</code> 命令的第一个参数指明要横跨的列数，第二个参数指明对齐和边框线，第三个参数指明该单元格的内容。</p><h5 id="③-浮动表格"><a href="#③-浮动表格" class="headerlink" title="③.浮动表格"></a>③.浮动表格</h5><p>前面所说的插入表格的例子中，表格是在tabular 环境对应的位置排版出来的。如果表格高度大于当前页剩余高度，表格就会被放置到下一页中，造成这一页下部留出很大空白。大部分时候我们并不需要严格限定表格出现的位置，而只要求表格在该段正文的附近出现即可。此时，我们可以用table 浮动环境来达到自动调整位置的效果。</p><p>我们只需，在WinEdt中点击<img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441397699756.png" alt="图标">，代码如下：</p><pre><code class="latex">\begin{table}  \centering    \caption{}\label{}</code></pre><p>将表格代码插进去就行了，示例代码如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\begin{document}\begin{table}[htbp!]  \centering  \begin{tabular}{|l|c|r|}  \hline  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...  左列 &amp; 中列 &amp; 右列 \\  \hline  2行1列 &amp; 2行2列 &amp; 2行3列 \\  \hline  3行1列 &amp; 3行2列 &amp; 3行3列 \\  \hline  4行1列 &amp; 4行2列 &amp; 4行3列 \\  \hline\end{tabular}  \caption{示例表格}\label{we}\end{table}\end{document}</code></pre><p>其中的可选参数里，h（here，当前位置）、t（top，页面顶部）、b（bottom，页面底部）、p（page，单独一页）表明允许将表格放置在哪些位置，而! 表示不管某些浮动的限制。用table 浮动环境，还可以用\caption命令指明表格的名称，并得到表格的自动编号。</p><h4 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8.插入图片"></a>8.插入图片</h4><p>在LATEX 文档中插入现有的图形，可以使用graphics。我们这里只介绍graphicx 宏包。需要载入graphicx 宏包</p><pre><code class="latex">\usepackage{graphicx}</code></pre><h5 id="①-图文混排。"><a href="#①-图文混排。" class="headerlink" title="①.图文混排。"></a>①.图文混排。</h5><p>命令：\includegraphics[选项]{图形文件} 。如下的代码：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{graphicx}\begin{document}和Microsoft Office Word 等所见即所得的办公软件不同，用\raisebox{-2mm}{\includegraphics[scale=0.8]{picture/tupian.jpg}}排版文档，首先要用文本编辑器编辑好tex文档，然后通过各种程序编译，得到pdf 文档用于打印或者阅读。\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441415662572.png" alt="图文混排"></p><blockquote><ul><li><code>\includegraphics</code> 命令有许多选项，上面例子中使用的选项scale=0.03 指明了整体的伸缩因子，常用的选项还有宽度值和高度值选项，例如width=64mm 和height=48mm 等等。如果宽度值和高度值只指明一项，将按同比例对另一项作伸缩。</li><li>默认情况下，图片是和正文的基线对齐的，当图片高度比行距大时，结果不是很美观。可以用<code>\raisebox</code>命令稍微降低图片的位置。</li></ul></blockquote><h5 id="②-图文分开"><a href="#②-图文分开" class="headerlink" title="②.图文分开"></a>②.图文分开</h5><p>如果插入的图片需要独立居中显示。这可以通过把插入的图片放在center 环境中来实现。如下面的代码：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{graphicx}\begin{document}和Microsoft Office Word 等所见即所得的办公软件不同，用\begin{center}\includegraphics{picture/tupian.jpg}\end{center}排版文档，首先要用文本编辑器编辑好tex文档，然后通过各种程序编译，得到pdf 文档用于打印或者阅读。\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441433785860.png" alt="图文分开"></p><p>图片最好设置宽和高，让它按照我们的约定显示。图片的伸缩因子需要计算有些麻烦，如果将它设为页芯宽度<code>\textwidth</code> 的某个因子，如\includegraphics[width=0.9\textwidth]{picture/tupian.jpg}，图片将页芯宽度显示。</p><h5 id="③-浮动图片"><a href="#③-浮动图片" class="headerlink" title="③.浮动图片"></a>③.浮动图片</h5><p>同表格的插入情形类似，自动调整图片的位置。用figure 浮动环境来达到这个效果。</p><p>在WinEdt中点击<img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441445038303.png" alt="图标">，出现代码代码如下：</p><pre><code class="latex">\begin{figure}  \centering  % Requires \usepackage{graphicx}  \includegraphics[width= ]{ }\\  \caption{ }\label{ }\end{figure}</code></pre><p>修改代码如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{graphicx}\begin{document}和Microsoft Office Word 等所见即所得的办公软件不同，用\begin{figure}[h]  \centering  % Requires \usepackage{graphicx}  \includegraphics{picture/tupian.jpg}\\  \caption{latex}\end{figure}排版文档，首先要用文本编辑器编辑好tex文档，然后通过各种程序编译，得到pdf文档用于打印或者阅读。\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441462536105.png" alt="浮动图片"></p><h4 id="9-插入公式"><a href="#9-插入公式" class="headerlink" title="9.插入公式"></a>9.插入公式</h4><p>在LATEX 中，数学公式有两种：即<strong>行内公式</strong>（inline formula）和<strong>行间公式</strong>（displayed formula）。</p><p>一般地，对于行内公式，我们常用<code>$...$</code>形式；而对于行间公式，我们常用<code>\[...\]</code>形式。</p><p><strong>行内公式</strong>和正文在同一行中显示，示例如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{graphicx}\begin{document}From $ a+b&gt;c $, we have ...\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441470502749.png" alt="行内公式"></p><p><strong>行间公式</strong>在单独一行居中显示，示例如下：</p><pre><code class="latex">\documentclass[UTF8]{ctexart}\usepackage{graphicx}\begin{document}Since\[ x^n + y^n = z^n, \]we have...\end{document}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441479568892.png" alt="行间公式"></p><h5 id="①公式编号"><a href="#①公式编号" class="headerlink" title="①公式编号"></a>①公式编号</h5><p>用</p><p>形式来输入行间公式，除了输入麻烦外还有其它缺点。但它有一个特有的好处，就是可以用<code>\eqno</code>命令指定公式的编号，例如：</p><pre><code class="latex">$$x_1+y_1&gt;z_1 \eqno{(1)}$$</code></pre><p>另外，我们可以用<code>equation</code> 环境来得到自动编号的行间公式。例如：</p><pre><code class="latex">\begin{equation}x^n+y^n=z^n\end{equation}</code></pre><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441493628420.png" alt="公式编号"></p><h5 id="②数学函数"><a href="#②数学函数" class="headerlink" title="②数学函数"></a>②数学函数</h5><p>点击WinEdt的<img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441512534966.png" alt="图标">，选择你要编辑的公式或符号，进行编辑即可，示例如下：</p><pre><code class="latex">\[\int\frac{1}{x} dx = \ln |x| + C\]</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441522378665.png" alt="数学函数"></p><h5 id="③配对括号"><a href="#③配对括号" class="headerlink" title="③配对括号"></a>③配对括号</h5><p>我们可以用<code>\left</code> 和<code>\right</code>命令来得到自动调整大小的括号，例如</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441534565839.png" alt="自动调整大小的括号"></p><p>自动调整大小的括号有时候效果仍然差强人意，这时候你也可以自己指定括号的大小：</p><pre><code class="latex">\[ \Bigg&lt; \bigg\{ \Big[ \big( xyz \big) \Big] \bigg\} \Bigg&gt; \]</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441551598626.png" alt="指定括号大小"></p><p>注意：{ 和} 是特殊字符，需要用\{ 和\} 来表示。</p><h5 id="④多行公式"><a href="#④多行公式" class="headerlink" title="④多行公式"></a>④多行公式</h5><p>要方便地输入多行公式，可以使用美国数学会的<code>amsmath</code> 宏包</p><pre><code class="latex">\usepackage{amsmath}</code></pre><p>得到对齐的公式，用<code>align</code> 环境。例如：</p><pre><code class="latex">\begin{align}x + y &amp;= 5 \\2x + 3y &amp;= 8\end{align}</code></pre><p>其中&amp; 符号后面的字符就是各行间对齐的位置。</p><p>显示效果如下：</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441571448498.png" alt="多行公式"></p><p>各行之间是不对齐的,可以用<code>gather</code> 环境的多行公式里面，</p><pre><code class="latex">\begin{gather}x + y = 5 \\2x + 3y = 8\end{gather}</code></pre><p>前面两个环境中的多行公式都是自动编号的。如果不要编号，可以用对应的<code>gather*</code> 和<code>align*</code> 环境。将{}修改为对应的gather* 和align*即可。</p><h5 id="⑤折行公式"><a href="#⑤折行公式" class="headerlink" title="⑤折行公式"></a>⑤折行公式</h5><p>一个公式太长需要拆为几行，这种折行公式应该只需要一个编号，可以使用equation 环境中的\split 环境。例如：</p><pre><code class="latex">\begin{equation}\begin{split}(3+3)\cdot111 &amp;= 3\cdot111 + 3\cdot111 \\&amp;= 666\end{split}\end{equation}</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261441585503729.png" alt="折行公式"></p><h5 id="⑥复杂公式"><a href="#⑥复杂公式" class="headerlink" title="⑥复杂公式"></a>⑥复杂公式</h5><pre><code class="latex">\documentclass{article}\usepackage{amsmath}\begin{document}\begin{equation}\left.\begin{aligned}x+y &amp;&gt; 5 \\y-y &amp;&gt; 11\end{aligned}\ \right\}\Rightarrow x^2 - y^2 &gt; 55\end{equation}\end{document}</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442006444101.png" alt="复杂公式"></p><h5 id="⑦定理环境"><a href="#⑦定理环境" class="headerlink" title="⑦定理环境"></a>⑦定理环境</h5><p>定理命题的撰写的简单例子：</p><pre><code class="latex">\newtheorem{thm}{Theorem}[subsection]\newtheorem{cor}[thm]{Corollary}\begin{thm}This is a theorem.\end{thm}\begin{cor}This is a corollary.\end{cor}</code></pre><p>这里的例子是对于<code>article</code> 文档类来说的，如果是<code>book</code> 文档类，最前面的<code>subsection</code>应改为<code>section</code>。</p><h3 id="四-中文排版"><a href="#四-中文排版" class="headerlink" title="四.中文排版"></a>四.中文排版</h3><h4 id="1-使用LaTeX-排版中文文档"><a href="#1-使用LaTeX-排版中文文档" class="headerlink" title="1.使用LaTeX 排版中文文档"></a>1.使用LaTeX 排版中文文档</h4><p>传统的方法有两种：一是用CJK 宏包，二是用CCT 宏包。这里先介绍CJK 的中文排版。</p><p>CJK 是国外人编写的，不仅支持中文，而且也支持其它双字节语言（实际上CJK 就是Chinese，Japanese 和Korean 这三个词语的缩写）。安装之后就可使用。</p><pre><code class="latex">\documentclass{article}\usepackage{CJK}\begin{document}\begin{CJK}{GB}{gbsn}欢迎来到CJK！这里使用的是CJK宏包里有的文鼎宋体。\end{CJK}\end{document}</code></pre><p>然后就用latex 编译就可以得到中文文档了。</p><blockquote><ul><li>要把中文部分放在<code>\begin{CJK}</code> 和<code>\end{CJK}</code>之间。</li><li>上面代码中的GB 指的是编码，对于简体中文来说，常见的有GB 编码和GBK 编码两种。而<strong>gbsn</strong> 指使用的字体为文鼎宋体。</li></ul></blockquote><p>CTeX 里另外多了GBK 编码的六种中文字体（宋体、仿宋、楷体、黑体、隶书和幼圆），如果你安装了CTeX，就可以类似下面的例子来使用这几种字体：</p><pre><code class="latex">\documentclass{article}\usepackage{CJK}%\begin{document}\begin{CJK}{GBK}{song}CTeX里中文默认用宋体！\CJKfamily}{GBK}{hei} 这是CTeX里的黑体！\CJKfamily{fs} 这是CTeX里的仿宋体！\CJKfamily{kai} 这是CTeX里的楷体！\CJKfamily{li} 这是CTeX里的隶书！\CJKfamily{you} 这是CTeX里的幼圆体！\end{CJK}\end{document}</code></pre><p>CCT 和CJK 就是两种外挂而已，很容易就出现比如pdf 书签乱码之类的问题。XeTeX 和LuaTeX 从底端就支持各种文字包括中文，而且能够直接使用系统自带的字体，生成的文档更为美观。本文介绍用XeTeX 排版LaTeX 文档的方法。</p><p>XeTeX 对TeX 的改动主要集中在字体的使用上，因此原来的LaTeX 文档稍为修改下就能够用XeTeX 编译了。最新的MiKTeX（CTeX）和TeXLive 套装都包含XeTeX 程序。示例如下：</p><pre><code class="latex">% !TEX program = xelatex\documentclass [12pt ,a4paper ]{article}\usepackage[cm -default ]{ fontspec}\usepackage{xunicode}\usepackage{xltxtra}\setmainfont[BoldFont=SimHei ,ItalicFont=KaiTi_GB2312 ]{ SimSun}\setsansfont[BoldFont=SimHei ]{ KaiTi_GB2312}\setmonofont{NSimSun}\XeTeXlinebreaklocale &quot;zh&quot;\XeTeXlinebreakskip = 0pt plus 1pt\begin{document}\XeTeX\ Show: $\alpha$ , $a^2+b^2=c^2$中文字体！\end{document}</code></pre><h4 id="2-字体大小"><a href="#2-字体大小" class="headerlink" title="2.字体大小"></a>2.字体大小</h4><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442047229047.png" alt="字体大小"></p><p>在LaTeX 中可以用各种命令来改变文本字体的大小，它的实际大小和文档类的正常字体大小（即<code>\normalsize</code> 的大小）设置有关。在代码里，直接添加字体命令即可。</p><h4 id="3-段落对齐"><a href="#3-段落对齐" class="headerlink" title="3.段落对齐"></a>3.段落对齐</h4><h5 id="①居中对齐"><a href="#①居中对齐" class="headerlink" title="①居中对齐"></a>①居中对齐</h5><p>在LaTeX 中，可以用center 环境得到居中的文本段落，其中可以用<code>\</code> 换行。例如：</p><pre><code class="latex">LATEX（英语发音：/ˈleɪtɛk/ LAY-tek或英语发音：/ˈlɑːtɛk/ LAH-tek，音译“拉泰赫”），是一种基于TEX的排版系统，由美国电脑学家莱斯利•兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能。\begin{center}对于生成复杂表格和数学公式，这一点表现得尤为突出。\end{center}因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的邮件到完整书籍的所有其他种类的文档。</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442085818693.png" alt="居中对齐"></p><h5 id="②单侧对齐"><a href="#②单侧对齐" class="headerlink" title="②单侧对齐"></a>②单侧对齐</h5><p>可以用<code>flushleft</code> 和<code>flushright</code> 环境分别得到向左对齐和向右对齐的文本段落。例如：</p><pre><code class="latex">\begin{flushleft}LATEX（英语发音：/ˈleɪtɛk/ ），\end{flushleft}\begin{flushright}是一种基于TEX的排版系统，\end{flushright}由美国电脑学家莱斯利•兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能。</code></pre><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442127372195.png" alt="单侧对齐"></p><h5 id="③调整页面布局"><a href="#③调整页面布局" class="headerlink" title="③调整页面布局"></a>③调整页面布局</h5><p>现在我们来说说如何定制页面的布局，比如正文区域的宽度和高度，和各个边距的大小。LATEX 中一般推荐用<code>geometry</code> 宏包来调整页面的布局。例如本文档（页面为B5 纸张大小）的页面布局就是用如下的代码设定的：</p><pre><code class="latex">\usepackage[text={125mm,195mm},centering]{geometry}</code></pre><p>其中的<code>geometry</code> 包的text={width,height} 选项指明了页面正文区域的宽度和高度大小，而后面的centering 选项表示将正文区域自动居中（即上下边距相等，而且左右边距也相等）。</p><h2 id="第三部分-如何做论文模板"><a href="#第三部分-如何做论文模板" class="headerlink" title="第三部分 如何做论文模板"></a>第三部分 如何做论文模板</h2><p>本节以清华大学论文模板为例，主要是通过学习模板总结如何去做。</p><p>清华大学论文模板下载地址：<a href="https://github.com/cnblogs-/latex-model" target="_blank" rel="noopener">https://github.com/cnblogs-/latex-model</a></p><h4 id="1-ThuThesis-的主要文件及功能介绍："><a href="#1-ThuThesis-的主要文件及功能介绍：" class="headerlink" title="1.ThuThesis 的主要文件及功能介绍："></a>1.ThuThesis 的主要文件及功能介绍：</h4><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442166597328.png" alt="主要文件1"></p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442187376228.png" alt="主要文件2"><br>thuthesis.cls和thuthesis.cfg 可由thuthesis.ins和thuthesis.dtx生成。</p><h4 id="2-建立步骤"><a href="#2-建立步骤" class="headerlink" title="2.建立步骤"></a>2.建立步骤</h4><p>思想：让形式与内容分离，这也是前端的思想。</p><p>①最主要的就是写宏。</p><blockquote><ul><li>thuthesis模板类。按照论文要求定义字体、目录、字号、行高等等。</li><li>写thubib参考文献样式模板</li><li>thutiles.sye：包含的宏包。</li></ul></blockquote><p>②建立data文件夹用于存放文章的内容</p><p><img src="//NU-LL.github.io/2019/08/19/Latex排版全解/261442218782489.png" alt="data文件夹"></p><p>建立figures用于存储图片</p><p>建立ref存放参考文献</p><p>③建立main.tex，调用之前写的宏，写论文，引用相应的数据到相应的区块。</p><pre><code class="latex">%%% Local Variables:%%% mode: latex%%% TeX-master: t%%% End:\documentclass[doctor]{thuthesis}% \documentclass[%%   bachelor|master|doctor, % mandatory option%   xetex|pdftex|dvips|dvipdfm, % optional%   secret,%   openany|openright,%   arialtoc,arialtitle]{thuthesis}% 所有其它可能用到的包都统一放到这里了，可以根据自己的实际添加或者删除。\usepackage{thutils}% 你可以在这里修改配置文件中的定义，导言区可以使用中文。% \def\myname{薛瑞尼}\begin{document}% 定义所有的eps文件在 figures 子目录下\graphicspath{{figures/}}%%% 封面部分\frontmatter\input{data/cover}\makecover% 目录\tableofcontents% 符号对照表\input{data/denotation}%%% 正文部分\mainmatter\include{data/chap01}\include{data/chap02}%%% 其它部分\backmatter% 本科生要这几个索引，研究生不要。选择性留下。\makeatletter\ifthu@bachelor  % 插图索引  \listoffigures  % 表格索引  \listoftables  % 公式索引  \listofequations\fi\makeatother% 参考文献\bibliographystyle{thubib}\bibliography{ref/refs}% 致谢\include{data/ack}% 附录\begin{appendix}\input{data/appendix01}\end{appendix}% 个人简历\include{data/resume}\end{document}</code></pre><p><strong>参考：</strong></p><p>1.LaTex Help e-Book</p><p>2.<a href="https://www.cnblogs.com/jingwhale/p/4250296.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingwhale/p/4250296.html</a></p><p>3.latex排版学习笔记</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> Ctex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kconfig文件语法分析</title>
      <link href="/2019/08/15/Kconfig%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/15/Kconfig%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Kconfig文件语法分析"><a href="#Kconfig文件语法分析" class="headerlink" title="Kconfig文件语法分析"></a>Kconfig文件语法分析</h1><p>Kconfig是进行各种大型项目配置的关键文件，用于生成menuconfig的界面并生成最终确定编译选项的<code>.config</code>文件。关于Kconfig文件的编写规则，linux内核中一般会在<code>Documentation/kbuild/kconfig-language.txt</code>中有详尽的叙述。这里主要用linux内核配置的实例进行语法分析。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>确定了条目前面是否有选项，menuconfig界面中的条目中一共有3种主动选项，分别是<code>[ ]</code>,<code>&lt; &gt;</code>和<code>( )</code>，分别表示”被编译进内核or舍弃”，”编译进内核or编译成模块or舍弃”， “按照提示输入一个数字”，分别对应Kconfig文件中的<code>bool</code>,<code>tristate</code>和<code>int</code>。<code>{ }</code>和<code>- -</code>属于被动选项，是配置系统根据依赖关系自动生成的选项，不能被手动修改。</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204170103490-1786922138.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204170107912-308931664.png" alt="界面"></p><h3 id="menu-endmenu"><a href="#menu-endmenu" class="headerlink" title="menu/endmenu"></a>menu/endmenu</h3><p>即图形界面中有<code>---&gt;</code>的条目，回车后可以展开。条目前面没有选项</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204170411396-1031446652.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171141459-1055444.png" alt="界面"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204170415677-1545317589.png" alt="界面"></p><h3 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h3><p>是menu和config的结合体，既在前面有选项，回车后也可以展开。</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204165326849-1152606067.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204170151318-1797584401.png" alt="界面"></p><h3 id="choice-endchoice"><a href="#choice-endchoice" class="headerlink" title="choice/endchoice"></a>choice/endchoice</h3><p>展开之后会有多选一的界面，每种选项都有独立的config管理</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171556177-1752964533.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171600646-97360519.png" alt="界面"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171604568-1301383238.png" alt="界面"></p><h3 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h3><p>简单的注释</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171859162-662046583.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204171904131-2138325327.png" alt="界面"></p><h3 id="if-endif"><a href="#if-endif" class="headerlink" title="if/endif"></a>if/endif</h3><p>如果if之后的值被选定了，里面的内容才能展开</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204175014131-1344714824.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204175019193-1290374412.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204175030099-1660517054.png" alt="界面"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204175039568-1059082491.png" alt="界面"></p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>表示调用指定路径的Kconfig，相当于C中的<code>include</code>，上例已经给出说明</p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends on"></a>depends on</h3><p>实现配置的相当关键的关键字，表示当前选项依赖于另外一个选项，如果另外一个不选，这个<strong>不会出现</strong>。</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180009506-1959384842.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180013802-374604716.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180019740-1973892369.png" alt="界面"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180023896-933070749.png" alt="界面"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180028240-1601478542.png" alt="界面"></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>另一个相当关键的关键字，表示当前选项需要另外选项的支持，如果选了当前选项，那么其后的选项会被<strong>强制选择</strong>，<code>{ }</code>或<code>--</code>就是这个实现的。下例中，只要这些Kconfig中进行了”select HAVE_ARM_ARCH_TIMER”，都会导致”HAVE_ARM_ARCH_TIMER”被强制选择，表现在menuconfig上就是”Architected timer support”被强制选定</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204180513912-1673882001.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204181532068-835119198.png" alt="kconfig"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204181334177-420570376.png" alt="界面"></p><h3 id="config文件分析"><a href="#config文件分析" class="headerlink" title=".config文件分析"></a>.config文件分析</h3><p>经过适当的配置之后保存就会在顶层目录下生成.config文件<br><code>=y</code>表示该配置将会被编译进内核，<code>=m</code>表示该配置需要单独编译成模块</p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204181109631-14529620.png" alt=".config文件"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204181104146-896323284.png" alt=".config文件"></p><p><img src="//NU-LL.github.io/2019/08/15/Kconfig文件语法分析/1022162-20161204181123771-2061689542.png" alt=".config文件"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kconfig语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造根文件系统</title>
      <link href="/2019/08/14/%E6%9E%84%E9%80%A0%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/08/14/%E6%9E%84%E9%80%A0%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="构造根文件系统"><a href="#构造根文件系统" class="headerlink" title="构造根文件系统"></a>构造根文件系统</h1><h2 id="一、流程分析"><a href="#一、流程分析" class="headerlink" title="一、流程分析"></a>一、流程分析</h2><p>回顾<code>Linux内核启动流程</code>中提到的流程：</p><blockquote><p>start_kernel：</p><ol><li><p>中断初始化、时钟初始化、打印内核版本信息</p></li><li><p>处理uboot传进来的启动信息</p></li><li><p>处理命令行信息</p></li><li><p>调度初始化等各种初始化</p></li><li><p>挂接根文件系统<code>rest_init</code></p><ol><li><p>创建<code>kernel_init</code>线程</p><ol><li><p>早期的用户空间初始化<code>prepare_namespace</code></p><ol><li>挂载根文件系统<code>mount_root</code></li></ol></li><li><p>初始化某些设备<code>init_post</code></p><ol><li><p>打开<code>/dev/console</code>设备</p></li><li><p>标准设备设置</p><pre><code class="c"> (void) sys_dup(0); (void) sys_dup(0);</code></pre></li><li><p>执行应用程序</p><pre><code class="c"> if (execute_command) {     run_init_process(execute_command);     printk(KERN_WARNING &quot;Failed to execute %s.  Attempting &quot;            &quot;defaults...\n&quot;, execute_command); } run_init_process(&quot;/sbin/init&quot;); run_init_process(&quot;/etc/init&quot;); run_init_process(&quot;/bin/init&quot;); run_init_process(&quot;/bin/sh&quot;); panic(&quot;No init found.  Try passing init= option to kernel.&quot;);</code></pre></li></ol></li></ol></li></ol></li></ol></blockquote><p>发现内核有如下现象：</p><ol><li><p>打开设备<code>/dev/console</code>（即终端，在开发板上为串口0），并将标准输入输出错误信息指向这里</p></li><li><p>如果uboot传入的命令行参数（bootargs）中有init参数时，会执行该程序，通常该程序不会返回</p><blockquote><p>init参数最后会赋值给execute_command，即上述代码的第1行</p><p>通常，init=/linuxrc，实际上是链接到了busybox</p></blockquote></li><li><p>如发生意外，会依次查找以下程序并执行（通常程序不会返回）：</p><ul><li>/sbin/init</li><li>/etc/init</li><li>/bin/init</li><li>/bin/sh</li></ul></li><li><p>若上述程序全部执行失败，则输出<code>No init found.  Try passing init= option to kernel.</code></p></li></ol><h2 id="二、init进程分析"><a href="#二、init进程分析" class="headerlink" title="二、init进程分析"></a>二、init进程分析</h2><p>busybox是各种常用命令的组合，一般来说常见命令都是通过链接来间接调用busybox并传入相关参数。如：<code>ls</code>实际是<code>busybox ls</code></p><p>通过上述分析，最后会进入busybox中的<code>init</code>程序，经过搜索，得出会进入busybox中的init_main函数：</p><ol><li><p>init_main</p></li><li><p>根据内核中的设置初始化控制台（sys_dup已经指定）</p></li><li><p><code>parse_inittab</code></p><ol><li><p>打开<code>/etc/inittab</code>配置文件，若无则选取默认项</p><blockquote><p>详细格式见：busybox/examples/inittab.txt</p><hr><p><id>:<runlevels>:<action>:<process></process></action></runlevels></id></p><hr><p><id>：会自动加上/dev/前缀并用于终端（stdin、stdout、stderr），可省略</id></p><p><runlevels>：忽略</runlevels></p><p><action>：何时执行，包括：<code>sysinit</code>, <code>respawn</code>, <code>askfirst</code>, <code>wait</code>, <code>once</code> , <code>restart</code>, <code>ctrlaltdel</code>,<code>shutdown</code></action></p><p><process>：应用程序或脚本</process></p></blockquote><blockquote><p>默认项反向解析后得出配置文件：</p><pre><code class="bash">::ctrlaltdel:reboot::shutdown:umount -a -r::restart:init::askfirst:-/bin/shtty2::askfirst:-/bin/shtty3::askfirst:-/bin/shtty4::askfirst:-/bin/sh::sysinit:/etc/init.d/rcS（初始化脚本文件，其他相关的配置可以在这这个脚本中运行）</code></pre></blockquote></li><li><p>解析配置文件</p></li><li><p>调用<code>new_init_action</code>函数</p><blockquote><pre><code class="c">static void new_init_action(int action, const char *command, const char *cons)</code></pre><p>action：脚本中的<action>，执行时机</action></p><p>command：脚本中的<process>，应用程序或脚本</process></p><p>cons：脚本中的<id>，用作终端</id></p></blockquote><ol><li>创建一个<code>init_action</code>结构存储action、command、cons等数据</li><li>将该结构放入<code>init_action_list</code>链表</li></ol></li></ol></li><li><p>调用<code>run_actions</code>函数一次执行脚本中<action>参数所代表的一类应用程序或脚本</action></p><pre><code class="c"> /* Now run everything that needs to be run */ /* First run the sysinit command */ run_actions(SYSINIT);//首先执行SYSINIT类应用程序或脚本 /* Next run anything that wants to block */ run_actions(WAIT);//接着执行WAIT类应用程序或脚本 /* Next run anything to be run only once */ run_actions(ONCE);//再执行ONCE类应用程序或脚本 /* Now run the looping stuff for the rest of forever */ while (1) {     /* run the respawn stuff */     run_actions(RESPAWN);//执行RESPAWN类应用程序或脚本     /* run the askfirst stuff */     run_actions(ASKFIRST);//执行ASKFIRST类应用程序或脚本     /* Wait for a child process to exit */     wpid = wait(NULL);     while (wpid &gt; 0) {         ......     } }</code></pre><p> SYSINIT、WAIT类：</p><ol><li><p>从之前的init_action_list链表中取出对应的项</p></li><li><p>通过<code>waitfor</code>函数运行对应应用程序或脚本</p><ol><li>调用run函数创建子进程运行对应应用程序或脚本</li><li>通过waitpid函数等待子进程结束</li></ol></li><li><p>调用<code>delete_init_action</code>从链表中删除</p><p>ONCE类：</p></li><li><p>从之前的init_action_list链表中取出对应的项</p></li><li><p>调用run函数创建子进程运行对应应用程序或脚本</p></li><li><p>调用<code>delete_init_action</code>从链表中删除</p><p>RESPAWN类：</p></li><li><p>调用run函数创建子进程运行对应应用程序或脚本</p></li><li><p>子进程退出后再次调用run函数</p><p>ASKFIRST类：</p></li><li><p>调用run函数创建子进程运行对应应用程序或脚本</p></li><li><p>子进程退出后打印：<code>Please press Enter to activate this console</code>，并等待回车</p></li><li><p>再次调用run函数</p></li></ol></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最小根文件系统需要有：</p><ol><li><p><code>/dev/console</code>文件、<code>/dev/null</code>文件</p><blockquote><p>当<code>/etc/inittab</code>配置文件中没有设置<id>项时会默认到<code>/dev/null</code>文件</id></p></blockquote></li><li><p>init程序（一般来源于busybox）</p><blockquote><p>/linuxrc、/sbin/init、/etc/init、/bin/init、/bin/sh这些文件最后均会链接到busybox</p></blockquote></li><li><p>配置文件<code>/etc/inittab</code></p></li><li><p>配置文件中指定的应用程序</p></li><li><p>C库</p></li></ol><h2 id="三、配置编译busybox"><a href="#三、配置编译busybox" class="headerlink" title="三、配置编译busybox"></a>三、配置编译busybox</h2><blockquote><p>可以参考busybox/INSTALL中的说明</p></blockquote><ol><li><p>make defconfig采取默认配置项</p></li><li><p>make menuconfig配置</p><blockquote><p>或者直接修改makefile，找到CROSS_COMPILE设置为交叉工具链：arm-linux-</p></blockquote></li><li><p>make编译</p></li><li><p>make CONFIG_PREFIX=目录：指定编译结果存放的目录</p><blockquote><p>make install 为安装到PC机上</p><p>eg：</p><p>在/home/null/nfs_root目录下安装编译出来的busybox</p><p>make install CONFIG_PREFIX=/home/null/nfs_root</p></blockquote></li></ol><h2 id="四、构建根文件系统"><a href="#四、构建根文件系统" class="headerlink" title="四、构建根文件系统"></a>四、构建根文件系统</h2><h3 id="最精简的根文件系统"><a href="#最精简的根文件系统" class="headerlink" title="最精简的根文件系统"></a>最精简的根文件系统</h3><ol><li><p>创建设备文件<code>/dev/console</code>、<code>/dev/null</code></p><blockquote><p>通过观察PC机上相同的设备来创建（在/dev/目录下）：</p><pre><code class="bash">sudo mknod console c 5 1sudo mknod null c 1 3</code></pre></blockquote></li><li><p>创建配置文件<code>/etc/inittab</code>（最小的配置文件）</p><pre><code class="bash"> console::askfirst:-/bin/sh</code></pre></li><li><p>安装C库（glibc库）</p><p> 在开发板上只需要加载器和动态库，假设要构建的根文件系统目录为/ work/nfs_root/fs_mini,操作如下：</p><pre><code class="bash"> mkdir -p /work/nfs_root/fs_mini/lib cd /work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux/lib cp *.so* /work/nfs_root/fs_mini/lib -d</code></pre></li><li><p>通过<code>mkyaffs2image</code>工具打包成镜像下载至开发板（需要自己编译，支持NorFlash）</p><pre><code class="bash"> mkyaffs2image test_fs/ test_fs.yaffs2 #mkyaffs2image 待打包文件 生成的镜像</code></pre></li></ol><h3 id="完善根文件系统"><a href="#完善根文件系统" class="headerlink" title="完善根文件系统"></a>完善根文件系统</h3><h4 id="挂载相关文件系统（2种方法）"><a href="#挂载相关文件系统（2种方法）" class="headerlink" title="挂载相关文件系统（2种方法）"></a>挂载相关文件系统（2种方法）</h4><ol><li><p>手动创建proc目录并挂载虚拟文件系统</p><blockquote><pre><code class="bash">mkdir proc#创建mount -t proc none /proc#挂载</code></pre><p>默认配置文件中会执行<code>/etc/init.d/rcS</code>脚本文件，也可以在这里边执行挂载命令<code>mount -t proc none /proc</code>挂载proc虚拟文件系统，创建后记得<code>chmod +x /etc/init.d/rcS</code></p></blockquote></li><li><p>mount -a（该命令也是在/etc/init.d/rcS中）</p><ol><li><p>该命令会读出<code>/etc/fstab</code>配置文件中的内容来挂载文件系统</p><blockquote><p><code>etc/fstab</code>文件被用来定义文件系统的“静态信息”,这些信息被用来控制 mount命令的行为。<code>/etc/fstab</code>配置文件格式：</p><hr><p>device mount-point type options dump fsck order</p><hr><p>device ：要挂载的设备</p><p>mount-point：挂载到哪，挂载点</p><p>type：文件系统类型</p><p>options：挂接参数，以逗号隔开</p><p>dump：</p><p>fsck：</p><p>order：</p><hr><p>例子：</p><pre><code class="bash">#device mount-point type options dump fsck orderproc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0</code></pre></blockquote></li><li><p>可以通过<code>cat /proc/mounts</code>命令来查看当前系统中已经挂载的文件系统</p></li></ol></li></ol><h4 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a>mdev</h4><p>linux操作系统中有<code>udev</code>，它能够自动在<code>/dev/</code>下创建设备节点。在嵌入式中，有一个简化版本：<code>mdev</code>（busybox中自带），使用方法：</p><ol><li><p>挂载相关文件系统（这里采用<code>/etc/fstab</code>配置文件，直接添加）</p><p> 命令：</p><pre><code class="bash"> mount -t sysfs sysfs /sys mount -t tmpfs mdev /dev</code></pre><p> 或<code>/etc/fstab</code>配置文件中添加：</p><pre><code class="bash"> sysfs /sys sysfs defaults 0 0 tmpfs /dev tmpfs defaults 0 0</code></pre></li><li><p>执行相关命令（这里采用<code>/etc/init.d/rcS</code>脚本文件，直接添加）</p><pre><code class="bash"> mkdir /dev/pts mount -t devpts devpts /dev/pts echo /sbin/mdev &gt; /proc/sys/kernel/hotplug#热插拔 mdev -s#先将系统中已有的设备节点创建出来</code></pre></li></ol><h2 id="五、NFS服务"><a href="#五、NFS服务" class="headerlink" title="五、NFS服务"></a>五、NFS服务</h2><h3 id="服务器设置——PC机"><a href="#服务器设置——PC机" class="headerlink" title="服务器设置——PC机"></a>服务器设置——PC机</h3><ol><li><p>安装NFS服务、创建共享文件夹</p><pre><code class="bash"> sudo apt-get install nfs-kernel-server mkdir -p nfs_root  chmod 777 -R nfs_root#修改权限</code></pre></li><li><p>修改NFS配置文件<code>/etc/exports</code>(自行修改nfs挂载目录)</p><pre><code class="bash"> sudo vim /etc/exports</code></pre><p> 添加如下内容（绝对路径）</p><pre><code class="bash"> /home/null/NFS_Share *(sync,rw,insecure,no_subtree_check,no_root_squash) #挂载目录 所有人都可以访问 #rw:读/写权限 #sync:数据同步写入内存和硬盘 #insecure:端口号大于1024时的非法设置 #no_root_squash:服务器允许远程系统以root特权存取该目录 #no_subtree_check:关闭子树检查</code></pre></li><li><p>重启服务</p><pre><code class="bash"> service rpcbind start rpcbi sudo service nfs-kernel-server restart 或 sudo /etc/init.d/nfs-kernel-server start sudo /etc/init.d/portmap start</code></pre></li><li><p>检查是否配置成功（自己挂接自己）（绝对路径）</p><pre><code class="bash"> sudo mount -t nfs -o nolock localhost://home/null/NFS_Share/nfsroot/tmp/fs_mini_mdev /mnt/nfs_test/#挂接 ls -l /mnt/nfs_test#检查 sudo umount /mnt/nfs_test#卸载</code></pre></li></ol><h3 id="客户端设置——开发板"><a href="#客户端设置——开发板" class="headerlink" title="客户端设置——开发板"></a>客户端设置——开发板</h3><h4 id="启动linux后手动挂接"><a href="#启动linux后手动挂接" class="headerlink" title="启动linux后手动挂接"></a>启动linux后手动挂接</h4><ol><li><p>开发板和服务器能够互ping</p></li><li><p>挂接（绝对路径）</p><pre><code class="bash">mount -t nfs -o nolock 192.168.1.111:/home/null/NFS_Share/nfsroot/tmp/fs_mini_mdev /mnt</code></pre><p>这里192.168.1.111为服务器ip地址，两者需要在同一网段</p></li><li><p>查看</p><pre><code class="bash"> ls /mnt</code></pre></li></ol><h4 id="启动linux后自动挂接"><a href="#启动linux后自动挂接" class="headerlink" title="启动linux后自动挂接"></a>启动linux后自动挂接</h4><p>这里是利用了启动后的初始化脚本<code>/etc/init.d/rcS</code>自动挂载：</p><p>修改内容为：</p><pre><code class="bash">ifconfig eth0 192.168.1.17mount -amkdir /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -sif [ ! -e /etc/pointercal ]then/bin/ts_cal.shfi/bin/qpe.sh &amp;mount -t nfs -o nolock 192.168.1.111:/home/null/NFS_Share /mnt &amp;#增加这一条#mount -t nfs -o nolock 服务器ip:挂载目录（绝对目录） 开发板上的挂载点</code></pre><p>如果是通过删除脚本再新建的，最后务必修改执行权限：</p><pre><code class="bash">chmod 777 /etc/init.d/rcS</code></pre><h4 id="启动linux前自动挂接（必须要路由器）"><a href="#启动linux前自动挂接（必须要路由器）" class="headerlink" title="启动linux前自动挂接（必须要路由器）"></a>启动linux前自动挂接（必须要路由器）</h4><ol><li><p>uboot中修改启动参数<code>bootargs</code></p><pre><code class="bash"> set bootargs noinitrd root=/dev/nfs nfsroot=192.168.2.101:/home/null/nfs_root ip=192.168.2.17:192.168.2.101:192.168.2.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200;save</code></pre></li></ol><pre><code>nfsroot=服务器ip:nfs绝对路径 ip=开发板ip:服务器ip:网关:子网掩码::网卡:off&gt; 注：原来从flash上启动的参数为&gt;&gt; ```bash&gt; set bootargs noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200;save&gt; &gt; mount -t nfs -o intr,nolock,rsize=1024,wsize=1024 192.168.2.111:/home/null/NFS_Share/ /mnt &amp;&gt; ```&gt;&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核启动流程</title>
      <link href="/2019/08/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/08/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核启动流程"><a href="#Linux内核启动流程" class="headerlink" title="Linux内核启动流程"></a>Linux内核启动流程</h1><h2 id="一、配置及编译"><a href="#一、配置及编译" class="headerlink" title="一、配置及编译"></a>一、配置及编译</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>三种方法配置：</p><ol><li><p>直接输入 make menuconfig   命令,从头到尾重新配置菜单 (非常复杂)</p><p> make menuconfig时修改配置项，最终的配置结果会保存在.config文件中，这主要是Kconfig的功能，</p><p> 再执行make menuconfig时就可以回去读取<code>.config</code>文件。这是内核配置的过程。</p></li><li><p>通过make xxx_defconfig命令在默认的配置上进行修改,然后再输入make menuconfig配置菜单</p><p> 可以使用,使用 <code>find –name \*defconfig</code> 命令查找所有带defconfig名字的文件.</p></li><li><p>使用厂家提供的配置config_ok文件</p><p> 在linux-2.6.22.6目录下，使用<code>cp config_ok  .config</code>将config_ok复制覆盖新的.config隐藏文件(通过 ls -la 命令可以查看.config隐藏文件)，</p><p> 最后执行make menuconfig时就可以回去读取.config文件</p></li></ol><p>可见，最后的配置文件为<code>.config</code>文件。该配置文件通过<code>make uImage</code>或<code>make</code>命令后会影响以下几个文件：</p><ul><li><p>相关的源代码（包含该宏，该宏的具体定义在下一个文件<code>autoconf.h</code>中）</p></li><li><p>该源码所对应的头文件（include/linux/autoconf.h）</p><blockquote><p>该头文件会通过make命令根据<code>.config</code>文件自动生成，同时将CONFIG_XXX定义为1（不论是否为模块）</p></blockquote></li><li><p>子目录中的makefile</p><blockquote><p>编译成模块或者是内核是通过该文件体现出来的：</p><p>例子：</p><pre><code class="makefile">obj-$(CONFIG_XXX) += xxx.o</code></pre><p>这里<code>CONFIG_XXX</code>的值就是下一点中的配置文件<code>auto.conf</code>中的内容，即：</p><ul><li>obj-y：编译到内核</li><li>obj-m：编译成模块</li></ul></blockquote></li><li><p>配置文件（include/config/auto.conf）</p><blockquote><p>该文件中的内容是通过make命令根据<code>.config</code>文件自动生成</p><p>例子：</p><p>CONFIG_XXX=y（编译到内核）</p><p>或</p><p>CONFIG_XXX=m（编译成模块）</p></blockquote></li></ul><h3 id="分析顶层makefile"><a href="#分析顶层makefile" class="headerlink" title="分析顶层makefile"></a>分析顶层makefile</h3><p>分析makefile的主要目的是找到第一个文件和链接脚本，相关方法和uboot中的过程类似</p><blockquote><p>详细的文档可以查看<code>Documentation/kbuild/makefiles.txt</code></p></blockquote><blockquote><p>通过上面的讲解，我们可以知道每个文件是如何被编译成模块或者是内核中去的，这里拓展下多个文件一起编译的情况：</p><p>例子：a.c、b.c两个文件需要同时编译成一个模块</p><pre><code class="makefile">obj-m += ab.oab-objs := a.o b.o</code></pre><p>此时会将a.c、b.c两个文件编译成ab.ko这个模块</p></blockquote><p>通过<code>make uImage</code>命令，发现目标<code>uImage</code>位于<code>arch/arm/makefile</code>：</p><blockquote><p>顶层的makefile包括了子目录下的makefile以及上文中讲的<code>.config</code>配置文件</p></blockquote><pre><code class="makefile">ZImage Image xipImage bootpImage uImage:vmlinux    $(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@</code></pre><p>此时目标<code>vmlinux</code>又在顶层makefile中：</p><pre><code class="makefile">all: vmlinux......vmlinux-init := $(head-y) $(init-y)#初始化代码，原材料vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)#核心代码vmlinux-all  := $(vmlinux-init) $(vmlinux-main)vmlinux-lds  := arch/$(ARCH)/kernel/vmlinux.lds#链接脚本......vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCEifdef CONFIG_HEADERS_CHECK#编译命令：    $(Q)$(MAKE) -f $(srctree)/Makefile headers_checkendif    $(call if_changed_rule,vmlinux__)    $(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost $@    $(Q)rm -f .old_version</code></pre><p>同分析uboot的方法一致，这里直接执行<code>make uImage V=1</code>命令，关心最后一条命令(展开后)：</p><blockquote><p>V=1：打印信息更加详细的列出来</p></blockquote><pre><code class="bash">arm-linux-ld -EL -P --no-urde fined -X -o vmlinux -T arch/arm/kernel/vmlinux.ldsarch/arn/kernel/head.o arch/arm/kernel/init_task.oiniti/built-in.o--start-group usr/built-in.o arch/arm/kernel/built-in.o arch/arm/mm/built-in.o arch/arm/common/built-in.o arch/arm/mach-s3c2410/built-in.o arch/arm/mach-s3c2400/built-in.o arch/arm/mach-s3c2412/built-in.o arch/arm/mach-s3c2440/built-in.o arch/arm/mach-s3c2442/built-in.o arch/arm/mach-s3c2443/built-in.o arch/arm/nwfpe/built-in.o arch/arm/plat-s3c24xx/built-in.o kernel/built-in.o mm/built-in.o fs/built-in.o ipc/built-in.o security/built-in.o crypto/built-in.o block/built-in.o arch/arm/lib/lib.a 1ib/1ib.a arch/arm/lib/built-in.o lib/built-in.o drivers/built-in.o sound/built-in.onet/built-in.o --end-group .tmp_kallsyms2.o</code></pre><p>可见：</p><ul><li>第一个文件为：<code>arch/arn/kernel/head.S</code></li><li>链接脚本为：<code>arch/arm/kernel/vmlinux.lds</code>（根据make命令由同级目录下的vmlinux.lds.S文件生成）</li></ul><pre><code>SECTIONS{. = (0xc0000000) + 0x00008000;          //设置内核运行地址.text.head : {                               _stext = .;    _sinittext = .;    *(.text.head)                     //存放.text.head段}.init : {*(.init.text)                    //存放.init.text段   ...   ...</code></pre><h2 id="二、第一个文件head-S"><a href="#二、第一个文件head-S" class="headerlink" title="二、第一个文件head.S"></a>二、第一个文件head.S</h2><p>head.S步骤：</p><ol><li><p>检查是否支持该处理器<code>__lookup_processor_type</code></p></li><li><p>检查单板ID（就是uboot传进来的机器ID）</p><blockquote><p>这里会通过<code>__lookup_machine_type</code>函数，将链接脚本中定义的<code>.arch.info.init</code>段中存放的架构相关的初始化信息和uboot传进来的机器ID进行对比，如果不匹配就进入死循环</p><p>注：通过MACHINE_START宏可以定义架构相关的初始化信息在<code>.arch.info.init</code>段中</p></blockquote></li><li><p>创建页表<code>__create_page_tables</code></p></li><li><p>使能MMU<code>__enable_mmu</code></p></li><li><p>跳转到<code>start_kernel</code>函数（内核的第一个C函数）</p></li></ol><h2 id="三、启动内核start-kernel"><a href="#三、启动内核start-kernel" class="headerlink" title="三、启动内核start_kernel"></a>三、启动内核start_kernel</h2><h3 id="start-kernel步骤"><a href="#start-kernel步骤" class="headerlink" title="start_kernel步骤"></a>start_kernel步骤</h3><ol><li><p>中断初始化、时钟初始化、打印内核版本信息</p></li><li><p>处理uboot传进来的启动信息<code>setup_arch(&amp;command_line);</code></p><ol><li>提取信息，处理</li><li>解析命令行信息<code>parse_cmdline</code></li></ol></li><li><p>处理命令行信息<code>setup_command_line(command_line);</code></p></li><li><p>调度初始化等各种初始化</p></li><li><p>挂接根文件系统<code>rest_init</code></p><ol><li><p>创建<code>kernel_init</code>线程</p><ol><li><p>早期的用户空间初始化<code>prepare_namespace</code></p><ol><li>挂载根文件系统<code>mount_root</code></li></ol></li><li><p>初始化某些设备<code>init_post</code></p><ol><li><p>打开/dev/console设备</p></li><li><p>执行应用程序</p><pre><code class="c"> run_init_process(&quot;/sbin/init&quot;); run_init_process(&quot;/etc/init&quot;); run_init_process(&quot;/bin/init&quot;); run_init_process(&quot;/bin/sh&quot;);</code></pre></li></ol></li></ol></li></ol></li></ol><h3 id="处理uboot传进来的启动信息"><a href="#处理uboot传进来的启动信息" class="headerlink" title="处理uboot传进来的启动信息"></a>处理uboot传进来的启动信息</h3><p>通过调用宏<code>__setup</code>来处理uboot传进来的<code>bootargs</code>命令行参数</p><pre><code class="c">__setup(&quot;命令&quot;,调用的函数)</code></pre><blockquote><p>例子：</p><p>__setup(“root=”,root_dev_setup)：当uboot传进来<code>bootargs</code>命令行参数中有root参数时，会调用函数root_dev_setup。同时用了一个专门的结构体obs_kernel_param来保存相关的一些数据并存在了<code>.init.setup</code>段中</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>u-boot分析与使用</title>
      <link href="/2019/08/12/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/12/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="u-boot分析与使用"><a href="#u-boot分析与使用" class="headerlink" title="u-boot分析与使用"></a>u-boot分析与使用</h1><h2 id="零、U-boot使用"><a href="#零、U-boot使用" class="headerlink" title="零、U-boot使用"></a>零、U-boot使用</h2><p>uboot 命令中输入的数字均为<strong>十六进制</strong>，而非十进制，注意！！！</p><h3 id="0-1信息查询命令"><a href="#0-1信息查询命令" class="headerlink" title="0.1信息查询命令"></a>0.1信息查询命令</h3><p>buinfo：查看板子信息 </p><p>printenv：查看环境变量（直接输入print也行）</p><p>version：查看uboot版本号</p><h3 id="0-2环境变量相关操作"><a href="#0-2环境变量相关操作" class="headerlink" title="0.2环境变量相关操作"></a>0.2环境变量相关操作</h3><ul><li><p>setenv：新建、删除、设置或者修改环境变量的值</p><pre><code class="bash">  setenv [变量名] [变量值]</code></pre><p>  如果变量值中有空格，可以用单引号<code>&#39;</code>括起来：</p><pre><code class="bash">  setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code></pre></li><li><p>saveenv：保存修改后的环境变量</p></li></ul><h3 id="0-3内存操作"><a href="#0-3内存操作" class="headerlink" title="0.3内存操作"></a>0.3内存操作</h3><h4 id="md"><a href="#md" class="headerlink" title="md"></a>md</h4><p>内存查看命令，用于显示内存值</p><pre><code class="bash">md[.b, .w, .l] address [# of objects]#eg:md.b 80000000 10</code></pre><p>命令中的[.b .w .l]对应 byte、 word 和 long，即分别以 1 个字节、 2 个字节、 4 个字节来显示内存值。 address 就是要查看的内存起始地址， [# of objects]表示要查看的数据长度，这个长度和你所选择的显示格式有关。  </p><h4 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h4><p>修改指定地址的内存值</p><pre><code class="bash">nm[.b, .w, .l] address#eg:nm.b 80000000</code></pre><p>同样以.b、 .w 和.l 来指定操作格式。 address 就是要修改的内存起始地址。  值得注意的是该命令修改完后地址<strong>不会自增</strong></p><h4 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h4><p>修改指定地址的内存值</p><pre><code class="bash">mm[.b, .w, .l] address#eg:mm.b 80000000</code></pre><p>与nm命令类似，区别就是修改完后地址<strong>会自增</strong></p><h4 id="mw"><a href="#mw" class="headerlink" title="mw"></a>mw</h4><p>使用一个指定的数据填充一段内存</p><pre><code class="bash">mw[.b, .w, .l] address value [count]#eg:md.b 80000000 fe 10</code></pre><p>以.b、 .w 和.l 来指定操作格式。 address 表示要填充的内存起始地址，value为要填充的数据， count是填充的长度。</p><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中</p><pre><code class="bash">cp[.b, .w, .l] source target count#eg:cp.b 80000000 80000100 10</code></pre><p>以.b、 .w 和.l 来指定操作格式。source 为源地址， target 为目的地址， count 为拷贝的长度</p><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>比较命令，用于比较两段内存的数据是否相等</p><pre><code class="bash">cmp[.b, .w, .l] addr1 addr2 count#eg:cmp.b 80000000 80000100 10</code></pre><p>以.b、 .w 和.l 来指定操作格式。addr1 为第一段内存首地址， addr2 为第二段内存首地址， count 为要比较的长度。</p><h3 id="0-4网络操作"><a href="#0-4网络操作" class="headerlink" title="0.4网络操作"></a>0.4网络操作</h3><p>该部分命令需要有以下环境变量的支持：</p><pre><code class="bash">#板卡ip地址setenv ipaddr 192.168.1.106#板卡MAC地址setenv ethaddr 00:34:9f:21:a0:56#网关地址setenv gatewayip 192.168.1.1#子网掩码setenv netmask 255.255.255.0#服务器ip地址setenv serverip 192.168.1.100saveenv</code></pre><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>验证网络是否正常，不做过多解释</p><p>注意！只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot（uboot 没有对 ping命令做处理，如果用其他的机器 ping uboot 会失败）</p><h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p>dhcp会自动获取 IP 地址，同时还会通过 TFTP 来启动 linux 内核，输入<code>? dhcp</code>可查看uboot中 dhcp 命令详细的信息，这里一般用于自动获取ip地址</p><h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><p>通过nfs(Network File System，网络文件系统)使得板卡能够直接从服务器（服务器需要提前布置好NFS服务与NFS文件目录）上下载相关资源到DRAM中（如zImage、文件系统、设备树等）</p><pre><code class="bash">nfs [loadAddress] [[hostIPaddr:]bootfilename]#eg:nfs 80800000 192.168.1.100:/home/null/zImagenfs 80800000 /home/null/zImage#如果环境变量中存在serverip</code></pre><p>其中 loadAddress 是要保存的 DRAM 地址， [[hostIPaddr:]bootfilename]是要下载的文件地址（需要输入服务器中的完整路径）</p><h4 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h4><p>与nfs类似，均用于通过网络下载文件到 DRAM 中（服务器需要提前布置好TFTP服务与TFTP文件目录）</p><pre><code class="bash">tftp [loadAddress] [[hostIPaddr:]bootfilename]#eg:tftp 80800000 192.168.1.100:zImagetftp 80800000 zImage#如果环境变量中存在serverip</code></pre><p>loadAddress 是 文 件 在 DRAM 中 的存 放 地 址 ，[[hostIPaddr:]bootfilename]是要从 Ubuntu 中下载的文件（这里不需要输入服务器中的完整路径，直接从TFTP文件目录中获取）</p><h3 id="0-5EMMC和SD卡操作"><a href="#0-5EMMC和SD卡操作" class="headerlink" title="0.5EMMC和SD卡操作"></a>0.5EMMC和SD卡操作</h3><h4 id="mmc-info"><a href="#mmc-info" class="headerlink" title="mmc info"></a>mmc info</h4><p><code>mmc info</code>命令和<code>mmcinfo</code>命令相同，均为输出当前选中的设备信息，不做过多解释</p><h4 id="mmc-rescan"><a href="#mmc-rescan" class="headerlink" title="mmc rescan"></a>mmc rescan</h4><p>用于扫描当前开发板上所有的 MMC 设备，包括 EMMC 和 SD 卡</p><h4 id="mmc-list"><a href="#mmc-list" class="headerlink" title="mmc list"></a>mmc list</h4><p>查看当前开发板一共有几个 MMC 设备，通过该命令可以查看当前选中的设备（一般来说0为SD卡，1为EMMC）</p><h4 id="mmc-dev"><a href="#mmc-dev" class="headerlink" title="mmc dev"></a>mmc dev</h4><p>切换当前 MMC 设备</p><pre><code class="bash">mmc dev [dev] [part]#eg:mmc dev 0 # 切换到设备0（一般为SD卡，通过mmc list可以查看）的分区0</code></pre><p>[dev]用来设置要切换的 MMC 设备号，[part]是分区号（可以不写，默认为分区 0）</p><h4 id="mmc-part"><a href="#mmc-part" class="headerlink" title="mmc part"></a>mmc part</h4><p>查看选中的设备对应的分区信息</p><h4 id="mmc-read"><a href="#mmc-read" class="headerlink" title="mmc read"></a>mmc read</h4><p>读取当前选中 mmc 设备的数据</p><pre><code class="bash">mmc read addr blk# cnt#eg:mmc read 80800000 600 10 # 从选中设备的第 1536(0x600)个块开始，读取 16(0x10)个块的数据到 DRAM 的0X80800000 地址处</code></pre><p>addr 是数据读取到 DRAM 中的地址， blk# 是要读取的块起始地址(十六进制)，一个块是 512字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区， cnt 是要读取的块数量(十六进制)。  </p><h4 id="mmc-write"><a href="#mmc-write" class="headerlink" title="mmc write"></a>mmc write</h4><p>将数据写入到当前选中 mmc 设备中</p><pre><code class="bash">mmc write addr blk# cnt#eg:mmc write 80800000 600 10 # 从 DRAM 的0X80800000 地址处写入 16(0x10)个块的数据到选中设备的第 1536(0x600)个块开始处</code></pre><p>addr 是数据写入到 DRAM 中的地址， blk# 是要写入的块起始地址(十六进制)，一个块是 512字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区， cnt 是要写入的块数量(十六进制)。  </p><h4 id="mmc-erase"><a href="#mmc-erase" class="headerlink" title="mmc erase"></a>mmc erase</h4><p>擦除 MMC 设备的指定块，最好别用</p><pre><code class="bash">mmc erase blk# cnt</code></pre><p>blk# 为要擦除的起始块， cnt 是要擦除的数量。  </p><h3 id="0-6FAT文件系统操作"><a href="#0-6FAT文件系统操作" class="headerlink" title="0.6FAT文件系统操作"></a>0.6FAT文件系统操作</h3><p>需要在 uboot 中对 SD 卡或者 EMMC 中存储的文件进行操作时需要用到该部分操作命令（只支持FAT格式）  </p><h4 id="fatinfo"><a href="#fatinfo" class="headerlink" title="fatinfo"></a>fatinfo</h4><p>查询指定 MMC 设置指定分区的文件系统信息</p><pre><code class="bash">fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]#eg:fatinfo mmc 1:1 # 查询 EMMC 设备（一般emmc为1，sd卡为0，通过mmc list可以查看）的分区 1 的文件系统信息</code></pre><p>interface 表示接口，比如 mmc。dev 是查询的设备号， part 是要查询的分区。</p><h4 id="fatls"><a href="#fatls" class="headerlink" title="fatls"></a>fatls</h4><p>查询 FAT 格式设备的目录和文件信息</p><pre><code class="bash">fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]#eg:fatls mmc 1:1</code></pre><p>interface 是要查询的接口，比如 mmc。dev 是要查询的设备号，part 是要查询的分区，directory是要查询的目录（默认为根目录<code>/</code>）</p><h4 id="fstype"><a href="#fstype" class="headerlink" title="fstype"></a>fstype</h4><p>查看 MMC 设备某个分区的文件系统格式</p><pre><code class="bash">fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;#eg:fstype mmc 1:1</code></pre><p>interface 是要查询的接口，比如 mmc。dev 是要查询的设备号，part 是要查询的分区</p><h4 id="fatload"><a href="#fatload" class="headerlink" title="fatload"></a>fatload</h4><p>将指定的文件读取到 DRAM 中</p><pre><code class="bash">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]#eg:fatload mmc 1:1 80800000 zImage # 将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的0X80800000 地址处</code></pre><p>interface 为接口，比如 mmc。 dev 是设备号， part 是分区， addr 是保存在 DRAM 中的起始地址， filename 是要读取的文件名字。 bytes 表示读取多少字节的数据（0或者省略表示读取整个文件）。pos 是要读的文件相对于文件首地址的偏移（0或者省略表示从文件首地址开始读取）  </p><h4 id="fatwrite"><a href="#fatwrite" class="headerlink" title="fatwrite"></a>fatwrite</h4><p>uboot 默认没有使能 fatwrite 命令，需要修改板子配置头文件来使能宏<code>CONFIG_FAT_WRITE</code>。该命令用于将 DRAM 中的数据写入到 MMC 设备中</p><pre><code class="bash">fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;#eg:fatwrite mmc 1:1 80800000 zImage 0x5c2720</code></pre><p>interface 为接口，比如 mmc， dev 是设备号， part 是分区， addr 是要写入的数据在 DRAM中的起始地址， filename 是写入的数据文件名字， bytes 表示要写入多少字节的数据</p><h3 id="0-7EXT文件系统操作"><a href="#0-7EXT文件系统操作" class="headerlink" title="0.7EXT文件系统操作"></a>0.7EXT文件系统操作</h3><p>uboot 有 ext2 和 ext4 这两种格式的文件系统的操作命令，常用的就四个命令，分别为：<code>ext2load</code>、 <code>ext2ls</code>、 <code>ext4load</code>、 <code>ext4ls</code> 和 <code>ext4write</code>。  这些命令与FAT文件系统的类似，在此不做过多叙述。</p><h3 id="0-8BOOT操作"><a href="#0-8BOOT操作" class="headerlink" title="0.8BOOT操作"></a>0.8BOOT操作</h3><h4 id="bootz"><a href="#bootz" class="headerlink" title="bootz"></a>bootz</h4><p>用于启动zImage镜像文件</p><pre><code class="bash">bootz [addr [initrd[:size]] [fdt]]#eg:bootz 80800000 – 83000000</code></pre><p>addr 是 Linux 镜像文件在 DRAM 中的位置， initrd 是 initrd 文件在DRAM 中的地址（不使用该参数可以用<code>-</code>代替）， fdt 就是设备树文件在 DRAM 中的地址。  </p><h4 id="bootm"><a href="#bootm" class="headerlink" title="bootm"></a>bootm</h4><p>与上述命令类似，但是是启动uImage镜像文件，如果不使用设备树，则命令为：</p><pre><code class="bash">bootm addr</code></pre><p>addr 是 uImage 镜像在 DRAM 中的首地址。如果要使用设备树则和bootz命令一致</p><h4 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h4><p>通过读取环境变量 bootcmd 来启动 Linux 系统</p><p>例子：</p><pre><code class="bash">setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;saveenvboot</code></pre><h3 id="0-9其他命令"><a href="#0-9其他命令" class="headerlink" title="0.9其他命令"></a>0.9其他命令</h3><h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>复位命令，不做过多解释</p><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><p>用于运行裸机程序</p><pre><code class="bash">go addr [arg ...]</code></pre><p>addr 是应用在 DRAM 中的首地址，arg是传入的参数</p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>用于运行环境变量中定义的命令</p><pre><code class="bash">setenv mybootemmc &#39;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ullalientek-emmc.dtb;bootz 80800000 - 83000000&#39;setenv mybootnand &#39;nand read 80800000 4000000 800000;nand read 83000000 6000000 100000;bootz 80800000 - 83000000&#39;setenv mybootnet &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;saveenvrun mybootemmcrun mytoobnandrun mybootnet</code></pre><h2 id="一、Makefile结构分析"><a href="#一、Makefile结构分析" class="headerlink" title="一、Makefile结构分析"></a>一、Makefile结构分析</h2><p>编译u-boot时，一般需要采取以下命令：</p><pre><code class="bash">make V=1 xxx_config # V=1输出全部内容make -j8</code></pre><p>下面依次介绍各命令的作用：</p><blockquote><p>其中会用到以下命令，提前熟悉下：</p><pre><code class="bash">#搜索文件内的变量名grep -nR &quot;变量名&quot;</code></pre></blockquote><h3 id="1、make-xxx-config"><a href="#1、make-xxx-config" class="headerlink" title="1、make xxx_config"></a>1、make xxx_config</h3><p>该命令会执行顶层Makefile中的目标<code>%config</code>，具体如下所示：</p><pre><code class="makefile">%config: scripts_basic outputmakefile FORCE    $(Q)$(MAKE) $(build)=scripts/kconfig $@</code></pre><p>其中一些变量在其他地方定义过，总结如下：</p><ul><li><p>相关参数值：</p><pre><code class="makefile">  #使用参数V=1时  Q = # 输出详细信息  #不使用参数V=1时  Q = @ # 此时输出信息为精简版  MAKE = make  build = -f ./scripts/Makefile.bulid obj</code></pre></li><li><p>outputmakefile为空，scripts_basic：</p><pre><code class="makefile">  scripts_basic:      $(Q)$(MAKE) $(build)=scripts/basic      $(Q)rm -f .tmp_quiet_recordmcount</code></pre><p>  展开后：</p><pre><code class="makefile">  scripts_basic:      make -f ./scripts/Makefile.bulid obj=scripts/basic      rm -f .tmp_quiet_recordmcount</code></pre></li><li><p><code>FORCE</code>表示会让该依赖每次都执行</p></li></ul><p>最后实际上运行的命令为：</p><pre><code class="makefile">#依赖中：make -f ./scripts/Makefile.bulid obj=scripts/basicrm -f .tmp_quiet_recordmcount # 删除文件，不用管#目标中：make -f ./scripts/Makefile.bulid obj=scripts/kconfig xxx_defconfig</code></pre><p>通过上述命令，可以看出都是调用<code>./scripts/Makefile.bulid</code>，该文件也可以视为Makefile，下面分析上述两条命令：</p><hr><p><strong>1、命令<code>make -f ./scripts/Makefile.bulid obj=scripts/basic</code>：</strong></p><p>未指定目标，即采取<code>./scripts/Makefile.bulid</code>文件中<code>PHONY</code>指定的默认目标：<code>__build</code>：</p><pre><code class="makefile">__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \     $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \     $(subdir-ym) $(always)    @:</code></pre><p>利用<code>echo</code>输出各变量，有：</p><pre><code class="makefile">#顶层Makefile中：KBUILD_MODULES :=KBUILD_BUILTIN := 1#echo直接输出：builtin-target = lib-target = extra-y = subdir-ym = always = /scripts/basic/fixdep</code></pre><p>综上，有：</p><pre><code class="makefile">__build: /scripts/basic/fixdep    @:</code></pre><p>所以这条命令只是<strong>编译可执行文件/scripts/basic/fixdep</strong></p><hr><p><strong>2、命令<code>make -f ./scripts/Makefile.bulid obj=scripts/kconfig xxx_defconfig</code>：</strong></p><p>在Makefile.bulid中通过<code>include $(kbuild-file)</code>，即调用<code>include ./scripts/kconfig/Makefile</code>，在这里边指定目标：</p><pre><code class="makefile">%_defconfig: $(obj)/conf    $(Q)$&lt; $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)</code></pre><p>这里替换掉各个变量后有：</p><pre><code class="makefile">%_defconfig: scripts/kconfig/conf    scripts/kconfig/conf --defconfig=arch/../configs/xxx_defconfig Kconfig</code></pre><p>即有：</p><ol><li>编译生成软件scripts/kconfig/conf</li><li>调用编译好的软件scripts/kconfig/conf生成配置输出文件<code>.config</code></li></ol><hr><h3 id="2、make"><a href="#2、make" class="headerlink" title="2、make"></a>2、make</h3><p>未指定目标，即采取Makefile文件中<code>PHONY</code>指定的默认目标，这里<code>PHONY</code>依赖有点多，但是重心为以下依赖：</p><p><code>PHONY</code>-&gt;<code>_all</code>-&gt;<code>$(ALL-y)</code></p><p>其中<code>$(ALL-y)</code>中的依赖也很多，但是重点是<code>u-boot.bin</code>依赖，且<code>u-boot.bin</code>依赖的文件也比较多，只需关注以下依赖即可：</p><pre><code class="makefile">u-boot.bin: u-boot-nodtb.bin FORCE    $(call if_changed,copy)#依赖u-boot-nodtb.bin：u-boot-nodtb.bin: u-boot FORCE    $(call if_changed,objcopy)    $(call DO_STATIC_RELA,$&lt;,$@,$(CONFIG_SYS_TEXT_BASE))    $(BOARD_SIZE_CHECK)#依赖u-boot：u-boot:    $(u-boot-init) $(u-boot-main) u-boot.lds FORCE    $(call if_changed,u-boot__)ifeq ($(CONFIG_KALLSYMS),y)    $(call cmd,smap)    $(call cmd,u-boot__) common/system_map.oendif#上述依赖中：u-boot-init := $(head-y)u-boot-main := $(libs-y)#其中head-y和CPU架构相关，在arch/arm/Makefile中：head-y := arch/arm/cpu/$(CPU)/start.o # 这里CPU = armv7#libs-y有很多，基本上为各种源码库，如lib</code></pre><ul><li><p><code>libs-y</code>会包括很多，但是基本上均为各种源码所对应的<code>.o</code>文件</p><pre><code class="makefile">  libs-y += lib/  libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/  libs-$(CONFIG_OF_EMBED) += dts/  libs-y += fs/  libs-y += net/  libs-y += disk/  libs-y += drivers/  ...  libs-y        := $(patsubst %/, %/built-in.o, $(libs-y))</code></pre><ul><li>最后的<code>libs-y := $(patsubst %/, %/built-in.o, $(libs-y))</code>调用了<code>patsubst</code>函数，将<code>libs-y</code>中的<code>/</code>替换为<code>/built-in.o</code>，即将原来的各个目录替换为了对应目录下的<code>built-in.o</code>文件</li><li><code>built-in.o</code>文件是通过相同文件夹下<code>.built-in.o.cmd</code>文件生成的</li></ul></li></ul><p>综上，最后简化后的makefile如下：</p><pre><code class="makefile">u-boot:    arch/arm/cpu/armv7/start.o lib/built-in.o ...(大量的built-in.o文件) u-boot.lds FORCE    $(call if_changed,u-boot__)</code></pre><ul><li>u-boot.lds为编译出的<strong>链接脚本</strong>（真正的链接脚本来自<code>arch/arm/cpu/u-boot.lds</code>）</li></ul><h3 id="3、链接脚本"><a href="#3、链接脚本" class="headerlink" title="3、链接脚本"></a>3、链接脚本</h3><h4 id="链接地址"><a href="#链接地址" class="headerlink" title="链接地址"></a>链接地址</h4><p>通过<code>make V=1 -j8</code>编译U-boot时，最后会输出<code>Entry Point: xxxxxxxx</code>，此地址即为链接地址</p><p>该地址可以通过编译输出时的log信息发现，在最后<strong>链接</strong>时，会加入<code>-Ttext xxxxxxxx</code>，即在链接过程中即指定了链接地址</p><p>通过<code>grep -nR &quot;xxxxxxxx&quot;</code>可以发现最后的链接地址来自于<code>include/configs/mx6_common.h</code>中的<strong><code>CONFIG_SYS_TEXT_BASE</code></strong>宏</p><h4 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h4><p>编译成功后会生成一个<code>u-boot.map</code>文件，其中包括了各段的具体地址，结合该<code>.lds</code>文件分析可以得到各段的地体地址</p><pre><code class="json">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)OUTPUT_ARCH(arm)ENTRY(_start) //入口地址 0x87800000 具体标号在arch/arm/lib/vectors.SSECTIONS{    . = 0x00000000;    . = ALIGN(4);    .text : //代码段    {        *(.__image_copy_start) //镜像起始地址 0x87800000        *(.vectors) //中断向量表地址        arch/arm/cpu/armv7/start.o (.text*) //start.o        *(.text*)    }    . = ALIGN(4);    .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }    . = ALIGN(4);    .data : { //data段        *(.data*)    }    . = ALIGN(4);    . = .;    . = ALIGN(4);    .u_boot_list : {        KEEP(*(SORT(.u_boot_list*))); //uboot命令存放段    }    . = ALIGN(4);    .image_copy_end :    {        *(.__image_copy_end) //镜像结束地址 0x8785dc6c 300k+    }    .rel_dyn_start :    {        *(.__rel_dyn_start) //rel段（重定位用）起始地址 0x8785dc6c    }    .rel.dyn : {        *(.rel*)    }    .rel_dyn_end :    {        *(.__rel_dyn_end) //rel段（重定位用）结束地址 0x878668a4 35k+    }    .end :    {        *(.__end) //总的代码结束地址 0x878668a4    }    _image_binary_end = .; //0x878668a4    . = ALIGN(4096);    .mmutable : {        *(.mmutable)    }    .bss_start __rel_dyn_start (OVERLAY) : {        KEEP(*(.__bss_start)); //bss段起始地址 0x8785dc6c        __bss_base = .;    }    .bss __bss_base (OVERLAY) : {        *(.bss*)         . = ALIGN(4);         __bss_limit = .;    }    .bss_end __bss_limit (OVERLAY) : {        KEEP(*(.__bss_end)); //bss段结束地址 0x878a8d74    }    .dynsym _image_binary_end : { *(.dynsym) }    .dynbss : { *(.dynbss) }    .dynstr : { *(.dynstr*) }    .dynamic : { *(.dynamic*) }    .plt : { *(.plt*) }    .interp : { *(.interp*) }    .gnu.hash : { *(.gnu.hash) }    .gnu : { *(.gnu*) }    .ARM.exidx : { *(.ARM.exidx*) }    .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }}</code></pre><h2 id="二、初始化流程"><a href="#二、初始化流程" class="headerlink" title="二、初始化流程"></a>二、初始化流程</h2><p>详见思维导图：<code>U-Boot启动流程.xmind</code></p><p><img src="//NU-LL.github.io/2019/08/12/u-boot分析与使用/U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="U-Boot启动流程"></p><h2 id="三、u-boot命令实现"><a href="#三、u-boot命令实现" class="headerlink" title="三、u-boot命令实现"></a>三、u-boot命令实现</h2><ol><li><p>所有命令通过结构体<code>cmd_tbl_t</code>进行封装（在<code>include/command.h</code>中定义）</p><pre><code class="c"> struct cmd_tbl_s {     char        *name;        /* Command Name            */     int        maxargs;    /* maximum number of arguments    */     int        repeatable;    /* autorepeat allowed?        */                     /* Implementation function    */     int        (*cmd)(struct cmd_tbl_s *, int, int, char * const []);     char        *usage;        /* Usage message    (short)    */ #ifdef    CONFIG_SYS_LONGHELP     char        *help;        /* Help  message    (long)    */ #endif #ifdef CONFIG_AUTO_COMPLETE     /* do auto completion on the arguments */     int        (*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]); #endif }; typedef struct cmd_tbl_s    cmd_tbl_t;</code></pre></li><li><p>所有命令通过结构体中的<code>name</code>成员进行查找</p></li><li><p>这些结构体存在一个uboot自定义的段内：</p><pre><code class="json"> SECTIONS {     ...     .u_boot_list : {         KEEP(*(SORT(.u_boot_list*))); //uboot命令存放段     }     ... }</code></pre></li><li><p>通过宏<code>U_BOOT_CMD</code>可以快速定义这些命令结构体：</p><pre><code class="c">U_BOOT_CMD(名字,最大参数,是否可重复,cmd函数,短字符串,长字符串);</code></pre><blockquote><p>例子：</p><pre><code class="c">U_BOOT_CMD(     bootm,    CFG_MAXARGS,    1,    do_bootm,     &quot;bootm   - boot application image from memory\n&quot;,     &quot;[addr [arg ...]]\n    - boot application image stored in memory\n&quot;     &quot;\tpassing arguments &#39;arg ...&#39;; when booting a Linux kernel,\n&quot;     &quot;\t&#39;arg&#39; can be the address of an initrd image\n&quot;#ifdef CONFIG_OF_FLAT_TREE    &quot;\tWhen booting a Linux kernel which requires a flat device-tree\n&quot;    &quot;\ta third argument is required which is the address of the of the\n&quot;    &quot;\tdevice-tree blob. To boot that kernel without an initrd image,\n&quot;    &quot;\tuse a &#39;-&#39; for the second argument. If you do not pass a third\n&quot;    &quot;\ta bd_info struct will be passed instead\n&quot;#endif);</code></pre></blockquote></li></ol><h2 id="四、一般的移植思路"><a href="#四、一般的移植思路" class="headerlink" title="四、一般的移植思路"></a>四、一般的移植思路</h2><ol><li>芯片厂商或者<a href="https://www.denx.de/wiki/U-Boot/SourceCode" target="_blank" rel="noopener">uboot官网</a>找到uboot的源码</li><li>直接在<code>configs/</code>下复制类似芯片或板卡的<code>xxx_defconfig</code>默认配置文件</li><li>在<code>include/configs</code>下找到类似芯片或板卡的配置头文件，直接复制</li><li>在<code>board/</code>下找到类似芯片或板卡的板级文件夹，直接复制</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> u-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>u-boot分析与使用</title>
      <link href="/2019/08/12/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8%20-%20%E8%80%81%E7%89%88%E6%9C%AC%E5%A4%87%E4%BB%BD/"/>
      <url>/2019/08/12/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/u-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8%20-%20%E8%80%81%E7%89%88%E6%9C%AC%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="u-boot分析与使用"><a href="#u-boot分析与使用" class="headerlink" title="u-boot分析与使用"></a>u-boot分析与使用</h1><h2 id="一、Makefile结构分析"><a href="#一、Makefile结构分析" class="headerlink" title="一、Makefile结构分析"></a>一、Makefile结构分析</h2><h3 id="1、make-100ask24x0-config配置芯片类型"><a href="#1、make-100ask24x0-config配置芯片类型" class="headerlink" title="1、make 100ask24x0_config配置芯片类型"></a>1、make 100ask24x0_config配置芯片类型</h3><p>打开u-boot-1.1.6/Makefile文件，发现：</p><pre><code class="makefile">SRCTREE    := $(CURDIR) *CURDIR是make的内嵌变量， 为当前目录......MKCONFIG    := $(SRCTREE)/mkconfig......100ask24x0_config    :    unconfig@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</code></pre><p>上述$(SRCTREE)等于​$(CURDIR)，也就是当前目录u-boot-1.1.6，所以MKCONFIG=./mkconfig<br>上述$(@:_config=)的结果就是将 “100ask24x0_config” 中的 “_config” 去掉， 结果为 “100ask24x0” 。<br><strong>实际执行:</strong></p><pre><code class="makefile">mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0  $0         $1     $2    $3        $4      $5     $6 </code></pre><h4 id="mkconfig脚本分析"><a href="#mkconfig脚本分析" class="headerlink" title="mkconfig脚本分析"></a>mkconfig脚本分析</h4><p>显然这里是调用的mkconfig，打开当前目录u-boot-1.1.6下的该文件(用的linux_shell语法，可以参考《精通linux_shell编程教程pdf完整版》以及Linux应用开发手册第264页U-Boot配置过程)，在第6行中给出了mkconfig的用法：</p><pre><code class="makefile"># Parameters: Target Architecture CPU Board [VENDOR] [SOC]</code></pre><p>刚好对应mkconfig(参数) 100ask24x0(目标) arm(架构) arm920t(cpu)100ask24x0(开发板选型) NULL(供应商) s3c24x0(片上系统/芯片) 。</p><p>通过分析，精简后的mkconfig文件：</p><pre><code class="bash">#!/bin/sh -e# Parameters:  Target  Architecture  CPU  Board [VENDOR] [SOC]# mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0APPEND=no    # Default: Create new config fileBOARD_NAME=&quot;&quot;    # Name to print in make outputwhile [ $# -gt 0 ] ; do    #不运行done[ &quot;${BOARD_NAME}&quot; ] || BOARD_NAME=&quot;$1&quot;#BOARD_NAME=100ask24x0# $#:参数的个数[ $# -lt 4 ] &amp;&amp; exit 1#不运行[ $# -gt 6 ] &amp;&amp; exit 1#不运行echo &quot;Configuring for ${BOARD_NAME} board...&quot;## Create link to architecture specific headers#if [ &quot;$SRCTREE&quot; != &quot;$OBJTREE&quot; ] ; then#通过Makefile发现相等    #不运行else    cd ./include#进入include目录    rm -f asm    ln -s asm-$2 asm#ln -s asm-arm asm：建立链接文件asm，指向asm-armfirm -f asm-$2/arch#rm -f asm-arm/arch：删除文件if [ -z &quot;$6&quot; -o &quot;$6&quot; = &quot;NULL&quot; ] ; then#第6个参数为空或等于NULL    ln -s ${LNPREFIX}arch-$3 asm-$2/arch#不运行else    ln -s ${LNPREFIX}arch-$6 asm-$2/arch#ln -s arch-s3c24x0 asm-arm/arch：建立链接文件asm-arm/arch，指向arch-s3c24x0fiif [ &quot;$2&quot; = &quot;arm&quot; ] ; then    rm -f asm-$2/proc#删除文件    ln -s ${LNPREFIX}proc-armv asm-$2/proc#ln -s proc-armv asm-arm/proc：建立链接文件asm-arm/proc，指向proc-armvfi## Create include file for Make#echo &quot;ARCH   = $2&quot; &gt;  config.mk#新建config.mkecho &quot;CPU    = $3&quot; &gt;&gt; config.mk#追加echo &quot;BOARD  = $4&quot; &gt;&gt; config.mk[ &quot;$5&quot; ] &amp;&amp; [ &quot;$5&quot; != &quot;NULL&quot; ] &amp;&amp; echo &quot;VENDOR = $5&quot; &gt;&gt; config.mk#不会执行[ &quot;$6&quot; ] &amp;&amp; [ &quot;$6&quot; != &quot;NULL&quot; ] &amp;&amp; echo &quot;SOC    = $6&quot; &gt;&gt; config.mk## Create board specific header file#if [ &quot;$APPEND&quot; = &quot;yes&quot; ]    #第五行：APPEND=nothen    echo &gt;&gt; config.helse    &gt; config.h        #新建config.hfiecho &quot;/* Automatically generated - do not edit */&quot; &gt;&gt;config.hecho &quot;#include &lt;configs/$1.h&gt;&quot; &gt;&gt;config.hexit 0</code></pre><p>发现会创建include/config.mk文件：</p><pre><code>  ARCH = arm  CPU = arm920t  BOARD = 100ask24x0  SOC = s3c24x0</code></pre><p>以及include/config.h</p><pre><code class="c">/* Automatically generated - do not edit */#include &lt;configs/100ask24x0.h&gt;</code></pre><h4 id="mkconfig脚本总结"><a href="#mkconfig脚本总结" class="headerlink" title="mkconfig脚本总结"></a>mkconfig脚本总结</h4><ol><li><p>创建相关的头文件链接：</p><pre><code class="bash"> ln -s asm-arm asm ln -s arch-s3c24x0 asm-arm/arch ln -s proc-armv asm-arm/proc</code></pre></li><li><p>创建顶层makefile包含的文件include/config.mk</p><pre><code>   ARCH = arm   CPU = arm920t   BOARD = 100ask24x0   SOC = s3c24x0</code></pre></li><li><p>创建开发板相关的头文件include/config.h</p><pre><code class="c"> /* Automatically generated - do not edit */ #include &lt;configs/100ask24x0.h&gt;</code></pre></li></ol><h3 id="2、make-编译u-boot"><a href="#2、make-编译u-boot" class="headerlink" title="2、make 编译u-boot"></a>2、make 编译u-boot</h3><p>u-boot-1.1.6/Makefile文件:</p><pre><code class="makefile">include $(OBJTREE)/include/config.mk//调用config.mk这个文件...ifeq ($(ARCH),ppc)//判断config.mk这个文件中ARCH是否等于ppcCROSS_COMPILE = powerpc-linux- endififeq ($(ARCH),arm)//判断config.mk这个文件中ARCH是否等于armCROSS_COMPILE = arm-linux- endif...include $(TOPDIR)/config.mk</code></pre><p>最后的config.mk是属于顶层目录的config,主要通过arm，arm920t，100ask24x0，s3c24x0来确定编译器、编译选项等</p><p>顶层的config.mk部分为：</p><pre><code class="bash">...LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)...</code></pre><p>这里的<code>LDFLAGS</code>就是下文中的<code>$(LDFLAGS)</code></p><ul><li><code>$(LDSCRIPT)</code>：链接脚本</li><li><code>$(TEXT_BASE)</code>：board/100ask24x0/config.mk中定义，为链接脚本的起始地址</li></ul><p>继续看，发现all目标：</p><pre><code class="makefile">...ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)//all的依赖文件all:    $(ALL)//使用make命令,相当于执行make all ...$(obj)u-boot.bin:   $(obj)u-boot//生成u-boot.bin需要elf格式的u-boot，elf也就是通过ld链接文件生成的。$(OBJCOPY) ${OBJCFLAGS} -O binary $&lt; $@//执行:arm-linux-objcopy -O binary u-boot u-boot.bin...$(obj)u-boot:   depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)//生成elf格式的u-boot所需要的依赖文件        UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed -n -e &#39;s/.*\(__u_boot_cmd_.*\)/-u\1/p&#39;|sort|uniq`;\        cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \                                   --start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \            -Map u-boot.map -o u-boot</code></pre><p>上述10行开始就是开始制作elf格式的u-boot，具体展开的命令可以看make后命令行最后输出的命令，值得注意的是这中间包含的<strong>链接脚本</strong>，他决定了各种.o文件是怎么组织的（注意<code>$(LDFLAGS)</code>）</p><p>通过make后命令行输出的命令：</p><pre><code class="bash">......&amp;&amp;arm-linux-ld -Bstatic -T /work/system/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000 $UNDEF_SYM cpu/arm920t/start.o......</code></pre><p>可以发现链接脚本为<code>board/100ask24x0/u-boot.lds</code>，并且通过<strong>-Ttext</strong>参数确定链接脚本的起始地址为0x33F80000</p><blockquote><p>开发板有64M的SDRAM，SDRAM从0x3000 0000开始，0x33F80000到SDRAM的结束地址刚好为512k</p></blockquote><p>同时，第一个链接的文件为cpu/arm920t/start.o，若链接脚本中没有明确指定那个文件在代码段（text段）的开头，该文件就是第一个被执行的文件</p><h4 id="链接脚本分析"><a href="#链接脚本分析" class="headerlink" title="链接脚本分析"></a>链接脚本分析</h4><pre><code>OUTPUT_ARCH(arm)//设置输出文件的体系架构。ENTRY(_start)//将_start这个全局符号设置成入口地址,进行复位初始化SECTIONS//输出文件的内容布局{    . = 0x00000000;//指定地址0x00000000,最终运行地址在0x33F80000+0x00000000    . = ALIGN(4);//代码以4字节对齐    .text ://指定.text section段(位于0x33F80000)    {        cpu/arm920t/start.o (.text)//添加第一个目标文件cpu/arm920t/start.o里面的.text代码段        board/100ask24x0/boot_init.o (.text)//添加第二个目标文件board/100ask24x0/boot_init.o里面的.text代码段        *(.text)//*(.data) 表示添加剩下的全部文件的.text代码段    }    . = ALIGN(4);    .rodata : { *(.rodata) }//指定.rodata section段(位于0x33F80000+.text section),将所有的.rodata只读数据段合并成一个.rodata只读数据段    . = ALIGN(4);    .data : { *(.data) }//指定读写数据段    . = ALIGN(4);    .got : { *(.got) }//指定got段，got段是uboot自定义的一个段    . = .;    __u_boot_cmd_start = .;//把__u_boot_cmd_start赋值为当前位置, 即起始位置    .u_boot_cmd : { *(.u_boot_cmd) }// u_boot_cmd段，所有的u-boot命令相关的定义都放在这个位置    __u_boot_cmd_end = .;// *u_boot_cmd段结束位置    . = ALIGN(4);    __bss_start = .;//把__bss_start赋值为当前位置,即bss段的开始位置    .bss : { *(.bss) }//指定bss段，这里NOLOAD的意思是这段不需装载，仅在执行域中才会有这段    _end = .;//把_end赋值为当前位置,即bss段的结束位置}</code></pre><p>发现第一个文件是<code>cpu/arm920t/start.S</code></p><h2 id="二、start-S——硬件初始化"><a href="#二、start-S——硬件初始化" class="headerlink" title="二、start.S——硬件初始化"></a>二、start.S——硬件初始化</h2><ol><li><p>跳到reset处，执行复位函数</p></li><li><p>设为SVC(管理员)模式、f关闭看门狗、关闭中断、CPU的相关初始化（SDRAM初始化）</p></li><li><p>设置堆栈，为之后进入C函数做准备</p><pre><code class="assembly"> /* Set up the stack                            */ stack_setup:     ldr    r0, _TEXT_BASE/*_TEXT_BASE，代码段起始地址，就是之前的0x33F80000*/     sub    r0, r0, #CFG_MALLOC_LEN    /* malloc area                      */     sub    r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */ #ifdef CONFIG_USE_IRQ     sub    r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ) #endif     sub    sp, r0, #12        /* leave 3 words for abort-stack  最后sp指针的位置  */ #ifndef CONFIG_SKIP_LOWLEVEL_INIT     bl clock_init/*跳到C函数初始化时钟（自己写的，一般为汇编写的）*/ #endif</code></pre></li><li><p><strong>重定位</strong></p><pre><code class="assembly"> //搬移代码，将完整的u-boot从flash（NOR、NAND）中搬移到SDRAM中的链接地址去 #ifndef CONFIG_SKIP_RELOCATE_UBOOT relocate:                /* relocate U-Boot to RAM        */     adr    r0, _start        /* r0 &lt;- current position of code   */     ldr    r1, _TEXT_BASE        /* test if we run from flash or RAM */     cmp     r0, r1                  /* don&#39;t reloc during debug         */     beq     clear_bss     ldr    r2, _armboot_start     ldr    r3, _bss_start     sub    r2, r3, r2        /* r2 &lt;- size of armboot            */ #if 1     bl  CopyCode2Ram    /* r0: source, r1: dest, r2: size */ #else</code></pre></li><li><p>清除BSS段，全部清为0</p><blockquote><p>_bss_start 和 _bss_end由链接脚本决定</p></blockquote><pre><code class="assembly"> clear_bss:     ldr    r0, _bss_start        /* find start of bss segment        */     ldr    r1, _bss_end        /* stop here                        */     mov     r2, #0x00000000        /* clear                            */ clbss_l:str    r2, [r0]        /* clear loop...                    */     add    r0, r0, #4     cmp    r0, r1     ble    clbss_l</code></pre></li><li><p>调用C函数<code>start_armboot</code></p><pre><code class="assembly"> ldr    pc, _start_armboot _start_armboot:    .word start_armboot</code></pre></li></ol><blockquote><p>注意：</p><p>ldr是<strong>位置有关码</strong>，将_start_armboot这个标号的值作为地址，<strong>取出其中的值</strong>（即start_armboot的位置，该位置是通过链接脚本指定的）赋值给pc，所以无论该代码现在运行在哪里（芯片内部SRAM、外部NOR FLASH或者外部SDRAM）都会跳转到已经拷贝到的外部SDRAM中的start_armboot中去</p><p>实例：</p><p>若此时该汇编代码运行在芯片内部SRAM中，前期通过搬移已经将完整的u-boot搬移至片外SDRAM中，链接脚本指定的链接地址（运行地址）为<code>33f80000</code>，设此时汇编所对应的反汇编为：</p><pre><code class="assembly">#链接地址     机器码          反汇编指令33f80070:    e59ff04c     ldr    pc, [pc, #76]    ; 33f800c4......33f800c4:    33f805a0     mvnccs    r0, #671088640    ; 0x28000000......33f805a0 &lt;start_armboot&gt;:33f805a0:    e92d4030     stmdb    sp!, {r4, r5, lr}</code></pre><p>此时第一行中的代码肯定是在片内SRAM中运行的，所以该行代码所处的实际物理地址应该是0x33f8 0070-0x33f8 0000=0x70，通过pc+8+76=pc+84=pc+0x54，得出pc应该赋值为地址0x70+0x54=0xc4中的值，即此时pc等于0xc4处所储存的数据33f805a0，正好对应start_armboot的链接地址。即下一刻跳转到片外的SDRAM中的start_armboot函数</p><p><strong>总结</strong>：</p><p>重定位前的代码应该使用<strong>位置无关码</strong>来写，以确保不同位置都可运行</p><blockquote><ol><li>使用相对跳转指令：B、BL</li><li>不可使用绝对地址，不可访问全局变量、静态变量（根本方法是看反汇编）</li><li>不能访问有初始值的数组，这种数组（指局部数组，全局变量不能使用）本身会存在栈中，但是初始值会在rodata段中，访问这些数据的值会用绝对地址进行访问</li></ol></blockquote><p>重定位后的跳转到SDRAM代码应该用<strong>位置有关码</strong>（LDR）来写，以确保可以跳到外部SDRAM中的运行地址去运行</p></blockquote><h2 id="三、start-armboot"><a href="#三、start-armboot" class="headerlink" title="三、start_armboot"></a>三、start_armboot</h2><p>该函数会：</p><ol><li><p>初始化堆栈，用于自定义的malloc和free</p></li><li><p>拥有<strong>读写flash的能力</strong></p><blockquote><p>NOR：Flash_init</p><p>NAND：nand_init</p></blockquote></li><li><p>跳到<code>main_loop</code>函数</p><pre><code class="c"> /* main_loop() can return to retry autoboot, if so just run it again. */ for (;;) {     main_loop (); }</code></pre><p> main_loop函数可以等待用户输入相关的命令或者是通过uboot中的环境变量bootcmd中的命令启动linux内核</p><p> 而main_loop函数的核心在于<code>getenv</code>函数和<code>run_command</code>函数，前者负责从uboot中的环境变量中取出对应的数据，后者负责执行相关的命令</p></li></ol><h2 id="四、u-boot命令实现"><a href="#四、u-boot命令实现" class="headerlink" title="四、u-boot命令实现"></a>四、u-boot命令实现</h2><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><ol><li><p>所有命令通过一个结构体进行封装（cmd_tb1_t）</p></li><li><p>所有命令通过结构体中的name成员进行查找</p></li><li><p>这些结构体存在一个uboot自定义的段内，在之前的链接脚本中已经进行声明了段的起始和结束地址：</p><pre><code>. = .; __u_boot_cmd_start = .;//把__u_boot_cmd_start赋值为当前位置, 即起始位置 .u_boot_cmd : { *(.u_boot_cmd) }// u_boot_cmd段，所有的u-boot命令相关的定义都放在这个位置 __u_boot_cmd_end = .;// *u_boot_cmd段结束位置</code></pre></li></ol><blockquote><p>通过搜索.u_boot_cmd可以找到怎样将这些结构体放入这个段中（利用__attribute__关键字）</p><p>通过搜索常用命令（如：bootm）可以找到相关的定义这些结构体的方法</p></blockquote><ol start="4"><li><p>通过宏U_BOOT_CMD定义这些命令结构体</p><pre><code class="c">U_BOOT_CMD(名字,最大参数,是否可重复,cmd函数,短字符串,长字符串);</code></pre><blockquote><p>例子：</p><pre><code class="c">U_BOOT_CMD(     bootm,    CFG_MAXARGS,    1,    do_bootm,     &quot;bootm   - boot application image from memory\n&quot;,     &quot;[addr [arg ...]]\n    - boot application image stored in memory\n&quot;     &quot;\tpassing arguments &#39;arg ...&#39;; when booting a Linux kernel,\n&quot;     &quot;\t&#39;arg&#39; can be the address of an initrd image\n&quot;#ifdef CONFIG_OF_FLAT_TREE    &quot;\tWhen booting a Linux kernel which requires a flat device-tree\n&quot;    &quot;\ta third argument is required which is the address of the of the\n&quot;    &quot;\tdevice-tree blob. To boot that kernel without an initrd image,\n&quot;    &quot;\tuse a &#39;-&#39; for the second argument. If you do not pass a third\n&quot;    &quot;\ta bd_info struct will be passed instead\n&quot;#endif);</code></pre></blockquote></li></ol><h2 id="五、启动内核"><a href="#五、启动内核" class="headerlink" title="五、启动内核"></a>五、启动内核</h2><p>uboot启动内核是依赖以下两条命令：</p><pre><code class="c">s = getenv (&quot;bootcmd&quot;);</code></pre><pre><code class="c">run_command (s, 0);</code></pre><p>这里的<code>s</code>为环境变量<code>bootcmd</code>中的值，即</p><pre><code class="bash">nand read.jffs2 0x30007EC0 kernel;//从kernel分区读出内核放到0x30007EC0位置bootm 0x30007EC0//从0x30007EC0位置启动内核</code></pre><p>这里的分区在源码中已经写死，位置为：<code>include/configs/a00ask24x0.h</code>中的<code>MTDPARTS_DEFAULT</code>宏：</p><pre><code class="c">#define MTDPARTS_DEFAULT &quot;mtdparts=nandflash0:256k@0(bootloader),&quot; \/*0开始的256k为bootloader*/                            &quot;128k(params),&quot; \/*接下来的128k为环境变量*/                            &quot;2m(kernel),&quot; \                            &quot;-(root)&quot;</code></pre><p>在uboot下可以通过<code>mtd</code>命令读取，kernel结果为0x0006 0000起始，大小为0x0020 0000，故原来的指令可以改写为：</p><pre><code>nand read.jffs2 0x30007EC0 0x00060000 0x00200000;//从0x00060000读出0x00200000大小数据放到0x30007EC0位置bootm 0x30007EC0//从0x30007EC0位置启动内核</code></pre><h3 id="nand命令"><a href="#nand命令" class="headerlink" title="nand命令"></a>nand命令</h3><p>通过全局搜索<code>nand</code>可以搜索到其命令函数在<code>common/cmd_nand.c</code>下的do_nand函数，简化后：</p><pre><code class="c">int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[]){    int i, dev, ret;    ulong addr, off, size;    char *cmd, *s;    nand_info_t *nand;    int quiet = 0;    const char *quiet_str = getenv(&quot;quiet&quot;);    /* at least two arguments please */    if (argc &lt; 2)        goto usage;    if (quiet_str)        quiet = simple_strtoul(quiet_str, NULL, 0) != 0;    cmd = argv[1];    ......    /* read write */    if (strncmp(cmd, &quot;read&quot;, 4) == 0 || strncmp(cmd, &quot;write&quot;, 5) == 0) {        int read;        if (argc &lt; 4)            goto usage;        addr = (ulong)simple_strtoul(argv[2], NULL, 16);        read = strncmp(cmd, &quot;read&quot;, 4) == 0; /* 1 = read, 0 = write */        printf(&quot;\nNAND %s: &quot;, read ? &quot;read&quot; : &quot;write&quot;);        if (arg_off_size(argc - 3, argv + 3, nand, &amp;off, &amp;size) != 0)            return 1;        s = strchr(cmd, &#39;.&#39;);        if (s != NULL &amp;&amp;            (!strcmp(s, &quot;.jffs2&quot;) || !strcmp(s, &quot;.e&quot;) || !strcmp(s, &quot;.i&quot;))) {            if (read) {                /* read */                nand_read_options_t opts;                memset(&amp;opts, 0, sizeof(opts));                opts.buffer = (u_char*) addr;                opts.length = size;                opts.offset = off;                opts.quiet      = quiet;                ret = nand_read_opts(nand, &amp;opts);            } else {                /* write */                ......            }        }        ......        printf(&quot; %d bytes %s: %s\n&quot;, size,               read ? &quot;read&quot; : &quot;written&quot;, ret ? &quot;ERROR&quot; : &quot;OK&quot;);        return ret == 0 ? 0 : 1;    }usage:    printf(&quot;Usage:\n%s\n&quot;, cmdtp-&gt;usage);    return 1;}</code></pre><p>最后是调用的<code>nand_read_opts</code>读出的内核</p><h3 id="bootm命令"><a href="#bootm命令" class="headerlink" title="bootm命令"></a>bootm命令</h3><p>Flash上储存的是uImage=头部+zImage，其中头部为：</p><pre><code class="c">typedef struct image_header {    uint32_t    ih_magic;    /* Image Header Magic Number    */    uint32_t    ih_hcrc;    /* Image Header CRC Checksum    */    uint32_t    ih_time;    /* Image Creation Timestamp    */    uint32_t    ih_size;    /* Image Data Size        */    uint32_t    ih_load;    /* Data     Load  Address        */    uint32_t    ih_ep;        /* Entry Point Address        */    uint32_t    ih_dcrc;    /* Image Data CRC Checksum    */    uint8_t        ih_os;        /* Operating System        */    uint8_t        ih_arch;    /* CPU architecture        */    uint8_t        ih_type;    /* Image Type            */    uint8_t        ih_comp;    /* Compression Type        */    uint8_t        ih_name[IH_NMLEN];    /* Image Name        */} image_header_t;</code></pre><p>这里有以下两个成员值得关注：</p><ul><li>ih_load：加载地址，即运行时放在那里（加载地址&lt;—&gt;存储地址）</li><li>ih_ep：入口地址，运行内核是跳转的地址（运行地址&lt;—&gt;链接地址）</li></ul><p>bootm命令流程：</p><ol><li><p>读取头部信息，并根据头部信息移动内核到<code>ih_load</code>处</p><blockquote><p>uboot环境变量中的启动命令：</p><p>nand read.jffs2 0x30007EC0 0x00060000 0x00200000;</p><p>上述ih_load在本文所处的环境中为0x30008000 ，而头部信息刚好64字节，所以这里0x30007EC0=0x30008000 - 64，即提前将linux内核搬移到指定位置，避免bootm命令中重复搬移</p></blockquote></li><li><p>通过<code>do_bootm_linux</code>启动内核</p><ol><li><p>设置启动参数（各种tag：开始tag、命令行tag、结束tag…..）</p><blockquote><p>这里的命令行tag就是uboot中的环境变量bootargs中的值</p><p>本文所处的环境中：</p><p>bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</p></blockquote></li><li><p>跳转到入口地址<code>ih_ep</code>处，并将机器id和启动参数的所在地址一并传入</p><blockquote><p>linux内核会根据不同的机器id来决定是否支持该板卡</p></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> u-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种存储器的区别</title>
      <link href="/2019/08/11/%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/11/%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="各种存储器的区别"><a href="#各种存储器的区别" class="headerlink" title="各种存储器的区别"></a>各种存储器的区别</h1><p>存储器可以分为很多种类，其中根据<em>掉电后数据是否丢失</em>可以分为易失性存储器<strong>RAM</strong>(Random Access Memory，随机存取存储器)和非易失性存储器<strong>ROM</strong> (Read Only Memory，只读存储器)，均为半导体存储器。其中RAM的访问速度比较快，但掉电后数据会丢失，而ROM掉电后数据不会丢失。人们通常所说的内存即指系统中的RAM。</p><hr><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>RAM 有两大类，一种称为静态 RAM (Static RAM，即<strong>SRAM</strong>)，SRAM 速度非常快，是目前读写最快的设备了，但是它也非常昂贵，所以只在要求很苛刻的地方使用，比如CPU的一级缓冲，二级缓冲。另一种称为动态 RAM(Dynamic RAM，即<strong>DRAM</strong>)，DRAM保留数据的时间很短，速度也比 SRAM 慢，不过他还是比任何的 ROM 都要快，但从价格上来说 DRAM 相比 SRAM 要便宜很多，计算机内存就是 DRAM。</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>DRAM (Dynamic Random Access Memory)，即动态存储器。DRAM分为很多种，常见的主要有 FPRAM/FastPage、EDORAM、SDRAM、DDR RAM、RDRAM、SGRAM以及WRAM等。</p><h4 id="SDRAM"><a href="#SDRAM" class="headerlink" title="SDRAM"></a>SDRAM</h4><p>SDRAM（Synchronous DRAM），同步动态随机存储器。目前的168线64bit带宽内存基本上都采用SDRAM芯片，工作电压3.3V电压，存取速度高达7.5ns，而EDO内存最快为15ns。并将RAM与CPU以相同时钟频率控制，使RAM与CPU外频同步，取消等待时间。所以其传输速率比EDO DRAM更快。</p><h4 id="DDR-RAM（DDR-SDRAM）"><a href="#DDR-RAM（DDR-SDRAM）" class="headerlink" title="DDR RAM（DDR SDRAM）"></a>DDR RAM（DDR SDRAM）</h4><p>DDR RAM(Double Data Rate RAM)也称作 DDR SDRAM，这种改进型的RAM 和 SDRAM是基本一样的，不同之处在于SDRAM仅在时钟信号的上升沿读取数据，而DDR在时钟信号的上升沿和下降沿都读取数据，因此，它的速度是标准SDRAM的2倍。这是目前电脑中用的最多的内存，而且它有着成本优势，事实上击败了Intel的另外一种内存标准-Rambus DRAM。在很多高端的显卡上，也配备了高速 DDR RAM 来提高带宽，这可以大幅度提高 3D 加速卡的像素渲染能力。</p><h4 id="DDR2-RAM"><a href="#DDR2-RAM" class="headerlink" title="DDR2 RAM"></a>DDR2 RAM</h4><p>速度在DDR RAM的基础上再翻一倍</p><h4 id="DDR3-RAM"><a href="#DDR3-RAM" class="headerlink" title="DDR3 RAM"></a>DDR3 RAM</h4><p>速度在DDR2 RAM的基础上再翻一倍</p><h4 id="RDRAM"><a href="#RDRAM" class="headerlink" title="RDRAM"></a>RDRAM</h4><p>RDRAM（Rambus DRAM）：总线式动态随机存储器，是由RAMBUS公司与INTEL公司合作提出的一项专利技术，它的数据传输率最高可达800MHZ，而它的总线宽度却仅为16bit，远远小于现在的SDRAM的64bit。</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM（Static Random Access Memory），即静态随机访问存储器，他是一种类型的半导体存储器。</p><ul><li>”<strong>静态</strong>“是指只要不掉电，存储在SRAM中的数据就不会丢失。这一点与动态RAM(DRAM)不同，DRAM 需要进行周期性的刷新操作。然后，我们不应该将SRAM与只读存储器(ROM)和 FLASH Memory 相混淆，因为SRAM是一种易失性存储器，它只有在电源保持连续供应的情况下才能够保存数据。</li><li>”<strong>随机访问</strong>“是指存储器的内容可以以任何顺序访问，而不管前一次访问的是哪一个位置。</li></ul><blockquote><p>结构原理：</p><p>SRAM中的每一位均存储在四个晶体管当中，这四个晶体管组成了两个交叉耦合反向器。这个存储单元具有两个稳定状态，通常表示为0和1.另外还需要两个访问晶体管用于控制读或写操作过程中存储单元的访问。因此，一个存储位通常需要六个 MOSFET。对称的电路结构使得SRAM的访问速度要快于DRAM。<strong>SRAM比DRAM访问速度快的另一个原因是SRAM可以一次接收所有的地址位，而DRAM则使用行地址和列地址复用的结构。</strong></p></blockquote><p>SRAM不应该与SDRAM相混淆，<strong>SDRAM代表的是同步DRAM(Synchronous DRAM)</strong>,这与SRAM是完全不同打的。</p><p>SRAM也不应该与PSRAM相混淆，PSRAM是一种伪装成SRAM的DRAM。</p><p>从晶体管的类型分，SRAM可以分为双极性与CMOS两种。从功能上分，SRAM可以分为异步SRAM和同步SRAM(SSRAM)。异步SRAM的访问独立于时钟，数据输入和输出都由地址的变化控制。同步SRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均与时钟信号相关。</p><hr><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM 也有很多种，PROM 是可编程的 ROM，EPROM 是可擦除可编程 ROM。两者区别是，PROM 是一次性的，也就是灌入软件后，就无法修改了，而 EPROM 是通过紫外光的照射擦除原先的程序，是一种通用的存储器另外一种EEPROM是通过电子擦除，价格很高，写入时间长，效率慢。</p><hr><h2 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h2><p><strong>FLASH 存储器</strong>又称闪存，它结合了ROM和RAM的长处，不仅具备电子可擦除可编程(EEPROM)的性能，还不会断点丢失数据，同事还可以快速读取数据(NVRAM的优势)，U盘和MP3里用的有时这种存储器。目前 FLASH 主要用两种：<strong>NOR FLASH</strong> 和 <strong>NAND FLASH</strong>。</p><h3 id="NOR-FLASH"><a href="#NOR-FLASH" class="headerlink" title="NOR FLASH"></a>NOR FLASH</h3><p>NOR FLASH的读取和我们常见的 SDRAM 的读取是一样的，用户可以直接运行装载在 NOR FLASH 里面的代码，这样可以减少  SRAM 的容量从而节约了成本。</p><h3 id="NAND-FLASH"><a href="#NAND-FLASH" class="headerlink" title="NAND FLASH"></a>NAND FLASH</h3><p>NAND FLASH 没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的 FLASH 比较廉价。用户不能直接运行NAND FLASH 上的代码，因此好多使用 NAND FLASH 的开发板除了使用 NAND FLASH以外，还作上了一块小的 NOR FLASH来运行启动代码。一般小容量的用NOR FLASH，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用NAND FLASH，最常见的 NAND FLASH 应用是嵌入式设备采用的 DOC(Disk On Chip)和我们通常用打的闪盘(U盘)，可以在线擦除。</p><blockquote><p>eMMC</p><p>eMMC (Embedded Multi Media Card）是MMC协会订立、主要针对手机或平板电脑等产品的内嵌式存储器标准规格。</p><p>NAND Flash和eMMC的区别大致有如下几个方面：</p><p>1、NAND封装多种，有TSSOP、BGA等，eMMC封装只有BGA；</p><p>2、eMMC的存储核心是NAND，多颗NAND颗粒的容量叠加就组成了eMMC；</p><p>3、NAND存储规格形式多样，对使用者来说，比eMMC要复杂得多；</p></blockquote><hr><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p><strong>硬盘与内存（RAM）的区别：</strong></p><ul><li><p>内存是计算机的工作场所，硬盘用来存放暂时不用的信息。</p></li><li><p>内存是半导体材料制作，硬盘是磁性材料制作。</p></li><li><p>内存中的信息会随掉电而丢失，硬盘中的信息可以长久保存。</p></li></ul><p>内存与硬盘的联系也非常密切，这里只提一点：硬盘上的信息永远是暂时不用的，要用吗？请装入内存！CPU与硬盘不发生直接的数据交换，CPU只是通过控制信号指挥硬盘工作，硬盘上的信息只有在装入内存后才能被处理</p>]]></content>
      
      
      <categories>
          
          <category> 感悟与总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTC驱动分析</title>
      <link href="/2019/08/07/RTC%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/07/RTC%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="RTC驱动分析"><a href="#RTC驱动分析" class="headerlink" title="RTC驱动分析"></a>RTC驱动分析</h1><blockquote><p>  linux中的rtc驱动位于<code>drivers/rtc</code>下,里面包含了许多开发平台的RTC驱动，我们这里是以S3C24xx为主,所以它的RTC驱动为<code>rtc-s3c.c</code></p></blockquote><h2 id="1、入口函数s3c-rtc-init分析"><a href="#1、入口函数s3c-rtc-init分析" class="headerlink" title="1、入口函数s3c_rtc_init分析"></a>1、入口函数s3c_rtc_init分析</h2><p>进入./drivers/rtc/rtc-s3c.c，找到入口函数，如下所示：</p><pre><code class="c">static struct platform_driver s3c2410_rtcdrv = {    .probe        = s3c_rtc_probe,//.probe函数    .remove        = s3c_rtc_remove,    .suspend    = s3c_rtc_suspend,    .resume        = s3c_rtc_resume,    .driver        = {        .name    = &quot;s3c2410-rtc&quot;,        .owner    = THIS_MODULE,    },};static char __initdata banner[] = &quot;S3C24XX RTC, (c) 2004,2006 Simtec Electronics\n&quot;;static int __init s3c_rtc_init(void){    printk(banner);    return platform_driver_register(&amp;s3c2410_rtcdrv);}module_init(s3c_rtc_init);</code></pre><p>这里注册了一个“s3c2410-rtc”名称的平台设备驱动</p><p>而“s3c2410-rtc”的平台设备,在<code>./arch/arm/plat-s3c24xx/devs.c</code>里定义了,只不过这里没有注册,如下所示:</p><pre><code class="c">/* RTC */static struct resource s3c_rtc_resource[] = {    [0] = {        .start = S3C24XX_PA_RTC,//RTC寄存器地址        .end   = S3C24XX_PA_RTC + 0xff,        .flags = IORESOURCE_MEM,//内存资源    },    [1] = {        .start = IRQ_RTC,//RTC闹钟中断        .end   = IRQ_RTC,        .flags = IORESOURCE_IRQ,//IRQ资源    },    [2] = {        .start = IRQ_TICK,//RTC时钟节拍中断        .end   = IRQ_TICK,        .flags = IORESOURCE_IRQ//IRQ资源    }};struct platform_device s3c_device_rtc = {    .name          = &quot;s3c2410-rtc&quot;,    .id          = -1,    .num_resources      = ARRAY_SIZE(s3c_rtc_resource),    .resource      = s3c_rtc_resource,};EXPORT_SYMBOL(s3c_device_rtc);</code></pre><p>当内核匹配到有与它名称同名的平台设备,就会调用<strong>.probe函数</strong>,接下来我们便进入s3c2410_rtcdrv-&gt;probe函数（即<strong>s3c_rtc_probe</strong>函数）中看看,做了什么:</p><pre><code class="c">static int s3c_rtc_probe(struct platform_device *pdev){    struct rtc_device *rtc;           //rtc设备结构体    struct resource *res;    int ret;    s3c_rtc_tickno = platform_get_irq(pdev, 1);//获取IRQ_TICK节拍中断资源    s3c_rtc_alarmno = platform_get_irq(pdev, 0);//获取IRQ_RTC闹钟中断资源    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);//获取内存资源    s3c_rtc_mem = request_mem_region(res-&gt;start,res-&gt;end-res-&gt;start+1,pdev-&gt;name);//申请内存资源    s3c_rtc_base = ioremap(res-&gt;start, res-&gt;end - res-&gt;start + 1);//对内存进行重映射    s3c_rtc_enable(pdev, 1);//设置硬件相关设置,使能RTC寄存器    s3c_rtc_setfreq(s3c_rtc_freq);//设置TICONT寄存器，使能节拍中断,设置节拍计数值    /*1.注册RTC设备*/    rtc = rtc_device_register(&quot;s3c&quot;, &amp;pdev-&gt;dev, &amp;s3c_rtcops,THIS_MODULE);    rtc-&gt;max_user_freq = 128;    platform_set_drvdata(pdev, rtc);    return 0;}</code></pre><p>显然最终会调用<strong>rtc_device_register()</strong>函数来向内核注册rtc_device设备,注册成功会返回一个已注册好的rtc_device,而s3c_rtcops是一个<strong>rtc_class_ops结构体</strong>,里面就是保存如何操作这个rtc设备的函数,比如读写RTC时间,读写闹钟时间等,注册后,会保存在rtc_device-&gt;ops里。</p><p>rtc_device_register()函数在<code>drivers/rtc/Class.c</code>文件内被定义。Class.c文件主要定义了RTC子系统,而内核初始化,便会进入Class.c。</p><hr><p>再从Class.c中的初始化函数看：</p><p>先进入rtc_init()在创建了相关的类之后会调用rtc_dev_init()，在rtc_dev_init()中会通过<strong>alloc_chrdev_region()</strong>函数来注册字符设备：</p><pre><code class="c">err = alloc_chrdev_region(&amp;rtc_devt, 0, RTC_DEV_MAX, &quot;rtc&quot;);// RTC_DEV_MAX=16,表示只注册0~15个次设备号,设备编号保存在rtc_devt中 </code></pre><h2 id="2、rtc-device-register-函数分析"><a href="#2、rtc-device-register-函数分析" class="headerlink" title="2、rtc_device_register()函数分析"></a>2、rtc_device_register()函数分析</h2><p><code>Class.c</code>中的<strong>alloc_chrdev_region()</strong>函数和<code>./arch/arm/plat-s3c24xx/devs.c</code>中通过<strong>rtc_device_register()</strong>函数注册RTC设备,会有什么关系？</p><p>接下来便来看rtc_device_register(),代码如下:</p><pre><code class="c">struct rtc_device *rtc_device_register(const char *name, struct device *dev,const struct rtc_class_ops *ops,struct module *owner){    struct rtc_device *rtc;//定义一个rtc_device结构体    ... ...    rtc = kzalloc(sizeof(struct rtc_device), GFP_KERNEL);         //分配rtc_device结构体为全局变量    /*设置rtc_device*/    rtc-&gt;id = id;    rtc-&gt;ops = ops;//将s3c_rtcops保存在rtc_device-&gt;ops里    rtc-&gt;owner = owner;    rtc-&gt;max_user_freq = 64;    rtc-&gt;dev.parent = dev;    rtc-&gt;dev.class = rtc_class;    rtc-&gt;dev.release = rtc_device_release;    ... ...    rtc_dev_prepare(rtc);   //1.做提前准备,初始化cdev结构体    ... ...    rtc_dev_add_device(rtc);//2.在/dev下创建rtc相关文件,将cdev添加到系统中    rtc_sysfs_add_device(rtc);//在/sysfs下创建rtc相关文件    rtc_proc_add_device(rtc); //在/proc下创建rtc相关文件    ... ...    return rtc;}</code></pre><p>上面的rtc_dev_prepare(rtc)和rtc_dev_add_device(rtc)主要做了以下两件事(位于<code>./drivers/rtc/rtc-dev.c</code>)：</p><ul><li><p>rtc_dev_prepare(rtc)中：</p><pre><code class="c">  cdev_init(&amp;rtc-&gt;char_dev, &amp;rtc_dev_fops);//绑定file_operations  </code></pre></li><li><p>rtc_dev_add_device(rtc)中：</p><pre><code class="c">  cdev_add(&amp;rtc-&gt;char_dev, rtc-&gt;dev.devt, 1);//注册rtc-&gt;char_dev字符设备,添加一个从设备到系统中</code></pre></li></ul><p>显然这里就是利用新方法注册字符设备</p><hr><h2 id="probe函数总结"><a href="#probe函数总结" class="headerlink" title=".probe函数总结"></a>.probe函数总结</h2><p>所以“s3c2410-rtc”平台设备驱动的.probe主要做了以下几件事：</p><ul><li><p>1.设置RTC相关寄存器</p></li><li><p>2.分配rtc_device结构体</p></li><li><p>3.设置rtc_device结构体 </p><ul><li>3.1 通过<em>rtc_device_register</em>函数，将struct  rtc_class_ops  <strong>s3c_rtcops</strong>放入rtc_device-&gt;ops，实现对RTC读写时间等操作</li></ul></li><li><p>4.注册rtc-&gt;char_dev字符设备，通过<em>cdev_init</em>函数将该字符设备的操作结构体设为：struct file_operations <strong>rtc_dev_fops</strong></p></li></ul><hr><h2 id="3、file-operations结构体分析"><a href="#3、file-operations结构体分析" class="headerlink" title="3、file_operations结构体分析"></a>3、file_operations结构体分析</h2><p>综上所述，rtc-&gt;char_dev字符设备中绑定的file_operations结构体<strong>rtc_dev_fops</strong>为：</p><pre><code class="c">static const struct file_operations rtc_dev_fops = {    .owner        = THIS_MODULE,    .llseek        = no_llseek,    .read        = rtc_dev_read,    .poll        = rtc_dev_poll,    .ioctl        = rtc_dev_ioctl,    .open        = rtc_dev_open,    .release    = rtc_dev_release,    .fasync        = rtc_dev_fasync,};</code></pre><h3 id="3-1、open函数"><a href="#3-1、open函数" class="headerlink" title="3.1、open函数"></a>3.1、open函数</h3><p>当应用层open(”/dev/rtcXX”)时,就会调用rtc_dev_fops-&gt;<strong>rtc_dev_open()</strong>,我们来看看如何open的:</p><pre><code class="c">static int rtc_dev_open(struct inode *inode, struct file *file){    struct rtc_device *rtc = container_of(inode-&gt;i_cdev,struct rtc_device, char_dev);//获取对应的rtc_device结构体    const struct rtc_class_ops *ops = rtc-&gt;ops;//最终等于s3c_rtcops    file-&gt;private_data = rtc;//设置file结构体的私有成员等于rtc_device,再次执行ioctl等函数时,直接就可以提取file-&gt;private_data即可    err = ops-&gt;open ? ops-&gt;open(rtc-&gt;dev.parent) : 0;//调用s3c_rtcops-&gt;open    mutex_unlock(&amp;rtc-&gt;char_lock);    return err;}</code></pre><blockquote><p>container_of：</p><pre><code class="c">#define container_of(ptr, type, member) ({              \         const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \         (type *)( (char *)__mptr - offsetof(type,member) );})//ptr：返回的type类型的结构体首地址//type：该结构体类型//member：结构体中的某一个成员</code></pre><p>通过一个结构变量中一个成员的地址member找到这个结构体变量的首地址ptr。</p></blockquote><p>显然最终还是调用rtc_device下的<strong>s3c_rtcops</strong>-&gt;open函数：</p><pre><code class="c">static const struct rtc_class_ops s3c_rtcops = {    .open        = s3c_rtc_open,    .release    = s3c_rtc_release,    .ioctl        = s3c_rtc_ioctl,    .read_time    = s3c_rtc_gettime,    .set_time    = s3c_rtc_settime,    .read_alarm    = s3c_rtc_getalarm,    .set_alarm    = s3c_rtc_setalarm,    .proc            = s3c_rtc_proc,};</code></pre><p>即<strong>s3c_rtc_open()</strong>函数，而s3c_rtc_open()函数里主要是申请了两个中断，一个闹钟中断，一个计时中断：</p><pre><code class="c">static int s3c_rtc_open(struct device *dev){         struct platform_device *pdev = to_platform_device(dev);　　　　    struct rtc_device *rtc_dev = platform_get_drvdata(pdev);          int ret;    ret = request_irq(s3c_rtc_alarmno, s3c_rtc_alarmirq,IRQF_DISABLED,  &quot;s3c2410-rtc alarm&quot;, rtc_dev);//申请闹钟中断                          if (ret) {        dev_err(dev, &quot;IRQ%d error %d\n&quot;, s3c_rtc_alarmno, ret);        return ret;    }    ret = request_irq(s3c_rtc_tickno, s3c_rtc_tickirq,IRQF_DISABLED,  &quot;s3c2410-rtc tick&quot;, rtc_dev);//申请计时中断       if (ret) {        dev_err(dev, &quot;IRQ%d error %d\n&quot;, s3c_rtc_tickno, ret);        goto tick_err;    }    return ret;    tick_err:    free_irq(s3c_rtc_alarmno, rtc_dev);    return ret;}</code></pre><h3 id="3-2、ioctl函数"><a href="#3-2、ioctl函数" class="headerlink" title="3.2、ioctl函数"></a>3.2、ioctl函数</h3><p>当我们应用层open后，使用 ioctl(int fd, unsigned long cmd, …)时，就会调用rtc_dev_fops-&gt; rtc_dev_ioctl ()：</p><pre><code class="c">static int rtc_dev_ioctl(struct inode *inode, struct file *file,unsigned int cmd, unsigned long arg){    struct rtc_device *rtc = file-&gt;private_data;//提取rtc_device    void __user *uarg = (void __user *) arg;    ... ...    switch (cmd) {        case RTC_EPOCH_SET:        case RTC_SET_TIME://设置时间            if (!capable(CAP_SYS_TIME))                return -EACCES;            break;        case RTC_IRQP_SET://改变中断触发速度            ... ...    ... ...}    switch (cmd) {        case RTC_ALM_READ://读闹钟时间            err = rtc_read_alarm(rtc, &amp;alarm);//调用s3c_rtcops-&gt; read_alarm            if (err &lt; 0)                return err;            if (copy_to_user(uarg, &amp;alarm.time, sizeof(tm)))//长传时间数据                return -EFAULT;            break;        case RTC_ALM_SET://设置闹钟时间 , 调用s3c_rtcops-&gt; set_alarm            ... ...        case RTC_RD_TIME://读RTC时间, 调用s3c_rtcops-&gt; read_alarm            err = rtc_read_time(rtc, &amp;tm);            ... ...        case RTC_SET_TIME://写RTC时间,调用s3c_rtcops-&gt; set_time            ... ...        case RTC_IRQP_SET://改变中断触发频率,调用s3c_rtcops-&gt; irq_set_freq            ... ...    }</code></pre><p>这里我们假设是读RTC时间，即会进入rtc_read_time函数：</p><pre><code class="c">int rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm){    int err;    err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);    if (err)        return -EBUSY;    if (!rtc-&gt;ops)        err = -ENODEV;    else if (!rtc-&gt;ops-&gt;read_time)        err = -EINVAL;    else {        memset(tm, 0, sizeof(struct rtc_time));        err = rtc-&gt;ops-&gt;read_time(rtc-&gt;dev.parent, tm);//最终调用该函数    }    mutex_unlock(&amp;rtc-&gt;ops_lock);    return err;}</code></pre><p>从上面可以看出，rtc-&gt;ops-&gt;read_time即为rtc_device结构体下的ops成员<strong>s3c_rtcops</strong>下的read_time函数，即s3c_rtc_getalarm函数</p><blockquote><p>调用了半天，最终还是调用<strong>s3c_rtcops</strong>下的成员函数</p></blockquote><p>继续分析s3c_rtc_getalarm函数，看看如何读出时间：</p><pre><code class="c">static int s3c_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm){    unsigned int have_retried = 0;    void __iomem *base = s3c_rtc_base;//获取RTC相关寄存器基地址retry_get_time:    /*获取年,月,日,时,分,秒寄存器*/    rtc_tm-&gt;tm_min  = readb(base + S3C2410_RTCMIN);         rtc_tm-&gt;tm_hour = readb(base + S3C2410_RTCHOUR);    rtc_tm-&gt;tm_mday = readb(base + S3C2410_RTCDATE);    rtc_tm-&gt;tm_mon  = readb(base + S3C2410_RTCMON);    rtc_tm-&gt;tm_year = readb(base + S3C2410_RTCYEAR);    rtc_tm-&gt;tm_sec  = readb(base + S3C2410_RTCSEC);    /*  判断秒寄存器中是0，则表示过去了一分钟，那么小时，天，月，等寄存器中的值都可能已经变化，需要重新读取这些寄存器的值*/    if (rtc_tm-&gt;tm_sec == 0 &amp;&amp; !have_retried) {        have_retried = 1;        goto retry_get_time;    }    /*将获取的寄存器值,转换为真正的时间数据*/    BCD_TO_BIN(rtc_tm-&gt;tm_sec);    BCD_TO_BIN(rtc_tm-&gt;tm_min);    BCD_TO_BIN(rtc_tm-&gt;tm_hour);    BCD_TO_BIN(rtc_tm-&gt;tm_mday);    BCD_TO_BIN(rtc_tm-&gt;tm_mon);    BCD_TO_BIN(rtc_tm-&gt;tm_year);    rtc_tm-&gt;tm_year += 100;//存储器中存放的是从1900年开始的时间，所以加上100     rtc_tm-&gt;tm_mon -= 1;    return 0;}</code></pre><p>同样, 在s3c_rtc_gettime函数下（即s3c_rtcops-&gt; set_time()函数）,也是向相关寄存器写入RTC时间</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>rtc_device-&gt;char_dev   ：字符设备，与应用层、以及更底层的函数打交道</li><li>rtc_device-&gt;ops 　　　：更底层的操作函数，直接操作硬件相关的寄存器，被rtc_device-&gt;char_dev调用</li></ul><hr><h2 id="4、修改内核"><a href="#4、修改内核" class="headerlink" title="4、修改内核"></a>4、修改内核</h2><p>我们单板上使用<code>ls /dev/rtc*</code>,找不到该字符设备, 因为内核里只定义了s3c_device_rtc这个RTC平台设备,没有注册,所以平台驱动没有被匹配上,接下来我们来修改内核里的注册数组</p><p><strong>4.1进入arch/arm/plat-s3c24xx/Common-smdk.c</strong></p><p>如下所示,在smdk_devs[]里,添加RTC的平台设备即可,当内核启动时,就会调用该数组,将里面的platform_device统统注册一遍</p><pre><code class="c">static struct platform_device __initdata *smdk_devs[] = {    &amp;s3c_device_nand,    &amp;smdk_led4,    &amp;smdk_led5,    &amp;smdk_led6,    &amp;smdk_led7,    &amp;s3c_device_rtc,//加入这一行#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)    &amp;s3c_device_dm9k,#endif    #ifdef CONFIG_SERIAL_EXTEND_S3C24xx    &amp;s3c_device_8250,#endif#ifdef CONFIG_TOUCHSCREEN_S3C2410    &amp;s3c_device_ts,#endif};</code></pre><p>然后将Common-smdk.c代替虚拟机的内核目录下的Common-smdk.c,重新make uImage编译内核即可</p><h2 id="5、测试运行"><a href="#5、测试运行" class="headerlink" title="5、测试运行"></a>5、测试运行</h2><p>启动后,如下所示, 使用<code>ls /dev/rtc*</code>,就找到了rtc0这个字符设备</p><pre><code class="shell"># ls /dev/rtc*/dev/rtc0#</code></pre><h3 id="5-1、设置RTC时间"><a href="#5-1、设置RTC时间" class="headerlink" title="5.1、设置RTC时间"></a>5.1、设置RTC时间</h3><p>在linux里有两个时钟:</p><p>硬件时钟(2440里寄存器的时钟)、系统时钟(内核中的时钟)</p><p>所以有两个不同的命令: date命令、hwclock命令</p><h3 id="5-2、date命令"><a href="#5-2、date命令" class="headerlink" title="5.2、date命令"></a>5.2、date命令</h3><p>输入date查看系统时钟:</p><pre><code class="shell"># datewed Nov  3 14:50:24 UTC 2021</code></pre><p>如果觉得不方便也可以指定格式显示日期，需要在字符串前面加”+”</p><p>如下所示,输入了  date  “+ %Y/%m/%d %H:%M:%S”</p><pre><code class="shell"># datewed Nov 3 14:54:30 UTC 2021### data &quot;+ %Y/%m/%d %H:%M:%S&quot; 2021/11/03 14:54:33</code></pre><ul><li>%M:表示秒</li><li>%m:表示月</li><li>%Y:表示年,当只需要最后两位数字,输入%y即可</li></ul><p><strong>date命令设置时间格式如下:</strong></p><p>date  月日时分年.秒</p><p>如下所示,输入date 111515292017.20，即可设置好系统时钟</p><pre><code class="shell"># date 111515292017.20wed Nov 15 15:29:20 UTC 2017#</code></pre><h3 id="5-3、hwclock命令"><a href="#5-3、hwclock命令" class="headerlink" title="5.3、hwclock命令"></a>5.3、hwclock命令</h3><p>常用参数如下所示</p><ul><li>-r, –show          读取并打印硬件时钟（read hardware clock and print result ）</li><li>-s, –hctosys      将硬件时钟同步到系统时钟（set the system time from the hardware clock ）</li><li>-w, –systohc     将系统时钟同步到硬件时钟（set the hardware clock to the current system time ）</li></ul><p>如下所示,使用hwclock -w，即可同步硬件时钟</p><pre><code class="shell"># hwclock -rWed Nov  3 15:20:46 2021 0.000000 seconds 未同步之前的时间# hwclock -w# hwclock -rWed Nov 15 15:30:06 2017 0.000000 seconds 同步后的时间#</code></pre><p>然后重启后,使用date命令,看到时间正常</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符驱动设备的另一种写法</title>
      <link href="/2019/08/07/%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/"/>
      <url>/2019/08/07/%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字符驱动设备的另一种写法"><a href="#字符驱动设备的另一种写法" class="headerlink" title="字符驱动设备的另一种写法"></a>字符驱动设备的另一种写法</h1><h2 id="零、常用函数、宏汇总"><a href="#零、常用函数、宏汇总" class="headerlink" title="零、常用函数、宏汇总"></a>零、常用函数、宏汇总</h2><ol><li><p>设备号相关</p><pre><code class="c"> #define MINORBITS       20 //次设备号的占位数目 #define MINORMASK       ((1U &lt;&lt; MINORBITS) - 1)//低20位的掩码，相当于0xfffff #define MAJOR(dev)      ((unsigned int) ((dev) &gt;&gt; MINORBITS)) //得到主设备号 #define MINOR(dev)      ((unsigned int) ((dev) &amp; MINORMASK))  //得到次设备号 #define MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))          //将主,次设备号重新“合成”为一个数，返回</code></pre></li><li><p>内核空间、用户空间之间的数据传递</p><p> 内核空间–&gt;用户空间</p><pre><code class="c"> static inline long copy_to_user(void __user *to, const void *from, unsigned long n)</code></pre><ul><li><p>to：用户空间指针</p></li><li><p>from：内核空间指针</p></li><li><p>n：从内核空间向用户空间拷贝数据的字节数</p></li><li><p>成功返回0，失败返回失败数目</p><p>用户空间–&gt;内核空间</p><pre><code class="c">static inline long copy_from_user(void *to, const void __user * from, unsigned long n)</code></pre></li><li><p>to：内核空间指针</p></li><li><p>from：用户空间指针</p></li><li><p>n：从用户空间向内核空间拷贝数据的字节数</p></li><li><p>成功返回0，失败返回失败数目</p></li></ul></li><li></li></ol><h2 id="一、register-chrdev的缺点"><a href="#一、register-chrdev的缺点" class="headerlink" title="一、register_chrdev的缺点"></a>一、<code>register_chrdev</code>的缺点</h2><p>之前注册字符设备用的如下函数注册字符设备驱动：</p><pre><code class="c">register_chrdev(unsigned int major, const char *name,const struct file_operations *fops);</code></pre><p>但其实这个函数是linux版本2.4之前的注册方式，它的使用流程：</p><ol><li>确定一个主设备号</li><li>构造一个<code>file_operations</code>结构体，传给该函数（本质是将该结构体放在<code>chrdevs</code>数组中）</li><li>调用<code>register_chrdev</code>函数将字符设备注册到系统中</li></ol><p>当读写字符设备的时候，就会根据主设备号从<code>chrdevs</code>数组中取出相应的结构体，并调用相应的处理函数。</p><p><strong>缺点：</strong></p><ul><li><p>每注册一个字符设备，会连续注册256个次设备号，使它们绑定在同一个file_operations操作方法结构体上，会浪费很多资源。</p></li><li><p>最多只能有255个设备</p></li></ul><p><strong>改进后的优点：</strong></p><ul><li>通过一定区间长度的次设备号将file_operations操作方法结构体的数量限制住</li><li>通过主设备号和次设备号来查找设备，其中次设备号20位，主设备号12位，理论上最大支持4G个驱动程序</li></ul><h2 id="二、全新字符驱动设备的注册方法"><a href="#二、全新字符驱动设备的注册方法" class="headerlink" title="二、全新字符驱动设备的注册方法"></a>二、全新字符驱动设备的注册方法</h2><p>在2.4版本后,内核里就加入了以下几个函数也可以来实现注册字符设备：</p><h3 id="1、register-chrdev-region"><a href="#1、register-chrdev-region" class="headerlink" title="1、register_chrdev_region"></a>1、register_chrdev_region</h3><p><strong>指定设备编号</strong>时，采用该函数进行静态注册一个字符设备</p><pre><code class="c">int register_chrdev_region(dev_t from, unsigned count, const char *name);</code></pre><p><strong>from:</strong> 注册的指定起始设备编号,比如:MKDEV(100, 0),表示起始主设备号100, 起始次设备号为0</p><p><strong>count:</strong>需要连续注册的次设备编号个数,比如: 起始次设备号为0,count=100,表示0~99的次设备号都要绑定在同一个file_operations操作方法结构体上</p><p><strong>name:</strong>字符设备名称</p><p>当返回值小于0,表示注册失败</p><h3 id="2、alloc-chrdev-region"><a href="#2、alloc-chrdev-region" class="headerlink" title="2、alloc_chrdev_region"></a>2、alloc_chrdev_region</h3><p><strong>未指定设备编号</strong>时，采用该函数进行动态注册一个字符设备，内核会返回申请到的设备号</p><pre><code class="c">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name);</code></pre><p><strong>dev:</strong> 存放起始设备编号的指针,当注册成功, *dev就会等于分配到的起始设备编号,可以通过<code>MAJOR()</code>和<code>MINNOR()</code>宏来提取主次设备号</p><p><strong>baseminor:</strong>次设备号基地址,也就是起始次设备号</p><p><strong>count:</strong>需要连续注册的次设备编号个数,比如: 起始次设备号(baseminor)为0,baseminor=2,表示0~1的此设备号都要绑定在同一个file_operations操作方法结构体上</p><p><strong>name:</strong>字符设备名称</p><p>当返回值小于0,表示注册失败</p><h3 id="3、cdev-init"><a href="#3、cdev-init" class="headerlink" title="3、cdev_init"></a>3、cdev_init</h3><p>初始化<code>cdev</code>字符设备结构体，并将file_operations结构体放入<code>cdev-&gt;ops</code>里。一般该函数用在驱动程序的入口函数中</p><pre><code class="c">void cdev_init(struct cdev *cdev, const struct file_operations *fops);</code></pre><p>其中字符设备结构体<code>cdev</code>的成员如下所示:</p><pre><code class="c">struct cdev {    struct kobject    kobj;            // 内嵌的kobject对象     struct module   *owner;            //所属模块    const struct file_operations  *ops;//操作方法结构体    struct list_head  list;      　　　 //与 cdev 对应的字符设备文件的 inode-&gt;i_devices 的链表头    dev_t dev;      　　　　　　　　　　 //起始设备编号,可以通过MAJOR(),MINOR()来提取主次设备号    unsigned int count;              　//连续注册的次设备号个数};</code></pre><p>其中可以通过<code>MAJOR(cdev-&gt;dev)</code>，<code>MINOR(cdev-&gt;dev)</code>来提取主次设备号，亦可以通过<code>MKDEV(major,minor)</code>来将主设备号major和次设备号minor转换成dev_t类型变量dev</p><h3 id="4、cdev-add"><a href="#4、cdev-add" class="headerlink" title="4、cdev_add"></a>4、cdev_add</h3><p>根据 <code>cdev</code> 字符设备结构体变量中的内容来向 Linux 系统添加字符设备。一般该函数用在驱动程序的入口函数中</p><pre><code class="c">/*将cdev结构体添加到系统中,并将dev(注册好的设备编号)放入cdev-&gt; dev里,  count(次设备编号个数，即要添加的设备数量)放入cdev-&gt;count里*/int cdev_add(struct cdev *p, dev_t dev, unsigned count);</code></pre><h3 id="5、cdev-del"><a href="#5、cdev-del" class="headerlink" title="5、cdev_del"></a>5、cdev_del</h3><p>从 Linux 内核中删除相应的字符设备结构体。一般该函数用在驱动程序的出口函数中</p><pre><code class="c">void cdev_del(struct cdev *p);</code></pre><h3 id="6、unregister-chrdev-region"><a href="#6、unregister-chrdev-region" class="headerlink" title="6、unregister_chrdev_region"></a>6、unregister_chrdev_region</h3><p>注销字符设备</p><pre><code class="c">void unregister_chrdev_region(dev_t from, unsigned count);</code></pre><p><strong>from:</strong> 注销的指定起始设备编号,比如:MKDEV(100, 0),表示起始主设备号100, 起始次设备号为0</p><p><strong>count:</strong>需要连续注销的次设备编号个数,比如: 起始次设备号为0,baseminor=100,表示注销掉0~99的次设备号</p><h2 id="三、设备节点的自动创建"><a href="#三、设备节点的自动创建" class="headerlink" title="三、设备节点的自动创建"></a>三、设备节点的自动创建</h2><p><code>udev</code> 是一个用户程序，在 Linux 下通过 <code>udev</code> 来实现设备文件的创建与删除， <code>udev</code> 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。使用busybox 构建根文件系统的时候，busybox 会创建一个 <code>udev</code> 的简化版本——<code>mdev</code>  </p><p>一般来说，在嵌入式系统中，热插拔事件也由 mdev 管理。在初始化脚本<code>/etc/init.d/rcS</code>文件中加入如下语句可以将热插拔事件交由 mdev 来管理  ：</p><pre><code class="bash">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</code></pre><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 <code>cdev_add</code> 函数后面添加自动创建设备节点相关代码</p><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>创建一个 class 类（其实就是个结构体），通过宏创建：</p><pre><code class="c">#define class_create(owner, name)        \({                        \    static struct lock_class_key __key;    \    __class_create(owner, name, &amp;__key);    \})</code></pre><ul><li>owner：一般为<code>THIS_MODULE</code></li><li>name：类名字</li><li>返回值：指向结构体 class 的指针</li></ul><h3 id="删除类"><a href="#删除类" class="headerlink" title="删除类"></a>删除类</h3><pre><code class="c">void class_destroy(struct class *cls);</code></pre><h3 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h3><p>在类下创建一个设备就能够实现自动创建一个设备节点，使用 <code>device_create</code> 函数在类下面创建设备：</p><pre><code class="c">int device_create(struct class *class,  struct device *parent, dev_t devt, const char *fmt, ...)</code></pre><ul><li>class：设备要创建哪个类下面</li><li>parent：父设备，一般为NULL</li><li>devt：设备号</li><li>fmt：设备名字（若fmt=xxx，则会生成/dev/xxx设备文件）</li><li>返回值：创建好的设备</li></ul><h3 id="删除设备"><a href="#删除设备" class="headerlink" title="删除设备"></a>删除设备</h3><pre><code class="c">void device_destroy(struct class *class, dev_t devt)</code></pre><ul><li>classs：要删除的设备所处的类</li><li>devt：要删除的设备号</li></ul><h2 id="四、编写全新的字符驱动设备"><a href="#四、编写全新的字符驱动设备" class="headerlink" title="四、编写全新的字符驱动设备"></a>四、编写全新的字符驱动设备</h2><p>通过调用上面的函数,构造两个不同的file_operations操作结构体,</p><p>次设备号0~1对应第一个file_operations,</p><p>次设备号2~3对应第二个file_operations,</p><p>然后在/dev/下,通过次设备号（0~4）创建5个设备节点, 利用应用程序打开这5个文件，看有什么现象</p><h3 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h3><pre><code class="c">#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/arch/regs-gpio.h&gt;#include &lt;asm/hardware.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/list.h&gt;#include &lt;linux/cdev.h&gt;static int hello_fops1_open(struct inode *inode, struct file *file){    printk(&quot;open_hello1!!!\n&quot;);    return 0;}static int hello_fops2_open (struct inode *inode, struct file *file){    printk(&quot;open_hello2!!!\n&quot;);    return 0;}/*  操作结构体1   */static struct file_operations hello1_fops={    .owner=THIS_MODULE,    .open =hello_fops1_open,};/*  操作结构体2   */static struct file_operations hello2_fops={    .owner=THIS_MODULE,    .open =hello_fops2_open,};static int major;              //主设备static struct cdev hello1_cdev;//保存 hello1_fops操作结构体的字符设备 static struct cdev hello2_cdev;//保存 hello2_fops操作结构体的字符设备 static struct class *cls;static int chrdev_ragion_init(void){    dev_t  devid;      alloc_chrdev_region(&amp;devid, 0, 4,&quot;hello&quot;);//动态分配字符设备: (major,0)、(major,1)、(major,2)、(major,3)    major=MAJOR(devid);    cdev_init(&amp;hello1_cdev, &amp;hello1_fops);//创建cdev字符设备结构体    cdev_add(&amp;hello1_cdev, MKDEV(major,0), 2);//将cdev添加到系统 (major,0) (major,1)    cdev_init(&amp;hello2_cdev, &amp;hello2_fops);//创建cdev字符设备结构体    cdev_add(&amp;hello2_cdev,MKDEV(major,2), 2);//将cdev添加到系统 (major,2) (major,3)    cls=class_create(THIS_MODULE, &quot;hello&quot;);//创建类    /*创建字符设备节点 /dev/hello* */    class_device_create(cls,0, MKDEV(major,0), 0, &quot;hello0&quot;);//在类下创建设备节点 对应hello_fops1操作结构体    class_device_create(cls,0, MKDEV(major,1), 0, &quot;hello1&quot;);//在类下创建设备节点 对应hello_fops1操作结构体    class_device_create(cls,0, MKDEV(major,2), 0, &quot;hello2&quot;);//在类下创建设备节点 对应hello_fops2操作结构体    class_device_create(cls,0, MKDEV(major,3), 0, &quot;hello3&quot;);//在类下创建设备节点 对应hello_fops2操作结构体    class_device_create(cls,0, MKDEV(major,4), 0, &quot;hello4&quot;);//在类下创建设备节点 对应空    return 0;}void chrdev_ragion_exit(void){    class_device_destroy(cls, MKDEV(major,4));//删除类下设备    class_device_destroy(cls, MKDEV(major,3));//删除类下设备    class_device_destroy(cls, MKDEV(major,2));//删除类下设备    class_device_destroy(cls, MKDEV(major,1));//删除类下设备    class_device_destroy(cls, MKDEV(major,0));//删除类下设备    class_destroy(cls);//删除类    cdev_del(&amp;hello1_cdev);//删除cdev字符设备结构体    cdev_del(&amp;hello2_cdev);//删除cdev字符设备结构体    unregister_chrdev_region(MKDEV(major,0), 4);//注销字符设备 (major,0)~(major,3)}module_init(chrdev_ragion_init);module_exit(chrdev_ragion_exit);MODULE_LICENSE(&quot;GPL&quot;);</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;//打印使用帮助信息void print_useg(char arg[]){    printf(&quot;useg:  \n&quot;);    printf(&quot;%s   [dev]\n&quot;,arg);}int main(int argc,char **argv){    int fd;    if(argc!=2)    {        print_useg(argv[0]);        return -1;    }    fd=open(argv[1],O_RDWR);    if(fd&lt;0)        printf(&quot;can&#39;t open %s \n&quot;,argv[1]);    else        printf(&quot;can open %s \n&quot;,argv[1]);    return 0;}</code></pre><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>如下所示，挂载驱动后,通过 <code>ls /dev/hello* -l</code> ,看到创建了5个字符设备节点</p><pre><code class="shell"># ls /dev/hello* -lcrw-rw----    1 0     0     252, 0 Jan 1 00: 06/dev/hello0crw-rw----    1 0     0     252, 1 Jan 1 00: 06/dev/hello1crw-rw----    1 0     0     252, 2 Jan 1 00: 06/dev/hello2crw-rw----    1 0     0     252, 3 Jan 1 00: 06/dev/hello3crw-rw----    1 0     0     252, 4 Jan 1 00: 06/dev/hello4</code></pre><p>接下来开始测试驱动,如下所示,</p><p>打开/dev/hello0时,调用的是驱动代码的操作结构体hello1_fops里的.open(),</p><p>打开/dev/hello2时,调用的是驱动代码的操作结构体hello2_fops里的.open(),</p><p>打开/dev/hello4时,打开无效,因为在驱动代码里没有分配次设备号4的操作结构体,</p><pre><code class="shell"># ./20th_chrdev_region_test /dev/hello0open_hello1!!!can open /dev/hello0### ./20th_chrdev_region_test /dev/hello2open_hello2!!!can open /dev/hello2### ./20th_chrdev_region_test /dev/hello4can&#39;t open /dev/hello4</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组与指针的一些问题</title>
      <link href="/2019/08/06/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/06/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组与指针的一些问题"><a href="#二维数组与指针的一些问题" class="headerlink" title="二维数组与指针的一些问题"></a>二维数组与指针的一些问题</h1><pre><code class="c">#include&lt;stdio.h&gt;int main(){    int A[2][3] = {                        {1,2,3},                        {4,5,6}                    };    printf(&quot;=========================\n&quot;);    printf(&quot;A[0][1]:%d\n&quot;,A[0][1]);    printf(&quot;*(*(A+0)+1):%d\n&quot;,*(*(A+0)+1));    printf(&quot;=========================\n&quot;);    printf(&quot;&amp;A[1][0]:%d\n&quot;,&amp;A[1][0]);    printf(&quot;*(A+1):%d\n&quot;,*(A+1));    printf(&quot;=========================\n&quot;);    printf(&quot;**(A+1):%d\n&quot;,**(A+1));    printf(&quot;**((int (*)[1])A+1):%d\n&quot;,**((int (*)[1])A+1));    return 0;}</code></pre><p>结果：</p><pre><code>=========================A[0][1]:2*(*(A+0)+1):2=========================&amp;A[1][0]:6487612*(A+1):6487612=========================**(A+1):4**((int (*)[1])A+1):2</code></pre><hr><p>分析：</p><ol><li><code>A[0][1]</code>：常规的二维数组索引</li><li><code>*(*(A+0)+1))</code>：利用双重指针来对二维数组进行索引，这里的A应该是一个<strong>int (*)[3]</strong>数组指针类型的变量，*(A+0)就是一个<strong>int *</strong>类型的变量，所以这里和A[0][1]的结果是一样的。</li><li><code>&amp;A[1][0]</code>：第二行第一列数据的地址</li><li><code>*(A+1)</code>：同第二点，这里A是一个<strong>int (*)[3]</strong>数组指针类型的变量，故A+1指向第二<strong>行</strong>，且A+1仍是一个<strong>int (*)[3]</strong>数组指针类型的变量，取地址后就是第二行行首的地址</li><li><code>**(A+1)</code>：同理，A是一个<strong>int (*)[3]</strong>数组指针类型的变量，A+1指向第二<strong>行</strong>，两次取地址后就是元素A[1][0]</li><li><code>**((int (*)[1])A+1))</code>：这里利用强制类型转化将A的类型由<strong>int (*)[3]</strong>数组指针类型转化为<strong>int (*)[1]</strong>，故A+1指向第二<strong>列</strong>，且A+1仍是一个<strong>int (*)[1]</strong>数组指针类型的变量，两次取地址后就是元素A[0][1]</li></ol>]]></content>
      
      
      <categories>
          
          <category> 感悟与总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC驱动</title>
      <link href="/2019/08/05/IIC%E9%A9%B1%E5%8A%A8/"/>
      <url>/2019/08/05/IIC%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux之IIC驱动"><a href="#Linux之IIC驱动" class="headerlink" title="Linux之IIC驱动"></a>Linux之IIC驱动</h1><h2 id="一、IIC接口下的24C02-驱动分析"><a href="#一、IIC接口下的24C02-驱动分析" class="headerlink" title="一、IIC接口下的24C02 驱动分析"></a>一、IIC接口下的24C02 驱动分析</h2><h3 id="1、I2C通信介绍"><a href="#1、I2C通信介绍" class="headerlink" title="1、I2C通信介绍"></a>1、I2C通信介绍</h3><p>它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据，是一个多主机的半双工通信方式</p><p>每个挂接在总线上的器件都有个唯一的地址</p><p>位速在标准模式下可达 100kbit/s，在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。</p><h3 id="2、I2C总线系统结构-如下所示"><a href="#2、I2C总线系统结构-如下所示" class="headerlink" title="2、I2C总线系统结构,如下所示"></a>2、I2C总线系统结构,如下所示</h3><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160056575-1544374794.png" alt="I2C总线系统结构"></p><p>其中SCL时钟线的频率由主机提供,且从机不能主动来引起数据传输,必须等待主机先发信号才行</p><p>两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</p><h3 id="3、I2C时序介绍"><a href="#3、I2C时序介绍" class="headerlink" title="3、I2C时序介绍"></a>3、I2C时序介绍</h3><h4 id="1-空闲状态"><a href="#1-空闲状态" class="headerlink" title="1)空闲状态"></a>1)空闲状态</h4><p>当总线上的SDA和SCL两条信号线同时处于高电平,便是空闲状态,如上面的硬件图所示,当我们不传输数据时, SDA和SCL被上拉电阻拉高,即进入空闲状态</p><h4 id="2-起始信号"><a href="#2-起始信号" class="headerlink" title="2)起始信号"></a>2)起始信号</h4><p>当SCL为高期间，SDA由高到低的跳变；便是总线的启动信号,只能由主机发起,且在空闲状态下才能启动该信号,如下图所示：</p><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160104794-1546406489.png" alt="起始信号"></p><h4 id="3-停止信号"><a href="#3-停止信号" class="headerlink" title="3)停止信号"></a>3)停止信号</h4><p>当SCL为高期间，SDA由低到高的跳变；便是总线的停止信号,表示数据已传输完成,如下图所示：</p><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160108247-2041083640.png" alt="停止信号"></p><h4 id="4-传输数据格式"><a href="#4-传输数据格式" class="headerlink" title="4)传输数据格式"></a>4)传输数据格式</h4><p>当发了起始信号后,就开始传输数据,传输的数据格式如下图所示:</p><p>当SCL为高电平时,便会获取SDA数据值,其中SDA数据必须是稳定的(若SDA不稳定就会变成起始/停止信号)</p><p>当SCL为低电平时,便是SDA的电平变化状态</p><p>若主从机在传输数据期间,需要完成其它功能(例如一个中断),可以主动拉低SCL,使I2C进入等待状态,直到处理结束再释放SCL,数据传输会继续</p><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160112700-1908810180.png" alt="传输数据格式"></p><h4 id="5-应答信号ACK"><a href="#5-应答信号ACK" class="headerlink" title="5)应答信号ACK"></a>5)应答信号ACK</h4><p>I2C总线上的数据都是以8位数据(字节)进行的,当发送了8个数据后,发送方会在第9个时钟脉冲期间释放SDA数据,当接收方接收该字节成功,便会输出一个ACK应答信号,当SDA为高电平,表示为非应答信号NACK,当SDA为低电平,表示为有效应答信号ACK</p><blockquote><p>当<strong>主机为接收方</strong>时,收到最后一个字节后,主机可以不发送ACK,直接发送停止信号来结束传输。<br>当<strong>从机为接收方</strong>时,没有发送ACK,则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送,主机可以发送停止信号再次发送起始信号启动新的传输</p></blockquote><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160125278-134312409.png" alt="应答信号"></p><blockquote><p>并非每传输8位数据之后，都会有ACK信号，有以下3种例外。</p><ul><li>当从机不能响应从机地址时（例如它正忙于其他事而无法响应I2C总线的操作，或者这个地址没有对应的从机），在第9个SCL周期内SDA线没有被拉低，即没有ACK信号。<br>  这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li><li>如果从机接收器在传输过程中不能接收更多的数据时，它也不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li><li>主机接收器在接收到最后一个字节后，也不会发出ACK信号。于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。</li></ul></blockquote><h4 id="6-完整的数据传输"><a href="#6-完整的数据传输" class="headerlink" title="6)完整的数据传输"></a>6)完整的数据传输</h4><p>如下图所示, 发送起始信号后,便发送一个8位的设备地址,其中第8位是对设备的读写标志,后面紧跟着的就是数据了,直到发送停止信号终止</p><blockquote><p>当我们第一次是读操作,然后想换成写操作时,可以再次发送一个起始信号,然后发送读的设备地址,不需要停止信号便能实现不同的地址转换</p></blockquote><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160141888-898822484.png" alt="完整的数据传输"></p><h3 id="4、AT24C02介绍"><a href="#4、AT24C02介绍" class="headerlink" title="4、AT24C02介绍"></a>4、AT24C02介绍</h3><p>AT24C02是通过I2C实现通讯的,是一个存储芯片,能够存储2Kb(256KB*8)数据</p><h4 id="4-1、原理图"><a href="#4-1、原理图" class="headerlink" title="4.1、原理图"></a>4.1、原理图</h4><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160159731-872248298.png" alt="原理图"></p><p>其中A2~A0,是这个24C02设备的硬件地址,接GND表示硬件地址都为0</p><h4 id="4-2、AT24C02的数据格式"><a href="#4-2、AT24C02的数据格式" class="headerlink" title="4.2、AT24C02的数据格式"></a>4.2、AT24C02的数据格式</h4><p>如下所示:</p><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160208825-938746051.png" alt="数据格式"></p><h4 id="4-3、AT24C02的设备地址"><a href="#4-3、AT24C02的设备地址" class="headerlink" title="4.3、AT24C02的设备地址"></a>4.3、AT24C02的设备地址</h4><p> 打开AT24C02数据手册,它的设备地址如下图所示：<br><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160235434-519181103.png" alt="设备地址"></p><p>其中A2~A1表示硬件地址，P2~P0表示page页地址</p><p>bit[0]地址:表示读/写状态,1:读,0:写</p><blockquote><p>所有I2C器件都是这样,最低位表示方向位</p></blockquote><h5 id="4-3-1、为什么需要page页地址"><a href="#4-3-1、为什么需要page页地址" class="headerlink" title="4.3.1、为什么需要page页地址"></a>4.3.1、为什么需要page页地址</h5><p>因为I2C的数据位是8位,而AT24CXX的读写地址值最大可以为2048(2^11^),超过了I2C的数据位</p><p>而page页地址就是用来解决这个问题的</p><p><strong>比如AT24C16:</strong></p><blockquote><p>当发送:0XA2(设备地址P[2:0]=0x01) ,0x00(读地址)时:</p><p>表示要读的真正地址=0x01(页地址)*256+0(读地址)=0x100,转化为二进制= 1 0000 0000<br>当发送:0XA0(设备地址), 0x00(读地址)时:</p><p>表示要读的真正地址=0x00*256+0xFF=0xFF，转化为二进制= 0 1111 1111</p></blockquote><h5 id="4-3-2、对于AT24C02"><a href="#4-3-2、对于AT24C02" class="headerlink" title="4.3.2、对于AT24C02"></a>4.3.2、对于AT24C02</h5><ul><li>芯片的容量小于等于2^8(256)字节,那么读写地址就用8bit来表示,所以设备地址里没有P2~P0</li><li>读操作时,发送的设备地址等于0XA1</li><li>写操作时,发送的设备地址等于0XA0</li></ul><h3 id="5、AT24C02时序图介绍"><a href="#5、AT24C02时序图介绍" class="headerlink" title="5、AT24C02时序图介绍"></a>5、AT24C02时序图介绍</h3><h4 id="5-1、写时序介绍"><a href="#5-1、写时序介绍" class="headerlink" title="5.1、写时序介绍"></a>5.1、写时序介绍</h4><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160251747-176931382.png" alt="写时序"></p><p>当随机写一个字节时,只需要先发送一个起始信号,然后跟上0XA0设备地址,以及要写的起始地址值,后面便是要写入地址的data,如果需要连续写数据,只需要连续写入data,地址会自动加1,直到发送停止信号结束</p><h4 id="5-2、读时序介绍"><a href="#5-2、读时序介绍" class="headerlink" title="5.2、读时序介绍"></a>5.2、读时序介绍</h4><p> <img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171106160301450-1538334264.png" alt="读时序"></p><p>当随机读一个字节时,先发送第一个起始信号,然后写入0XA0设备地址和要读的地址值,</p><p>接着发送第二个起始信号,然后写入0XA1设备地址,接着就是要读的data,如果需要连续读数据,只需要连续读出data,地址会自动加1,直到发送停止信号结束</p><h2 id="二、Linux下IIC驱动分析"><a href="#二、Linux下IIC驱动分析" class="headerlink" title="二、Linux下IIC驱动分析"></a>二、Linux下IIC驱动分析</h2><h3 id="1、I2C体系结构分析"><a href="#1、I2C体系结构分析" class="headerlink" title="1、I2C体系结构分析"></a>1、I2C体系结构分析</h3><h4 id="1-1、driver-i2c目录"><a href="#1-1、driver-i2c目录" class="headerlink" title="1.1、driver/i2c目录"></a>1.1、driver/i2c目录</h4><p>进入linux内核的driver/i2c目录下，其中重要的文件介绍如下:</p><ul><li><p><strong>1)algos文件夹(algorithms)</strong></p><p>  里面保存I2C的通信方面的算法</p></li><li><p><strong>2)busses文件夹</strong></p><p>  里面保存I2C总线驱动相关的文件,比如i2c-omap.c、 i2c-versatile.c、 i2c-s3c2410.c等。</p></li><li><p><strong>3) chips文件夹</strong></p><p>  里面保存I2C设备驱动相关的文件,比如m41t00.c就是RTC实时钟</p></li><li><p><strong>4) i2c-core.c</strong><br>  这个文件实现了I2C核心的功能(I2C总线的初始化、注册和适配器添加和注销等相关工作)以及/proc/bus/i2c*接口。</p></li><li><p><strong>5) i2c-dev.c</strong><br>  提供了通用的read() 、write()和ioctl()等接口，实现了I2C适配器设备文件的功能，其中I2C设备的主设备号都为89， 次设备号为0~255。<br>  应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器， 并控制I2C设备的工作方式</p></li></ul><p>显然,它和前几次驱动类似， I2C也分为总线驱动和设备驱动,总线就是协议相关的，它知道如何收发数据，但不知道数据含义，设备驱动却知道数据含义</p><h4 id="1-2、I2C驱动架构"><a href="#1-2、I2C驱动架构" class="headerlink" title="1.2、I2C驱动架构"></a>1.2、I2C驱动架构</h4><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171110194431294-567878229.png" alt="I2C驱动架构"></p><p>如上图所示，每一条I2C对应一个adapter适配器（可以理解为插槽，就是利用之前的dev-bus-drv模型改的，属于之前的dev设备模型），在kernel中，adapter适配器是通过struct adapter结构体定义，主要是通过i2c core层将i2c设备与i2c adapter关联起来。</p><p>在kernel中提供了两个adapter注册接口，分别为<strong>i2c_add_adapter()</strong>和<strong>i2c_add_numbered_adapter()</strong>。由于在系统中可能存在多个adapter，因为将每一条I2C总线对应一个编号，下文中称为<strong>I2C总线号</strong>。这个总线号和PCI中的总线号不同。它<u>和硬件无关</u>，只是软件上便于区分而已。</p><p>对于i2c_add_adapter()而言，它使用的是动态总线号，即由系统给其分析一个总线号，而i2c_add_numbered_adapter()则是自己指定总线号，如果这个总线号非法或者是被占用，就会注册失败。</p><h3 id="2、分析I2C总线驱动i2c-s3c2410-c"><a href="#2、分析I2C总线驱动i2c-s3c2410-c" class="headerlink" title="2、分析I2C总线驱动i2c-s3c2410.c"></a>2、分析I2C总线驱动<code>i2c-s3c2410.c</code></h3><blockquote><p>参考drivers/i2c/busses/i2c-s3c2410.c</p></blockquote><p>先进入init入口函数,如下所示：</p><pre><code class="c">static struct platform_driver s3c2440_i2c_driver = {    .probe        = s3c24xx_i2c_probe,    .remove        = s3c24xx_i2c_remove,    .resume        = s3c24xx_i2c_resume,    .driver        = {        .owner    = THIS_MODULE,        .name    = &quot;s3c2440-i2c&quot;,//driver名字    },};static int __init i2c_adap_s3c_init(void){    int ret;    ret = platform_driver_register(&amp;s3c2410_i2c_driver);    if (ret == 0) {        ret = platform_driver_register(&amp;s3c2440_i2c_driver);//注册平台驱动s3c2440_i2c_driver        if (ret)            platform_driver_unregister(&amp;s3c2410_i2c_driver);    }    return ret;}</code></pre><p>在init函数中，注册了一个 “s3c2440-i2c”的platform_driver平台驱动，当内核中有同名的平台设备时会调用platform_driver结构体的.probe成员函数，我们来看看probe函数做了些什么</p><h3 id="3、s3c24xx-i2c-probe-分析"><a href="#3、s3c24xx-i2c-probe-分析" class="headerlink" title="3、s3c24xx_i2c_probe()分析"></a>3、s3c24xx_i2c_probe()分析</h3><pre><code class="c">struct i2c_adapter  adap;static int s3c24xx_i2c_probe(struct platform_device *pdev){    struct s3c24xx_i2c *i2c = &amp;s3c24xx_i2c;    ... ...    /*获取,使能I2C时钟*/    i2c-&gt;clk = clk_get(&amp;pdev-&gt;dev, &quot;i2c&quot;);//获取i2c时钟    clk_enable(i2c-&gt;clk);                 //使能i2c时钟    ... ....    /*获取资源*/    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);    i2c-&gt;regs = ioremap(res-&gt;start, (res-&gt;end-res-&gt;start)+1);    ... ....    /*设置i2c_adapter适配器结构体, 将i2c结构体设为adap的私有数据成员*/    i2c-&gt;adap.algo_data = i2c;          //i2c_adapter适配器指向s3c24xx_i2c;    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;    /* initialise the i2c controller */    /*初始化2440的I2C相关的寄存器*/    ret = s3c24xx_i2c_init(i2c);    if (ret != 0)        goto err_iomap;    ... ...    /*注册中断服务函数*/    ret = request_irq(res-&gt;start, s3c24xx_i2c_irq, IRQF_DISABLED,pdev-&gt;name, i2c);    ... ...    /*注册i2c_adapter适配器结构体*/    ret = i2c_add_adapter(&amp;i2c-&gt;adap);    ... ...}</code></pre><p>其中i2c_adapter结构体是放在s3c24xx_i2c-&gt;adap下,如下所示:</p><pre><code class="c">struct s3c24xx_i2c {    spinlock_t        lock;    wait_queue_head_t    wait;    struct i2c_msg        *msg;    unsigned int        msg_num;    unsigned int        msg_idx;    unsigned int        msg_ptr;    unsigned int        tx_setup;    enum s3c24xx_i2c_state    state;    void __iomem        *regs;    struct clk        *clk;    struct device        *dev;    struct resource        *irq;    struct resource        *ioarea;    struct i2c_adapter    adap;//i2c_adapter适配器结构体};</code></pre><h3 id="4、i2c-add-adapter-函数分析"><a href="#4、i2c-add-adapter-函数分析" class="headerlink" title="4、i2c_add_adapter()函数分析"></a>4、i2c_add_adapter()函数分析</h3><p>该函数是注册i2c_adapter适配器结构体，这里我们来分析下他是如何进行注册的</p><pre><code class="c">int i2c_add_adapter(struct i2c_adapter *adapter){    int   id, res = 0;    retry:    if (idr_pre_get(&amp;i2c_adapter_idr, GFP_KERNEL) == 0) //调用idr_pre_get()为i2c_adapter预留内存空间        return -ENOMEM;    mutex_lock(&amp;core_lists);    /* &quot;above&quot; here means &quot;above or equal to&quot;, sigh */    res = idr_get_new_above(&amp;i2c_adapter_idr, adapter,__i2c_first_dynamic_bus_num, &amp;id);    //调用idr_get_new_above()将结构插入i2c_adapter_idr中,并将插入的位置赋给id,以后可以通过id在i2c_adapter_idr中找到相应的i2c_adapter结构体    mutex_unlock(&amp;core_lists);    if (res &lt; 0) {        if (res == -EAGAIN)            goto retry;        return res;    }    adapter-&gt;nr = id;    return i2c_register_adapter(adapter);  //调用i2c_register_adapter()函数进一步来注册.}</code></pre><p>接着分析<strong>i2c_register_adapter()</strong>函数，其代码如下所示:</p><pre><code class="c">static int i2c_register_adapter(struct i2c_adapter *adap){    struct list_head  *item;               //链表头,用来存放i2c_driver结构体的表头    struct i2c_driver *driver;             //i2c_driver,用来描述一个IIC设备驱动    list_add_tail(&amp;adap-&gt;list, &amp;adapters); //添加到内核的adapter链表中    ... ...    if (adap-&gt;dev.parent == NULL) {        adap-&gt;dev.parent = &amp;platform_bus;//平台总线（虚拟总线）        pr_debug(&quot;I2C adapter driver [%s] forgot to specify &quot;             &quot;physical device\n&quot;, adap-&gt;name);    }    sprintf(adap-&gt;dev.bus_id, &quot;i2c-%d&quot;, adap-&gt;nr);    adap-&gt;dev.release = &amp;i2c_adapter_dev_release;    adap-&gt;dev.class = &amp;i2c_adapter_class;    res = device_register(&amp;adap-&gt;dev);    ... ...    list_for_each(item,&amp;drivers) {         //for循环,从drivers链表里找到i2c_driver结构体的表头        driver = list_entry(item, struct i2c_driver, list);//通过list_head表头,找到i2c_driver结构体        if (driver-&gt;attach_adapter)              /* We ignore the return code; if it fails, too bad */            driver-&gt;attach_adapter(adap);//调用i2c_driver的attach_adapter函数来看看,这个新注册的设配器是否支持i2c_driver    }}</code></pre><p>在<strong>i2c_register_adapter()</strong>函数里主要执行以下几步:</p><ul><li><p>①将adapter放入i2c_bus_type的adapter链表</p></li><li><p>②将所有的i2c设备调出来,执行i2c_driver设备的attach_adapter函数来匹配</p></li></ul><p>其中, i2c_driver结构体会在后面讲述到</p><p>而<strong>i2c_adapter适配器结构体</strong>的成员结构,如下所示:</p><pre><code class="c">struct i2c_adapter {    struct module *owner;　　　　　　　　//所属模块      unsigned int id;　　　　　　　　　　　//algorithm的类型，定义于i2c-id.h,      unsigned int class;    const struct i2c_algorithm *algo; //总线通信方法结构体指针      void *algo_data;   　　　　　　　　　//algorithm数据      struct rt_mutex bus_lock;　　　　　//控制并发访问的自旋锁      int timeout;    int retries;　　　　　　　　　　　　 //重试次数      struct device dev; 　　　　　　　　 //适配器设备    int nr;                  　　　　　//存放在i2c_adapter_idr里的位置号    char name[48];　　　　　　　　　　　 //适配器名称      struct completion dev_released;　 //用于同步      struct list_head userspace_clients;//client链表头  };</code></pre><p>i2c_adapter表示物理上的一个i2C设备(适配器), 在i2c-s3c2410.c中,是存放在s3c24xx_i2c结构体下的(struct  i2c_adapter  adap)成员中</p><h3 id="5、s3c24xx-i2c的结构体成员分析"><a href="#5、s3c24xx-i2c的结构体成员分析" class="headerlink" title="5、s3c24xx_i2c的结构体成员分析"></a>5、s3c24xx_i2c的结构体成员分析</h3><pre><code class="c">static const struct i2c_algorithm s3c24xx_i2c_algorithm = {    .master_xfer   = s3c24xx_i2c_xfer,  //主机传输    .functionality = s3c24xx_i2c_func,};static struct s3c24xx_i2c s3c24xx_i2c = {    .lock          = __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),    .wait          = __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),    .tx_setup      = 50,                //用来延时,等待SCL被释放    .adap          = {                  // i2c_adapter适配器结构体        .name          = &quot;s3c2410-i2c&quot;,        .owner         = THIS_MODULE,        .algo          = &amp;s3c24xx_i2c_algorithm,//存放i2c_algorithm算法结构体        .retries       = 2,             //重试次数        .class         = I2C_CLASS_HWMON,    },};</code></pre><p>显然这里是直接设置了i2c_adapter结构体,所以在s3c24xx_i2c_probe ()函数中没有分配i2c_adapter适配器结构体,</p><p>其中, i2c_adapter结构体的名称等于”s3c2410-i2c”,它的通信方式等于s3c24xx_i2c_algorithm,重试次数等于2</p><blockquote><p>如果缺少i2c_algorithm的i2c_adapter什么也做不了，就只是个I2C设备,而没有通信方式</p></blockquote><p>s3c24xx_i2c_algorithm中的关键函数<strong>master_xfer()</strong>就是用于产生i2c通信所需要的start、stop、ack等信号</p><p>比如,在s3c24xx_i2c_algorithm中的关键函数master_xfer()里,调用了:</p><p>s3c24xx_i2c_xfer -&gt; s3c24xx_i2c_doxfer()-&gt;s3c24xx_i2c_message_start()</p><p>来启动传输message信息, 其中s3c24xx_i2c_message_start()函数代码如下:</p><pre><code class="c">static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c, struct i2c_msg *msg){    unsigned int addr = (msg-&gt;addr &amp; 0x7f) &lt;&lt; 1;//IIC从设备地址的最低位为读写标志位    ... ...    stat = 0;    stat |=  S3C2410_IICSTAT_TXRXEN;     //设置标志位启动IIC收发使能    if (msg-&gt;flags &amp; I2C_M_RD) {         //判断是读,还是写        stat |= S3C2410_IICSTAT_MASTER_RX;        addr |= 1;                       //设置从IIC设备地址为读标志    } else        stat |= S3C2410_IICSTAT_MASTER_TX;    s3c24xx_i2c_enable_ack(i2c);        //使能ACK信号    iiccon = readl(i2c-&gt;regs + S3C2410_IICCON);//读出IICCON寄存器    writel(stat, i2c-&gt;regs + S3C2410_IICSTAT); //写入IICSTAT寄存器,使能IIC的读或写标志    dev_dbg(i2c-&gt;dev, &quot;START: %08lx to IICSTAT, %02x to DS\n&quot;, stat, addr);    writeb(addr, i2c-&gt;regs + S3C2410_IICDS);  //将IIC从设备地址写入IICDS寄存器    /* delay here to ensure the data byte has gotten onto the bus        * before the transaction is started */    ndelay(i2c-&gt;tx_setup);         //延时,等待SCL被释放,下面便可以发送起始信号+IIC设备地址值    dev_dbg(i2c-&gt;dev, &quot;iiccon, %08lx\n&quot;, iiccon);    writel(iiccon, i2c-&gt;regs + S3C2410_IICCON);    stat |=  S3C2410_IICSTAT_START;    writel(stat, i2c-&gt;regs + S3C2410_IICSTAT);//设置IICSTAT寄存器的bit5=1,开始发送起始信号+IIC从设备地址值,并回应ACK}</code></pre><p>通过上面的代码和注释，发现主要是写入IIC从设备地址，然后发送起始信号+IIC从设备地址值，并回应ACK</p><p>显然IIC总线驱动i2c-s3c2410.c中主要是设置适配器adapter。里面帮我们做好了IIC通信的架构，就是不知道发什么内容</p><h3 id="6、分析I2C设备驱动eeprom-c"><a href="#6、分析I2C设备驱动eeprom-c" class="headerlink" title="6、分析I2C设备驱动eeprom.c"></a>6、分析I2C设备驱动<code>eeprom.c</code></h3><p>进入driver/i2c/chips中,看看eeprom设备驱动是如何写的</p><blockquote><p>参考: driver/i2c/chips/eeprom.c</p></blockquote><p>首先来看它的init入口函数:</p><pre><code class="c">static int __init eeprom_init(void){    return i2c_add_driver(&amp;eeprom_driver);}static void __exit eeprom_exit(void){    i2c_del_driver(&amp;eeprom_driver);}</code></pre><p>其中struct  i2c_driver  eeprom_driver的成员如下:</p><pre><code class="c">static struct i2c_driver eeprom_driver = {    .driver = {        .name    = &quot;eeprom&quot;,//名称    },    .id        = I2C_DRIVERID_EEPROM,//IIC设备标识ID    .attach_adapter    = eeprom_attach_adapter,//用来与总线驱动的适配器匹配,匹配成功添加到适配器adapter中    .detach_client    = eeprom_detach_client,//与总线驱动的适配器解绑,分离这个IIC从设备};</code></pre><p>如下所示, eeprom_driver结构体的ID成员在i2c-id.h中,里面还定义了大部分常用I2C设备驱动的设备ID（事实证明不写也行）</p><pre><code class="c">....../* IDs --   Use DRIVERIDs 1000-1999 for sensors.   These were originally in sensors.h in the lm_sensors package */#define I2C_DRIVERID_LM78 1002#define I2C_DRIVERID_LM75 1003#define I2C_DRIVERID_GL518 1004#define I2C_DRIVERID_EEPROM 1005//EEPROM的ID#define I2C_DRIVERID_W83781D 1006#define I2C_DRIVERID_LM80 1007#define I2C_DRIVERID_ADM1021 1008#define I2C_DRIVERID_ADM9240 1009#define I2C_DRIVERID_LTC1710 1010#define I2C_DRIVERID_BT869 1013#define I2C_DRIVERID_MAXILIFE 1014#define I2C_DRIVERID_MATORB 1015#define I2C_DRIVERID_GL520 1016#define I2C_DRIVERID_THMC50 1017#define I2C_DRIVERID_ADM1025 1020#define I2C_DRIVERID_LM87 1021#define I2C_DRIVERID_PCF8574 1022#define I2C_DRIVERID_MTP008 1023#define I2C_DRIVERID_DS1621 1024#define I2C_DRIVERID_ADM1024 1025#define I2C_DRIVERID_CH700X 1027 /* single driver for CH7003-7009 digital pc to tv encoders */#define I2C_DRIVERID_FSCPOS 1028#define I2C_DRIVERID_FSCSCY 1029#define I2C_DRIVERID_PCF8591 1030#define I2C_DRIVERID_LM92 1033#define I2C_DRIVERID_SMARTBATT 1035#define I2C_DRIVERID_BMCSENSORS 1036#define I2C_DRIVERID_FS451 1037#define I2C_DRIVERID_LM85 1039#define I2C_DRIVERID_LM83 1040#define I2C_DRIVERID_LM90 1042#define I2C_DRIVERID_ASB100 1043#define I2C_DRIVERID_FSCHER 1046#define I2C_DRIVERID_W83L785TS 1047#define I2C_DRIVERID_OV7670 1048    /* Omnivision 7670 camera */......</code></pre><p>显然，在init函数中通过i2c_add_driver()注册i2c_driver结构体，然后通过i2c_driver -&gt;attach_adapter来匹配内核中的各个总线驱动的适配器，发送这个设备地址，若有ACK响应，表示匹配成功</p><h3 id="7、i2c-add-driver-函数分析"><a href="#7、i2c-add-driver-函数分析" class="headerlink" title="7、i2c_add_driver()函数分析"></a>7、i2c_add_driver()函数分析</h3><p>接下来,我们进入i2c_add_driver()来看看是不是像刚刚分析的那样</p><pre><code class="c">int i2c_add_driver(struct module *owner, struct i2c_driver *driver){    driver-&gt;driver.owner = owner;    driver-&gt;driver.bus = &amp;i2c_bus_type;    //将i2c_driver放在i2c_bus_type链表中    res = driver_register(&amp;driver-&gt;driver);//注册一个i2c_driver    ... ...    if (driver-&gt;attach_adapter) {        struct i2c_adapter *adapter;//定义一个i2c_adapter适配器        list_for_each_entry(adapter, &amp;adapters, list)//for循环提取出adapters链表中所有的i2c_adapter适配器,放入到adapter结构体中        {            driver-&gt;attach_adapter(adapter);//来匹配取出来的i2c_adapter适配器        }    }    ... ...    return 0;}</code></pre><p>在i2c_add_driver()函数里主要执行以下几步:</p><ul><li><p>①将i2c_driver放入到i2c_bus_type链表</p></li><li><p>②取出adapters适配器链表中所有的i2c_adapter适配器，然后执行i2c_driver-&gt;attach_adapter()</p></li></ul><p>所以i2c_adapter适配器和i2c_driver设备驱动注册框架如下所示:</p><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171110194549372-635602878.png" alt="i2c_adapter适配器和i2c_driver设备驱动注册框架"></p><p>这里调用了i2c_driver-&gt;attach_adapter(adapter)，我们看看里面是不是通过发送IIC设备地址，等待ACK响应来匹配的</p><h3 id="8、i2c-driver-gt-attach-adapter-函数分析"><a href="#8、i2c-driver-gt-attach-adapter-函数分析" class="headerlink" title="8、i2c_driver -&gt;attach_adapter()函数分析"></a>8、i2c_driver -&gt;attach_adapter()函数分析</h3><blockquote><p>这里以struct i2c_driver eeprom_driver 为例</p><pre><code class="c">/* This is the driver that will be inserted */static struct i2c_driver eeprom_driver = {    .driver = {        .name    = &quot;eeprom&quot;,    },    .id        = I2C_DRIVERID_EEPROM,    .attach_adapter    = eeprom_attach_adapter,//attach_adapter函数    .detach_client    = eeprom_detach_client,};</code></pre><p>所以这里的i2c_driver -&gt;attach_adapter()函数即为<strong>eeprom_attach_adapter()</strong></p></blockquote><p>如下所示，eeprom_attach_adapter()调用了i2c_probe(adapter, &amp;addr_data, eeprom_detect)函数</p><pre><code class="c">static int eeprom_attach_adapter(struct i2c_adapter *adapter){    return i2c_probe(adapter, &amp;addr_data, eeprom_detect);}</code></pre><p>上述代码中i2c_probe的参数如下：</p><ul><li><p>第1个参数是i2c_adapter适配器；</p></li><li><p>第2个参数addr_data变量，里面存放了IIC设备地址的信息；</p></li><li><p>第3个参数eeprom_detect就是具体的设备探测回调函数i2c_probe()函数，会通过adapter适配器发送IIC设备地址addr_data，如果收到ACK信号，就调用eeprom_detect()回调函数来注册i2c_client结构体，该结构体对应真实的物理从设备，而i2c_driver对应的是设备驱动，也就是说，只有当适配器支持这个设备驱动，才会注册i2c_client从设备，后面会讲这个回调函数如何注册i2c_client</p><p>  而在i2c_driver -&gt;detach_client()中，则注销i2c_client结构体</p></li></ul><p>其中addr_data变量是<strong>struct i2c_client_address_data结构体</strong>，它的成员如下所示：</p><pre><code class="c">struct i2c_client_address_data {    unsigned short *normal_i2c;     //存放正常的设备高7位地址数据    unsigned short *probe;          //存放不受*ignore影响的高7位设备地址数据    unsigned short *ignore;         //存放*ignore的高7位设备地址数据    unsigned short **forces;        //forces表示适配器匹配不了该设备,也要将其放入适配器中};</code></pre><p>当上面结构体的数组成员以<strong>I2C_CLIENT_END</strong>结尾，则表示地址已结束，比如<code>AT24C02设备</code>为例，看这个结构体如何定义的：</p><pre><code class="c">#define  AT24C02_ADDR           (0xA0&gt;&gt;1)           //AT24C02地址static unsigned short  ignore[] = { I2C_CLIENT_END };static unsigned short  normal_addr[] = { AT24C02_ADDR, I2C_CLIENT_END };static unsigned short  force_addr[] = {ANY_I2C_BUS, AT24C02_ADDR ,2C_CLIENT_END};static unsigned short* forces[] = {force_addr, NULL};//ANY_I2C_BUS:表示支持所有适配器总线,若填指定的适配器总线ID,则表示该设备只支持指定的那个适配器static struct i2c_client_address_data  addr_data = {    .normal_i2c     = normal_addr,   //存放at24c02地址    .probe          = ignore,        //表示无地址    .ignore         = ignore,        //表示无地址    . forces        = forces,        //存放强制的at24c02地址,表示强制支持};</code></pre><p>一般而言,都不会设置.forces成员,这里只是打个比方</p><h4 id="8-1、i2c-probe-函数分析"><a href="#8-1、i2c-probe-函数分析" class="headerlink" title="8.1、i2c_probe()函数分析"></a>8.1、i2c_probe()函数分析</h4><pre><code class="c">int i2c_probe(struct i2c_adapter *adapter,struct i2c_client_address_data *address_data,int (*found_proc) (struct i2c_adapter *, int, int)){    ... ...    err = i2c_probe_address(adapter,forces[kind][i + 1],kind, found_proc);}</code></pre><p>里面调用了i2c_probe_address()函数,从名称上来看,显然它就是用来发送起始信号+设备地址，来探测IIC设备地址用的</p><h4 id="8-2、i2c-probe-address-函数分析"><a href="#8-2、i2c-probe-address-函数分析" class="headerlink" title="8.2、i2c_probe_address()函数分析"></a>8.2、i2c_probe_address()函数分析</h4><pre><code class="c">static int i2c_probe_address(struct i2c_adapter *adapter, int addr, int kind,int (*found_proc) (struct i2c_adapter *, int, int)){    /*判断设备地址是否有效,addr里存放的是设备地址前7位,比如AT24C02=0xA0,那么addr=0x50*/    if (addr &lt; 0x03 || addr &gt; 0x77) {        dev_warn(&amp;adapter-&gt;dev, &quot;Invalid probe address 0x%02x\n&quot;,addr);//打印地址无效,并退出        return -EINVAL;    }    /*查找链表中其它IIC设备的设备地址,若这个设备地址已经被使用,则return*/    if (i2c_check_addr(adapter, addr))        return 0;    if (kind &lt; 0) {        if (i2c_smbus_xfer(adapter, addr, 0, 0, 0,I2C_SMBUS_QUICK, NULL) &lt; 0)//进入I2C传输函数            return 0;        ... ...    }</code></pre><h4 id="8-3、i2c-smbus-xfer-函数分析"><a href="#8-3、i2c-smbus-xfer-函数分析" class="headerlink" title="8.3、i2c_smbus_xfer()函数分析"></a>8.3、i2c_smbus_xfer()函数分析</h4><pre><code class="c">s32 i2c_smbus_xfer(struct i2c_adapter * adapter, u16 addr, unsigned short flags,char read_write, u8 command, int size,union i2c_smbus_data * data){    s32 res;    flags &amp;= I2C_M_TEN | I2C_CLIENT_PEC;    if (adapter-&gt;algo-&gt;smbus_xfer) {   //如果adapter适配器有smbus_xfer这个函数        mutex_lock(&amp;adapter-&gt;bus_lock);//加互斥锁        res = adapter-&gt;algo-&gt;smbus_xfer(adapter,addr,flags,read_write,command,size,data);//调用adapter适配器里的传输函数        mutex_unlock(&amp;adapter-&gt;bus_lock);//解互斥锁    } else                          //否则使用默认函数传输设备地址        res = i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,command,size,data);    return res;}</code></pre><p>看了上面代码后,显然我们的s3c2410-i2c适配器没有algo-&gt;smbus_xfer函数,而是使用i2c_smbus_xfer_emulated()函数,如下所示：</p><pre><code class="c">static const struct i2c_algorithm s3c24xx_i2c_algorithm = {    .master_xfer        = s3c24xx_i2c_xfer,    .functionality        = s3c24xx_i2c_func,    //缺少smbus_xfer函数};static struct s3c24xx_i2c s3c24xx_i2c = {    .lock        = __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),    .wait        = __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),    .tx_setup    = 50,    .adap        = {//s3c2410的i2c_adapter结构体适配器        .name            = &quot;s3c2410-i2c&quot;,        .owner            = THIS_MODULE,        .algo            = &amp;s3c24xx_i2c_algorithm,        .retries        = 2,        .class            = I2C_CLASS_HWMON,    },};</code></pre><blockquote><p>通常适配器都是不支持的，都使用默认的i2c_smbus_xfer_emulated()函数</p></blockquote><h4 id="8-4、i2c-smbus-xfer-emulated-函数分析"><a href="#8-4、i2c-smbus-xfer-emulated-函数分析" class="headerlink" title="8.4、i2c_smbus_xfer_emulated()函数分析"></a>8.4、i2c_smbus_xfer_emulated()函数分析</h4><pre><code class="c">static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,unsigned short flags,char read_write, u8 command, int size, union i2c_smbus_data * data){    unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];//属于msg[0]的buf成员    unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];//属于msg[1]的buf成员    int num = read_write == I2C_SMBUS_READ?2:1;  //如果为读命令,就等于2,表示要执行两次数据传输    struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },                             { addr, flags | I2C_M_RD, 0, msgbuf1 }};//定义两个i2c_msg结构体,    msgbuf0[0] = command;            //IIC设备地址最低位为读写命令    ... ...    if (i2c_transfer(adapter, msg, num) &lt; 0)        return -1;    /*设置i2c_msg结构体成员*/    if (read_write == I2C_SMBUS_READ)        switch(size) {            ... ...            case I2C_SMBUS_BYTE_DATA://如果是读字节                if (read_write == I2C_SMBUS_READ)                    msg[1].len = 1;                else {                    msg[0].len = 2;                    msgbuf0[1] = data-&gt;byte;                }                break;            ... ...        }    ... ...    if (i2c_transfer(adapter, msg, num) &lt; 0)//将i2c_msg结构体的内容发送给I2C设备        return -1;    ... ...}</code></pre><p>其中i2c_msg结构体的结构，如下所示：</p><pre><code class="c">struct i2c_msg {    __u16 addr;  //I2C从机的设备地址    __u16 flags; //当flags=0表示写, flags= I2C_M_RD表示读    __u16 len;   //传输的数据长度,等于buf数组里的字节数    __u8 *buf;   //存放数据的数组};</code></pre><p>上面代码中之所以读操作需要两个i2c_msg，写操作需要一个i2c_msg，是因为读IIC设备是两个流程，在上一节已经分析到了，具体如下所示：</p><p>只要发送一个S起始信号则就是一个i2c_msg，如下图所示：</p><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171110194638622-994179422.png" alt="读一个字节"></p><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171110194645528-2046926273.png" alt="写一个字节"></p><p>而在i2c_transfer()函数中,最终又是调用了之前分析的i2c_adapter-&gt;algo-&gt;master_xfer()发送函数,如下所示：</p><pre><code class="c">int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num){    int ret;    if (adap-&gt;algo-&gt;master_xfer) {#ifdef DEBUG        for (ret = 0; ret &lt; num; ret++) {            dev_dbg(&amp;adap-&gt;dev, &quot;master_xfer[%d] %c, addr=0x%02x, &quot;                &quot;len=%d%s\n&quot;, ret, (msgs[ret].flags &amp; I2C_M_RD)                ? &#39;R&#39; : &#39;W&#39;, msgs[ret].addr, msgs[ret].len,                (msgs[ret].flags &amp; I2C_M_RECV_LEN) ? &quot;+&quot; : &quot;&quot;);        }#endif        mutex_lock_nested(&amp;adap-&gt;bus_lock, adap-&gt;level);        ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);//最终还是调用master_xfer()函数        mutex_unlock(&amp;adap-&gt;bus_lock);        return ret;    } else {        dev_dbg(&amp;adap-&gt;dev, &quot;I2C level transfers not supported\n&quot;);        return -ENOSYS;    }}</code></pre><p>其中i2c_transfer()的参数<code>adap</code>表示通过哪个适配器传输出去，<code>msgs</code>表示I2C消息，<code>num</code>表示msgs的数目</p><p>内核每发送一个Msg都会先发出S开始信号和设备地址，直到所有Msg传输完毕，最后发出P停止信号。</p><p>当i2c_transfer()返回值为正数，表示已经传输正数个数据，当返回负数，说明I2C传输出错</p><h4 id="8-5、总结"><a href="#8-5、总结" class="headerlink" title="8.5、总结"></a>8.5、总结</h4><p>综上，在i2c_driver-&gt;attach_adapter(adapter)函数里主要执行以下几步:</p><p>1) 调用<strong>i2c_probe</strong>(adap适配器, i2c_client_address_data设备地址结构体, 回调函数);</p><p>2) 将要发的设备地址结构体打包成<strong>i2c_msg</strong></p><p>3) 然后执行<strong>i2c_transfer()</strong>来调用i2c_adapter-&gt;algo-&gt;<strong>master_xfer</strong>()将i2c_msg发出去</p><p>4) 若收到ACK回应（即发现有I2C设备），便进入回调函数，<strong>注册i2c_client</strong>从设备，使该设备与适配器联系在一起</p><p>所以适配器和iic设备驱动<strong>最终注册框架图</strong>如下所示：</p><p><img src="//NU-LL.github.io/2019/08/05/IIC驱动/1182576-20171110194722247-1723647250.png" alt="最终注册框架图"></p><h3 id="9、注册i2c-client从设备"><a href="#9、注册i2c-client从设备" class="headerlink" title="9、注册i2c_client从设备"></a>9、注册i2c_client从设备</h3><p>接下来便来分析回调函数如何注册i2c_client从设备，先来看看i2c_client结构体：</p><pre><code class="c">struct i2c_client {      unsigned short flags;//标志    unsigned short addr;//该i2c从设备的设备地址,存放地址高7位      char name[I2C_NAME_SIZE];//设备名字    struct i2c_adapter *adapter;//依附的i2c_adapter,表示该IIC设备支持哪个适配器      struct i2c_driver *driver;//依附的i2c_driver,表示该IIC从设备的驱动是哪个    struct device dev;//设备结构体    int irq;//设备所使用的结构体    struct list_head detected;//链表头  };</code></pre><p>还是以driver/i2c/chips/eeprom.c为例，如下所示：</p><pre><code class="c">static int eeprom_attach_adapter(struct i2c_adapter *adapter){    return i2c_probe(adapter, &amp;addr_data, eeprom_detect);}</code></pre><p>这里的回调函数是eeprom_detect()函数接下来便分析该函数</p><h4 id="9-1、回调函数eeprom-detect-分析"><a href="#9-1、回调函数eeprom-detect-分析" class="headerlink" title="9.1、回调函数eeprom_detect()分析"></a>9.1、回调函数eeprom_detect()分析</h4><pre><code class="c">static int eeprom_detect(struct i2c_adapter *adapter, int address, int kind){    struct i2c_client *new_client;        //定义一个i2c_client结构体局部变量    new_client =kzalloc(sizeof(struct i2c_client), GFP_KERNEL);//分配i2c_client结构体为全局变量    /*设置i2c_client结构体*/    new_client-&gt;addr = address;           //设置设备地址    new_client-&gt;adapter = adapter;        //设置依附的i2c_adapter    new_client-&gt;driver = &amp;eeprom_driver;  //设置依附的i2c_driver    new_client-&gt;flags = 0;                //设置标志位为初始值    strlcpy(new_client-&gt;name, &quot;eeprom&quot;, I2C_NAME_SIZE);//设置名字    /*注册i2c_client*/    if ((err = i2c_attach_client(new_client)))        goto exit_kfree;    //注册失败,便释放i2c_client这个全局变量    ... ...exit_kfree:    kfree(new_client);exit:    return err;}</code></pre><p>当注册了i2c_client从设备后,便可以使用i2c_transfer()来实现与设备传输数据了</p><h3 id="10、24C02驱动及测试程序的编写"><a href="#10、24C02驱动及测试程序的编写" class="headerlink" title="10、24C02驱动及测试程序的编写"></a>10、24C02驱动及测试程序的编写</h3><p>参考driver/i2c/chips/eeprom.c驱动，可以得出驱动代码步骤如下：</p><ol><li><p>定义<strong>file_operations</strong>结构体 ，设置字符设备的读写函数(实现对24C02的读写操作)<br> //构造i2c_msg结构体，使用i2c_transfer()来实现与设备传输数据</p></li><li><p>定义<strong>i2c_client_address_data</strong>结构体，里面保存24C02的设备地址</p></li><li><p>定义一个<strong>i2c_driver</strong>驱动结构体</p><p> 3.1 设置i2c_driver-&gt; <strong>attach_adapter</strong>    // i2c_add_driver函数的最后会调用attach_adapter函数，attach_adapter函数最后会对adapters链表中的每个adapter（可理解为设备dev（<code>这里的adapter相当于芯片内的硬件i2c部分，而芯片外接的i2c从机可理解为i2c_client</code>））调用该函数与相应的驱动进行连接，里面直接调用函数<code>i2c_probe(adap适配器, i2c_client_address_data设备地址结构体, 回调函数fn);</code>即可</p><blockquote><p>attach_adapter函数（实际上是i2c_probe）中的连接过程：</p><ol><li>发出start信号（调用adapter-&gt;algo-&gt;master_xfer算法函数）</li><li>发出设备地址</li><li>若从设备会用ACK信号则调用<code>回调函数fn</code></li></ol></blockquote><p> 3.2 设置i2c_driver-&gt; <strong>detach_client</strong>   //卸载这个驱动后，如果之前发现能够支持的设备，则调用它来清理，主要负责卸载i2c_client、字符设备</p></li><li><p>写<code>回调函数fn</code>，里面<strong>注册i2c_client</strong>，字符设备( 字符设备用来实现读写24C02里的数据)</p><p> 4.1 分配并设置i2c_client（adress（高七位，不算读写位）、adapter、driver、name）</p><p> 4.2 使用i2c_attach_client()将i2c_client与适配器adapter进行连接</p><blockquote><p>此步骤后i2c_driver-&gt;detach_client函数才能在卸载时被正常调用</p></blockquote><ul><li><p>上述两步可通过以下函数实现</p><pre><code class="c">  struct i2c_client *i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)//认为设备肯定存在  //adap:适配器  //info:单板信息</code></pre><p>  或：</p><pre><code class="c">  struct i2c_client *i2c_new_probed_device(struct i2c_adapter *adap,struct i2c_board_info *info,unsigned short const *addr_list)//对于“已经识别出来的设备”，才会创建（最后调用i2c_new_device）  //adap:适配器  //info:单板信息  //addr_list:地址列表，会根据该地址列表依次判断设备是否有回应，即是否存在</code></pre></li></ul><p> 4.3 注册字符设备</p></li><li><p>写init入口函数，exit出口函数<br> init：使用<strong>i2c_add_driver()</strong>注册i2c_driver驱动结构体<br> exit：使用<strong>i2c_del_driver()</strong>卸载i2c_driver驱动结构体</p></li><li><p>i2c数据传输：</p><p>6.1 构造i2c消息<code>i2c_msg</code>结构体</p><pre><code class="c">struct i2c_msg {   __u16 addr;    /*从机地址，一般为i2c_client-&gt;addr*/   __u16 flags;/* 0：写    */#define I2C_M_TEN    0x10    /* we have a ten bit chip address    */#define I2C_M_RD    0x01    /* 读    */#define I2C_M_NOSTART    0x4000#define I2C_M_REV_DIR_ADDR    0x2000#define I2C_M_IGNORE_NAK    0x1000#define I2C_M_NO_RD_ACK        0x0800#define I2C_M_RECV_LEN        0x0400 /* length will be first received byte */   __u16 len;        /* 消息长度    */   __u8 *buf;        /* 消息数据指针 */};</code></pre><p>6.2 调用函数<code>i2c_transfer()</code>函数传输消息</p><pre><code class="c">int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)</code></pre><p>adap：适配器（dev），一般i2c_client-&gt;adapter</p><p>msgs：传输消息</p><p>num：消息条数</p><p>返回值：发送成功条数</p></li></ol><hr><h4 id="i2c从机设备i2c-client的4种构建方法（3-4-2内核）"><a href="#i2c从机设备i2c-client的4种构建方法（3-4-2内核）" class="headerlink" title="i2c从机设备i2c_client的4种构建方法（3.4.2内核）"></a>i2c从机设备i2c_client的4种构建方法（3.4.2内核）</h4><h5 id="1-通过总线号声明"><a href="#1-通过总线号声明" class="headerlink" title="1. 通过总线号声明"></a>1. 通过总线号声明</h5><p>定义一个i2c_board_info结构体，用于描述硬件名字、地址addr及相应其他数据，该结构体会在系统初始化时被<code>i2c_register_board_info</code>调用并生成对应的i2c_client</p><pre><code class="c">static struct i2c_board_info at24cxx_info = {    I2C_BOARD_INFO(&quot;at24c08&quot;,0x50),}</code></pre><blockquote><p><code>i2c_register_board_info</code>函数最后还是通过调用<code>i2c_new_device</code>生成及注册i2c_client</p></blockquote><p>限制：不适合动态加载</p><h5 id="2-直接创建设备"><a href="#2-直接创建设备" class="headerlink" title="2. 直接创建设备"></a>2. 直接创建设备</h5><p>直接使用<code>i2c_new_device</code>或<code>i2c_new_probed_device</code>函数，具体使用方法见上文</p><p>可以通过以下方法取得适配器：</p><pre><code class="c">static struct i2c_client *at24cxx_client;...struct i2c_adapter *i2c_adap;i2c_adap = i2c_get_adapter(0);//取得系统中的第0个适配器at24cxx_client = i2c_new_device(i2c_adap,&amp;at24cxx_info);//得到i2c_clienti2c_put_adapter(i2c_adap);//释放适配器</code></pre><h5 id="3-从用户空间创建设备"><a href="#3-从用户空间创建设备" class="headerlink" title="3. 从用户空间创建设备"></a>3. 从用户空间创建设备</h5><p>向<code>new_device</code>写入数据，能够自己创建设备：</p><pre><code class="bash">#eg1：$ echo eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-0/new_device#eg2：$ echo at24c08 0x50 &gt; /sys/class/i2c-adapter/i2c-0/new_device</code></pre><p>向<code>delete_device</code>写入数据，能够自己删除设备</p><blockquote><p>最终仍是调用<code>i2c_new_device</code></p></blockquote><h5 id="4-探测某些设备的I2c总线"><a href="#4-探测某些设备的I2c总线" class="headerlink" title="4. 探测某些设备的I2c总线"></a>4. 探测某些设备的I2c总线</h5><p>例子：drivers/hwmon/lm90.c</p><p>使用较少，类似于2.6内核中的方式</p><hr><p><strong>具体驱动代码如下所示：</strong></p><pre><code class="c">/* *  I2C-24C02 */#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/jiffies.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;static struct i2c_client *at24c02_client;         //从设备结构体static struct class *at24c02_class;                //类结构体static unsigned int at24c02_major;/*1.定义file_operations结构体 ,  *  设置字符设备的读写函数(实现对24C02的读写操作)  */static ssize_t at24c02_read(struct file *file, char __user *buf, size_t size, loff_t * offset){    struct i2c_msg msg[2];    u8 addr;    u8 data;    int ret;    if(size!=1)        return -EINVAL;    copy_from_user(&amp;addr,buf,1);    /* 数据传输三要素: 源,目的,长度 */    /* 读AT24CXX时,要先把要读的存储空间的地址发给它 */    msg[0].addr=at24c02_client-&gt;addr;/* 目的 */    msg[0].flags=0;                     /* 表示写 */    msg[0].len  =1;                     /* 地址=1 byte */    msg[0].buf  =&amp;addr;              /* 源 */    /* 然后启动读操作 */    msg[1].addr=at24c02_client-&gt;addr;/* 源 */    msg[1].flags=I2C_M_RD;           /* 表示读 */    msg[1].len  =1;                     /* 数据=1 byte */    msg[1].buf  =&amp;data;              /* 目的 */    ret=i2c_transfer(at24c02_client-&gt;adapter, msg, 2);    if(ret==2)      //表示2个msg传输成功    {        copy_to_user(buf,&amp;data,1);      //上传数据        return 0;    }    else        return -EAGAIN;}static ssize_t at24c02_write(struct file *file, const char __user *buf, size_t size, loff_t *offset){    struct i2c_msg msg[1];    u8 val[2];    int ret;    if(size!=2)//地址   数据        return -EINVAL;    copy_from_user(val,buf,2);    /* 数据传输三要素: 源,目的,长度 */    msg[0].addr=at24c02_client-&gt;addr;/* 目的 */    msg[0].flags=0;                   /* 表示写 */    msg[0].len  =2;                    /* 地址+数据=2 byte */    msg[0].buf  =val;                 /* 源 */    ret=i2c_transfer(at24c02_client-&gt;adapter, msg, 1);    if(ret==1)      //表示1个msg传输成功    {        return 0;    }    else        return -EAGAIN;}static struct  file_operations at24c02_fops={    .owner = THIS_MODULE,    .read  = at24c02_read,    .write = at24c02_write,};/*2.定义i2c_client_address_data结构体,保存24C02的设备地址*/static unsigned short ignore[] = { I2C_CLIENT_END };static unsigned short normal_addr[] = {0X50,  I2C_CLIENT_END };//这里地址值是7位，左移一位后即为0xA0static unsigned short   force_addr[] = {ANY_I2C_BUS, 0x60, I2C_CLIENT_END};//这地地址设为0x60，即使不存在该设备也会认为存在这个设备，并调用at24cxx_detect函数static unsigned short   * forces[] =     {force_addr, NULL};//指针数组static struct i2c_client_address_data   at24c02_addr={    .normal_i2c=normal_addr,//要发出S信号和设备地址并得到ACK信号,才能确定存在这个设备    .probe=ignore,    .ignore=ignore,    //  .forces=forces,                  // 强制地址，强制认为存在这个设备，一般不使用};/*3. 定义一个i2c_driver驱动结构体*/static int   at24c02_attach_adapter(struct i2c_adapter *adapter);static int   at24c02_detach_client(struct i2c_client *client);static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind);/* This is the driver that will be inserted */static struct i2c_driver at24c02_driver = {    .driver = {        .name    = &quot;at24c02&quot;,    },    .attach_adapter   = at24c02_attach_adapter,//绑定回调函数    .detach_client    = at24c02_detach_client, //解绑回调函数};/*3.1 设置i2c_driver-&gt; attach_adapter*/static int   at24c02_attach_adapter(struct i2c_adapter *adapter){    return i2c_probe(adapter,&amp;at24c02_addr, at24c02_detect);}/*3.2 设置i2c_driver-&gt; detach_client*/static int at24c02_detach_client(struct i2c_client *client){    printk(&quot;at24c02_detach_client\n&quot;);    //销毁i2c_client结构体at24c02_client    i2c_detach_client(at24c02_client) ;    kfree(at24c02_client);    //销毁类和对应的设备    class_device_destroy(at24c02_class,MKDEV(at24c02_major, 0));    class_destroy(at24c02_class);    return 0;}/*4.写回调函数,里面注册i2c_client,字符设备*/static int at24c02_detect(struct i2c_adapter *adap, int addr, int kind){    printk(&quot;at24c02_detect\n&quot;);    /* 4.1 分配并设置i2c_client */    at24c02_client= kzalloc(sizeof(struct i2c_client), GFP_KERNEL);    at24c02_client-&gt;addr = addr;    at24c02_client-&gt;adapter = adap;    at24c02_client-&gt;driver = &amp;at24c02_driver;    at24c02_client-&gt;flags = 0;    strlcpy(at24c02_client-&gt;name, &quot;at24c02&quot;, I2C_NAME_SIZE);    /*4.2 使用i2c_attach_client()将i2c_client与适配器进行连接*/    i2c_attach_client(at24c02_client);    /*4.3 注册字符设备*/    at24c02_major= register_chrdev(0, &quot;at24c02&quot;, &amp;at24c02_fops);      at24c02_class=class_create(THIS_MODULE, &quot;at24c02&quot;);    class_device_create(at24c02_class,0, MKDEV(at24c02_major, 0),0,&quot;at24c02&quot;);    return 0;}/*5. 写init入口函数,exit出口函数*/static int at24c02_init(void){    i2c_add_driver(&amp;at24c02_driver);    return 0;}static void at24c02_exit(void){    i2c_del_driver(&amp;at24c02_driver);}module_init(at24c02_init);module_exit(at24c02_exit);MODULE_LICENSE(&quot;GPL&quot;);</code></pre><p><strong>测试程序：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;/* 测试方法： * i2c_test r addr * i2c_test w addr val */void print_usage(char *file){    printf(&quot;%s r addr\n&quot;, file);    printf(&quot;%s w addr val\n&quot;, file);}int main(int argc, char **argv){    int fd;    unsigned char buf[2];    if ((argc != 3) &amp;&amp; (argc != 4))    {        print_usage(argv[0]);        return -1;    }    //打开设备    fd = open(&quot;/dev/at24cxx&quot;, O_RDWR);    if (fd &lt; 0)    {        printf(&quot;can&#39;t open /dev/at24cxx\n&quot;);        return -1;    }    //读操作    if (strcmp(argv[1], &quot;r&quot;) == 0)    {        buf[0] = strtoul(argv[2], NULL, 0);//将字符串转为数字        read(fd, buf, 1);        printf(&quot;data: %c, %d, 0x%2x\n&quot;, buf[0], buf[0], buf[0]);    }    else if (strcmp(argv[1], &quot;w&quot;) == 0)//写操作    {        buf[0] = strtoul(argv[2], NULL, 0);//将字符串转为数字        buf[1] = strtoul(argv[3], NULL, 0);//将字符串转为数字        write(fd, buf, 2);    }    else//错误使用    {        print_usage(argv[0]);        return -1;    }    return 0;}</code></pre><p>扩展：</p><blockquote><p><code>strtoul</code>函数（将字符串转换成无符号长整型数）</p><p><strong>头文件</strong></p><pre><code class="c">#include&lt;stdlib.h&gt;</code></pre><p><strong>定义函数</strong></p><pre><code class="c">unsigned long strtoul(const char *nptr,char **endptr,int base);</code></pre><p><strong>函数说明</strong></p><p>strtoul()会将参数nptr字符串根据参数base来转换成无符号的长整型数。参数base范围从2至36，或0。参数base代表采用的进制方式，如base值为10则采用10进制，若base值为16则采用16进制数等。当base值为0时会根据情况选择用哪种进制：如果第一个字符是’0’，就判断第二字符如果是‘x’则用16进制，否则用8进制；第一个字符不是‘0’，则用10进制。一开始strtoul()会扫描参数nptr字符串，跳过前面的空格字符串，直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(‘’)结束转换，并将结果返回。若参数endptr不为NULL，则会将遇到不合条件而终止的nptr中的字符指针由endptr返回。</p><p><strong>返回值</strong></p><p>返回转换后的长整型数，否则返回ERANGE并将错误代码存入errno中。</p><p><strong>附加说明</strong></p><p>ERANGE指定的转换字符串超出合法范围。</p><p><strong>范例</strong></p><p>将十六进制 0xFF，转换成 10进制，得到 255</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){   int a;   char pNum[]=&quot;0xFF&quot;;   a=strtoul(pNum,0,0);//最后的0，表示自动识别pNum是几进制   printf(&quot;%ul\n&quot;,a);   return 0;}</code></pre><p>输出：</p><pre><code class="c">255</code></pre></blockquote><h3 id="11、测试运行"><a href="#11、测试运行" class="headerlink" title="11、测试运行"></a>11、测试运行</h3><p>如下所示：</p><pre><code class="shell"># ./19th_test R 0x10Read address 0x10 data is 0xff# ./19th_test W 0x10 0x10Write address 0x10 data is 0x10# ./19th_test R 0x10Read address 0x10 data is 0x10#</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IIC驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DM9000C网卡移植</title>
      <link href="/2019/08/04/DM9000C%E7%BD%91%E5%8D%A1%E7%A7%BB%E6%A4%8D/"/>
      <url>/2019/08/04/DM9000C%E7%BD%91%E5%8D%A1%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="DM9000C网卡移植"><a href="#DM9000C网卡移植" class="headerlink" title="DM9000C网卡移植"></a>DM9000C网卡移植</h1><h2 id="一、DM9000C原理图"><a href="#一、DM9000C原理图" class="headerlink" title="一、DM9000C原理图"></a>一、DM9000C原理图</h2><p>如下图所示:</p><p> <img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103114450670-735565523.png" alt="DM9000C原理图"></p><blockquote><p><strong>#</strong>:表示低电平有效</p></blockquote><ul><li><strong>SD0~15:</strong> 16位数据线,有CMD引脚决定访问类型</li><li><strong>CMD:</strong>      命令线,当CMD为高,表示SD 传输的是数据,CMD为低表示传输的是地址</li><li><strong>INT:</strong>         中断引脚,接在2440的GPF7脚上</li><li><strong>IOR#:</strong>      读引脚,接在2440的nOE脚上</li><li><strong>IOW#:</strong>     写引脚,接在2440的nWE脚上</li><li><strong>CS#:</strong>       片选,放在2440的bank4的片选上面</li></ul><h3 id="1、2440的bank4地址区间"><a href="#1、2440的bank4地址区间" class="headerlink" title="1、2440的bank4地址区间"></a>1、2440的bank4地址区间</h3><p><img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103114516623-1536854114.png" alt="bank4地址区间"></p><p>bank4的区间位于: 0X20000000~0X28000000,当我们访问这个区间的地址,内存控制器便会使能网卡DM9000C的使能脚,所以我们的DM9000C的io基地址=0X20000000</p><p>其中DM9000C的CMD引脚接在bank4的LADDR2上面，所以会有以下情况出现：</p><blockquote><p>当在地址<strong>0X2000 0000</strong>上读写数据时,表示读写的数据是DM9000C的<strong>地址</strong></p></blockquote><blockquote><p>访问的地址<strong>0X2000 0004</strong>上读写数据时,表示读写的数据是DM9000C的<strong>数据</strong></p></blockquote><h3 id="2、DM9000C收发过程"><a href="#2、DM9000C收发过程" class="headerlink" title="2、DM9000C收发过程"></a>2、DM9000C收发过程</h3><ul><li><p>当DM9000C收到外部的数据后,会暂存到内部地址中,然后产生一个上升沿中断,等待2440读取数据</p></li><li><p>当DM9000C将2440的数据转发出去后,也会产生一个上升沿中断给2440</p></li></ul><p>如下图所示,DM9000C的中断引脚位于pin34脚</p><p> <img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103114537123-407287413.png" alt="DM9000C中断引脚"></p><p><img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103114557904-271584403.png" alt="2440检测引脚"></p><p>接在2440的GPF7引脚上,使用的中断为<strong>EINT7</strong></p><h2 id="二、厂家提供的DM9000C源码"><a href="#二、厂家提供的DM9000C源码" class="headerlink" title="二、厂家提供的DM9000C源码"></a>二、厂家提供的DM9000C源码</h2><p>一般来说一个公司想推他的网卡芯片，厂家肯定比我们更加清楚怎么操作这个芯片，所以一般都会提供一个驱动程序，我们只需要在这个基础上修改即可。</p><pre><code class="c">#ifdef MODULEMODULE_LICENSE(&quot;GPL&quot;);MODULE_DESCRIPTION(&quot;Davicom DM9000/DM9010 ISA/uP Fast Ethernet Driver&quot;);....../* Description:    when user used insmod to add module, system invoked init_module()   to initilize and register.*/int __init init_module(void){    switch(mode) {        case DM9KS_10MHD:        case DM9KS_100MHD:        case DM9KS_10MFD:        case DM9KS_100MFD:            media_mode = mode;            break;        default:            media_mode = DM9KS_AUTO;    }    dmfe_dev = dmfe_probe();//初始化DM9000C硬件和设置net_device结构体的成员 下一步会讲    if(IS_ERR(dmfe_dev))        return PTR_ERR(dmfe_dev);    return 0;}/* Description:    when user used rmmod to delete module, system invoked clean_module()   to  un-register DEVICE.*/void __exit cleanup_module(void){    ......}#endif</code></pre><p>这里可以发现它的init_module()入口函数前有个条件编译，而该编译条件之前是未定义的，所以这里应该注释掉 <strong>“#ifdef MODULE”</strong> 和 <strong>“#endif”</strong></p><p>关于入口出口函数名，这里建议修改函数名并利用如下宏修饰函数名，避免与内核的其它函数重名</p><pre><code class="c">/* Description:    when user used insmod to add module, system invoked init_module()   to initilize and register.*/int __init dm9000c_init(void){    ......}/* Description:    when user used rmmod to delete module, system invoked clean_module()   to  un-register DEVICE.*/void __exit dm9000c_exit(void){    ......}module_init(dm9000c_init);module_exit(dm9000c_exit);</code></pre><h2 id="三、修改驱动的硬件相异性-设置基地址-寄存器-中断等"><a href="#三、修改驱动的硬件相异性-设置基地址-寄存器-中断等" class="headerlink" title="三、修改驱动的硬件相异性(设置基地址,寄存器,中断等)"></a>三、修改驱动的硬件相异性(设置基地址,寄存器,中断等)</h2><h3 id="1、初始化DM9000C硬件"><a href="#1、初始化DM9000C硬件" class="headerlink" title="1、初始化DM9000C硬件"></a>1、初始化DM9000C硬件</h3><p>通过入口程序发现会调用<strong>dmfe_probe()</strong>：</p><blockquote><p>dm9000c_init()</p><p>​       -&gt; dmfe_probe()</p></blockquote><p>其中dmfe_probe()函数如下:</p><pre><code class="c">struct net_device * __init dmfe_probe(void){    struct net_device *dev;    dev= alloc_etherdev(sizeof(struct board_info));//分配一个net_device结构体    ... ...    err = dmfe_probe1(dev);//调用dmfe_probe1()函数    ... ...    err = register_netdev(dev);//向内核注册net_device结构体    ... ...}</code></pre><p>显然dmfe_probe1()函数就是用来初始化DM9000C硬件和设置net_device结构体的成员用的</p><h3 id="2、dmfe-probe1-函数"><a href="#2、dmfe-probe1-函数" class="headerlink" title="2、dmfe_probe1()函数"></a>2、dmfe_probe1()函数</h3><p>如下所示，这个iobase 变量就是我们DM9000C的io基地址0x20000000</p><pre><code class="c">int __init dmfe_probe1(struct net_device *dev){    struct board_info *db;    /* Point a board information structure */    u32 id_val;    u16 i, dm9000_found = FALSE;    u8 MAC_addr[6]={0x00,0x60,0x6E,0x33,0x44,0x55};    u8 HasEEPROM=0,chip_info;    DMFE_DBUG(0, &quot;dmfe_probe1()&quot;,0);    /* Search All DM9000 serial NIC */    do {        outb(DM9KS_VID_L, iobase);//CMD引脚置0，写入要读的地址        id_val = inb(iobase + 4);//CMD置1，读出要读的数据        outb(DM9KS_VID_H, iobase);        id_val |= inb(iobase + 4) &lt;&lt; 8;        outb(DM9KS_PID_L, iobase);        id_val |= inb(iobase + 4) &lt;&lt; 16;        outb(DM9KS_PID_H, iobase);        id_val |= inb(iobase + 4) &lt;&lt; 24;        ... ...}</code></pre><p><strong>iobase的作用:</strong></p><p>如上图, 读一次DM9000C的VID低字节之前,需要先将地址赋为0x20000000,也就是将DM9000C的CMD置0，然后向0x20000000写入要读的DM9KS_VID_L地址值</p><p>最后再将地址+4,也就是赋为0x20000100,将CMD置1,然后读出0x20000100的值,也就是DM9000C的VID低字节</p><blockquote><p> DM9000C的读写方式都是这样的,先将CMD置0，写入DM9000C的地址,然后再将CMD置1,来读写数据</p></blockquote><h3 id="3、重新初始化iobase"><a href="#3、重新初始化iobase" class="headerlink" title="3、重新初始化iobase"></a>3、重新初始化iobase</h3><p>所以这里需要在init函数中便重新设置iobase 变量,其中iobase是int型</p><pre><code class="c">void __init dm9000c_init(void){    iobase = (int)ioremap(0x20000000,4096);//获取DM9000C基地址    ......}</code></pre><p>并在exit出口函数中,添加iounmp()</p><pre><code class="c">void __exit dm9000c_exit(void){    ......    iounmap(iobase);}</code></pre><h3 id="4、屏蔽核对版本代码"><a href="#4、屏蔽核对版本代码" class="headerlink" title="4、屏蔽核对版本代码"></a>4、屏蔽核对版本代码</h3><p>如下所示为dmfe_probe1()函数中用来核对版本的代码,我们的DM9000C版本号不一样,所以<strong>要屏蔽</strong></p><pre><code class="c">int __init dmfe_probe1(struct net_device *dev){    struct board_info *db;    /* Point a board information structure */    u32 id_val;    u16 i, dm9000_found = FALSE;    u8 MAC_addr[6]={0x00,0x60,0x6E,0x33,0x44,0x55};    u8 HasEEPROM=0,chip_info;    DMFE_DBUG(0, &quot;dmfe_probe1()&quot;,0);    /* Search All DM9000 serial NIC */    do {        ... ...        if (id_val == DM9KS_ID || id_val == DM9010_ID) {            ... ...            chip_info = ior(db,0x43);            if((db-&gt;chip_revision!=0x1A) || ((chip_info&amp;(1&lt;&lt;5))!=0) || ((chip_info&amp;(1&lt;&lt;2))!=1)) return -ENODEV;//核对DM9000C版本，需要屏蔽            ... ...}</code></pre><h3 id="5、修改中断名"><a href="#5、修改中断名" class="headerlink" title="5、修改中断名"></a>5、修改中断名</h3><p>在init函数中,修改中断名,将irq改为<strong>IRQ_EINT7</strong></p><pre><code class="c">void __init dm9000c_init(void){    iobase = (int)ioremap(0x20000000,4096);//获取DM9000C基地址    irq = IRQ_EINT7;//修改中断名    ......}</code></pre><h3 id="6、修改中断"><a href="#6、修改中断" class="headerlink" title="6、修改中断"></a>6、修改中断</h3><p>当使用了register_netdev()注册了网卡驱动net_device后,在命令行中使用ifconfig就会进入net_device-&gt;open成员函数，该函数会进行申请中断、激活队列等操作</p><p>所以我们要修改open成员函数的申请中断函数,将触发中断改为“IRQT_RISING”,上升沿触发</p><p>通过dmfe_probe1()函数可以知道open成员函数为：<strong>dmfe_open()</strong></p><pre><code class="c">int __init dmfe_probe1(struct net_device *dev){    ......    /* Search All DM9000 serial NIC */    do {        ......        if (id_val == DM9KS_ID || id_val == DM9010_ID) {            ......            chip_info = ior(db,0x43);            if((db-&gt;chip_revision!=0x1A) || ((chip_info&amp;(1&lt;&lt;5))!=0) || ((chip_info&amp;(1&lt;&lt;2))!=1)) return -ENODEV;            /* driver system function */                            dev-&gt;base_addr         = iobase;            dev-&gt;irq         = irq;            dev-&gt;open         = &amp;dmfe_open;//open成员函数            dev-&gt;hard_start_xmit     = &amp;dmfe_start_xmit;            dev-&gt;watchdog_timeo    = 5*HZ;                dev-&gt;tx_timeout        = dmfe_timeout;            dev-&gt;stop         = &amp;dmfe_stop;            dev-&gt;get_stats         = &amp;dmfe_get_stats;            dev-&gt;set_multicast_list = &amp;dm9000_hash_table;            dev-&gt;do_ioctl         = &amp;dmfe_do_ioctl;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,28)            dev-&gt;ethtool_ops = &amp;dmfe_ethtool_ops;#endif#ifdef CHECKSUM            //dev-&gt;features |=  NETIF_F_IP_CSUM;            dev-&gt;features |=  NETIF_F_IP_CSUM|NETIF_F_SG;#endif            db-&gt;mii.dev = dev;            db-&gt;mii.mdio_read = mdio_read;            db-&gt;mii.mdio_write = mdio_write;            db-&gt;mii.phy_id = 1;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,20)            db-&gt;mii.phy_id_mask = 0x1F;             db-&gt;mii.reg_num_mask = 0x1F; #endif            //db-&gt;msg_enable =(debug == 0 ? DMFE_DEF_MSG_ENABLE : ((1 &lt;&lt; debug) - 1));            ......}</code></pre><p>接着修改open成员函数<strong>dmfe_open()</strong>,将触发中断改为“<strong>IRQT_RISING</strong>”</p><pre><code class="c">static int dmfe_open(struct net_device *dev){    board_info_t *db = (board_info_t *)dev-&gt;priv;    u8 reg_nsr;    int i;    DMFE_DBUG(0, &quot;dmfe_open&quot;, 0);    //修改为IRQT_RISING，即为1    //默认为IRQT_NOEDGE，即为0    if (request_irq(dev-&gt;irq,&amp;dmfe_interrupt,IRQT_RISING,dev-&gt;name,dev))         return -EAGAIN;    ......}</code></pre><h2 id="四、设置2440的存储控制寄存器"><a href="#四、设置2440的存储控制寄存器" class="headerlink" title="四、设置2440的存储控制寄存器"></a>四、设置2440的存储控制寄存器</h2><p>这里需要设置2440的bank4的硬件位宽、时序。因为不同的硬件，涉及的数据收发都不同。</p><h3 id="1、设置BWSCON总线宽度控制寄存器"><a href="#1、设置BWSCON总线宽度控制寄存器" class="headerlink" title="1、设置BWSCON总线宽度控制寄存器"></a>1、设置BWSCON总线宽度控制寄存器</h3><p>这里我们只设置BANK4的内容,所以只有下面3个需要设置</p><blockquote><p>注：BANK0的位宽由OM[1:0] 硬件设置</p></blockquote><p><img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103134935138-777045831.png" alt="BWSCON寄存器"></p><p>设置ST4=0,不使用UB/LB(UB/LB:表示高字节与低字节数据是否分开传输)</p><p>设置WS4=0,其中WAIT引脚为PE4,而我们DM9000C没有引脚接入PE4,所以禁止</p><p>设置DW4=0x01,我们的DM9000C的数据线为16位</p><h3 id="2、设置BANKCON4控制寄存器"><a href="#2、设置BANKCON4控制寄存器" class="headerlink" title="2、设置BANKCON4控制寄存器"></a>2、设置BANKCON4控制寄存器</h3><p><img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103134946857-449769840.png" alt="BANKCON4控制寄存器"></p><p>设置这些时序之前,首先来看DM9000C芯片手册时序图和2440的时序图</p><p><img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20180110140356176-1156072857.png" alt="DM9000C芯片手册时序图和2440的时序图"></p><p>参考上图,得出<strong>BANKCON4</strong> 寄存器设置如下(HCLK=100MHZ,1个时钟等于10ns)</p><ul><li>设置Tacs=0,因为CS和CMD可以同时结束(bank4地址(也就是CMD)稳定多久后,CS片选才启动)</li><li>设置Tcos=T1=0(CS片选后,多久才能使能读写)</li><li>设置Tacc=T2&gt;=10ns=1,表示2个时钟 (access cycle ,读写使能后,多久才能访问数据)</li><li>设置Tcoh=T4&gt;=3ns=1,表示1个时钟 ,因为当DM9000的写信号取消后,数据线上的数据还需要至少3ns才消失(nOE读写取消后,片选需要维持多长时间)</li><li>设置Tcah=0,因为 CS和CMD可以同时结束 (CS片选取消后,地址(也就是CMD)需要维持多长时间)</li></ul><p>代码如下,在init入口函数中设置</p><pre><code class="c">int __init dm9000c_init(void){    unsigned long *BWSCON;//0x48000000    unsigned long *BANKCON4;//0x48000014    iobase =(int)ioremap(0x20000000,4096);//获取DM9000C基地址    irq=IRQ_EINT7;//设置中断名    /*设置硬件相关*/    BWSCON   = ioremap(0x48000000,4);    BANKCON4 = ioremap(0x48000014,4);    /*    ST4[19]：0=未使用UB/LB    *    WS4[18]：0=WAIT禁止    *    DW4[17：16]：01=16位    */    *BWSCON &amp;=~(0XFF&lt;&lt;16);    *BWSCON |= (0x01&lt;&lt;16);//关闭UB/LB，解止WAIT信号，设置16位宽数据    /*     * Tacs[14:13]: 发出片选信号之前,多长时间内要先发出地址信号     *              DM9000C的片选信号和CMD信号可以同时发出,     *              所以它设为0     * Tcos[12:11]: 发出片选信号之后,多长时间才能发出读信号nOE     *              DM9000C的T1&gt;=0ns,      *              所以它设为0     * Tacc[10:8] : 读写信号的脉冲长度,      *              DM9000C的T2&gt;=10ns,      *              所以它设为1, 表示2个hclk周期,hclk=100MHz,就是20ns     * Tcoh[7:6]  : 当读信号nOE变为高电平后,片选信号还要维持多长时间     *              DM9000C进行写操作时, nWE变为高电平之后, 数据线上的数据还要维持最少3ns     *              DM9000C进行读操作时, nOE变为高电平之后, 数据线上的数据在6ns之内会消失     *              我们取一个宽松值: 让片选信号在nOE放为高电平后,再维持10ns,      *              所以设为01     * Tcah[5:4]  : 当片选信号变为高电平后, 地址信号还要维持多长时间     *              DM9000C的片选信号和CMD信号可以同时出现,同时消失     *              所以设为0     * PMC[1:0]   : 00-正常模式     *     */    *BANKCON4 = (0x1&lt;&lt;8)|(0x1&lt;&lt;6);    /*后面不会用到，所以注销掉*/    iounmap(BWSCON);    iounmap(BANKCON4);    ......</code></pre><blockquote><p>若DM9000C无法驱动,可能是Tacc时间太短,导致读取不到数据<strong>,</strong>可以将Tacc设大一点</p></blockquote><h2 id="五、编译测试"><a href="#五、编译测试" class="headerlink" title="五、编译测试"></a>五、编译测试</h2><p>编译之前，首先添加该驱动需要的内核头文件:</p><pre><code class="c">#include &lt;asm/delay.h&gt;#include &lt;asm/irq.h&gt;#include &lt;linux/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/arch-s3c2410/regs-mem.h&gt;</code></pre><p>编译无误后,便开始测试DM9000C驱动程序:</p><ul><li><p>1) 把dm9dev9000c.c放到内核的drivers/net目录下,来替换原来内核的DM9000C</p></li><li><p>2) 修改内核中的makefile，位于drivers/net/Makefile </p><p>  把</p><pre><code class="makefile">  obj-$(CONFIG_DM9000) += dm9000.o</code></pre><p>  改为</p><pre><code class="makefile">  obj-$(CONFIG_DM9000) += dm9dev9000c.o</code></pre></li><li><p>3) make uImage</p><p>  如下图,说明新的驱动已编译进内核</p><p>  <img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103140121763-1818826998.png" alt="新驱动"></p></li><li><p>4) 使用新内核启动</p><pre><code class="shell">  ifconfig eth0 192.168.2.107  ping 192.168.2.1</code></pre><p>  如下图,可以ping通,说明移植成功</p><p>  <img src="//NU-LL.github.io/2019/08/04/DM9000C网卡移植/1182576-20171103135053201-1652277175.png" alt="命令截图"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DM9000C </tag>
            
            <tag> 网卡移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网卡驱动程序</title>
      <link href="/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/08/04/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="网卡驱动程序"><a href="#网卡驱动程序" class="headerlink" title="网卡驱动程序"></a>网卡驱动程序</h1><h2 id="一、网卡驱动程序框架"><a href="#一、网卡驱动程序框架" class="headerlink" title="一、网卡驱动程序框架"></a>一、网卡驱动程序框架</h2><h3 id="相关驱动特点"><a href="#相关驱动特点" class="headerlink" title="相关驱动特点"></a>相关驱动特点</h3><ul><li><p>字符设备驱动</p><ol><li>设置主设备号</li><li>填充file_operations结构体</li><li>用register_chrdev(主设备号，name，file_operations结构体)注册驱动</li><li>入口函数</li><li>出口函数</li></ol></li><li><p>块符设备驱动</p><ol><li><p>分配geadisk结构体（利用alloc_disk函数）</p></li><li><p>设置</p><ul><li>构造队列queue=blk_init_queue(处理队列的函数)</li><li>其他属性（主设备号、容量）</li></ul></li><li><p>注册geadisk结构体（利用add_disk函数）</p><blockquote><p>上述字符设备驱动和块符设备驱动的共同特点：</p><ul><li>都有设备节点</li><li>字符设备需要先open、块设备需要先格式化然后挂接（mount）</li></ul></blockquote></li></ol></li><li><p>网卡驱动</p><p>  不需要打开某设备，直接使用socket即可编程</p><p>  网卡的驱动与硬件相关,主要是负责收发网络的数据包,它将上层协议传递下来的数据包以特定的媒介访问控制方式进行发送， 并将接收到的数据包传递给上层协议。</p><p>  网卡设备与字符设备和块设备不同， 网络设备并不对应于<strong>/dev</strong>目录下的文件,不过会存放在<strong>/sys/class/net</strong>目录下</p></li></ul><h3 id="Linux网络设备驱动的4层模型"><a href="#Linux网络设备驱动的4层模型" class="headerlink" title="Linux网络设备驱动的4层模型"></a>Linux网络设备驱动的4层模型</h3><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1022162-20170327104036061-1284399912.png" alt="OSI 7层模型"></p><p>上图就是经典的OSI 7层模型，Linux的网卡驱动程序处于OSI模型中的数据链路层，他的职责就是将上上层的协议栈传过来的信息通过网卡发送出去，Linux的网络驱动模型采用4层结构:</p><p><strong>1)网络协议接口层:</strong></p><p>实现统一的数据包收发的协议,该层主要负责调用dev_queue_xmit()函数发送数据，netif_rx()函数接收数据</p><p><strong>2)网络设备接口层:</strong></p><p>通过net_device结构体来描述一个具体的网络设备的信息,实现不同的硬件的统一</p><p><strong>3)设备驱动功能层：</strong></p><p>用来负责驱动网络设备硬件来完成各个功能, 它通过hard_start_xmit() 函数启动发送操作， 并通过网络设备上的中断触发接收操作,</p><p><strong>4)网络设备与媒介层：</strong></p><p>用来负责完成数据包发送和接收的物理实体, 设备驱动功能层的函数都在这物理上驱动的</p><h3 id="网卡驱动初始化"><a href="#网卡驱动初始化" class="headerlink" title="网卡驱动初始化"></a>网卡驱动初始化</h3><p>我们的网卡驱动程序,只需要编写网络设备接口层,填充net_device数据结构的内容并将net_device注册入内核,设置硬件相关操作,使能中断处理等</p><h4 id="net-device结构体的重要成员"><a href="#net-device结构体的重要成员" class="headerlink" title="net_device结构体的重要成员"></a>net_device结构体的重要成员</h4><pre><code class="c">struct net_device{    char               name[IFNAMSIZ];   //网卡设备名称    unsigned long      mem_end;          //该设备的内存结束地址    unsigned long      mem_start;        //该设备的内存起始地址    unsigned long      base_addr;        //该设备的内存I/O基地址    unsigned int       irq;              //该设备的中断号    unsigned char      if_port;          //多端口设备使用的端口类型    unsigned char      dma;              //该设备的DMA通道    unsigned long      state;            //网络设备和网络适配器的状态信息    struct net_device_stats* (*get_stats)(struct net_device *dev); //获取流量的统计信息    //运行ifconfig便会调用该成员函数,并返回一个net_device_stats结构体获取信息    struct net_device_stats  stats;      //用来保存统计信息的net_device_stats结构体    unsigned long      features;        //接口特征,         unsigned int       flags;             //flags指网络接口标志,以IFF_(Interface Flags)开头    /*当flags =         IFF_UP（ 当设备被激活并可以开始发送数据包时， 内核设置该标志）        IFF_AUTOMEDIA（设置设备可在多种媒介间切换）        IFF_BROADCAST（ 允许广播）        IFF_DEBUG（ 调试模式， 可用于控制printk调用的详细程度）        IFF_LOOPBACK（ 回环）、IFF_MULTICAST（ 允许组播）        IFF_NOARP（ 接口不能执行ARP,点对点接口就不需要运行 ARP）        IFF_POINTOPOINT（ 接口连接到点到点链路） 等。    */    unsigned           mtu;                //最大传输单元,也叫最大数据包    unsigned short     type;   　　       //接口的硬件类型    unsigned short     hard_header_len; //硬件帧头长度,一般被赋为ETH_HLEN,即14    unsigned char      dev_addr[MAX_ADDR_LEN];//存放设备的MAC地址    unsigned long      last_rx;            //接收数据包的时间戳,调用netif_rx()后赋上jiffies即可    unsigned long      trans_start;     //发送数据包的时间戳,当要发送的时候赋上jiffies即可    unsigned char      dev_addr[MAX_ADDR_LEN];//MAC地址    int (*hard_start_xmit) (struct sk_buff *skb, struct net_device *dev);//数据包发送函数, sk_buff就是用来收发数据包的结构体    void (*tx_timeout) (struct net_device *dev);//发包超时处理函数    ... ...}</code></pre><p>上面讲到的统计信息net_device_stats结构体,其中重要成员如下所示:</p><pre><code class="c">struct net_device_stats{    unsigned long       rx_packets;          　　/*收到的数据包数*/    unsigned long       tx_packets;          　　/*发送的数据包数    */    unsigned long       rx_bytes;               /*收到的字节数,可以通过sk_buff结构体的成员len来获取*/    unsigned long       tx_bytes;               /*发送的字节数,可以通过sk_buff结构体的成员len来获取*/    unsigned long       rx_errors;              /*收到的错误数据包数*/    unsigned long       tx_errors;              /*发送的错误数据包数*/    ... ...}</code></pre><h4 id="初始化网卡步骤"><a href="#初始化网卡步骤" class="headerlink" title="初始化网卡步骤"></a>初始化网卡步骤</h4><ul><li>1)使用alloc_netdev()来分配一个net_device结构体 </li><li>2)设置网卡硬件相关的寄存器</li><li>3)设置net_device结构体的成员</li><li>4)使用register_netdev()来注册net_device结构体</li></ul><h3 id="网卡驱动发包过程"><a href="#网卡驱动发包过程" class="headerlink" title="网卡驱动发包过程"></a>网卡驱动发包过程</h3><p>在内核中,当上层要发送一个数据包时, 就会调用网络设备层里net_device数据结构的成员<strong>hard_start_xmit()</strong>将数据包发送出去。</p><p><strong>hard_start_xmit()</strong>发包函数需要我们自己构建,该函数原型如下所示:</p><pre><code class="c">int (*hard_start_xmit) (struct sk_buff *skb, struct net_device *dev);</code></pre><p>在这个函数中需要涉及到sk_buff结构体，即套接字缓冲区(socket buffer)，用来网络各个层次之间传递数据。</p><h4 id="sk-buff结构体及其重要成员"><a href="#sk-buff结构体及其重要成员" class="headerlink" title="sk_buff结构体及其重要成员"></a>sk_buff结构体及其重要成员</h4><pre><code class="c">struct sk_buff {    /* These two members must be first. */    struct sk_buff        *next;//指向下一个sk_buff结构体    struct sk_buff        *prev;//指向前一个sk_buff结构体    ... ...    unsigned int          len,  //数据包的总长度,包括线性数据和非线性数据    data_len,        //非线性的数据长度    mac_len;         //mac包头长度    __u32    　　　　          priority;//该sk_buff结构体的优先级       __be16  　　 　　         protocol;//存放上层的协议类型,可以通过eth_type_trans()来获取    ... ...    sk_buff_data_t         transport_header;//传输层头部的偏移值    sk_buff_data_t         network_header;  //网络层头部的偏移值    sk_buff_data_t         mac_header;      //MAC数据链路层头部的偏移值    sk_buff_data_t         tail;            //指向缓冲区的数据包末尾    sk_buff_data_t         end;             //指向缓冲区的末尾    unsigned char        　*head,           //指向缓冲区的协议头开始位置                           *data;           //指向缓冲区的数据包开始位置    ... ...}</code></pre><p>可以看出该结构体为一个双向链表</p><p>其中sk_buff结构体的空间,如下图所示:</p><p> <img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031190937701-249952599.png" alt="sk_buff结构体空间"></p><p>其中sk_buff-&gt; data数据包格式如下图所示:</p><p> <img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031190949216-296868542.png" alt="data数据包格式"></p><p> 即：</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1022162-20170301210540141-1527132087.png" alt="sk_buff"></p><h4 id="hard-start-xmit-发包的处理步骤"><a href="#hard-start-xmit-发包的处理步骤" class="headerlink" title="hard_start_xmit()发包的处理步骤"></a>hard_start_xmit()发包的处理步骤</h4><ul><li><p>1)把数据包发出去之前,需要使用<strong>netif_stop_queue()</strong>来停止上层传下来的数据包,</p></li><li><p>2)设置寄存器,通过网络设备硬件,来发送数据</p></li><li><p>3)当数据包发出去后, 再调用<strong>dev_kfree_skb()</strong>函数来释放sk_buff,该函数原型如下:</p><pre><code class="c">  void dev_kfree_skb(struct sk_buff *skb);</code></pre></li><li><p>4)当数据包发出成功,就会进入TX中断函数,然后更新统计信息,调用<strong>netif_wake_queue()</strong>来唤醒,启动上层继续发包下来.</p></li><li><p>5)若数据包发出去超时,一直进不到TX中断函数,就会调用net_device结构体的(<em>tx_timeout)超时成员函数,在该函数中更新统计信息, 调用*</em>netif_wake_queue()**来唤醒</p></li></ul><p>其中netif_wake_queue()和netif_stop_queue()函数原型如下所示:</p><pre><code class="c">void netif_wake_queue(struct net_device *dev);  //唤醒被阻塞的上层,启动继续向网络设备驱动层发送数据包</code></pre><pre><code class="c">void netif_stop_queue(struct net_device *dev); //阻止上层向网络设备驱动层发送数据包</code></pre><h3 id="网卡驱动收包过程"><a href="#网卡驱动收包过程" class="headerlink" title="网卡驱动收包过程"></a>网卡驱动收包过程</h3><p>而接收数据包主要是通过中断函数处理,来判断中断类型,如果等于<strong>ISQ_RECEIVER_EVENT</strong>,表示为接收中断,然后进入接收数据函数,通过<strong>netif_rx()</strong>将数据上交给上层。</p><p>如下所示,参考的内核中自带的网卡驱动:/drivers/net/cs89x0.c</p><pre><code class="c">static irqreturn_t net_interrupt(int irq, void *dev_id){    struct net_device *dev = dev_id;    struct net_local *lp;    int ioaddr, status;     int handled = 0;    ioaddr = dev-&gt;base_addr;    lp = netdev_priv(dev);    /* we MUST read all the events out of the ISQ, otherwise we&#39;ll never           get interrupted again.  As a consequence, we can&#39;t have any limit           on the number of times we loop in the interrupt handler.  The           hardware guarantees that eventually we&#39;ll run out of events.  Of           course, if you&#39;re on a slow machine, and packets are arriving           faster than you can read them off, you&#39;re screwed.  Hasta la           vista, baby!  */    while ((status = readword(dev-&gt;base_addr, ISQ_PORT))) {        if (net_debug &gt; 4)printk(&quot;%s: event=%04x\n&quot;, dev-&gt;name, status);        handled = 1;        switch(status &amp; ISQ_EVENT_MASK) {        case ISQ_RECEIVER_EVENT:        //判断是否为接受中断            /* Got a packet(s). */            net_rx(dev);                //通过net_rx函数将接受到的数据上交给上层            break;        case ISQ_TRANSMITTER_EVENT:        //判断是否为发送中断                ......</code></pre><p>该函数就是通过获取的status标志来判断是什么中断,如果是接收中断,就进入<strong>net_rx()</strong></p><h4 id="net-rx-收包的处理步骤"><a href="#net-rx-收包的处理步骤" class="headerlink" title="net_rx()收包的处理步骤"></a>net_rx()收包的处理步骤</h4><ul><li>1)使用dev_alloc_skb()来构造一个新的sk_buff</li><li>2)使用skb_reserve(rx_skb, 2); 将sk_buff缓冲区里的数据包先后位移2字节,来腾出sk_buff缓冲区里的头部空间</li><li>3)读取网络设备硬件上接收到的数据</li><li>4)使用memcpy()将数据复制到新的sk_buff里的data成员指向的地址处,可以使用skb_put()来动态扩大sk_buff结构体里中的数据区</li><li>5)使用eth_type_trans()来获取上层协议,将返回值赋给sk_buff的protocol成员里</li><li>6)然后更新统计信息,最后使用netif_rx( )来将sk_fuffer传递给上层协议中</li></ul><p>其中<strong>skb_put()</strong>函数原型如下所示:</p><pre><code class="c">static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len);//len:将数据区向下扩大len字节</code></pre><p>使用skb_put()函数后,其中sk_buff缓冲区变化如下图:</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031191040904-388639517.png" alt="sk_buff缓冲区变化"></p><h2 id="二、编写虚拟网卡驱动"><a href="#二、编写虚拟网卡驱动" class="headerlink" title="二、编写虚拟网卡驱动"></a>二、编写虚拟网卡驱动</h2><p>这里写一个简单的虚拟网卡驱动,也就是说不需要硬件相关操作,所以就没有中断函数,我们通过linux的ping命令来实现发包,然后在发包函数中伪造一个收的ping包函数,实现能ping通任何ip地址</p><p><strong>在init初始函数中:</strong></p><ul><li>1)使用<strong>alloc_netdev()</strong>来分配一个net_device结构体</li><li>2)设置net_device结构体的成员</li><li>3)使用<strong>register_netdev()</strong>来注册net_device结构体</li></ul><p><strong>在发包函数中:</strong></p><ul><li>1)使用<strong>netif_stop_queue()</strong>来阻止上层向网络设备驱动层发送数据包</li><li>2)调用收包函数,并传入发送的sk_buff缓冲区, 用来伪造一个收到ping包的函数</li><li>3)使用<strong>dev_kfree_skb()</strong>函数来释放发送的sk_buff缓存区</li><li>4)更新发送的统计信息</li><li>5)使用<strong>netif_wake_queue()</strong>来唤醒被阻塞的上层,</li></ul><p><strong>在收包函数中:</strong></p><blockquote><p>该部分可以参考LDD3（linux device drivers,third edition）</p></blockquote><p>首先修改发送的sk_buff里数据包的数据,使它变为一个接收的sk_buff,其中数据包结构如下图所示:</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031191106623-1661659162.png" alt="数据包"></p><ul><li><p>1)需要对调上图的ethhdr结构体中的 ”源/目的”MAC地址</p></li><li><p>2)需要对调上图的iphdr结构体中的”源/目的” IP地址</p></li><li><p>3)使用<strong>ip_fast_csum()</strong>来重新获取iphdr结构体的校验码</p></li><li><p>4)设置上图数据包的数据类型,之前是发送ping包为0x08,需要改为0x00,表示接收ping包</p></li><li><p>5)使用dev_alloc_skb()来构造一个新的sk_buff</p></li><li><p>6)使用skb_reserve(rx_skb, 2);将sk_buff缓冲区里的数据包先后位移2字节,来腾出sk_buff缓冲区里的头部空间</p></li><li><p>7)使用memcpy()将之前修改好的sk_buff-&gt;data复制到新的sk_buff里的data成员指向的地址处:</p><pre><code class="c">  memcpy(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len);// skb_put():来动态扩大sk_buff结构体里中的数据区，避免溢出</code></pre></li><li><p>8)设置新的sk_buff 其它成员</p></li><li><p>9)使用<strong>eth_type_trans()</strong>来获取上层协议,将返回值赋给sk_buff的protocol成员里</p></li><li><p>10)然后更新接收统计信息,最后使用<strong>netif_rx()</strong>来将sk_fuffer传递给上层协议中</p></li></ul><h3 id="驱动具体代码分析"><a href="#驱动具体代码分析" class="headerlink" title="驱动具体代码分析"></a>驱动具体代码分析</h3><pre><code class="c">#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/netdevice.h&gt;#include &lt;linux/etherdevice.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/fcntl.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/ioport.h&gt;#include &lt;linux/in.h&gt;#include &lt;linux/skbuff.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/spinlock.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/bitops.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ip.h&gt; #include &lt;asm/system.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/irq.h&gt;static struct net_device    *virt_net;static void virt_rs_packet(struct sk_buff *skb, struct net_device *dev){    unsigned char *type;    struct iphdr *ih;    __be32 *saddr, *daddr, tmp;    unsigned char tmp_dev_addr[ETH_ALEN];    struct ethhdr *ethhdr;    struct sk_buff *rx_skb;    /*1) 对调ethhdr结构体 &quot;源/目的&quot;MAC地址*/    ethhdr = (struct ethhdr *)skb-&gt;data;    memcpy(tmp_dev_addr, ethhdr-&gt;h_dest, ETH_ALEN);    memcpy(ethhdr-&gt;h_dest, ethhdr-&gt;h_source, ETH_ALEN);    memcpy(ethhdr-&gt;h_source, tmp_dev_addr, ETH_ALEN);    /*2)对调 iphdr结构体&quot;源/目的&quot; IP地址*/    ih = (struct iphdr *)(skb-&gt;data + sizeof(struct ethhdr));    saddr = &amp;ih-&gt;saddr;    daddr = &amp;ih-&gt;daddr;    tmp = *saddr;    *saddr = *daddr;    *daddr = tmp;    /*3)使用ip_fast_csum()来重新获取iphdr结构体的校验码*/    ih-&gt;check = 0;                   ih-&gt;check = ip_fast_csum((unsigned char *)ih,ih-&gt;ihl);    /*4)设置数据类型*/    type = skb-&gt;data + sizeof(struct ethhdr) + sizeof(struct iphdr);    *type = 0;      //之前是发送ping包0x08,需要改为0x00,表示接收ping包    /*5)使用dev_alloc_skb()来构造一个新的sk_buff   */    rx_skb = dev_alloc_skb(skb-&gt;len + 2);    /*6)使用skb_reserve()来腾出2字节头部空间  */    skb_reserve(rx_skb, 2);    /*7)使用memcpy()将之前修改好的sk_buff-&gt;data复制到新的sk_buff里*/    memcpy(skb_put(rx_skb, skb-&gt;len), skb-&gt;data, skb-&gt;len); // skb_put():来动态扩大sk_buff结构体里中的数据区，避免溢出    /*8)设置新的sk_buff 其它成员*/    rx_skb-&gt;dev = dev;    rx_skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; /* don&#39;t check it */    /*9)使用eth_type_trans()来获取上层协议 */    rx_skb-&gt;protocol = eth_type_trans(rx_skb, dev);    /*10) 更新接收统计信息,并使用netif_rx( )来 传递sk_fuffer收包 */    dev-&gt;stats.rx_packets++;                         dev-&gt;stats.rx_bytes += skb-&gt;len;    dev-&gt;last_rx= jiffies;//收包时间戳    netif_rx(rx_skb);}static int virt_send_packet(struct sk_buff *skb, struct net_device *dev){    /*1)使用netif_stop_queue()来阻止上层向网络设备驱动层发送数据包*/    netif_stop_queue(dev);    //期间设置硬件发送数据包    /*2)调用收包函数,里面来伪造一个收的ping包函数*/    virt_rs_packet(skb,dev);    /*3)使用dev_kfree_skb()函数来释放发送的sk_buff缓存区*/    dev_kfree_skb(skb);    /*4)更新发送的统计信息*/    dev-&gt;stats.tx_packets++;            //成功发送一个包    dev-&gt;stats.tx_bytes+=skb-&gt;len;      //成功发送len长字节    dev-&gt;trans_start = jiffies;         //发送时间戳    /*5)使用netif_wake_queue()来唤醒被阻塞的上层*/    netif_wake_queue(dev);     return 0;}static int virt_net_init(void){    /*1)使用alloc_netdev()来分配一个net_device结构体*/    virt_net= alloc_netdev(sizeof(struct net_device), &quot;virt_eth0&quot;, ether_setup);    /*2)设置net_device结构体的成员 */    virt_net-&gt;hard_start_xmit      = virt_send_packet;    /* 设置MAC地址 */    virt_net-&gt;dev_addr[0] = 0x08;　　　　     virt_net-&gt;dev_addr[1] = 0x89;    virt_net-&gt;dev_addr[2] = 0x89;    virt_net-&gt;dev_addr[3] = 0x89;    virt_net-&gt;dev_addr[4] = 0x89;    virt_net-&gt;dev_addr[5] = 0x89;    /* 设置下面两项才能ping通 */    virt_net-&gt;flags           |= IFF_NOARP;    virt_net-&gt;features        |= NETIF_F_NO_CSUM;    /*3)使用register_netdev()来注册net_device结构体 */    register_netdev(virt_net);    return 0;}static void virt_net_exit(void){    unregister_netdev(virt_net);    free_netdev(virt_net);   }module_init(virt_net_init);module_exit(virt_net_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;by:NU-LL&quot;);</code></pre><h2 id="三、测试运行"><a href="#三、测试运行" class="headerlink" title="三、测试运行"></a>三、测试运行</h2><p>挂载驱动,如下图所示,可以看到net类下就有了这个网卡设备</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031191142623-1185832566.png" alt="网卡信息"></p><p>开始测试,首先设置这个网卡设备的ip,然后去ping一下其它的ip,如下图所示:</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031191155154-1353223217.png" alt="网卡测试"></p><p>上图的ping,之所以成功,是因为我们在发包函数中,伪造了一个来收包,通过netif_rx()来将收包上传给上层</p><p>使用ifconfig,可以看到这个网卡设备的统计信息共收发了6个包,以及收发的总数据</p><p><img src="//NU-LL.github.io/2019/08/04/网卡驱动程序/1182576-20171031191207373-1423144563.png" alt="测试验证"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网卡驱动框架 </tag>
            
            <tag> 虚拟网卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/07/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>描述:</strong></p><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<a href="https://baike.baidu.com/item/递归" target="_blank" rel="noopener">递归</a>进行，以此达到整个数据变成有序<a href="https://baike.baidu.com/item/序列/1302588" target="_blank" rel="noopener">序列</a>。</p><p>快速排序 的平均时间复杂度为O(NlogN),是冒泡排序的一种改进版。</p><p><strong>方法:快速排序主要采用“二分”的思想,步骤如下:</strong></p><p>1)  设置两个变量i、j，<a href="https://baike.baidu.com/item/排序" target="_blank" rel="noopener">排序</a>开始的时候：i=0，j=n-1；</p><p>2）待排序数组的第一个数组值s[0]作为比较值，首先保存到temp中，即temp=s[0]；</p><p>3）然后j– ,向前搜索,找到小于temp后,因为s[i]的值保存在temp中,所以直接赋值,s[i]=s[j]</p><p>4）然后i++,向后搜索,找到大于temp后,因为s[j]的值保存在第2步的s[i]中,所以直接赋值,s[j]=s[i],然后j–,避免死循环</p><p>5）重复第3、4步，直到i=j,最后将temp值返回s[i]中</p><p>6)  然后采用“二分”的思想,以i为分界线,拆分成两个数组 s[0,i-1]、s[i+1,n-1]又开始排序</p><p><strong>如下图,以数组 6 4 7 1 2为例:</strong></p><p><img src="//NU-LL.github.io/2019/07/29/快速排序/1182576-20170926154540323-363735898.png" alt="快速排序"></p><p><strong>代码如下:</strong></p><pre><code class="c">#include &quot;stdio.h&quot;void find_frst(int *s,int left,int right){    int i=left,j=right,temp;  //(1)初始化i、j        if(left&gt;=right)      return ;    temp=s[i];                //(2)以第一个数组为比较值,保存到temp中     while(i&lt;j)    {          while(j&gt;i&amp;&amp;s[j]&gt;=temp)  //(3)j--,找小值       j--;      s[i]= s[j];             //保存小值,到s[i]上       while(i&lt;j&amp;&amp;s[i]&lt;=temp)  //(4)i++,找大值       i++;      s[j--]=s[i];            //保存大值 到s[j]上     }    s[i]=temp;             //(5)将比较值放在s[i]上   /*(6)拆分成两个数组 s[0,i-1]、s[i+1,n-1]又开始排序 */  find_frst(s,left,i-1);         //左  find_frst(s,i+1,right);        //右     }int main(){    int i=0,s[100],n;    scanf(&quot;%d&quot;,&amp;n);   　　　　　//输入数组长度    for(i=0;i&lt;n;i++)    scanf(&quot;%d&quot;,&amp;s[i]);        find_frst(s,0,n-1);      for(i=0;i&lt;n;i++)    printf(&quot;%d &quot;,s[i]);      //打印    printf(&quot;\n&quot;);}</code></pre><p>既然有了排序,那么还有可能用到查找,在有序条件下,当然用二分查找快咯,即简单又速度快</p><p><strong>代码如下:</strong></p><pre><code class="c">#include &quot;stdio.h&quot;/*快速排序  */void find_frst(int *s,int left,int right){    int i=left,j=right,temp;  //(1)初始化i、j        if(left&gt;=right)      return ;    temp=s[i];                //(2)以第一个数组为比较值,保存到temp中     while(i&lt;j)    {          while(j&gt;i&amp;&amp;s[j]&gt;=temp)  //(3)j--,找小值       j--;      s[i]= s[j];             //保存小值,到s[i]上       while(i&lt;j&amp;&amp;s[i]&lt;=temp)  //(4)i++,找大值       i++;      s[j--]=s[i];            //保存大值 到s[j]上     }    s[i]=temp;             //(5)将比较值放在s[i]上   /*(6)拆分成两个数组 s[0,i-1]、s[i+1,n-1]又开始排序 */  find_frst(s,left,i-1);         //左  find_frst(s,i+1,right);        //右     }/*二分查找  *s[]:数组        size:数组个数   cmp:需要比较的数字      *返回值:表示数组的第几个,返回-1表示没有找到  */int binary_query(const int* s, int size, int cmp)  {      int low = 0;      int high = size-1;    int mid;              //中间值     while(low&lt;=high)      {          mid = (low+high)/2;          if(s[mid] == cmp)              return mid;          else if(s[mid] &gt; cmp)              high = mid-1;          else              low = mid+1;      }      return -1;  }  int main(){    int i=0,s[100],n,tmp,index;        scanf(&quot;%d&quot;,&amp;n);             //输入：数组长度     for(i=0;i&lt;n;i++)    scanf(&quot;%d&quot;,&amp;s[i]);        //输入：数组数据     find_frst(s,0,n-1);    printf(&quot;find_frst:\n&quot;,s[i]);           for(i=0;i&lt;n;i++)        printf(&quot;%d &quot;,s[i]);      //打印：有序数组     printf(&quot;\n&quot;);    scanf(&quot;%d&quot;,&amp;tmp);             //输入：要查找的数据    index=binary_query(s,n,tmp);    if(index&lt;0)        printf(&quot;ERR,The value is not querying\n&quot;);        else    printf(&quot;index=%d\n&quot;,index);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入子系统</title>
      <link href="/2019/07/25/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/25/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h1><h2 id="一、系统分析"><a href="#一、系统分析" class="headerlink" title="一、系统分析"></a>一、系统分析</h2><h3 id="1-输入子系统简介"><a href="#1-输入子系统简介" class="headerlink" title="1.输入子系统简介"></a>1.输入子系统简介</h3><p>同样的输入子系统也需要输入驱动的框架,好来辨认应用程序要打开的是哪个输入驱动</p><p>比如: 鼠标、键盘、游戏手柄等等这些都属于输入设备；这些输入设备的驱动都是通过输入子系统来实现的（当然，这些设备也依赖于usb子系统）</p><p>这些输入设备都各有不同，那么输入子系统也就只能实现他们的共性，差异性则由设备驱动来实现。差异性又体现在哪里？</p><p>最直观的就表现在这些设备功能上的不同了。对于我们写驱动的人来说在设备驱动中就只要使用输入子系统提供的工具（也就是函数）来完成这些“差异”就行了，其他的则是输入子系统的工作。这个思想不仅存在于输入子系统，其他子系统也是一样(比如:usb子系统、video子系统等)</p><p>所以我们先来分析下输入子系统<strong>input.c</strong>的代码,然后怎么来使用输入子系统(在内核中以input来形容输入子系统)</p><h3 id="2-输入子系统初始化分析"><a href="#2-输入子系统初始化分析" class="headerlink" title="2.输入子系统初始化分析"></a>2.输入子系统初始化分析</h3><p>打开input.c,位于内核deivers/input，有以下这么两段:</p><pre><code class="c">subsys_initcall(input_init);   //修饰入口函数module_exit(input_exit);     //修饰出口函数</code></pre><p>显然输入子系统是作为一个模块存在,我们先来分析下input_int()入口函数</p><pre><code class="c">static int __init input_init(void){       int err;       err = class_register(&amp;input_class);   //(1)在/sys/class 里创建一个 input类       if (err) {              printk(KERN_ERR &quot;input: unable to register input_dev class\n&quot;);              return err;       }       err = input_proc_init();    //在/proc下面建立相关的文件       if (err)              goto fail1;       err = register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops); //(2)注册驱动       if (err) {              printk(KERN_ERR &quot;input: unable to register char major %d&quot;, INPUT_MAJOR);              goto fail2;       }       return 0; fail2:    input_proc_exit(); fail1:    class_unregister(&amp;input_class);       return err;}</code></pre><ul><li><p>(1)这里的input_class变量如下所示：</p><pre><code class="c">  struct class input_class={      .name        = &quot;input&quot;,      .release    = input_dev_release,      .uevent        = input_dev_uevent,  }</code></pre><p>  当启动一个input子系统的驱动后，可以通过如下命令看到创建了个”input”类 :</p><pre><code class="bash">  # ls /sys/class/  graphics     misc  hwmon         mmc_host  i2c-adapter mtd  input         net  mem         ppdev  #</code></pre><p>  为什么这里代码只创建类，没有使用class_device_create()函数在类下面创建驱动设备？</p><p>  在下面第8小结会详细讲到,这里简单描述:当注册input子系统的驱动后，才会有驱动设备，此时这里的代码是没有驱动的</p></li><li><p>(2)这里通过register_chrdev创建驱动设备,其中宏INPUT_MAJOR =13,所以创建了一个主设备为13的”input”设备。</p><p>   然后我们来看看它的操作结构体input_fops,如下:</p><pre><code class="c">  static const struct file_operations input_fops={      .owner    =THIS_MODULE,      .open    =input_open_file,  };</code></pre><p>  只有一个.open函数,比如当我们挂载一个新的input驱动,则内核便会调用该.open函数，其他一些工作肯定是在这个函数中处理的,接下来分析该.open函数</p></li></ul><h3 id="3-input-open-file函数分析"><a href="#3-input-open-file函数分析" class="headerlink" title="3.input_open_file函数分析"></a>3.input_open_file函数分析</h3><p>然后进入input_open_file函数(drivers/input/input.c)：</p><pre><code class="c">static int input_open_file(struct inode *inode, struct file *file) {    struct input_handler *handler = input_table[iminor(inode) &gt;&gt; 5]; // (1)    const struct file_operations *old_fops, *new_fops = NULL;    int err;    if (!handler || !(new_fops = fops_get(handler-&gt;fops)))  //(2)        return -ENODEV;    if (!new_fops-&gt;open) {        fops_put(new_fops);        return -ENODEV;    }    old_fops = file-&gt;f_op;    file-&gt;f_op = new_fops;     //(3)    err = new_fops-&gt;open(inode, file);   //(4)    if (err) {        fops_put(file-&gt;f_op);        file-&gt;f_op = fops_get(old_fops);    }    fops_put(old_fops);    return err;}</code></pre><ul><li>（1）这里iminor (inode)函数调用了MINOR(inode-&gt;i_rdev);读取打开文件（input设备）的子设备号,然后将子设备除以32,找到<strong>新挂载的input驱动</strong>的数组号,然后放在input_handler *类型的handler中</li><li>（2）若handler有值,说明挂载有这个驱动,利用fops_get()将handler结构体里的成员file_operations *fops取出赋到新的file_operations *new_fops里面，即此时new_fops指向了<strong>新挂载的input驱动</strong>的操作函数</li><li>（3）再将新的file_operations <em>new_fops赋到file-&gt;file_operations  <em>f_op里, 此时input子系统的file_operations就等于</em></em>新挂载的input驱动<strong>的file_operations结构体,实现一个</strong>偷天换日的效果.**</li><li>（4）然后调用<strong>新挂载的input驱动</strong>的*new_fops里面的成员.open函数</li></ul><h3 id="4-input-table-数组的赋值"><a href="#4-input-table-数组的赋值" class="headerlink" title="4.input_table[]数组的赋值"></a>4.input_table[]数组的赋值</h3><p>上面代码的input_table[]数组在初始时是没有值的,所以需要找到他在那里被赋值</p><p>在input.c函数(drivers/input/input.c)中搜索input_table,找到它在input_register_handler()函数中被赋值,代码如下:</p><pre><code class="c">int input_register_handler(struct input_handler *handler){    ... ...        input_table[handler-&gt;minor &gt;&gt; 5] = handler;   //input_table[]被赋值    ... ...        list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //将这个input_handler放到input_handler_list链表中      ... ...}</code></pre><p>这里就是将input_handler *类型的变量handler注册到input_table[]中，然后将handler插入input_handler_list链表中,后面第7.1会讲这个链表</p><h3 id="5-input-register-handler的调用"><a href="#5-input-register-handler的调用" class="headerlink" title="5.input_register_handler的调用"></a>5.input_register_handler的调用</h3><p>继续来搜索input_register_handler,看看这个函数被谁来调用</p><p>通过搜索可以查到,有evdev.c(事件设备)，tsdev.c(触摸屏设备)，joydev.c(joystick操作杆设备)，keyboard.c(键盘设备)，mousedev.c(鼠标设备) 等各种设备调用了该函数</p><p>大致可以推断，以上各种设备通过input_register_handler函数向input.c注册</p><p>这里以evdev.c(事件设备)举例，通过如下函数向input.c注册</p><pre><code class="c">static int __init evdev_init(void){    return input_register_handler(&amp;evdev_handler)}</code></pre><h3 id="6-input-handler结构体分析"><a href="#6-input-handler结构体分析" class="headerlink" title="6.input_handler结构体分析"></a>6.input_handler结构体分析</h3><p>我们来看看这个evdev_handler变量是什么结构体</p><pre><code class="c">static struct input_handler evdev_handler = {       .event         = evdev_event,       .connect     = evdev_connect,  //(4)       .disconnect     = evdev_disconnect,       .fops         = &amp;evdev_fops,    //(1)       .minor         = EVDEV_MINOR_BASE, //(2)       .name         = &quot;evdev&quot;,       .id_table     = evdev_ids, //(3)};</code></pre><ul><li><p>（1）<strong>.fops:</strong>文件操作结构体,其中evdev_fops为file_operations结构体，就是自己的写的操作函数,然后赋到.fops中</p></li><li><p>（2）<strong>.minor:</strong>用来存放次设备号，其中EVDEV_MINOR_BASE=64, 这里调用input_register_handler(&amp;evdev_handler)后,由于EVDEV_MINOR_BASE/32=2,所以最终会将evdev_handler存到input_table[2]中</p><p>  假设当open打开这个input设备时，就会进入 input_open_file()函数,执行evdev_handler-&gt; evdev_fops -&gt; .open函数,如下所示为evdev_fops结构体的内容</p><pre><code class="c">  static const struct flle_operations evdev_fops={      .owner            =THIS MODULE,      .read            =evdev_read,      .write            =evdev_write,      .poll            =evdeV_poll,      .open            =evdev_open,      .release        =evdev_release,      .unlocked_ioctl    =evdev_ioctl,  #ifdef CONFIG_COMPAT      .compat_ioctl    =evdev_ioctl_compat,  #endif      .fasync            =evdev_fasync,      .flush            =evdev_flush  };</code></pre><p>  故最终会调用到evdev_open函数</p></li><li><p>（3）<strong>.id_table :</strong> 表示能支持哪些输入设备，比如某个驱动设备的input_dev-&gt;的id和某个input_handler的id_table相匹配，就会调用.connect连接函数,如下图</p></li><li><p>（4）<strong>.connect:</strong> 连接函数，将设备input_dev和某个input_handler建立连接,如下图</p><p>  <img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125805775-128197571.png" alt="img"></p></li></ul><h3 id="7-input-dev和input-handler及其相关关系"><a href="#7-input-dev和input-handler及其相关关系" class="headerlink" title="7.input_dev和input_handler及其相关关系"></a>7.input_dev和input_handler及其相关关系</h3><p>我们先来看看上图的input_register_device()函数,谁负责调用他</p><p>搜索input_register_device,发现内核自己就已经注册了很多驱动设备</p><h4 id="7-1input-register-device-函数分析"><a href="#7-1input-register-device-函数分析" class="headerlink" title="7.1input_register_device()函数分析"></a>7.1input_register_device()函数分析</h4><p>进入input_register_device()函数,代码如下:</p><pre><code class="c">int input_register_device(struct input_dev *dev)   //*dev:要注册的驱动设备{    ... ...        list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   //(1)将驱动设备放入input_dev_list链表中    ... ...        list_for_each_entry(handler, &amp;input_handler_list, node)  //(2)            input_attach_handler(dev, handler); //(3)    ... ...}</code></pre><ul><li>（1）将要注册的input_dev类型的驱动设备放在input_dev_list链表中</li><li>（2）其中input_handler_list在前面第4点讲过（下面会再讲）,就是存放每个input_handle结构体的链表,然后list_for_each_entry()函数会将每个input_handle从链表中取出，放到handler中，并调用一次input_attach_handler</li><li>（3）根据要注册的驱动设备和每个input_handle类型的handler的id_table进行判断，能否支持这个input_dev类型的驱动设备，若两者支持便进行连接。</li></ul><h4 id="7-2-input-register-handler-函数分析"><a href="#7-2-input-register-handler-函数分析" class="headerlink" title="7.2.input_register_handler()函数分析"></a>7.2.input_register_handler()函数分析</h4><p>然后我们在回过头来看注册input_handler的input_register_handler()函数，有：</p><pre><code class="c">int input_register_handler(struct input_handler *handler){    ... ...        input_table[handler-&gt;minor &gt;&gt; 5] = handler;   //(1)input_table[]被赋值    ... ...        list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //(2)将这个input_handler放到input_handler_list链表中        list_for_each_entry(dev,&amp;input_dev_list,node)//(3)            input_attach_handler(dev,handler);//(4)    ... ...}</code></pre><ul><li>（1）将input_handler *类型的变量handler放入数组input_table[]中</li><li>（2）将input_handler *类型的变量handler插入input_handler_list链表中</li><li>（3）list_for_each_entry()函数会将每个input_dev从链表input_dev_list中取出，放到dev中，并调用一次input_attach_handler</li><li>（4）根据要注册的input_handler类型的handler的id_table和每个input_dev类型的dev进行判断，能否支持这个input_dev类型的驱动设备，若两者支持便进行连接。</li></ul><p>所以,不管新添加input_dev还是input_handler,都会进入<strong>input_attach_handler()</strong>判断两者id是否匹配, 若两者匹配便进行连接。</p><h4 id="7-3-input-attach-handler-函数分析"><a href="#7-3-input-attach-handler-函数分析" class="headerlink" title="7.3.input_attach_handler()函数分析"></a>7.3.input_attach_handler()函数分析</h4><p>我们来看看input_attach_handler()如何实现匹配两者id的</p><pre><code class="c">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler){    ... ...        id = input_match_device(handler-&gt;id_table, dev);  //根据handler的id_table和dev进行匹配    if (!id)                                     //若不匹配,return退出        return -ENODEV;    error = handler-&gt;connect(handler, dev, id);  //若匹配,调用handler的connect函数建立连接    ... ...}</code></pre><p>若两者匹配成功，就会自动进入input_handler类型变量handler的connect函数建立连接</p><h3 id="8-连接的建立"><a href="#8-连接的建立" class="headerlink" title="8.连接的建立"></a>8.连接的建立</h3><p>我们还是以evdev.c(事件驱动) 的evdev_handler-&gt;connect函数来分析是怎样建立连接的。</p><p>首先根据evdev.c中的input_handler类型变量evdev_handler分析，有：</p><pre><code class="c">static struct input_handler evdev_handler={    .event=evdev_event,    .connect=evdev_connect,    .disConnect=evdev_disconnect,    .fops=&amp; evdev_fops,    .minor=EVDEV_MINOR_BASE,    .name=&quot;evdev&quot;,    .id_table=evdev_ids,};</code></pre><h4 id="8-1-evdev-connect-函数分析"><a href="#8-1-evdev-connect-函数分析" class="headerlink" title="8.1.evdev_connect()函数分析"></a>8.1.evdev_connect()函数分析</h4><p>evdev_handler的.connect函数是evdev_connect(),代码如下:</p><pre><code class="c">static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id){    ... ...    for (minor = 0; minor &lt; EVDEV_MINORS &amp;&amp; evdev_table[minor]; minor++); //查找驱动设备的子设备号    if (minor == EVDEV_MINORS) {  // EVDEV_MINORS=32,所以该事件下的驱动设备最多存32个,        printk(KERN_ERR &quot;evdev: no more free evdev devices\n&quot;);        return -ENFILE;                //没找到驱动设备    }    ... ...    evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);   //struct evdev结构体中包含input_handle，这里主要是分配一个input_handle全局结构体(没有r)    ... ...    evdev-&gt;exist = 1;    evdev-&gt;minor = minor;    evdev-&gt;handle.dev = dev;              //指向input_dev驱动设备    evdev-&gt;handle.name = evdev-&gt;name;    evdev-&gt;handle.handler = handler;    //指向input_handler驱动处理结构体    evdev-&gt;handle.private = evdev;    sprintf(evdev-&gt;name, &quot;event%d&quot;, minor);    //(1)保存驱动设备名字, event%d    ... ...    devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor),  //(2) 将主设备号和次设备号转换成dev_t类型    cdev = class_device_create(&amp;input_class, &amp;dev-&gt;cdev, devt,dev-&gt;cdev.dev, evdev-&gt;name); // (3)在input类下创建驱动设备    ... ...    error = input_register_handle(&amp;evdev-&gt;handle); //(4)注册这个input_handle结构体    ... ...}</code></pre><ul><li><p>（1）保存驱动设备名字,名为event%d, 比如下面(键盘驱动)event1: 因为没有设置子设备号，默认从小到大排列,其中event0是表示这个input子系统,所以这个键盘驱动名字就是event1</p></li><li><p>（2）是在保存驱动设备的主次设备号,其中主设备号INPUT_MAJOR=13,因为EVDEV_MINOR_BASE=64,所以此设备号=64+驱动程序本事子设备号, 比如下图(键盘驱动)event1:  主次设备号就是13,65</p></li><li><p>（3）在之前在第2点中就分析了input_class类结构，所以该处会在/sys/class/input类下创建驱动设备event%d，比如下图(键盘驱动)event1:</p><pre><code class="shell">  # ls -l /dev/event*  crw-rw----    1 0      0       13, 64 Jan  1 00:00 /dev/event0(input子系统自带的驱动设备)  crw-rw----    1 0      0       13, 65 Jan  1 01:02 /dev/event1(后来安装的键盘驱动设备)  # ls /sys/class/input/  event0 event1 input0 input1 mice mouse0 ts0           |           V  键盘与input_handler在连接函数里创建的驱动设备</code></pre></li><li><p>（4）最终会进入input_register_handle()函数来注册,代码在下面</p></li></ul><h4 id="8-2-input-register-handle-函数分析"><a href="#8-2-input-register-handle-函数分析" class="headerlink" title="8.2.input_register_handle()函数分析"></a>8.2.input_register_handle()函数分析</h4><pre><code class="c">//error = input_register_handle(&amp;evdev-&gt;handle);int input_register_handle(struct input_handle *handle){    struct input_handler *handler = handle-&gt;handler; //此处的handler==evdev-&gt;handle.handler，即evdev_connect函数传下来的input_handler驱动处理结构体    list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); //(1)    list_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    // (2)    if (handler-&gt;start)        handler-&gt;start(handle);    return 0;}</code></pre><ul><li><p>（1）此处因为右边参数中handle-&gt;dev指向input_dev驱动设备，所以就是将左边参数handle-&gt;d_node放入到input_dev驱动设备的h_list链表中，即input_dev驱动设备的h_list就指向input_handle（没有r）结构体handle中的d_node成员</p></li><li><p>（2）同样, input_handler驱动处理结构体的h_list也指向了handle-&gt;h_node</p><p>  最终如下图所示:</p></li></ul><p><img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125909525-684596795.png" alt="img"></p><p>两者的.h_list都指向了同一个handle结构体，然后通过.h_list 来找到handle的成员.dev和handler,便能找到对方,便建立了连接</p><h3 id="9-按键读取分析"><a href="#9-按键读取分析" class="headerlink" title="9.按键读取分析"></a>9.按键读取分析</h3><p>假设当read打开这个input设备时，就会执行evdev_handler结构体中evdev_fops成员中的.read函数,如下所示为evdev_fops结构体的内容</p><pre><code class="c">static const struct flle_operations evdev_fops={    .owner            =THIS MODULE,    .read            =evdev_read,    .write            =evdev_write,    .poll            =evdeV poll,    .open            =evdev_open,    .release        =evdev_release,    .unlocked_ioctl    =evdev_ioctl,#ifdef CONFIG_COMPAT    .compat_ioctl    =evdev_ioctl_compat,#endif    .fasync            =evdev_fasync,    .flush            =evdev_flush};</code></pre><p>故最终会调用到evdev_read函数，我们来分析下:</p><pre><code class="c">static ssize_t evdev_read(struct file *file, char __user *      buffer, size_t count, loff_t *ppos){    ... ...    /*判断应用层要读取的数据是否正确*/    if (count &lt; evdev_event_size())        return -EINVAL;    /*无数据并且是非阻塞方式打开，则立刻返回*/    if (client-&gt;head == client-&gt;tail &amp;&amp; evdev-&gt;exist &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))        return -EAGAIN;    /*否则进入休眠  */    retval = wait_event_interruptible(evdev-&gt;wait,client-&gt;head != client-&gt;tail || !evdev-&gt;exist);    ... ...           //上传数据}</code></pre><h3 id="10-read函数的唤醒"><a href="#10-read函数的唤醒" class="headerlink" title="10.read函数的唤醒"></a>10.read函数的唤醒</h3><p>若read函数进入了休眠状态，又是谁来唤醒？</p><p>我们搜索这个evdev-&gt;wait这个等待队列变量,找到在evdev_event函数中唤醒:</p><pre><code class="c">static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value){    ... ...    wake_up_interruptible(&amp;evdev-&gt;wait);   //有事件触发，便唤醒等待中断}</code></pre><p>其中evdev_event()是evdev.c(事件驱动) 的input_handler结构体中的成员event,如下所示:</p><pre><code class="c">static struct input_handler evdev_handler={.event        =evdev_event,.connect    =evdev_connect,.disconnect    =evdev_disconnect,.fops        =&amp; evdev_fops,.minor        =EVDEV_MINOR_BASE,.name        =&quot;evdev&quot;,.id_table    =evdev_ids,};</code></pre><p>当有事件发生了,比如对于按键驱动,当有按键按下时,就会进入.event函数中处理事件</p><h3 id="11-evdev-event-的调用"><a href="#11-evdev-event-的调用" class="headerlink" title="11.evdev_event()的调用"></a>11.evdev_event()的调用</h3><p>分析下,是谁调用evdev_event()这个.event事件驱动函数</p><p>应该就是之前分析的input_dev那层调用的</p><p>我们来看看内核 gpio_keys_isr()函数代码例子就知道了 (driver/input/keyboard/gpio_key.c)</p><pre><code class="c">static irqreturn_t gpio_keys_isr(int irq, void *dev_id){    /*获取按键值,赋到state里*/    ... ...    /*上报事件*/    input_event(input, type, button-&gt;code, !!state);      input_sync(input);//同步信号通知,表示事件发送完毕}</code></pre><p>显然就是通过input_event()来调用.event事件函数,我们来看看:</p><pre><code class="c">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value){    struct input_handle *handle;    ... ...    /* 通过input_dev-&gt;h_list链表找到input_handle驱动处理结构体*/    list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)//这里就是从dev-&gt;h_list取出每一项（这里的每一项就是input_handle（没有r）类型的）并执行其对应的open函数        if (handle-&gt;open)  //如果input_handle之前open过,那么这个就是我们的驱动处理结构体            handle-&gt;handler-&gt;event(handle, type, code, value); //调用evdev_event()的.event事件函数}</code></pre><p>若之前驱动input_dev和处理input_handler已经通过input_handler 的.connect函数建立起了连接,那么就调用evdev_event()的.event事件函数，如下图所示:</p><p><img src="//NU-LL.github.io/2019/07/25/输入子系统/1182576-20170918125942290-1009610213.png" alt="img"></p><h3 id="12-总结分析"><a href="#12-总结分析" class="headerlink" title="12.总结分析"></a>12.总结分析</h3><p>1.注册输入子系统,进入put_init():</p><p>1)创建主设备号为13的”input”字符设备</p><pre><code class="c">err = register_chrdev(INPUT_MAJOR, &quot;input&quot;, &amp;input_fops);</code></pre><p>2.open打开驱动,进入input_open_file():</p><p>1)更新设备的file_oprations</p><pre><code class="c">file-&gt;f_op=fops_get(handler-&gt;fops);</code></pre><p> 2)执行file_oprations-&gt;open函数</p><pre><code class="c">err = new_fops-&gt;open(inode, file);</code></pre><p>3.注册input_handler,进入input_register_handler():</p><p>1)添加到input_table[]处理数组中</p><pre><code class="c">input_table[handler-&gt;minor &gt;&gt; 5] = handler;</code></pre><p>2）添加到input_handler_list链表中</p><pre><code class="c">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</code></pre><p>3)判断input_dev的id,是否有支持这个驱动的设备</p><pre><code class="c"> list_for_each_entry(dev, &amp;input_dev_list, node)   //遍历查找input_dev_list链表里所有input_dev input_attach_handler(dev, handler);             //判断两者id,若两者支持便进行连接。</code></pre><p>4.注册input_dev，进入input_register_device():</p><p>1)放在input_dev_list链表中</p><pre><code class="c">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</code></pre><p>2)判断input_handler的id，是否有支持这个设备的驱动</p><pre><code class="c">list_for_each_entry(handler, &amp;input_handler_list, node)  //遍历查找input_handler_list链表里所有input_handlerinput_attach_handler(dev, handler);                      //判断两者id,若两者支持便进行连接。</code></pre><p>5.判断input_handler和input_dev的id,进入input_attach_handler():</p><p>1）匹配两者id,</p><pre><code class="c">input_match_device(handler-&gt;id_table, dev);        //匹配input_handler和dev的id,不成功退出函数</code></pre><p>2)匹配成功调用input_handler -&gt;connect</p><pre><code class="c">handler-&gt;connect(handler, dev, id);              //建立连接</code></pre><p>6.建立input_handler和input_dev的连接，进入input_handler-&gt;connect():</p><p>1)创建全局结构体,通过input_handle结构体连接双方</p><pre><code class="c">evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);    //创建两者连接的input_handle全局结构体list_add_tail(&amp;handle-&gt;d_node, &amp;handle-&gt;dev-&gt;h_list); //连接input_dev-&gt;h_listlist_add_tail(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);    // 连接input_handle-&gt;h_list</code></pre><p>7.有事件发生时,比如按键中断,在中断函数中需要进入input_event()上报事件:</p><p>1)找到驱动处理结构体，然后执行input_handler-&gt;event()</p><pre><code class="c">    list_for_each_entry(handle, &amp;dev-&gt;h_list, d_node)     // 通过input_dev -&gt;h_list链表找到input_handle驱动处理结构体    if (handle-&gt;open)  //如果input_handle之前open 过,那么这个就是我们的驱动处理结构体(有可能一个驱动设备在不同情况下有不同的驱动处理方式)        handle-&gt;handler-&gt;event(handle, type, code, value); //调用evdev_event()的.event事件函数</code></pre><h2 id="二、程序分析"><a href="#二、程序分析" class="headerlink" title="二、程序分析"></a>二、程序分析</h2><p><strong>目标:</strong>实现键盘驱动,让开发板的4个按键代表键盘中的L、S、空格键、回车键</p><h3 id="1-几个常用结构体和函数"><a href="#1-几个常用结构体和函数" class="headerlink" title="1.几个常用结构体和函数"></a>1.几个常用结构体和函数</h3><ul><li><p><strong>1)input_dev驱动设备结构体中常用成员如下:</strong></p><pre><code class="c">  struct input_dev {      void *private;      const char *name;  //设备名字      const char *phys;  //文件路径,比如 input/buttons      const char *uniq;      struct input_id id;</code></pre></li></ul><pre><code>    unsigned long evbit[NBITS(EV_MAX)];  //表示支持哪类事件,常用有以下几种事件(可以多选)    //EV_SYN      同步事件，当使用input_event()函数后,就要使用这个上报个同步事件    //EV_KEY       键盘事件    //EV_REL       (relative)相对坐标事件，比如鼠标    //EV_ABS       (absolute)绝对坐标事件，比如摇杆、触摸屏感应    //EV_MSC      其他事件,功能    //EV_LED       LED灯事件    //EV_SND      (sound)声音事件    //EV_REP       重复键盘按键事件    //(内部会定义一个定时器,若有键盘按键事件一直按下/松开,就重复定时,时间一到就上报事件)    //EV_FF         受力事件    //EV_PWR      电源事件    //EV_FF_STATUS  受力状态事件    unsigned long keybit[NBITS(KEY_MAX)];   //存放支持的键盘按键值    //键盘变量定义在:include/linux/input.h, 比如: KEY_L(按键L)    unsigned long relbit[NBITS(REL_MAX)];    //存放支持的相对坐标值    unsigned long absbit[NBITS(ABS_MAX)];   //存放支持的绝对坐标值    unsigned long mscbit[NBITS(MSC_MAX)];   //存放支持的其它事件,也就是功能    unsigned long ledbit[NBITS(LED_MAX)];    //存放支持的各种状态LED    unsigned long sndbit[NBITS(SND_MAX)];    //存放支持的各种声音    unsigned long ffbit[NBITS(FF_MAX)];       //存放支持的受力设备    unsigned long swbit[NBITS(SW_MAX)];     //存放支持的开关功能    ... ...}```</code></pre><ul><li><p><strong>2)函数如下:</strong></p><pre><code class="c">  struct input_dev *input_allocate_device(void);  //向内核中申请一个input_dev设备,然后返回这个设备</code></pre><pre><code class="c">  input_unregister_device(struct input_dev *dev);   //卸载/sys/class/input目录下的input_dev这个类设备, 一般在驱动出口函数写</code></pre><pre><code class="c">  input_free_device(struct input_dev *dev);   //释放input_dev这个结构体, 一般在驱动出口函数写</code></pre><pre><code class="c">  set_bit(nr,p);                  //设置某个结构体成员p里面的某位等于nr,支持这个功能  /* 比如:  set_bit(EV_KEY,buttons_dev-&gt;evbit);   //设置input_dev结构体buttons_dev-&gt;evbit支持EV_KEY  set_bit(KEY_S,buttons_dev-&gt;keybit);  //设置input_dev结构体buttons_dev-&gt;keybit支持按键”S”  */</code></pre><pre><code class="c">  void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);  //上报事件   // input_dev *dev :要上报哪个input_dev驱动设备的事件   // type : 要上报哪类事件, 比如按键事件,则填入: EV_KEY   // code: 对应的事件里支持的哪个变量，比如按下按键L则填入: KEY_L   //value:对应的变量里的数值,比如松开按键则填入1,松开按键则填入0</code></pre><pre><code class="c">  void input_sync(struct input_dev *dev); //同步事件通知</code></pre><p>  这里input_event()函数只是个事件函数,需要input_sync()同步事件函数来通知系统,然后系统才会知道</p><p>  其中，input_sync()代码如下:</p><pre><code class="c">  static inline void input_sync(struct input_dev *dev)  {      input_event(dev, EV_SYN, SYN_REPORT, 0); //就是上报同步事件,告诉内核:input_event()事件执行完毕  }</code></pre></li></ul><h3 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2.代码分析"></a>2.代码分析</h3><p>1)向内核申请input_dev结构体</p><p>2)设置input_dev的成员</p><p>3)注册input_dev 驱动设备</p><p>4)初始化定时器和中断</p><p>5)写中断服务函数</p><p>6)写定时器超时函数</p><p>7)在出口函数中 释放中断函数,删除定时器,卸载释放驱动</p><pre><code class="c">#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/pm.h&gt;#include &lt;linux/sysctl.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/gpio_keys.h&gt;#include &lt;asm/gpio.h&gt;struct input_dev *buttons_dev;            //  定义一个input_dev结构体  static struct ping_desc *buttons_id;          //保存dev_id,在定时器中用static struct timer_list buttons_timer;    //定时器结构体  struct  ping_desc{    unsigned  char  *name;          //中断设备名称    int            pin_irq;          //按键的外部中断标志位    unsigned  int    pin;                //引脚    unsigned int  irq_ctl;           //触发中断状态:   IRQ_TYPE_EDGE_BOTH    unsigned  int    button;         //dev_id,对应键盘的 L ,  S,  空格,  enter};// KEY1 -&gt; L// KEY2 -&gt; S// KEY3 -&gt; 空格// KEY4 -&gt; enterstatic  struct ping_desc   buttons_desc[5]={    {&quot;s1&quot;, IRQ_EINT0,   S3C2410_GPF0,  IRQ_TYPE_EDGE_BOTH,KEY_L},    {&quot;s2&quot;, IRQ_EINT2,   S3C2410_GPF2,  IRQ_TYPE_EDGE_BOTH,KEY_S},    {&quot;s3&quot;, IRQ_EINT11, S3C2410_GPG3 , IRQ_TYPE_EDGE_BOTH,KEY_SPACE},    {&quot;s4&quot;, IRQ_EINT19, S3C2410_GPG11,IRQ_TYPE_EDGE_BOTH,KEY_ENTER},};/*5. 写中断服务函数*/static irqreturn_t  buttons_irq (int irq, void *dev_id)       //中断服务函数{    buttons_id=(struct ping_desc *)dev_id;             //保存当前的dev_id    mod_timer(&amp;buttons_timer, jiffies+HZ/100 );   //更新定时器值 10ms    return 0;}/*6.写定时器超时函数*/void buttons_timer_function(unsigned long i){    int val;    val=s3c2410_gpio_getpin(buttons_id-&gt;pin);             //获取是什么电平    if(val)         //高电平,松开    {        /*上报事件*/        input_event(buttons_dev,EV_KEY,buttons_id-&gt;button, 0);  //上报EV_KEY类型,button按键,0(没按下)        input_sync(buttons_dev);         // 上传同步事件,告诉系统有事件出现    }    else      //低电平，按下    {        /*上报事件*/        input_event(buttons_dev, EV_KEY, buttons_id-&gt;button, 1);  //上报EV_KEY类型,button按键,1(按下)        input_sync(buttons_dev);       // 上传同步事件,告诉系统有事件出现    }}static int buttons_init(void)   //入口函数{    int i;    buttons_dev=input_allocate_device();  //1.向内核 申请input_dev结构体    /*2.设置input_dev ,  */    set_bit(EV_KEY,buttons_dev-&gt;evbit);       //支持键盘事件    set_bit(EV_REP,buttons_dev-&gt;evbit);       //支持键盘重复按键事件，该事件在input_event上报EV_KEY事件时会自动修改定时器来进行处理    set_bit(KEY_L,buttons_dev-&gt;keybit);                  //支持按键 L    set_bit(KEY_S,buttons_dev-&gt;keybit);                //支持按键 S    set_bit(KEY_SPACE,buttons_dev-&gt;keybit);      //支持按键 空格    set_bit(KEY_ENTER,buttons_dev-&gt;keybit);     //支持按键 enter    /*3.注册input_dev */    input_register_device(buttons_dev);    /*4. 初始化硬件:初始化定时器和中断*/    // KEY1 -&gt; L    // KEY2 -&gt; S    // KEY3 -&gt; 空格    // KEY4 -&gt; enter    init_timer(&amp;buttons_timer);    buttons_timer.function=buttons_timer_function;    add_timer(&amp;buttons_timer);    for(i=0;i&lt;4;i++)        request_irq(buttons_desc[i].pin_irq, buttons_irq, buttons_desc[i].irq_ctl, buttons_desc[i].name, &amp;buttons_desc[i]);    return 0;}static int buttons_exit(void)  //出口函数{    /*7.释放中断函数,删除定时器,卸载释放驱动*/    int i;    for(i=0;i&lt;4;i++)        free_irq(buttons_desc[i].pin_irq,&amp;buttons_desc[i]);    //释放中断函数    del_timer(&amp;buttons_timer);   //删除定时器    input_unregister_device(buttons_dev);     //卸载类下的驱动设备    input_free_device(buttons_dev);                //释放驱动结构体    return 0;}module_init(buttons_init);module_exit(buttons_exit);MODULE_LICENSE(&quot;GPL v2&quot;);</code></pre><h3 id="3-测试运行"><a href="#3-测试运行" class="headerlink" title="3.测试运行"></a>3.测试运行</h3><p>挂载键盘驱动后, 如下所示,可以通过  ls -l /dev/event*   命令查看已挂载的设备节点:</p><pre><code class="shell"># ls -l /dev/event*crw-rw----    1 0      0       13, 64 Jan  1 00:00 /dev/event0(自带的触摸屏驱动设备)crw-rw----    1 0      0       13, 65 Jan  1 01:02 /dev/event1(后来安装的键盘驱动设备)</code></pre><p>在<strong>上一节输入子系统里分析</strong>到:输入子系统的主设备号为13,其中event驱动本身的此设备号是从64开始的,如上所示,内核启动时,会加载自带触摸屏驱动,所以我们的键盘驱动的次设备号=64+1</p><h4 id="3-1测试运行有两种-一种是直接打开-dev-tyy1-第二种是使用exec命令"><a href="#3-1测试运行有两种-一种是直接打开-dev-tyy1-第二种是使用exec命令" class="headerlink" title="3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令"></a>3.1测试运行有两种,一种是直接打开/dev/tyy1,第二种是使用exec命令</h4><p>方法1:</p><pre><code class="shell">cat /dev/tty1     //tty1:LCD终端,就会通过tty_io.c来访问键盘驱动,然后打印在tty1终端上</code></pre><p>方法2:</p><pre><code class="shell">exec 0&lt;/dev/tty1    //利用&gt;将/dev/tty1作为输入传给该shell进程的0号文件（该shell的输入设备）,此时的键盘驱动就会直接打印在shell上</code></pre><h4 id="3-2-调试"><a href="#3-2-调试" class="headerlink" title="3.2 调试"></a>3.2 调试</h4><p><strong>若测试不成功,板子又在QT下进行的:</strong></p><p>1)可以使用vi命令,在记事本中按按键试</p><p>2)或者删除/etc/init.d/rcS 里面有关QT自启动的命令,然后重启</p><p><strong>若板子没在QT下进行,也无法测试成功:</strong></p><p>1)可以使用hexdump命令来调试代码</p><pre><code class="sh">hexdump /dev/event1           秒        微秒     类  code    value0000000 0bb2 0000 0e48 000c 0001 0026 0001 00000000010 0bb2 0000 0e54 000c 0000 0000 0000 00000000020 0bb2 0000 5815 000e 0001 0026 0000 00000000030 0bb2 0000 581f 000e 0000 0000 0000 0000</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 按键驱动 </tag>
            
            <tag> 输入子系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按键驱动：异步通知机制</title>
      <link href="/2019/07/22/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%EF%BC%9A%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/22/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%EF%BC%9A%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="按键驱动：异步通知机制"><a href="#按键驱动：异步通知机制" class="headerlink" title="按键驱动：异步通知机制"></a>按键驱动：异步通知机制</h1><h2 id="一、相关函数说明"><a href="#一、相关函数说明" class="headerlink" title="一、相关函数说明"></a>一、相关函数说明</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>signum是传递给它的唯一参数。执行了signal()调用后，进程只要接收到类型为signum的信号，不管其正在执行程序的哪一部分，就立即执行handler()函数。当handler()函数执行结束后，控制权返回进程被中断的那一点继续执行。</p><p>函数原型：</p><pre><code class="c">void (*signal(int signum,void(* handler)(int)))(int);//或者：typedef void (*sig_t)( int );sig_t signal(int signum,sig_t handler);</code></pre><p><strong>参数说明</strong>：</p><ul><li><p>signum：所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。</p></li><li><p>handler：与信号关联的动作，它可以取以下三种值：</p><ul><li><p>一个无返回值的函数地址</p><p>  此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为signum的信号时，就执行handler 所指定的函数。这个函数应有如下形式的定义：</p><pre><code class="c">  void func(int sig);</code></pre></li><li><p>SIG_IGN</p><p>  这个符号表示忽略该信号，执行了相应的signal()调用后，进程会忽略类型为sig的信号。</p></li><li><p>SIG_DFL</p><p>  这个符号表示恢复系统对信号的默认处理。</p></li></ul></li></ul><p><strong>返回值：</strong>返回先前的信号处理函数指针，如果有错误则返回SIG_ERR(-1)。</p><p><strong>函数说明</strong>：</p><p>signal()会依参数signum 指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行。当一个信号的信号处理函数执行时，如果进程又接收到了该信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数。但是如果在信号处理函数执行时进程收到了其它类型的信号，该函数的执行就会被中断。</p><p>下面的情况可以产生Signal：</p><ol><li>按下CTRL+C产生SIGINT</li><li>硬件中断，如除0，非法内存访问（SIGSEV）等等</li><li>Kill函数可以对进程发送Signal</li><li>Kill命令。实际上是对Kill函数的一个包装</li><li>软件中断。如当Alarm Clock超时（SIGURG），当Reader中止之后又向管道写数据（SIGPIPE），等等</li></ol><p>相关的信号：</p><table><thead><tr><th align="center"><strong>Signal</strong></th><th align="center"><strong>Description</strong></th></tr></thead><tbody><tr><td align="center">SIGABRT</td><td align="center">由调用abort函数产生，进程非正常退出</td></tr><tr><td align="center">SIGALRM</td><td align="center">用alarm函数设置的timer超时或setitimer函数设置的interval timer超时</td></tr><tr><td align="center">SIGBUS</td><td align="center">某种特定的硬件异常，通常由内存访问引起</td></tr><tr><td align="center">SIGCANCEL</td><td align="center">由Solaris Thread Library内部使用，通常不会使用</td></tr><tr><td align="center">SIGCHLD</td><td align="center">进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td></tr><tr><td align="center">SIGCONT</td><td align="center">当被stop的进程恢复运行的时候，自动发送</td></tr><tr><td align="center">SIGEMT</td><td align="center">和实现相关的硬件异常</td></tr><tr><td align="center">SIGFPE</td><td align="center">数学相关的异常，如被0除，浮点溢出，等等</td></tr><tr><td align="center">SIGFREEZE</td><td align="center">Solaris专用，Hiberate或者Suspended时候发送</td></tr><tr><td align="center">SIGHUP</td><td align="center">发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td></tr><tr><td align="center">SIGILL</td><td align="center">非法指令异常</td></tr><tr><td align="center">SIGINFO</td><td align="center">BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGINT</td><td align="center">由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td></tr><tr><td align="center">SIGIO</td><td align="center">异步IO事件</td></tr><tr><td align="center">SIGIOT</td><td align="center">实现相关的硬件异常，一般对应SIGABRT</td></tr><tr><td align="center">SIGKILL</td><td align="center">无法处理和忽略。中止某个进程</td></tr><tr><td align="center">SIGLWP</td><td align="center">由Solaris Thread Libray内部使用</td></tr><tr><td align="center">SIGPIPE</td><td align="center">在reader中止之后写Pipe的时候发送</td></tr><tr><td align="center">SIGPOLL</td><td align="center">当某个事件发送给Pollable Device的时候发送</td></tr><tr><td align="center">SIGPROF</td><td align="center">Setitimer指定的Profiling Interval Timer所产生</td></tr><tr><td align="center">SIGPWR</td><td align="center">和系统相关。和UPS相关。</td></tr><tr><td align="center">SIGQUIT</td><td align="center">输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGSEGV</td><td align="center">非法内存访问</td></tr><tr><td align="center">SIGSTKFLT</td><td align="center">Linux专用，数学协处理器的栈异常</td></tr><tr><td align="center">SIGSTOP</td><td align="center">中止进程。无法处理和忽略。</td></tr><tr><td align="center">SIGSYS</td><td align="center">非法系统调用</td></tr><tr><td align="center">SIGTERM</td><td align="center">请求中止进程，kill命令缺省发送</td></tr><tr><td align="center">SIGTHAW</td><td align="center">Solaris专用，从Suspend恢复时候发送</td></tr><tr><td align="center">SIGTRAP</td><td align="center">实现相关的硬件异常。一般是调试异常</td></tr><tr><td align="center">SIGTSTP</td><td align="center">Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGTTIN</td><td align="center">当Background Group的进程尝试读取Terminal的时候发送</td></tr><tr><td align="center">SIGTTOU</td><td align="center">当Background Group的进程尝试写Terminal的时候发送</td></tr><tr><td align="center">SIGURG</td><td align="center">当out-of-band data接收的时候可能发送</td></tr><tr><td align="center">SIGUSR1</td><td align="center">用户自定义signal 1</td></tr><tr><td align="center">SIGUSR2</td><td align="center">用户自定义signal 2</td></tr><tr><td align="center">SIGVTALRM</td><td align="center">setitimer函数设置的Virtual Interval Timer超时的时候</td></tr><tr><td align="center">SIGWAITING</td><td align="center">Solaris Thread Library内部实现专用</td></tr><tr><td align="center">SIGWINCH</td><td align="center">当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td></tr><tr><td align="center">SIGXCPU</td><td align="center">当CPU时间限制超时的时候</td></tr><tr><td align="center">SIGXFSZ</td><td align="center">进程超过文件大小限制</td></tr><tr><td align="center">SIGXRES</td><td align="center">Solaris专用，进程超过资源限制的时候发送</td></tr></tbody></table><p><strong>注意：</strong></p><p>1、不要使用低级的或者STDIO.H的IO函数</p><p>2、不要使用对操作</p><p>3、不要进行系统调用</p><p>4、不是浮点信号的时候不要用<strong>longjmp</strong></p><p>5、signal函数是由ISO C定义的。因为ISO C不涉及多进程，进程组以及终端I/O等，所以他对信号的定义非常含糊，以至于对UNIX系统而言几乎毫无用处。</p><p>备注：因为signal的语义与现实有关，所以最好使用sigaction函数替代本函数。</p><hr><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p>通过fcntl可以改变已打开的文件性质。fcntl针对描述符提供控制。参数fd是被参数cmd操作的描述符。针对cmd的值，fcntl能够接受第三个参数int arg。</p><p>fcntl的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。</p><p>函数原型：</p><pre><code class="c">int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock);</code></pre><p><strong>参数说明</strong>：</p><ul><li>fd：欲设置的文件描述符。</li><li>cmd：打算操作的指令，它可以取以下几种值：<ul><li>F_DUPFD用来查找大于或等于参数arg的最小且仍未使用的文件描述符，并且复制参数fd的文件描述符。执行成功则返回新复制的文件描述符。新描述符与fd共享同一文件表项，但是新描述符有它自己的一套文件描述符标志，其中FD_CLOEXEC文件描述符标志被清除。请参考dup2。</li><li>F_GETFD取得close-on-exec旗标。若此旗标的FD_CLOEXEC位为0，代表在调用exec()相关函数时文件将不会关闭。</li><li>F_SETFD 设置close-on-exec 旗标。该旗标以参数arg 的FD_CLOEXEC位决定。</li><li>F_GETFL 取得文件描述符状态旗标，此旗标为open（）的参数flags。</li><li>F_SETFL 设置文件描述符状态旗标，参数arg为新旗标，但只允许O_APPEND、O_NONBLOCK和O_ASYNC位的改变，其他位的改变将不受影响。</li><li>F_GETLK 取得文件锁定的状态。</li><li>F_SETLK 设置文件锁定的状态。此时flcok 结构的l_type 值必须是F_RDLCK、F_WRLCK或F_UNLCK。如果无法建立锁定，则返回-1，错误代码为EACCES 或EAGAIN。</li><li>F_SETLKW F_SETLK 作用相同，但是无法建立锁定时，此调用会一直等到锁定动作成功为止。若在等待锁定的过程中被信号中断时，会立即返回-1，错误代码为EINTR。</li></ul></li></ul><p><strong>返回值：</strong>与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。</p><hr><h3 id="kill-fasync函数"><a href="#kill-fasync函数" class="headerlink" title="kill_fasync函数"></a>kill_fasync函数</h3><p>当设备可写/读时，函数kill_fasync会发送信号sig给内核。</p><p>函数原型：</p><pre><code class="c">void kill_fasync(struct fasync_struct **fp, int sig, int band)</code></pre><p><strong>参数说明</strong>：</p><ul><li>fp：内核的异步队列</li><li>sig：所要发送的信号类型。</li><li>band：带宽，它可以取以下两种值：<ul><li>POLL_IN：设备可读</li><li>POLL_OUT：设备可写</li></ul></li></ul><h2 id="二、Linux异步通知"><a href="#二、Linux异步通知" class="headerlink" title="二、Linux异步通知"></a>二、Linux异步通知</h2><h3 id="1-什么是异步通知"><a href="#1-什么是异步通知" class="headerlink" title="1. 什么是异步通知"></a>1. 什么是异步通知</h3><p>个人认为，异步通知类似于中断的机制，如下面的将要举例的程序，当设备可写时，设备驱动函数发送一个信号给内核，告知内核有数据可读,在条件不满足之前，并不会造成阻塞。而不像之前学的阻塞型IO和poll，它们是调用函数进去检查，条件不满足时还会造成阻塞。</p><h3 id="2-应用层中启用异步通知机制"><a href="#2-应用层中启用异步通知机制" class="headerlink" title="2. 应用层中启用异步通知机制"></a>2. 应用层中启用异步通知机制</h3><p>其实就三个步骤：</p><p>1）</p><pre><code class="c">signal(SIGIO, sig_handler);</code></pre><p>调用signal函数，让指定的信号SIGIO与处理函数sig_handler对应。</p><p>2）</p><pre><code class="c">fcntl(fd, F_SET_OWNER, getpid());</code></pre><p>指定一个进程作为文件的“属主(filp-&gt;owner)”(可以理解为告诉驱动程序应用程序的PID)，这样内核才知道信号要发给哪个进程。</p><p>3）</p><pre><code class="c">f_flags = fcntl(fd, F_GETFL);fcntl(fd, F_SETFL, f_flags | FASYNC);</code></pre><p>在设备文件中添加FASYNC标志，驱动中就会调用驱动中实现的fasync函数。</p><p>三个步骤执行后，一旦有信号产生，相应的应用程序中的进程就会收到。</p><h3 id="3-驱动中需要实现的异步通知"><a href="#3-驱动中需要实现的异步通知" class="headerlink" title="3. 驱动中需要实现的异步通知"></a>3. 驱动中需要实现的异步通知</h3><p>实现异步通知，内核需要知道几个东西：哪个文件(filp)，什么信号(SIGIO)，发给哪个进程(pid)，收到信号后做什么(sig_handler)。这些都由上述前两个步骤完成了，而这前两个步骤内核帮忙实现了，所以，我们只需要实现第三个步骤的一个简单的传参。</p><ul><li><p>fasync_struct结构体</p><p>  要实现传参，我们需要把一个结构体struct fasync_struct添加到内核的异步队列中，这个结构体用来存放对应设备文件的信息(如fd, filp)并交给内核来管理。一但收到信号，内核就会在这个所谓的异步队列头找到相应的文件(fd)，并在filp-&gt;owner中找到对应的进程PID，并且调用对应的sig_handler了。</p><pre><code class="c">  struct fasync_struct {      int magic;      int fa_fd;      struct fasync_struct *fa_next; /* singly linked list */      struct file *fa_file;  };</code></pre></li></ul><p>上面说了前两个步骤会由内核完成，所以我们只要做两件事情：</p><ol><li><p>定义结构体fasync_struct。</p><pre><code class="c"> struct fasync_struct *async_queue;</code></pre></li><li><p>实现驱动程序中的fasync函数：test_fasync，利用函数fasync_helper将fd,filp和定义的异步队列结构体传给内核（这里主要是初始化异步队列async_queue）。</p><pre><code class="c"> static struct fasync_struct *async_queue; int test_fasync (int fd, struct file *filp, int on) {     return fasync_helper(fd, filp, on, &amp;async_queue); } static struct file_operations sencod_drv_fops = {     .owner   =  THIS_MODULE,    /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */     ...     ...     .fasync     =  test_fasync, };</code></pre><p> 函数fasync_helper的定义为：</p><pre><code class="c"> int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)</code></pre><p> 该函数主要负责初始化或释放异步队列async_queue。前面的三个参数其实就是teat_fasync的三个参数，所以只要我们定义好的fasync_struct结构体也传进去就可以了。</p></li><li><p>当设备可读时，调用函数kill_fasync发送信号SIGIO给内核。</p><pre><code class="c"> kill_fasync (&amp;async_queue, SIGIO, POLL_IN);</code></pre></li><li><p>当设备关闭时，需要将fasync_struct从异步队列中删除：</p><pre><code class="c"> test_fasync(-1, filp, 0);</code></pre><p> 删除也是调用test_fasync，不过改了一下参数而已，实际上是通过fasync_helper函数实现的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 按键驱动 </tag>
            
            <tag> 异步通知机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按键驱动——poll机制</title>
      <link href="/2019/07/21/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94poll%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/21/%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94poll%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="按键驱动——poll机制"><a href="#按键驱动——poll机制" class="headerlink" title="按键驱动——poll机制"></a>按键驱动——poll机制</h1><h2 id="一、机制分析（主要分析sys-poll）"><a href="#一、机制分析（主要分析sys-poll）" class="headerlink" title="一、机制分析（主要分析sys_poll）"></a>一、机制分析（主要分析sys_poll）</h2><p>对于应用程序调用poll或select，它们调用的内核函数都是sys_poll。</p><ol><li><p>sys_poll函数位于fs/select.c文件中，代码如下：</p><pre><code class="C">asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds,           long timeout_msecs){   s64 timeout_jiffies;   if (timeout_msecs &gt; 0) {#if HZ &gt; 1000       /* We can only overflow if HZ &gt; 1000 */       if (timeout_msecs / 1000 &gt; (s64)0x7fffffffffffffffULL / (s64)HZ)           timeout_jiffies = -1;       else#endif           timeout_jiffies = msecs_to_jiffies(timeout_msecs);   } else {       /* Infinite (&lt; 0) or no (0) timeout */       timeout_jiffies = timeout_msecs;   }   return do_sys_poll(ufds, nfds, &amp;timeout_jiffies);}</code></pre><p>它对超时参数稍作处理后，直接调用do_sys_poll。</p></li><li><p>do_sys_poll函数也位于位于fs/select.c文件中，我们忽略其他代码：</p><pre><code class="C">int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds, s64 *timeout){   ……   poll_initwait(&amp;table);   ……   fdcount = do_poll(nfds, head, &amp;table, timeout);   ……}</code></pre></li></ol><ul><li>poll_initwait函数非常简单，它初始化一个poll_wqueues结构体变量table：</li></ul><pre><code class="C">poll_initwait(&amp;table) --&gt; init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait); --&gt; pt-&gt;qproc = qproc;//简化后即为table-&gt;qproc = __pollwait</code></pre><ul><li>do_sys_poll函数位于fs/select.c文件中，代码如下：</li></ul><pre><code class="C">static int do_poll(unsigned int nfds,  struct poll_list *list,           struct poll_wqueues *wait, s64 *timeout){……    for (;;) {……        if (do_pollfd(pfd, pt)) {//实际上就是调用自己写的poll驱动函数，返回值为poll驱动函数的返回值            count++;            pt = NULL;        }……       if (count || !*timeout || signal_pending(current))//count非0，超时、有信号等待处理           break;       count = wait-&gt;error;       if (count)           break;       if (*timeout &lt; 0) {           /* Wait indefinitely */           __timeout = MAX_SCHEDULE_TIMEOUT;       } else if (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT-1)) {           /*                * Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in                * a loop                */           __timeout = MAX_SCHEDULE_TIMEOUT - 1;           *timeout -= __timeout;       } else {           __timeout = *timeout;           *timeout = 0;       }       __timeout = schedule_timeout(__timeout);//休眠__timeout       if (*timeout &gt;= 0)           *timeout += __timeout;   }   __set_current_state(TASK_RUNNING);   return count;}</code></pre><p>分析其中的代码，可以发现，它的作用如下：</p><p>① 从02行可以知道，这是个循环，它退出的条件为：</p><ol><li>12行的3个条件之一(count非0，超时、有信号等待处理)</li></ol><p>count非0表示04行的do_pollfd至少有一个成功。</p><ol start="2"><li>14、15行：发生错误</li></ol><p>② 重点在do_pollfd函数，后面再分析</p><p>③ 第32行，让本进程休眠一段时间，注意：应用程序执行poll调用后，如果①②的条件不满足，进程就会进入休眠。那么，谁唤醒呢？除了休眠到指定时间被系统唤醒外，还可以被驱动程序唤醒──记住这点，这就是为什么驱动的poll里要调用poll_wait的原因，后面分析。</p><ol start="3"><li><p>do_pollfd函数位于fs/select.c文件中，代码如下：</p><pre><code class="c">static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait){……   if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;poll)       mask = file-&gt;f_op-&gt;poll(file, pwait);……   return mask;}</code></pre><pre><code>这里file为file结构体指针，file-&gt;f_op即为file_operations结构体，故file-&gt;f_op-&gt;poll就是自己编写的驱动程序里注册的poll函数。</code></pre></li></ol><h2 id="二、驱动程序"><a href="#二、驱动程序" class="headerlink" title="二、驱动程序"></a>二、驱动程序</h2><p>驱动程序里与poll相关的地方有两处：一是构造file_operation结构时，要定义自己的poll函数。二是通过poll_wait来调用上面说到的__pollwait函数，poll_wait的代码如下：</p><p>​```C<br>static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)<br>{<br>    if (p &amp;&amp; wait_address)<br>        p-&gt;qproc(filp, wait_address, p);<br>}</p><pre><code>这里的p即为上文中的poll_wqueues结构体变量table，p-&gt;qproc就是poll_initwait中赋值的\__pollwait函数。从__pollwait的代码可知，它只是把当前进程挂入我们驱动程序里定义的一个队列wait_address而已。它的代码如下：```cstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,                poll_table *p){    struct poll_table_entry *entry = poll_get_entry(p);    if (!entry)        return;    get_file(filp);    entry-&gt;filp = filp;    entry-&gt;wait_address = wait_address;    init_waitqueue_entry(&amp;entry-&gt;wait, current);    add_wait_queue(wait_address, &amp;entry-&gt;wait);}</code></pre><p>执行到驱动程序的poll_wait函数时，进程并没有休眠，我们的驱动程序里实现的poll函数是不会引起休眠的。让进程进入休眠，是前面分析的do_sys_poll函数的32行“__timeout = schedule_timeout(__timeout)”。</p><p>poll_wait只是把本进程挂入某个等待队列，应用程序调用poll –&gt; sys_poll –&gt; do_sys_poll –&gt; poll_initwait，do_poll –&gt; do_pollfd –&gt; 我们自己写的poll函数后，再调用schedule_timeout进入休眠。如果我们的驱动程序发现情况就绪，可以把这个等待队列上挂着的进程唤醒（如：通过中断的wake_up_interruptible函数唤醒休眠的进程），此时由于do_sys_poll中for循环的原因会再执行一次do_pollfd 函数，即底层自己编写的poll函数，随后timeout会减为0跳出for，应用层poll函数执行完毕。可见，poll_wait的作用，只是为了将schedule_timeout休眠的进程绑在一个等待队列上，让驱动程序能找到要唤醒的进程并通过某种方式唤醒（如中断中利用wake_up_interruptible函数）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在来总结一下poll机制：</p><ol><li><p>poll –&gt; sys_poll –&gt; do_sys_poll –&gt; poll_initwait，poll_initwait函数注册一下回调函数__pollwait，它就是我们的驱动程序执行poll_wait时，真正被调用的函数。</p></li><li><p>接下来执行file-&gt;f_op-&gt;poll，即我们驱动程序里自己实现的poll函数</p><p>它会调用poll_wait（即1中注册的回调函数__pollwait）把自己挂入某个等待队列，这个等待队列也是我们的驱动自己定义的；</p><p>它还判断一下设备是否就绪。</p></li><li><p>如果设备未就绪，do_sys_poll里会让进程休眠一定时间</p></li><li><p>进程被唤醒的条件有二：一是上面说的“一定时间”到了，二是被驱动程序唤醒（如中断中利用wake_up_interruptible函数唤醒绑定在等待队列上由poll_wait设置的成员）。驱动程序发现条件就绪时，就把“某个等待队列”上挂着的进程唤醒，这个等待队列是由驱动自己定义的，也就是前面通过poll_wait把schedule_timeout休眠的进程挂过去的队列。</p></li><li><p>如果驱动程序没有去唤醒进程，那么chedule_timeout(__timeou)超时后，会再执行一次2动作，接着退出应用层的poll函数。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 按键驱动 </tag>
            
            <tag> poll机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux等待队列wait_queue_head_t和wait_queue_t</title>
      <link href="/2019/07/21/linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97wait_queue_head_t%E5%92%8Cwait_queue_t/"/>
      <url>/2019/07/21/linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97wait_queue_head_t%E5%92%8Cwait_queue_t/</url>
      
        <content type="html"><![CDATA[<h1 id="linux等待队列wait-queue-head-t和wait-queue-t"><a href="#linux等待队列wait-queue-head-t和wait-queue-t" class="headerlink" title="linux等待队列wait_queue_head_t和wait_queue_t"></a>linux等待队列wait_queue_head_t和wait_queue_t</h1><p>等待队列在linux内核中有着举足轻重的作用，很多linux驱动都或多或少涉及到了等待队列。因此，对于linux内核及驱动开发者来说，掌握等待队列是必须课之一。 Linux内核的等待队列是以双循环链表为基础数据结构，与进程调度机制紧密结合，能够用于实现核心的异步事件通知机制。它有两种数据结构：等待队列头（wait_queue_head_t）和等待队列项（wait_queue_t）。等待队列头和等待队列项中都包含一个list_head类型的域作为”连接件”。它通过一个双链表和把等待task的头，和等待的进程列表链接起来。下面具体介绍。</p><h2 id="一、定义："><a href="#一、定义：" class="headerlink" title="一、定义："></a>一、定义：</h2><p>头文件：/include/linux/wait.h</p><pre><code class="c">struct __wait_queue_head {    spinlock_t lock;    struct list_head task_list;};typedef struct __wait_queue_head wait_queue_head_t;</code></pre><h2 id="二、作用："><a href="#二、作用：" class="headerlink" title="二、作用："></a>二、作用：</h2><p>在内核里面，等待队列是有很多用处的，尤其是在中断处理、进程同步、定时等场合。可以使用等待队列在实现阻塞进程的唤醒。它以队列为基础数据结构，与进程调度机制紧密结合，能够用于实现内核中的异步事件通知机制，同步对系统资源的访问等。</p><h2 id="三、字段详解："><a href="#三、字段详解：" class="headerlink" title="三、字段详解："></a>三、字段详解：</h2><p>1、spinlock_t lock;</p><p> 在对task_list与操作的过程中，使用该锁实现对等待队列的互斥访问。</p><p> 2、srtuct list_head_t task_list;</p><p>双向循环链表，存放等待的进程。</p><h2 id="四、操作："><a href="#四、操作：" class="headerlink" title="四、操作："></a>四、操作：</h2><h3 id="1、定义并初始化："><a href="#1、定义并初始化：" class="headerlink" title="1、定义并初始化："></a>1、定义并初始化：</h3><p>(1)</p><pre><code class="c">wait_queue_head_t my_queue;init_waitqueue_head(&amp;my_queue);</code></pre><p>直接定义并初始化。init_waitqueue_head()函数会将自旋锁初始化为未锁，等待队列初始化为空的双向循环链表。</p><p>(2)</p><p>DECLARE_WAIT_QUEUE_HEAD(my_queue);</p><p>定义并初始化，相当于(1)。</p><p>(3) 定义等待队列：</p><p>DECLARE_WAITQUEUE(name,tsk);</p><p>注意此处是定义一个wait_queue_t类型的变量name，并将其private与设置为tsk。wait_queue_t类型定义如下：</p><pre><code class="c">typedef struct __wait_queue wait_queue_t;struct __wait_queue {    unsigned int flags;#define WQ_FLAG_EXCLUSIVE    0x01    void *private;    wait_queue_func_t func;    struct list_head task_list;};</code></pre><p>其中flags域指明该等待的进程是互斥进程还是非互斥进程。其中0是非互斥进程，WQ_FLAG_EXCLUSIVE(0x01)是互斥进程。等待队列(wait_queue_t)和等待对列头(wait_queue_head_t)的区别是等待队列是等待队列头的成员。也就是说等待队列头的task_list域链接的成员就是等待队列类型的(wait_queue_t)。</p><p><img src="//NU-LL.github.io/2019/07/21/linux等待队列wait_queue_head_t和wait_queue_t/%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.jpg" alt="等待队列"></p><h3 id="2、-从等待队列头中-添加／移出等待队列："><a href="#2、-从等待队列头中-添加／移出等待队列：" class="headerlink" title="2、(从等待队列头中)添加／移出等待队列："></a>2、(从等待队列头中)添加／移出等待队列：</h3><p>(1) add_wait_queue()函数：</p><pre><code class="c">void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait){    unsigned long flags;    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;    spin_lock_irqsave(&amp;q-&gt;lock, flags);    __add_wait_queue(q, wait);    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);}EXPORT_SYMBOL(add_wait_queue);</code></pre><p>设置等待的进程为非互斥进程，并将其添加进等待队列头(q)的队头中。</p><pre><code class="c">void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait){    unsigned long flags;    wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;    spin_lock_irqsave(&amp;q-&gt;lock, flags);    __add_wait_queue_tail(q, wait);    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);}EXPORT_SYMBOL(add_wait_queue_exclusive);</code></pre><p>该函数也和add_wait_queue()函数功能基本一样，只不过它是将等待的进程(wait)设置为互斥进程。</p><p>(2)remove_wait_queue()函数：</p><pre><code class="c">void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait){    unsigned long flags;    spin_lock_irqsave(&amp;q-&gt;lock, flags);    __remove_wait_queue(q, wait);    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);}EXPORT_SYMBOL(remove_wait_queue);</code></pre><p>在等待的资源或事件满足时，进程被唤醒，使用该函数被从等待头中删除。</p><h3 id="3、等待事件："><a href="#3、等待事件：" class="headerlink" title="3、等待事件："></a>3、等待事件：</h3><p>(1)wait_event()宏：</p><pre><code class="c">/** * wait_event - sleep until a condition gets true * @wq: the waitqueue to wait on * @condition: a C expression for the event to wait for * * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the * @condition evaluates to true. The @condition is checked each time * the waitqueue @wq is woken up. * * wake_up() has to be called after changing any variable that could * change the result of the wait condition. */#define wait_event(wq, condition)                     \do {                                    \    if (condition)                             \        break;                            \    __wait_event(wq, condition);                    \} while (0)</code></pre><p>在等待会列中睡眠直到condition为真。在等待的期间，进程会被置为TASK_UNINTERRUPTIBLE进入睡眠，直到condition变量变为真。每次进程被唤醒的时候都会检查condition的值.</p><p>(2)wait_event_interruptible()函数:</p><p>和wait_event()的区别是调用该宏在等待的过程中当前进程会被设置为TASK_INTERRUPTIBLE状态.在每次被唤醒的时候,首先检查condition是否为真,如果为真则返回,否则检查如果进程是被信号唤醒,会返回-ERESTARTSYS错误码.如果是condition为真,则返回0.</p><p>(3)wait_event_timeout()宏:</p><p>也与wait_event()类似.不过如果所给的睡眠时间为负数则立即返回.如果在睡眠期间被唤醒,且condition为真则返回剩余的睡眠时间,否则继续睡眠直到到达或超过给定的睡眠时间,然后返回0.</p><p>(4)wait_event_interruptible_timeout()宏:</p><p> 与wait_event_timeout()类似,不过如果在睡眠期间被信号打断则返回ERESTARTSYS错误码.</p><p>(5) wait_event_interruptible_exclusive()宏</p><p>同样和wait_event_interruptible()一样,不过该睡眠的进程是一个互斥进程.</p><h3 id="4、唤醒队列"><a href="#4、唤醒队列" class="headerlink" title="4、唤醒队列:"></a>4、唤醒队列:</h3><p>(1)wake_up()函数:</p><pre><code class="c">#define wake_up(x)          __wake_up(x, TASK_NORMAL, 1, NULL)/** * __wake_up - wake up threads blocked on a waitqueue. * @q: the waitqueue * @mode: which threads * @nr_exclusive: how many wake-one or wake-many threads to wake up * @key: is directly passed to the wakeup function */void __wake_up(wait_queue_head_t *q, unsigned int mode,            int nr_exclusive, void *key){    unsigned long flags;    spin_lock_irqsave(&amp;q-&gt;lock, flags);    __wake_up_common(q, mode, nr_exclusive, 0, key);    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);}EXPORT_SYMBOL(__wake_up);</code></pre><p>唤醒等待队列.可唤醒处于TASK_INTERRUPTIBLE和TASK_UNINTERUPTIBLE状态的进程,和wait_event/wait_event_timeout成对使用.</p><p>(2)wake_up_interruptible()函数:</p><pre><code class="c">#define wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</code></pre><p>和wake_up()唯一的区别是它只能唤醒TASK_INTERRUPTIBLE状态的进程.,与wait_event_interruptible/wait_event_interruptible_timeout/ wait_event_interruptible_exclusive成对使用. </p><p>(3)</p><pre><code class="c">#define wake_up_all(x)            __wake_up(x, TASK_NORMAL, 0, NULL)#define wake_up_interruptible_nr(x, nr)    __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)#define wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</code></pre><p>这些也基本都和wake_up/wake_up_interruptible一样.</p><h3 id="5、在等待队列上睡眠："><a href="#5、在等待队列上睡眠：" class="headerlink" title="5、在等待队列上睡眠："></a>5、在等待队列上睡眠：</h3><p>(1) sleep_on()函数:</p><pre><code class="c">void __sched sleep_on(wait_queue_head_t *q){    sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);}static long __schedsleep_on_common(wait_queue_head_t *q, int state, long timeout){    unsigned long flags;    wait_queue_t wait;    init_waitqueue_entry(&amp;wait, current);    __set_current_state(state);    spin_lock_irqsave(&amp;q-&gt;lock, flags);    __add_wait_queue(q, &amp;wait);    spin_unlock(&amp;q-&gt;lock);    timeout = schedule_timeout(timeout);    spin_lock_irq(&amp;q-&gt;lock);    __remove_wait_queue(q, &amp;wait);    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);    return timeout;}</code></pre><p>该函数的作用是定义一个等待队列(wait)，并将当前进程添加到等待队列中(wait)，然后将当前进程的状态置为TASK_UNINTERRUPTIBLE，并将等待队列(wait)添加到等待队列头(q)中。之后就被挂起直到资源可以获取，才被从等待队列头(q)中唤醒，从等待队列头中移出。在被挂起等待资源期间，该进程不能被信号唤醒。</p><p>(2)sleep_on_timeout()函数：</p><pre><code class="c">long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout){    return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);}EXPORT_SYMBOL(sleep_on_timeout);</code></pre><p>与sleep_on()函数的区别在于调用该函数时，如果在指定的时间内(timeout)没有获得等待的资源就会返回。实际上是调用schedule_timeout()函数实现的。值得注意的是如果所给的睡眠时间(timeout)小于0，则不会睡眠。该函数返回的是真正的睡眠时间。</p><p>(3)interruptible_sleep_on()函数：</p><pre><code class="c">void __sched interruptible_sleep_on(wait_queue_head_t *q){    sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);}EXPORT_SYMBOL(interruptible_sleep_on);</code></pre><p>该函数和sleep_on()函数唯一的区别是将当前进程的状态置为TASK_INTERRUPTINLE，这意味在睡眠如果该进程收到信号则会被唤醒。</p><p>(4)interruptible_sleep_on_timeout()函数：</p><pre><code class="c">long __schedinterruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout){    return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);}EXPORT_SYMBOL(interruptible_sleep_on_timeout);</code></pre><p>类似于sleep_on_timeout()函数。进程在睡眠中可能在等待的时间没有到达就被信号打断而被唤醒，也可能是等待的时间到达而被唤醒。</p><p>以上四个函数都是让进程在等待队列上睡眠，不过是小有诧异而已。在实际用的过程中，根据需要选择合适的函数使用就是了。例如在对软驱数据的读写中，如果设备没有就绪则调用sleep_on()函数睡眠直到数据可读(可写)，在打开串口的时候，如果串口端口处于关闭状态则调用interruptible_sleep_on()函数尝试等待其打开。在声卡驱动中，读取声音数据时，如果没有数据可读，就会等待足够常的时间直到可读取。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 等待队列 </tag>
            
            <tag> wait_queue_head_t </tag>
            
            <tag> wait_queue_t </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux编程--文件描述符fd</title>
      <link href="/2019/07/21/Linux%E7%BC%96%E7%A8%8B--%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd/"/>
      <url>/2019/07/21/Linux%E7%BC%96%E7%A8%8B--%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux编程–文件描述符fd"><a href="#Linux编程–文件描述符fd" class="headerlink" title="Linux编程–文件描述符fd"></a>Linux编程–文件描述符fd</h1><p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p><p>​    我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p><p>​    既然是数组下标，<strong>fd的类型为int， &lt; 0 为非法值， &gt;=0 为合法值</strong>。在linux中，一个进程默认可以打开的文件数为1024个，fd的范围为0~1023。可以通过设置，改变最大值。</p><p>​    <strong>在linux中，值为0、1、2的fd，分别代表标准输入、标准输出、标准错误输出</strong>。在上一篇文章中，使用重定向 2&gt;/dev/null 就是把标准错误输出重定向到位桶中去，不显示出来。因为 0 1 2已经被linux使用了，通常在程序中打开的fd，是从3开始的。但我们在判断一个fd是否合法时，<strong>依然要使用&gt;=0的判断标准</strong>。</p><p>​    <strong>fd的分配原则，是从小到大，找到第一个不用的进行分配</strong>。</p><p>​    除了open之外， socket编程的socket()/accept()等函数，也会返回一个fd值。</p><p>​    1）Linux系统下，所有进程允许打开的最大fd数量。查询语句：</p><pre><code class="bash">cat /proc/sys/fs/file-max</code></pre><p>​    2）Linux系统下，所有进程已经打开的fd数量及允许的最大数量。查询语句：</p><pre><code class="bash">cat /proc/sys/fs/file-nr</code></pre><p>​    3）单个进程允许打开的最大fd数量.查询语句：</p><pre><code class="bash">ulimit -n</code></pre><p>​    4)单个进程（例如进程id为5454）已经打开的fd.查询语句：</p><pre><code class="bash">ls -l /proc/5454/fd/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件描述符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法整理</title>
      <link href="/2019/07/12/Markdown%20%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2019/07/12/Markdown%20%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法整理"><a href="#Markdown-语法整理" class="headerlink" title="Markdown 语法整理"></a>Markdown 语法整理</h1><p>简明教程：<a href="https://ouweiya.gitbooks.io/markdown/" target="_blank" rel="noopener">https://ouweiya.gitbooks.io/markdown/</a></p><hr><p>[TOC]</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p><strong>代码</strong></p><p>注：# 后面保持空格</p><pre><code># h1## h2### h3#### h4##### h5###### h6####### h7      // 错误代码######## h8     // 错误代码######### h9    // 错误代码########## h10  // 错误代码</code></pre><p><strong>演示</strong></p><p>![1562910228586](Markdown 语法整理/1562910228586.png)</p><hr><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h3><p><strong>代码</strong><br> 注：<code>=</code> <code>-</code> 最少可以只写一个，兼容性一般</p><pre><code>一级标题======================二级标题---------------------</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-c969047ea76e86b3.webp)</p><hr><h3 id="3-TOC"><a href="#3-TOC" class="headerlink" title="3.TOC"></a>3.TOC</h3><p>输入<code>[toc]</code>然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><p>注：根据标题生成目录，兼容性一般</p><p><strong>代码</strong></p><pre><code>[TOC]</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-0c9a604cd6f84d8c.webp)</p><hr><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h3><p><strong>代码1(单行式)</strong></p><pre><code>&gt; hello world!</code></pre><p><strong>演示</strong></p><blockquote><p>hello world!</p></blockquote><p><strong>代码2(多行式)</strong></p><pre><code>&gt; hello world!hello world!hello world!    </code></pre><p>或者</p><pre><code>&gt; hello world!&gt; hello world!&gt; hello world!</code></pre><p><strong>演示</strong></p><p>相同的结果</p><blockquote><p>hello world!<br> hello world!<br> hello world!</p></blockquote><p><strong>代码3(多层嵌套)</strong></p><pre><code>&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc</code></pre><p><strong>演示</strong></p><blockquote><p>aaaaaaaaa</p><blockquote><p>bbbbbbbbb</p><blockquote><p>cccccccccc</p></blockquote></blockquote></blockquote><hr><h3 id="5-行内标记"><a href="#5-行内标记" class="headerlink" title="5.行内标记"></a>5.行内标记</h3><p>注：用 `  标记<strong>代码块将变成一行</strong></p><p><strong>代码</strong></p><pre><code>标记之外`hello world`标记之外</code></pre><p><strong>演示</strong></p><p>标记之外<code>hello world</code>标记之外</p><p><strong>错误代码</strong><br> 注：不同平台错误略有差异</p><pre><code> 标记之外 ` &lt; div&gt;       &lt; div&gt;&lt;/div&gt;    &lt; div&gt;&lt;/div&gt;    &lt; div&gt;&lt;/div&gt;&lt; /div&gt;`标记之外</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-6e436a12165b5469.webp)</p><hr><h3 id="6-代码块"><a href="#6-代码块" class="headerlink" title="6.代码块"></a>6.代码块</h3><p>注：与上行距离一空行</p><p><strong>代码1(```)</strong></p><p>注：用`````生成块</p><pre><code>​```&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;​```</code></pre><p><strong>演示</strong></p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>代码2(Tab)</strong></p><p>注： Tab缩进</p><pre><code>我是文字……    &lt;div&gt;           &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;</code></pre><p><strong>演示</strong></p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>代码3(自定义语法)</strong><br> 注：根据不同的语言配置不同的代码着色</p><pre><code>​```javascriptvar num = 0;for (var i = 0; i &lt; 5; i++) {    num+=i;}console.log(num);​```</code></pre><p><strong>演示</strong></p><pre><code>var num = 0;for (var i = 0; i &lt; 5; i++) {    num+=i;}console.log(num);</code></pre><hr><h3 id="7-插入链接"><a href="#7-插入链接" class="headerlink" title="7.插入链接"></a>7.插入链接</h3><p><strong>代码1(内链式)</strong></p><p><code>Alt text</code>：图片、链接的Alt标签，用来描述图片、链接的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 </p><p><code>链接</code>：可以是图片、链接的本地地址或者是网址。</p><p><code>标题</code>：鼠标悬置于图片、链接上会出现的标题文字，可以不写。</p><p>注：<code>{:target=&quot;_blank&quot;}</code>跳转方式兼容性一般 ，多数第三方平台不支持跳转（Typora上实测不行）</p><pre><code>[百度1](http://www.baidu.com/ &quot;百度一下&quot;){:target=&quot;_blank&quot;}[Alt text](链接 &quot;标题&quot;)</code></pre><p><strong>演示</strong></p><p><a href="http://www.baidu.com/" title="百度二下" target="_blank" rel="noopener">百度1</a></p><p><strong>代码2(引用式)</strong></p><p>注：<code>{:target=&quot;_blank&quot;}</code>跳转方式兼容性一般 ，多数第三方平台不支持跳转（Typora上实测不行）</p><pre><code>[百度2][2]{:target=&quot;_blank&quot;}[2]:http://www.baidu.com/ &quot;百度二下&quot;</code></pre><p><strong>演示</strong></p><p><a href="http://www.baidu.com/" title="百度二下" target="_blank" rel="noopener">百度2</a></p><hr><h3 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8.插入图片"></a>8.插入图片</h3><p><strong>代码1(内链式)</strong></p><pre><code>[图片上传失败...(image-90880b-1542510791300)]</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-8c53b79a706bb7c2.webp)</p><p><strong>代码2(引用式)</strong></p><pre><code>![name][01][01]: ./01.png &#39;描述&#39;![名字](路径)</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-2b1e8871d7bf2d6e.webp)</p><hr><h3 id="9-插入图片带有链接"><a href="#9-插入图片带有链接" class="headerlink" title="9.插入图片带有链接"></a>9.插入图片带有链接</h3><p><strong>代码</strong></p><pre><code>[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com){:target=&quot;_blank&quot;}       // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]{:target=&quot;_blank&quot;}                      // 引用式[5]: http://www.baidu.com</code></pre><p><strong>演示</strong></p><p>暂无</p><h3 id="10-视频插入"><a href="#10-视频插入" class="headerlink" title="10.视频插入"></a>10.视频插入</h3><p>注：Markdown 语法是不支持直接插入视频的<br> 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法<br> 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面</p><p><strong>代码1</strong><br> 注：多数第三方平台不支持插入<code>&lt;iframe&gt;</code>视频</p><p>![youku](Markdown 语法整理/6912209-29337f2896bf4629.webp)</p><pre><code>&lt;iframe height=498 width=510 src=&#39;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&#39; frameborder=0 &#39;allowfullscreen&#39;&gt;&lt;/iframe&gt;</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-d11325d111b86cc1.webp)</p><p><strong>代码2</strong></p><pre><code>[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction){:target=&quot;_blank&quot;}</code></pre><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-d11325d111b86cc1-1562903542745.webp)</p><hr><h3 id="11-序表"><a href="#11-序表" class="headerlink" title="11.序表"></a>11.序表</h3><p><strong>代码1(有序)</strong></p><p>注：序列<code>.</code>后 保持空格</p><pre><code>1. one2. two3. three</code></pre><p><strong>演示</strong></p><ol><li>one</li><li>two</li><li>three</li></ol><p><strong>代码2(无序)</strong></p><pre><code>* one* two* three</code></pre><p><strong>演示</strong></p><ul><li>one</li><li>two</li><li>three</li></ul><p><strong>代码3(序表嵌套)</strong></p><pre><code>1. one    1. one-1    2. two-22. two     * two-1    * two-2</code></pre><p><strong>演示</strong></p><ol><li>one <ol><li>one-1</li><li>two-2</li></ol></li><li>two <ul><li>two-1</li><li>two-2</li></ul></li></ol><hr><p><strong>代码4(序表嵌套代码块)</strong><br> 注：换行+两个Tab</p><pre><code>* one    var a = 10;     // 与上行保持空行并 递进缩进</code></pre><p><strong>演示：</strong></p><ul><li><p>one</p><pre><code>  var a = 10;</code></pre></li></ul><hr><h3 id="12-任务列表"><a href="#12-任务列表" class="headerlink" title="12.任务列表"></a>12.任务列表</h3><p>注：兼容性一般 要隔开一行</p><p><strong>代码</strong></p><pre><code>这是文字……- [x] 选项一- [ ] 选项二  - [ ]  [选项3]</code></pre><p><strong>演示</strong></p><ul><li><input checked disabled type="checkbox"> 选项一</li><li><input disabled type="checkbox"> 选项二  </li><li><input disabled type="checkbox"> [选项3]</li></ul><hr><h3 id="13-表情"><a href="#13-表情" class="headerlink" title="13.表情"></a>13.表情</h3><p>注：兼容一般</p><p>![img](Markdown 语法整理/6912209-35a94b525d1ec313.webp)</p><p><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/'GitHub'" target="_blank" rel="noopener">表情代码地址</a></p><hr><h3 id="14-表格"><a href="#14-表格" class="headerlink" title="14.表格"></a>14.表格</h3><p>注： <code>:</code> 代表对齐方式 ,<strong><code>:</code> 与 <code>|</code> 之间不要有空格</strong>，否则对齐会有些不兼容</p><p><strong>代码1</strong></p><pre><code>|    a    |       b       |      c     ||:-------:|:------------- | ----------:||   居中  |     左对齐    |   右对齐   ||=========|===============|============|</code></pre><p><strong>演示</strong></p><table><thead><tr><th align="center">a</th><th align="left">b</th><th align="right">c</th></tr></thead><tbody><tr><td align="center">居中</td><td align="left">左对齐</td><td align="right">右对齐</td></tr><tr><td align="center">=========</td><td align="left">===============</td><td align="right">============</td></tr></tbody></table><hr><p><strong>代码2(简约写法)</strong></p><pre><code>a  | b | c  :-:|:- |-:    居中    |     左对齐      |   右对齐    ============|=================|=============</code></pre><p><strong>演示</strong></p><table><thead><tr><th align="center">a</th><th align="left">b</th><th align="right">c</th></tr></thead><tbody><tr><td align="center">居中</td><td align="left">左对齐</td><td align="right">右对齐</td></tr><tr><td align="center">============</td><td align="left">=================</td><td align="right">=============</td></tr></tbody></table><p><strong>代码3(特殊表格)</strong></p><p>注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的<br> 所以常规的做法是使用HTML标签，但是这样的编写效率极低。<br> 但是有了这款工具的话，所有问题都迎刃而解。</p><p>在线生成HTML代码 <a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">Tables Generator</a> (国外的站)</p><p>![Tables Generator](Markdown 语法整理/6912209-46aac2b114b995ec.webp)</p><p><strong>演示</strong></p><p>![img](Markdown 语法整理/6912209-5e14abef7e65830d.webp)</p><hr><h3 id="15-支持内嵌CSS样式"><a href="#15-支持内嵌CSS样式" class="headerlink" title="15.支持内嵌CSS样式"></a>15.支持内嵌CSS样式</h3><p><strong>代码</strong></p><pre><code>&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: &#39;宋体&#39;;&quot;&gt;内联样式&lt;/p&gt;</code></pre><p><strong>演示</strong></p><p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p>------<h3 id="16-语义标记"><a href="#16-语义标记" class="headerlink" title="16.语义标记"></a>16.语义标记</h3><table><thead><tr><th>描述</th><th>效果</th><th>代码</th></tr></thead><tbody><tr><td>斜体</td><td><em>斜体</em></td><td><code>*斜体*</code></td></tr><tr><td>斜体</td><td><em>斜体</em></td><td><code>_斜体_</code></td></tr><tr><td>加粗</td><td><strong>加粗</strong></td><td><code>**加粗**</code></td></tr><tr><td>加粗+斜体</td><td><strong><em>加粗+斜体</em></strong></td><td><code>***加粗+斜体***</code></td></tr><tr><td>加粗+斜体</td><td><strong><em>加粗+斜体</em></strong></td><td><code>**_加粗+斜体_**</code></td></tr><tr><td>删除线</td><td><del>删除线</del></td><td><code>~~删除线~~</code></td></tr></tbody></table><hr><h3 id="17-语义标签"><a href="#17-语义标签" class="headerlink" title="17.语义标签"></a>17.语义标签</h3><table><thead><tr><th>描述</th><th>效果</th><th>代码</th></tr></thead><tbody><tr><td>斜体</td><td><i>斜体</i></td><td><code>&lt;i&gt;斜体&lt;/i&gt;</code></td></tr><tr><td>加粗</td><td><b>加粗</b></td><td><code>&lt;b&gt;加粗&lt;/b&gt;</code></td></tr><tr><td>强调</td><td><em>强调</em></td><td><code>&lt;em&gt;强调&lt;/em&gt;</code></td></tr><tr><td>上标</td><td>Z<sup>a</sup></td><td><code>Z&lt;sup&gt;a&lt;/sup&gt;</code></td></tr><tr><td>下标</td><td>Z<sub>a</sub></td><td><code>Z&lt;sub&gt;a&lt;/sub&gt;</code></td></tr><tr><td>键盘文本</td><td><kbd>Ctrl</kbd></td><td><code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;</code></td></tr><tr><td>换行</td><td></td><td>``</td></tr></tbody></table><hr><h3 id="18-格式化文本"><a href="#18-格式化文本" class="headerlink" title="18.格式化文本"></a>18.格式化文本</h3><p><strong>保持输入排版格式不变</strong></p><p>注：对内含标签需要破坏结构才能显示</p><p><strong>代码</strong></p><pre><code>&lt;pre&gt;hello world hihello world &lt;/pre&gt;</code></pre><p><strong>演示</strong></p><pre>hello worldhihello world</pre><p><strong>错误解决方法</strong><br> 注：标签内部添加空格 或者 <strong>直接使用```标记来处理</strong><br> <strong>代码1(插入空格)</strong></p><pre><code>&lt;pre&gt;    &lt; div&gt;           &lt; div&gt;&lt; /div&gt;        &lt; div&gt;&lt; /div&gt;        &lt; div&gt;&lt; /div&gt;    &lt; /div&gt;&lt;/pre&gt;</code></pre><p><strong>演示</strong></p><pre>< div>< div>< /div>< div>< /div>< div>< /div>< /div></pre><p><strong>代码2( ``` 代码块标记)</strong></p><pre><code>​```&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;​```</code></pre><p><strong>演示</strong></p><pre><code>&lt;div&gt;       &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><hr><h3 id="19-公式"><a href="#19-公式" class="headerlink" title="19.公式"></a>19.公式</h3><p>注：1个$左对齐，2个居中</p><p><strong>代码</strong></p><pre><code>$$ x \href{why-equal.html}{=} y^2 + 1 $$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $</code></pre><p><strong>演示</strong></p><p>$$ x \href{why-equal.html}{=} y^2 + 1 $$<br>$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $</p><hr><h3 id="20-分隔符"><a href="#20-分隔符" class="headerlink" title="20.分隔符"></a>20.分隔符</h3><p>注：最少三个 <code>---</code> 或 <code>***</code>或 <code>* * *</code></p><p><strong>代码</strong></p><pre><code>***---* * *</code></pre><p><strong>演示</strong></p><hr><hr><hr><h3 id="21-脚注"><a href="#21-脚注" class="headerlink" title="21.脚注"></a>21.脚注</h3><p><strong>代码</strong></p><pre><code>Markdown[^1][^1]: Markdown是一种纯文本标记语言        // 在文章最后面显示脚注</code></pre><p><strong>演示</strong></p><p>Markdown<a href="Markdown是一种纯文本标记语言">^1</a></p><hr><h3 id="22-锚点"><a href="#22-锚点" class="headerlink" title="22.锚点"></a>22.锚点</h3><p><strong>代码</strong><br> 注：只有<strong>标题</strong>支持锚点， 跳转目录方括号后 保持空格</p><pre><code>[公式标题锚点](#1)### [需要跳转的目录] {#1}    // 方括号后保持空格</code></pre><p><strong>演示</strong></p><p><a href="#1">公式标题锚点</a></p><hr><h3 id="23-定义型列表"><a href="#23-定义型列表" class="headerlink" title="23.定义型列表"></a>23.定义型列表</h3><p>注：解释型定义<br> <strong>代码</strong></p><pre><code>Markdown :   轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个`:` + `Tab` 或 四个空格代码块定义:   代码块定义……        var a = 10;         // 保持空一行与 递进缩进(tab键，源代码模式tab键)</code></pre><p><strong>演示</strong></p><dl><dt>Markdown</dt><dd>轻量级文本标记语言，可以转换成html，pdf等格式</dd></dl><dl><dt>代码块定义</dt><dd>代码块定义……</dd></dl><pre><code>    var a = 10;</code></pre><hr><h3 id="24-自动邮箱链接"><a href="#24-自动邮箱链接" class="headerlink" title="24.自动邮箱链接"></a>24.自动邮箱链接</h3><p><strong>代码</strong></p><pre><code>&lt;xxx@outlook.com&gt;</code></pre><p><strong>演示</strong></p><p><a href="mailto:&#120;&#x78;&#x78;&#64;&#111;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#120;&#x78;&#x78;&#64;&#111;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#46;&#99;&#x6f;&#109;</a></p><hr><h3 id="25-流程图"><a href="#25-流程图" class="headerlink" title="25.流程图"></a>25.流程图</h3><p><strong>代码1</strong></p><pre><code>​```flow                     // 流程st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始e=&gt;end: 结束              // 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent]   // 判断条件c2=&gt;condition: 条件2      // 判断条件c3=&gt;condition: 条件3      // 判断条件io=&gt;inputoutput: 输出     // 输出//----------------以上为定义参数-------------------------//----------------以下为连接参数-------------------------// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;ec1(no)-&gt;e                   // 条件1不满足-&gt;结束c2(no)-&gt;e                   // 条件2不满足-&gt;结束c3(no)-&gt;e                   // 条件3不满足-&gt;结束​```</code></pre><p><strong>演示</strong></p><pre><code class="flow">st=&gt;start: 开始|past:&gt; http://www.baidu.come=&gt;end: 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent]c2=&gt;condition: 条件2c3=&gt;condition: 条件3io=&gt;inputoutput: 输出st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;ec1(no)-&gt;e                   c2(no)-&gt;e                   c3(no)-&gt;e                   </code></pre><p><strong>代码详解</strong><br> 流程图分为两个部分： <strong>定义参数</strong> 然后 <strong>连接参数</strong></p><p><strong>定义示例：</strong></p><pre><code>tag=&gt;type: content:&gt;url         // 形参格式 st=&gt;start: 开始:&gt;http://www.baidu.com[blank]  //实参格式</code></pre><p>注：<strong><code>st=&gt;start: 开始</code> 的<code>:</code>后面保持空格</strong></p><table><thead><tr><th>形参</th><th>实参</th><th>含义</th></tr></thead><tbody><tr><td>tag</td><td>st</td><td>标签 (可以自定义)</td></tr><tr><td>=&gt;</td><td>=&gt;</td><td>赋值</td></tr><tr><td>type</td><td>start</td><td>类型  (6种类型)</td></tr><tr><td>content</td><td>开始</td><td>描述内容 (可以自定义)</td></tr><tr><td>:&gt;url</td><td><code>http://www.baidu.com[blank]</code></td><td>链接与跳转方式 <strong>兼容性很差</strong></td></tr></tbody></table><table><thead><tr><th>6种类型</th><th>含义</th></tr></thead><tbody><tr><td>start</td><td>启动</td></tr><tr><td>end</td><td>结束</td></tr><tr><td>operation</td><td>程序</td></tr><tr><td>subroutine</td><td>子程序</td></tr><tr><td>condition</td><td>条件</td></tr><tr><td>inputoutput</td><td>输出</td></tr></tbody></table><p><strong>连接示例：</strong></p><pre><code>st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;e开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束</code></pre><table><thead><tr><th>形参</th><th>实参</th><th>含义</th></tr></thead><tbody><tr><td>-&gt;</td><td>-&gt;</td><td>连接</td></tr><tr><td>condition</td><td>c1</td><td>条件</td></tr><tr><td>(布尔值,方向)</td><td>(yes,right)</td><td>如果满足向右连接，4种方向：right ，left，up ，down 默认为：down</td></tr></tbody></table><p>注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。</p><pre><code>operation(right) subroutine(left)condition(yes,right)    // 只有条件 才能加布尔值</code></pre><hr><p><strong>代码2</strong></p><p>注：添加样式和url跳转 需要添加第三方的脚本<br> 实际效果很差，使用起来麻烦，意义不大</p><pre><code>​```flow                             // 流程st=&gt;start: 启动|past:&gt;http://www.baidu.com[blank] // 开始e=&gt;end: 结束                      // 结束op1=&gt;operation: 方案一             // 运算1sub2=&gt;subroutine: 方案二|approved:&gt;http://www.baidu.com[_parent]  // 运算2sub3=&gt;subroutine: 重新制定方案        // 运算2cond1=&gt;condition: 行不行？|request  // 判断条件1cond2=&gt;condition: 行不行？          // 判断条件2io=&gt;inputoutput: 结果满意           // 输出// 开始-&gt;方案1-&gt;判断条件-&gt;st-&gt;op1-&gt;cond1// 判断条件1为no-&gt;方案2-&gt;判断条件2为no-&gt;重新制定方案-&gt;方案1cond1(no,right)-&gt;sub2-&gt;cond2(no,right)-&gt;sub3(right)-&gt;op1cond1(yes)-&gt;io-&gt;e       // 判断条件满足-&gt;输出-&gt;结束cond2(yes)-&gt;io-&gt;e       // 判断条件满足-&gt;输出-&gt;结束​```</code></pre><p><strong>演示</strong></p><pre><code class="flow">st=&gt;start: 启动|past:&gt;http://www.baidu.com[blank]e=&gt;end: 结束op1=&gt;operation: 方案一sub2=&gt;subroutine: 方案二|approved:&gt;http://www.baidu.com[_parent]sub3=&gt;subroutine: 重新制定方案cond1=&gt;condition: 行不行?|requestcond2=&gt;condition: 行不行?io=&gt;inputoutput: 结果满意st-&gt;op1-&gt;cond1cond1(no,right)-&gt;sub2-&gt;cond2(no,right)-&gt;sub3(right)-&gt;op1cond1(yes)-&gt;io-&gt;econd2(yes)-&gt;io-&gt;e</code></pre><h3 id="26-时序图"><a href="#26-时序图" class="headerlink" title="26.时序图"></a>26.时序图</h3><p><strong>代码1</strong></p><pre><code>​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边     // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​```</code></pre><p><strong>演示</strong></p><pre><code class="sequence">A-&gt;&gt;B: 你好Note left of A: 我在左边Note right of B: 我在右边B--&gt;A: 很高兴认识你</code></pre><p><strong>代码详解</strong></p><p>注：<code>A-&gt;&gt;B: 你好</code>   后面可以不写文字，但是一定要在最后加上<code>：</code><br> Note left of A 代表注释在A的左边</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>-</code></td><td>实线</td></tr><tr><td><code>&gt;</code></td><td>实心箭头</td></tr><tr><td><code>--</code></td><td>虚线</td></tr><tr><td><code>&gt;&gt;</code></td><td>空心箭头</td></tr></tbody></table><p><strong>代码2</strong></p><pre><code>​```sequence起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天​```</code></pre><p><strong>演示</strong></p><pre><code class="sequence">起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天</code></pre><h3 id="27-生成侧边栏扩展"><a href="#27-生成侧边栏扩展" class="headerlink" title="27.生成侧边栏扩展"></a>27.生成侧边栏扩展</h3><p>注：生成侧边栏一般是插入JS，再就是模板,<br>总体来说，很是麻烦，效果一般，不作详解。</p><p>作者仓库：<a href="https://github.com/i5ting/i5ting_ztree_toc" target="_blank" rel="noopener">i5ting_ztree_toc</a></p><p>![img](Markdown 语法整理/6912209-4d15bbf4a613ced4.webp)</p><p>精简版：作者博客<a href="http://blog.csdn.net/haleypku/article/details/51226704" target="_blank" rel="noopener">HaleyPKU</a></p><h4 id="总结：常用标记"><a href="#总结：常用标记" class="headerlink" title="总结：常用标记"></a>总结：常用标记</h4><table><thead><tr><th>标记</th><th>Markdown 语法</th></tr></thead><tbody><tr><td>斜体</td><td><code>*italic*</code></td></tr><tr><td>粗体</td><td><code>**bold**</code></td></tr><tr><td>图片</td><td><code>![Image Title](http://xxx.png)</code></td></tr><tr><td>链接</td><td><code>[Link Text](http://xxx.com)</code></td></tr><tr><td>内联代码</td><td><code>code</code></td></tr><tr><td>块级代码</td><td><code>```code block```</code></td></tr><tr><td>引用</td><td><code>&gt; Here is a quote block</code></td></tr><tr><td>分隔符</td><td><code>----</code> 或 <code>*****</code></td></tr><tr><td>标题 1</td><td><code># Heading 1</code></td></tr><tr><td>标题 2</td><td><code>## Heading 2</code></td></tr><tr><td>标题 3</td><td><code>### Heading 3</code></td></tr><tr><td>标题 4</td><td><code>#### Heading 4</code></td></tr></tbody></table><h4 id="附：使用VSC写Markdown文档"><a href="#附：使用VSC写Markdown文档" class="headerlink" title="附：使用VSC写Markdown文档"></a>附：使用VSC写Markdown文档</h4><p>Visual Studio Code 原生就支持高亮Markdown的语法，想要一边编辑一遍预览，有两种方法：</p><ol><li>Ctrl + Shift + P 调出主命令框，输入 Markdown，应该会匹配到几项 Markdown相关命令</li></ol><p>![img](Markdown 语法整理/1077977-20180424164803684-1848899171.png)</p><ol start="2"><li>先按<kbd>Ctrl</kbd>+<kbd>K</kbd>，然后全部松开，紧接着再按 <kbd>V</kbd>，也能调出实时预览框。【要在英文输入状态下】</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
